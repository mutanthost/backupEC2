<?xml version="1.0" encoding="UTF-8"?>

<UserDefinedChecks
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="user_defined_checks.xsd"> <!-- Main Tag (root element)-->


<!-- +++++ USER DEFINED CHECKS +++++ -->

<!-- This is a SAMPLE file containing example checks for OS and SQL Checks -->
<!-- DO NOT EDIT this file and use it for your user defined checks.  Make a COPY of this file and save as user_defined_checks.xml -->
<!-- Create a new blank user_defined_checks.xml file using vi and copy the header above the +++++USER DEFINED CHECKS +++++ comment above -->
<!-- and the closing tag </UserDefinedChecks> at the very end of this file.  Your checks will be between the header and the closing tag -->
<!-- Use the sample checks below as templates and copy/paste/edit them in user_defined_checks.xml -->
<!-- Use your own checks as templates for other checks that you create -->
<!-- Checks are enclosed by <CHECK AUDIT_CHECK_NAME= ... and </CHECK> -->

<!-- This sample file is intended only for instructions and to copy sample checks to use as a template for your checks -->
<!-- The idea is to provide the values and logic that apply to your environment in your own -->

<!-- Most customers will have one or two platforms and one or two versions in there environment -->

<!-- +++++ TIPS AND TECHNIQUES +++++ -->

<!-- 1.   For best results use the vi editor.  Other editors may substitute characters that are not interpreted well in XML -->
<!-- 2.   DO NOT change the order of the XML tags.  A few tags can be removed when not applicable as noted below -->
<!-- 3.   Certain special characters must be substituted in order to be properly interpreted in XML,e.g.. -->
<!--        && should be &amp;&amp; 	-->
<!--        >= should be &gt; 		-->
<!--         <= should be &lt; 		-->
<!--        etc.		 		-->
<!-- 4.   Some editors will substitute other characters for single and double quote characters.  Make sure only plain single and double quotes are used  -->
<!-- 5.   By default ORAchk will run checks it finds in user_defined_checks.xml if the file exists.  To substitute a different file you may set RAT_USER_DEFINED_CHECKS -->
<!--        To substitute a different file you may set RAT_USER_DEFINED_CHECKS to point to the alternate file but it must be a valid user defined checks XML file -->
<!-- 6.   To run ONLY the user defined checks you may use the special built-in profile user_defined_checks, e.g.. -->
<!--        $ ./orachk -profile user_defined_checks 	-->
<!--        This will skip all other checks and only run the user defined checks -->
<!-- 7.   Running user defined checks as root is not supported -->
<!-- 8.   When ORAchk is upgraded this sample file will be over-written but the user_defined_checks.xml will NOT be over-written -->
<!-- 9.   Keep a backup copy of user_defined_checks.xml each time it is edited to maintain a fallback copy in case of loss or mistakes in editing -->
<!-- 10.  SQL commands can be embedded in OS commands. OS commands can consist of single-line programs as in the OSW Watcher Retention Check example below -->
<!-- 11.  Oracle Support is not responsible for your checks.  You must devise your own logic.  This mechanism only provides you with a method of automating your own checks  -->


<!-- OS AUDIT CHECK NAME -->
<!-- Use a name that is self documenting, enclosing the name in double quotes -->

<!-- +++++ BEGIN NEW OS CHECK +++++ -->

<CHECK AUDIT_CHECK_NAME="ASM Audit File Directory Growth">

<!-- SUPPORTED VERSIONS -->
<!-- The following VERSIONS are supported for Grid Infrastructure and Database -->
<!-- Remove any versions not present in your environment and any that your check does not apply to -->
<!-- If your check applies to multiple supported versions then include them in this list  -->
<!-- Your checks will only run on the version or versions that you specify and sometimes the logic for a check will be version-specific  -->
<!-- It doesnâ€™t hurt anything to specify versions that do not exist in your environment  -->
<!-- Versions that do not exist in your environment will just be ignored.  On the other hand, if a check is version-specific then you   -->
<!-- would want to remove the versions that the check does not apply to.  -->

<!-- All versions                                         -->
	<ORACLE_VERSION>*</ORACLE_VERSION> 

<!--  Other valid alternative version specifications      -->

<!-- 		<ORACLE_VERSION>112040</ORACLE_VERSION> would be an example for a check that is specific to 11.2.0.4 -->
<!--		<ORACLE_VERSION>102040:102050:111070:112010:112020:112030:112040:121010:121020</ORACLE_VERSION>      -->

<!-- SUPPORTED PLATFORMS -->
<!-- The following PLATFORMS are supported -->
<!-- Remove any platforms that are not present in your environment or for which your check does not apply -->
<!-- Each platform has one or more "flavors", which are distributions or versions which vary from platform to platform  -->
<!-- Many OS checks might be platform specific so those should be limited to the proper platforms  -->
<!-- For Linux OELRHEL refers to Oracle Linux or Red Hat Linux  -->
<!-- If removing platforms remove everything from the <PLATFORM> to </PLATFORM> tags leaving only the platforms you need  -->

<!--  All platforms and flavors using "*" wildcard   -->
    <PLATFORMS>
    <PLATFORM TYPE="*">
      <FLAVOR>*</FLAVOR>
    </PLATFORM>
    </PLATFORMS>


<!--  Other valid Platform specifications which can be sued depending upon your platform            -->
<!--		<PLATFORMS>                                                                         -->
<!--			<PLATFORM TYPE="LINUXX8664">                                                -->
<!--				<FLAVOR>OELRHEL5:OELRHEL6:OELRHEL7:SUSE10:SUSE11:SUSE12</FLAVOR>    -->
<!--			</PLATFORM>                                                                 -->
<!--			<PLATFORM TYPE="SOLARISSPARC64">                                            -->
<!--				<FLAVOR>10:11</FLAVOR>                                              -->
<!--			</PLATFORM>                                                                 -->
<!--			<PLATFORM TYPE="SOLARISX8664">                                              -->
<!--                            <FLAVOR>10:11</FLAVOR>                                              -->
<!--                    </PLATFORM>                                                                 -->
<!--			<PLATFORM TYPE="AIXPPC64">                                                  -->
<!--				<FLAVOR>61:71</FLAVOR>                                              -->
<!--			</PLATFORM>                                                                 -->
<!--			<PLATFORM TYPE="MSWINDOWS">                                                 -->
<!--                            <FLAVOR>64</FLAVOR>                                                 -->
<!--                    </PLATFORM>                                                                 -->
<!--			<PLATFORM TYPE="HPUX">                                                      -->
<!--                                <FLAVOR>Itanium1131</FLAVOR>                                    -->
<!--                        </PLATFORM>                                                             -->
<!--			<PLATFORM TYPE="HPUX">                                                      -->
<!--                                <FLAVOR>PARISC1123</FLAVOR>                                     -->
<!--                        </PLATFORM>                                                             -->
<!--		</PLATFORMS>                                                                        -->

<!-- If for instance you only have 64-bit OEL5 in your environment then your platform block for your checks could be as follows -->

<!--		<PLATFORMS> 					              -->
<!--			<PLATFORM TYPE="LINUXX8664"> 		              -->
<!--				<FLAVOR>OELRHEL5</FLAVOR>	              -->
<!--			</PLATFORM>				              -->
<!--            </PLATFORMS>                                                  -->

<!--            <PLATFORMS>                                                   -->
<!--            <PLATFORM TYPE="LINUXX8664">   for Linux and all flavors      -->
<!--            <FLAVOR>*</FLAVOR>                                            -->
<!--            </PLATFORM>                                                   -->
<!--            </PLATFORMS>                                                  -->

<!-- OS COMMAND CHECK LOGIC -->
<!-- This command or inline program should result in a single string or numeric return value that can be compared to a single comparison value -->
<!-- using an appropriate string or numeric comparison operator.  Typically this will be a boolean return value like in the sample below, 1 or 0 -->
<!-- But it could be a count resulting from the use of a command like grep -c where the count is expected to be 0 or a non-zero number  -->
<!-- depending upon the logic required for your check.  The important thing to remember though is that it should not result in a list or array -->
<!-- The best approach is to perfect your logic in a terminal shell and once perfected copy and paste it into the OS_COMMAND block of your check -->
<!-- Note that ORAchk populates two environment variables at runtime $CRS_HOME and $ORACLE_HOME.  So you can use those in you logic as in the example -->
<!-- $CRS_HOME will be static but $ORACLE_HOME will change according to the context of its usage which is defined by ORACLE_HOME_TYPE below -->
<!-- Note that when querying v$ views in Oracle using OS commands like this the dollar sign needs to be escaped as in v\$parameter -->
<!-- Note also that it is possible to embed SQLPlus formatting directives in your command and that a newline character (\n) follows them  -->
<!-- In this form of a multi-command program preceding tabs will cause problems so do not use any  -->
<!-- NOTE: NO tabs embedded in multi-line program -->

	<OS_COMMAND> 
	<![CDATA[
afdest=$(echo -e "set heading off timing off feedback off lines 180\n select value from v\$parameter where name='audit_file_dest';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$)
aud_files=$(find $afdest -name '*.*' 2>/dev/null|wc -l)
if [ $aud_files -gt 100000 ]
then echo 1 
else echo 0
fi
	]]>
		</OS_COMMAND>

<!-- The above program results in a single return value, 1 or 0, uses the $ORACLE_HOME environment variable which is set at runtime and a combination -->
<!-- of sqlplus and other os commands to arrive at the required single return value.  Use the power of the scripting language -->
<!-- This is a good example of how to pass sqlplus formatting and SQL commands to SQLPLUS and assigning the resultant value, the audit_file_dest in this case,  -->
<!-- to a variable that can then be used as input to another command the result of which is assigning that destination to another variable that is used to do a PASS/FAIL evaluation -->
<!-- In this example 0 represents a PASS and 1 represents a FAIL or WARNING because if there are greater than 100,000 audit files built up then that means some may need to be deleted -->
<!-- in order to avoid potentially filling up a filesystem.  So this logic ends up counting the number of files in the audit_file_dest location derived from the database  -->
<!-- and the rule is -gt (greater than) meaning too many.  The rule for your organization could vary as appropriate. -->
<!-- In general use the bash script language to author your checks but you can use any valid shell scripting that works in your environment including perl, e.g.. -->
<!-- perl -e 'print "Hello World!\n"' -->
<!-- but substituting your functional logic.  It is your responsibility to test and verify your logic.  GIGO. ORAchk will run any command you tell it to and dutifully use that output -->
<!-- trying to apply a rule. -->

<!-- TEST YOUR LOGIC OUTSIDE OF ORACHK and verify the formatting before pasting the command here -->


<!-- OS COMMAND REPORT LOGIC -->
<!-- This command or inline program should result in formatted output easily readable by a user reviewing the report -->
<!-- and the output should make it easy for the user to validate the finding of its accompanying check.  So it is the data derived  -->
<!-- from the system at runtime and unlike the check logic itself can contain a listing of multiple rows of data if appropriate -->
<!-- On the other hand you do not want to print out hundreds or thousands of rows of text.  That would be too unreadable and make the report larger in size than perhaps necessary -->
<!-- So in this example the number of audit files is output in a very readable and understandable format rather than listing of all the audit files and the user can clearly see that  -->
<!-- is more audit files than should be allowed to build up on the filesystem and there is action required to remediate the problem -->
<!-- Limit your output to a reasonable number of rows.  If necessary refer users to a command to derive the complete set of data needed for Action / Repair -->

<!-- TEST YOUR LOGIC OUTSIDE OF ORACHK  and verify the formatting before pasting the command here -->

		<OS_COMMAND_REPORT> 
		<![CDATA[	echo -e "Number of audit files at $afdest = $aud_files" ]]>
		</OS_COMMAND_REPORT>
		

<!-- OS REPAIR COMMAND LOGIC -->
<!-- This command or inline program should result in formatted output easily readable by a user reviewing the report -->
<!-- and the output should make it easy for the user to validate the finding of its accompanying check.  So it is the data derived  -->
<!-- from the system at runtime and unlike the check logic itself can contain a listing of multiple rows of data if appropriate -->
<!-- On the other hand you do not want to print out hundreds or thousands of rows of text.  That would be too unreadable and make the report larger in size than perhaps necessary -->
<!-- So in this example the number of audit files is output in a very readable and understandable format rather than listing of all the audit files and the user can clearly see that  -->
<!-- is more audit files than should be allowed to build up on the filesystem and there is action required to remediate the problem -->
<!-- Limit your output to a reasonable number of rows.  If necessary refer users to a command to derive the complete set of data needed for Action / Repair -->

<!-- TEST YOUR LOGIC OUTSIDE OF ORACHK  and verify the formatting before pasting the command here -->

		<OS_REPAIR_COMMAND> 
		<![CDATA[	 ]]>
		</OS_REPAIR_COMMAND>
		

<!-- COMPARISON OPERATOR -->
<!-- The comparison operator is used in conjunction with the command's actual return value and the comparison value, which is the expected return value -->
<!-- The comparison is evaluated and the check either passes or it fails -->
<!-- Valid numeric comparison operators are -eg, -ne, -gt, -lt, -ge, -le (equal, not equal, greater than, less than, greater than or equal, less than or equal) -->
<!-- Valid string comparison operators are =, !=, -n, -z (equal, not equal, empty, not empty) -->


		<OPERATOR>-eq</OPERATOR> 

<!-- 		<OPERATOR>-ne</OPERATOR> 	-->
<!-- 		<OPERATOR>-gt</OPERATOR> 	-->
<!-- 		<OPERATOR>-lt</OPERATOR> 	-->
<!-- 		<OPERATOR>-ge</OPERATOR> 	-->
<!-- 		<OPERATOR>-le</OPERATOR> 	-->
<!-- 		<OPERATOR>=</OPERATOR> 		-->
<!-- 		<OPERATOR>!=</OPERATOR> 	-->
<!-- 		<OPERATOR>-n</OPERATOR> 	-->
<!-- 		<OPERATOR>-z</OPERATOR> 	--> 

<!-- COMPARISON VALUE -->
<!-- The comparison value is used in conjunction with the comparison operator and the actual command return value to determine PASS/FAIL -->
<!-- In this example the expected return value of the command will be equal (-eq) to 0.  If it is the check passes and if not the check fails -->

		<COMPARE_VALUE>0</COMPARE_VALUE>  

<!-- 		<COMPARE_VALUE>1</COMPARE_VALUE> 	-->
<!-- 		<COMPARE_VALUE>8192</COMPARE_VALUE> 	-->
<!-- 		<COMPARE_VALUE>WHATEVER SINGLE RETURN NUMERIC OR STRING VALUE</COMPARE_VALUE> 	-->

<!-- CHECK TIMEOUT -->
<!-- Check execution timeout value in SECONDS. When the Check's execution time exceeds the given value, the check gets KILLED -->
<!-- In this example if the Check's execution time exceeds 120 seconds, the check will get killed -->

		<CHECK_TIMEOUT>120</CHECK_TIMEOUT>  

<!-- 		<CHECK_TIMEOUT>5</CHECK_TIMEOUT> 	-->
<!-- 		<CHECK_TIMEOUT>60</CHECK_TIMEOUT> 	-->
<!-- 		<CHECK_TIMEOUT>NUMERIC VALUE IN SECONDS</CHECK_TIMEOUT> 	-->

<!-- CANDIDATE SYSTEMS -->
<!-- If the system ORAchk is being run on is a database system, either a RAC or non-RAC system, then database or Grid Infrastructure checks can be run, -->
<!-- however some checks might be specific to a RAC system while others may only apply to non-RAC systems.   -->
<!-- In most cases a check might apply to both.  RACCHECK specifies RAC only.  SIDB specifies non-RAC or sometimes called single instance.   -->
<!-- The * wildcard character specifies it does not matter and to run on either type of system, RAC or non-RAC -->
<!-- Valid entries are RACCHECK, SIDB, * -->

		<CANDIDATE_SYSTEMS>*</CANDIDATE_SYSTEMS>

<!-- 		<CANDIDATE_SYSTEMS>RACCHECK</CANDIDATE_SYSTEMS> 	-->
<!-- 		<CANDIDATE_SYSTEMS>SIDB</CANDIDATE_SYSTEMS> 		-->

<!-- COMPONENT DEPENDENCY -->
<!-- This tag should be a single value and implies that for the command to be run successfully that a certain component of the Oracle stack needs to be running -->
<!-- For instance, for the above commands to run successfully the ASM instance must be up and running.  If it is not then the sqlplus commands upon which the  -->
<!-- other logic depends would be missing some input.  If the COMPONENT DEPENDENCY is not fulfilled at runtime then the check will be skipped -->
<!-- If there is no component dependency this tag will be ignored at runtime but do not delete it from your check.  -->
<!-- Valid entries are ASM, CRS, RDBMS -->

		<COMPONENT_DEPENDENCY>ASM</COMPONENT_DEPENDENCY> 

<!-- 		<COMPONENT_DEPENDENCY>CRS</COMPONENT_DEPENDENCY> 	-->
<!-- 		<COMPONENT_DEPENDENCY>RDBMS</COMPONENT_DEPENDENCY> 	-->

<!-- DATABASE MODE -->
<!-- If the command being run contains a SQL command and it depends upon the database mode in order to derive the needed data then that mode is specified here -->
<!-- Valid entries are numeric values which represent the database mode.  1 = nomount, 2 = mount, 3 = open -->
<!-- If there is no database dependency this tag will be ignored at runtime but do not delete it from your check.  -->
<!-- Most but not all SQL commands executed against a database will depend upon the database being running and Open -->

		<DATABASE_MODE>3</DATABASE_MODE>

<!-- 		<DATABASE_MODE>1</DATABASE_MODE> 	-->
<!-- 		<DATABASE_MODE>2</DATABASE_MODE> 	-->

<!-- ORACLE HOME TYPE -->
<!-- This should be a single value and controls the setting of ORACLE_HOME environment variable at runtime if for instance an Oracle executable needs to be run from that home -->
<!-- Examples of executables that might be run from a home are sqlplus, srvctl, crsctl, oifcfg, etc.  In general if your logic uses an Oracle executable to derive  -->
<!-- data then the script needs to know in which home's bin directory to find that executable -->
<!-- Valid entries are ASM, CRS, RDBMS.  In the above command sqlplus is being run and the check is going against the ASM instance to find its audit_file_dest,  so ASM is used in this example -->
<!-- NOTE:  If you are running any OS commands that have no dependency on Oracle executables, i.e. just basic OS commands, then this tag is ignored -->

		<ORACLE_HOME_TYPE>ASM</ORACLE_HOME_TYPE>

<!-- 		<ORACLE_HOME_TYPE>CRS</ORACLE_HOME_TYPE> 	-->
<!-- 		<ORACLE_HOME_TYPE>RDBMS</ORACLE_HOME_TYPE> 	-->

<!-- ALERT LEVEL -->
<!-- Valid entries for ORAchk built-in checks are FAIL, WARNING, INFO or you could specify one or more custom alert levels that are appropriate to your environment -->
<!-- Custom alert levels can only be applied to user-defined checks currently.  These alert levels are somewhat subjective but in general FAIL should be reserved -->
<!-- for the most potentially severe issues and WARNING is serious but does not rise to the level of a FAIL and INFO is the least serious but still important to evaluate and correct -->
<!-- It is also possible to pass purely informational data to the report by assigning an alert level of INFO and designing a check that is meant to fail, i.e.., a no-op check -->
<!-- INFOs that PASS are not displayed in the reports and therefore an INFO check that fails can be used to display the desired message in the report -->

		<ALERT_LEVEL>FAIL</ALERT_LEVEL>

<!-- 		<ALERT_LEVEL>WARNING</ALERT_LEVEL> -->
<!-- 		<ALERT_LEVEL>INFO</ALERT_LEVEL> -->
<!-- 		<ALERT_LEVEL>CUSTOM</ALERT_LEVEL> -->

<!-- PASS MESSAGE -->
<!-- This is the text that you want displayed in the report if your check PASSes -->
<!-- In this example in the report if the check passes you would see a row like -->
<!-- PASS	ASM Audit file destination file count &lt; 100,000 -->

		<PASS_MSG>ASM Audit file destination file count &lt;= 100,000</PASS_MSG>

<!-- 		<PASS_MSG>Substitute your PASS message here</PASS_MSG> 		-->

<!-- FAIL MESSAGE -->
<!-- This is the text that you want displayed in the report if your check FAILs or is a WARNING -->
<!-- In this example in the report if the check fails you would see a row like -->
<!-- FAIL	ASM Audit file destination file count &gt; 100,000 -->

		<FAIL_MSG>ASM Audit file destination file count &gt; 100,000</FAIL_MSG>

<!-- 		<FAIL_MSG>Substitute your FAIL message here</FAIL_MSG> 		-->

<!-- RECOMMENDATION RATIONALE -->
<!-- These are the details you want the user to see in the detailed section of the report for each check when they click the "View" link in the summary row for the check -->
<!-- Each check should have a rationale explaining why it is recommended (Benefit / Impact), why it is a problem if not corrected (Risk) and what to do about it (Action / Repair) -->
<!-- For a user defined check the Benefit / Impact might be a company standard based on a lesson learned, the Risk might be that the misconfiguration has led to a performance issue  -->
<!-- The Action / Repair could have an explanation of how to fix the problem or even refer to some internal company standard or build document for corrective action  -->
<!-- The three components of the rationale are concatenated together with the appropriate labels separating each section.  If any field is left blank that section will not be displayed  -->

		<BENEFIT_IMPACT>
		<![CDATA[
			The audit file destination directories for an ASM instance can grow to contain a very large number of files if they are not regularly maintained. Use the Linux cron(8) utility and the find(1) command to manage the number of files in the audit file destination directories.
			The impact of using cron(8) and find(1) to manage the number of files in the audit file destination directories is minimal.
		]]>	
		</BENEFIT_IMPACT>

		<RISK>
		<![CDATA[
			Having a very large number of files can cause the file system to run out of free disk space or inodes, or can cause Oracle to run very slowly due to file system directory scaling limits, which can have the appearance that the ASM instance is hanging on startup.
		]]>
		</RISK>

		<ACTION_REPAIR>
		<![CDATA[	Refer to the referenced MOS Note ]]>
		</ACTION_REPAIR>

<!-- REFERENCES -->
<!-- You can specify references that back up or further explain the rationale or that explain in more detail the Action / Repair -->
<!-- These references can be MOS Notes, external product documentation websites, or even company reference documents not otherwise accessible to other Oracle customers -->
<!-- If the references are specified as in these sample checks then ORAchk will automatically render them as clickable -->
<!-- HTML links.  In the case of MOS notes use the format below.  You do n to need to use HTML HREF tags if you use the specified formats -->
<!-- Here is an example of how to format a document available from a website other than My Oracle Support  -->
<!-- <LINK> Use Automatic Segment Space Management - http://docs.oracle.com/cd/E11882_01/server.112/e10803/config_db.htm#HABPT4845 -</LINK> -->

		<LINKS>
			<LINK>Note: 1298957.1 - Manage Audit File Directory Growth with cron</LINK>
		</LINKS>

	</CHECK> 

<!-- +++++ END OF OS CHECK +++++ -->

<!-- +++++ BEGINNING OF SQL CHECK +++++ -->


<!-- SQL AUDIT CHECK NAME -->
	
	<CHECK AUDIT_CHECK_NAME="Verify AUD$ and FGA_LOG$ tables use Automatic Segment Space Management">  

<!--  This check should run on all supported platforms and versions given the platform and version specs below -->

		<ORACLE_VERSION>*</ORACLE_VERSION>
		<PLATFORMS>
			<PLATFORM TYPE="*">
                           <FLAVOR>*</FLAVOR>
			</PLATFORM>
                </PLATFORMS>

<!-- PARAM_PATH -->
<!-- This should be a self-documenting string, to identify what exactly is being derived in the return value of the SQL -->
<!-- If querying a Database parameter - use the parameter name which is automatically self-documenting -->
<!-- If doing a count - what is being counted? Use a name that others users would be able to discern the purpose -->
<!-- This string MUST be included in your SQL select as the name portion in a name value pair such that your output would be written as name = value -->
<!-- When testing your SQL in SQL*Plus your output should look similar to the following example.  Note the spaces on either side of the "=" -->
<!-- Example - aud_fga_logs_manual_space_management_count = 0 -->
<!-- So each SQL_COMMAND should begin like this select 'aud_fga_logs_manual_space_management_count = '||count(ts.segment_space_management) from ... -->
<!-- NOTE - PARAM_PATH is not required for OS AUDIT CHECKS -->

		<PARAM_PATH>aud_fga_logs_manual_space_management_count</PARAM_PATH>

<!-- SQL COMMAND -->
<!-- This SQL check example would run on all the specified versions and platforms.  You need at least one version and one platform -->
<!-- This SQL COMMAND can be a valid SQL statement or a valid anonymous PL/SQL block but like an OS command there should be a single. -->
<!-- string or numeric return value that can be evaluated by comparing it to an expected return value using the specified comparison operator -->
<!-- See the comments for OS COMMAND CHECK LOGIC as similar concepts apply here for SQL -->
<!-- Care should be taken that the SQL statement executes efficiently.  There is a default 90 second timeout.  Slow SQL will slow the entire process -->
<!-- SQL statements that exceed the timeout will be killed.  Check for Skipped checks and killed processes in your report if your result does not appear -->
<!-- Typical return values will be counts, parameter values, etc. as in the example here -->
<!-- NOTE the PARAM_PATH is used in the SQL as described above -->

<!-- TEST YOUR LOGIC OUTSIDE OF ORACHK  and verify the formatting before pasting the command here -->

		<SQL_COMMAND>
	<![CDATA[	select 'aud_fga_logs_manual_space_management_count = '||count(ts.segment_space_management) from dba_tables t, dba_tablespaces ts where ts.tablespace_name = t.tablespace_name and t.table_name in ('AUD$','FGA_LOG$') and upper(ts.segment_space_management) != upper('AUTO'); ]]>
		</SQL_COMMAND>

<!-- SQL COMMAND REPORT -->
<!-- This SQL or anonymous PL/SQL block should result in formatted output easily readable by a user reviewing the report -->
<!-- and the output should make it easy for the user to validate the finding of its accompanying check.  So it is the data derived  -->
<!-- from the database at runtime and unlike the check logic itself can contain a listing of multiple rows of data if appropriate -->
<!-- On the other hand you do not want to print out hundreds or thousands of rows of text.  That would be too unreadable and make the report larger in size than perhaps necessary -->
<!-- Limit your output to a reasonable number of rows.  If necessary refer users to a query to derive the complete set of data needed for Action / Repair -->
<!-- You can use SQL*Plus column formatting to control the output if needed -->

<!-- TEST YOUR LOGIC OUTSIDE OF ORACHK  and verify the formatting before pasting the command here -->

		<SQL_COMMAND_REPORT>
		<![CDATA[ select t.table_name,ts.segment_space_management from dba_tables t, dba_tablespaces ts where ts.tablespace_name = t.tablespace_name and t.table_name in ('AUD$','FGA_LOG$'); ]]>
		</SQL_COMMAND_REPORT>
		
<!-- SQL REPAIR COMMAND REPORT -->
<!-- This SQL or anonymous PL/SQL block should result in formatted output easily readable by a user reviewing the report -->
<!-- and the output should make it easy for the user to validate the finding of its accompanying check.  So it is the data derived  -->
<!-- from the database at runtime and unlike the check logic itself can contain a listing of multiple rows of data if appropriate -->
<!-- On the other hand you do not want to print out hundreds or thousands of rows of text.  That would be too unreadable and make the report larger in size than perhaps necessary -->
<!-- Limit your output to a reasonable number of rows.  If necessary refer users to a query to derive the complete set of data needed for Action / Repair -->
<!-- You can use SQL*Plus column formatting to control the output if needed -->

<!-- TEST YOUR LOGIC OUTSIDE OF ORACHK  and verify the formatting before pasting the command here -->

		<SQL_REPAIR_COMMAND>
		<![CDATA[   ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;
ALTER DATABASE FORCE LOGGING;
   ]]>
		</SQL_REPAIR_COMMAND>

		<OPERATOR>-eq</OPERATOR>
                <COMPARE_VALUE>0</COMPARE_VALUE>
<!-- Please refer to the comments above for OS AUDIT CHECK for the following keywords as their usage is similar for SQL AUDIT CHECKS -->
		<CANDIDATE_SYSTEMS>*</CANDIDATE_SYSTEMS>
		<COMPONENT_DEPENDENCY>RDBMS</COMPONENT_DEPENDENCY>
		<DATABASE_MODE>3</DATABASE_MODE>

<!-- DATABASE TYPE -->
<!-- Database versions BEFORE 12.1 are referred to here as NORMAL (not multi-tenant) -->
<!-- Database versions 12.1 or greater could be NORMAL (not multi-tenant), CDB (multi-tenant container DB), PDB (multi-tenant pluggable DB) -->
<!-- Include the appropriate DATABASE TYPE(s) for your check depending upon version and multi-tenancy.  Your check will only run on the specified DATABASE TYPE(s) -->

		<DATABASE_TYPE>CDB:PDB:NORMAL</DATABASE_TYPE>

<!-- DATABASE ROLE -->
<!-- Database roles are PRIMARY, PHYSICAL STANDBY, LOGICAL STANDBY -->
<!-- A PHYSICAL STANDBY may be running in managed recovery (mounted mode) or Read Only mode and so the kinds of SQL checks that can be run may vary -->
<!-- Similarly a LOGICAL STANDBY may be running in apply mode and so the kinds of SQL checks that can be run may vary -->
<!-- In a database consolidation environment there could be databases of either role on a given system.  The role determination is made for each database at runtime -->
<!-- ORAchk runs checks with the appropriate role and ignores checks with an inappropriate role -->

		<DATABASE_ROLE>PRIMARY</DATABASE_ROLE>
		
<!--            <DATABASE_ROLE>PHYSICAL STANDBY</DATABASE_ROLE>         -->
<!--            <DATABASE_ROLE>LOGICAL STANDBY</DATABASE_ROLE>          -->

		<ALERT_LEVEL>FAIL</ALERT_LEVEL>
		<PASS_MSG>Table AUD$[FGA_LOG$] uses Automatic Segment Space Management</PASS_MSG>
		<FAIL_MSG>Table AUD$[FGA_LOG$] should use Automatic Segment Space Management</FAIL_MSG>
		<BENEFIT_IMPACT>
		<![CDATA[
			With AUDIT_TRAIL set for database (AUDIT_TRAIL=db), and the AUD$ and FGA_LOG$ tables located in a dictionary segment space managed SYSTEM tablespace, "gc" wait events are sometimes observed during heavy periods of database logon activity. Testing has shown that under such conditions, placing the AUD$ and FGA_LOG$ tables in the SYSAUX tablespace, which uses automatic segment space management, reduces the space related wait events.

			The impact of verifying that the AUD$ and FGA_LOG$ tables are in the SYSAUX table space is low. Moving them if they are not located in the SYSAUX does not require an outage, but should be done during a scheduled maintenance period or slow audit record generation window.
			]]>
		</BENEFIT_IMPACT>
		<RISK>
		<![CDATA[
			If AUD$ and FGA_LOG$ tables are not verifed to use automatic segment space management, there is a risk of a performance slowdown during periods of high database login activity.
			]]>
		</RISK>
		<ACTION_REPAIR>
		 <![CDATA[ 
			To verify the segment space management policy currently in use by the AUD$ and FGA_LOG$ tables, use the following Sqlplus command:

			select t.table_name,ts.segment_space_management from dba_tables t, dba_tablespaces ts where ts.tablespace_name = t.tablespace_name and t.table_name in ('AUD$','FGA_LOG$');

		The output should be:
		TABLE_NAME                     SEGMEN
		------------------------------ ------
		FGA_LOG$                       AUTO
		AUD$                           AUTO 
		If one or both of the AUD$ or FGA_LOG$ tables return "MANUAL", use the DBMS_AUDIT_MGMT package to move them to the SYSAUX tablespace:

		BEGIN
		DBMS_AUDIT_MGMT.set_audit_trail_location(audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_AUD_STD,--this moves table AUD$ 
		audit_trail_location_value => 'SYSAUX');  
		END;  

		BEGIN
		DBMS_AUDIT_MGMT.set_audit_trail_location(audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_FGA_STD,--this moves table FGA_LOG$ 
		audit_trail_location_value => 'SYSAUX');
		END;
		/   

		The output should be similar to:
		PL/SQL procedure successfully completed. 

		If the output is not as above, investigate and correct the condition.
		NOTE: This "DBMS_AUDIT_MGMT.set_audit_trail" command should be executed as part of the dbca template post processing scripts, but for existing databases, the command can be executed, but since it moves the AUD$ & FGA_LOG$ tables using "alter table ... move" command, it should be executed at a "quiet" time
		]]>
		</ACTION_REPAIR>
		<LINKS>
			<LINK>Use Automatic Segment Space Management - http://docs.oracle.com/cd/E11882_01/server.112/e10803/config_db.htm#HABPT4845</LINK>
		</LINKS>
	</CHECK> 

<!-- END OF SQL CHECK -->

<!-- +++++ BEGIN ADDITIONAL NEW OS CHECK WITH MINIMAL COMMENTS +++++ -->

<CHECK AUDIT_CHECK_NAME="OSW Watcher Running">

<!--  This check should run on all supported platforms and versions given the platform and version specs below -->

                <ORACLE_VERSION>*</ORACLE_VERSION> <!-- All supported versions -->

                <PLATFORMS>
                        <PLATFORM TYPE="*">
                           <FLAVOR>*</FLAVOR>
                        </PLATFORM>
                </PLATFORMS>

                <OS_COMMAND>
                <![CDATA[ps -ef|grep -v grep|grep -c OSWatcher.sh]]>
                </OS_COMMAND>

                <OS_COMMAND_REPORT>
              <![CDATA[  ps -ef|grep -v grep|grep OSWatcher.sh]]>
                </OS_COMMAND_REPORT>
			  	
				<OS_REPAIR_COMMAND>
			  <![CDATA[  ]]>	
				</OS_REPAIR_COMMAND>
                <OPERATOR>-gt</OPERATOR>
                <COMPARE_VALUE>0</COMPARE_VALUE>
                <CHECK_TIMEOUT>150</CHECK_TIMEOUT>
                <CANDIDATE_SYSTEMS>*</CANDIDATE_SYSTEMS>
<!-- NOTE: COMPONENT_DEPENDENCY, DATABASE_MODE, ORACLE_HOME_TYPE not required for this check due to no dependency on CRS, ASM, RDBMS  -->

                <ALERT_LEVEL>WARNING</ALERT_LEVEL>
                <PASS_MSG>OSWatcher is running</PASS_MSG>
                <FAIL_MSG>OSWatcher is NOT running</FAIL_MSG>

                <BENEFIT_IMPACT>
                       <![CDATA[ OS  Watcher should be running]]>
                </BENEFIT_IMPACT>
                <RISK>

                      <![CDATA[  Lack of first failure diagnostics for OS]]>
                </RISK>
                <ACTION_REPAIR>
                    <![CDATA[   Run OSWatcher.  See referecned notes for more details.]]>
                </ACTION_REPAIR>
                <LINKS>

                        <LINK>Note: 301137.1 - OSWatcher</LINK>
                        <LINK>Note: 580513.1 - How To Start OSWatcher Black Box (OSWBB) Every System Boot</LINK>
                </LINKS>
</CHECK>

<CHECK AUDIT_CHECK_NAME="OSW Watcher Interval Check">

<!--  This check should run on all supported platforms and versions given the platform and version specs below -->

                <ORACLE_VERSION>*</ORACLE_VERSION>

                <PLATFORMS>
                        <PLATFORM TYPE="*">
                           <FLAVOR>*</FLAVOR>
                        </PLATFORM>
                </PLATFORMS>

<!-- NOTE: NO tabs embedded in multi-line program -->
                <OS_COMMAND>
                <![CDATA[ 
interval=$(ps -ef|grep -v grep|grep OSWatcher.sh|head -1|awk '{print $10}')
if [[ $interval -ge 30 && $interval -le 60 ]]
then echo 1
else echo 0
fi
		]]>
                </OS_COMMAND>

                <OS_COMMAND_REPORT>
                <![CDATA[echo -e OSW interval = $interval seconds]]>
                </OS_COMMAND_REPORT>
				
				<OS_REPAIR_COMMAND>
			    <![CDATA[  ]]>	
				</OS_REPAIR_COMMAND>
                <OPERATOR>-eq</OPERATOR>
                <COMPARE_VALUE>1</COMPARE_VALUE>
                <CHECK_TIMEOUT>150</CHECK_TIMEOUT>
                <CANDIDATE_SYSTEMS>*</CANDIDATE_SYSTEMS>
<!-- NOTE: COMPONENT_DEPENDENCY, DATABASE_MODE, ORACLE_HOME_TYPE not required for this check due to no dependency on CRS, ASM, RDBMS  -->

                <ALERT_LEVEL>WARNING</ALERT_LEVEL>
                <PASS_MSG>OSWatcher interval is configured according to recommendation</PASS_MSG>
                <FAIL_MSG>OSWatcher interval is NOT configured according to recommendation</FAIL_MSG>

                <BENEFIT_IMPACT>
                        <![CDATA[The OS  Watcher interval should be between 30 and 60 seconds]]>
                </BENEFIT_IMPACT>
                <RISK>
                       <![CDATA[ Too short of an interval may run into OS Scheduling latency and be too often while
an interval more than 60 seconds is not often enough when first failure diagnostics are needed.]]>
                </RISK>
                <ACTION_REPAIR>
                      <![CDATA[  Stop and restart OS Watcher using a 30 second interval.  Only use a shorter interval if instructed by Oracle Support.  See the referenced note for more details.]]>
                </ACTION_REPAIR>

                <LINKS>
                <LINK>Note: 301137.1 - OSWatcher</LINK>
                        <LINK>Note: 580513.1 - How To Start OSWatcher Black Box (OSWBB) Every System Boot</LINK>

                </LINKS>
</CHECK>

<CHECK AUDIT_CHECK_NAME="OSW Watcher Retention Check">

<!--  This check should run on all supported platforms and versions given the platform and version specs below -->

                <ORACLE_VERSION>*</ORACLE_VERSION>

                <PLATFORMS>
                        <PLATFORM TYPE="*">
                          <FLAVOR>*</FLAVOR>
                        </PLATFORM>
                </PLATFORMS>

                <OS_COMMAND>
                <![CDATA[ 
                retention=$(ps -ef|grep -v grep|grep OSWatcher.sh|head -1|awk '{print $11}');if [[ $retention -ge 72 && $retention -le 96 ]];then echo 1;else echo 0;fi
                ]]>
                </OS_COMMAND>


                <OS_COMMAND_REPORT>
                <![CDATA[echo -e OSW retention = $retention hours]]>
                </OS_COMMAND_REPORT>
				
				<OS_REPAIR_COMMAND>
			    <![CDATA[  ]]>	
				</OS_REPAIR_COMMAND>
                <OPERATOR>-eq</OPERATOR>
                <COMPARE_VALUE>1</COMPARE_VALUE>
                <CANDIDATE_SYSTEMS>*</CANDIDATE_SYSTEMS>
<!-- NOTE: COMPONENT_DEPENDENCY, DATABASE_MODE, ORACLE_HOME_TYPE not required for this check due to no dependency on CRS, ASM, RDBMS  -->

                <ALERT_LEVEL>WARNING</ALERT_LEVEL>
                <PASS_MSG>OSWatcher retention period is configured according to recommendation</PASS_MSG>
                <FAIL_MSG>OSWatcher retention period is NOT configured according to recommendation</FAIL_MSG>

                <BENEFIT_IMPACT>
                        <![CDATA[The OS  Watcher retention period should be at least 72 hours (3 days) but no more than 96 hours]]>
                </BENEFIT_IMPACT>
                <RISK>
                        <![CDATA[Too short of a retention period may cause first failure diagnostics needed by Oracle Support to not be available and
too long of a retention period might take up more space than needed.]]>
                </RISK>
                <ACTION_REPAIR>
                      <![CDATA[  Stop and restart OS Watcher using a 72 hour retention period.  Only use a shorter or longer retention period if instructed by Oracle Support.
                        See the referenced note for more details.]]>
                </ACTION_REPAIR>

                <LINKS>
                        <LINK>Note: 301137.1 - OSWatcher</LINK>
                        <LINK>Note: 580513.1 - How To Start OSWatcher Black Box (OSWBB) Every System Boot</LINK>

                </LINKS>

        </CHECK>

<CHECK AUDIT_CHECK_NAME="Force Logging mode enabled">

<!--  This check should run on all supported platforms and versions given the platform and version specs below -->

                <ORACLE_VERSION>*</ORACLE_VERSION>
                <PLATFORMS>
                        <PLATFORM TYPE="*">
                          <FLAVOR>*</FLAVOR>
                        </PLATFORM>
                </PLATFORMS>

                <PARAM_PATH>force_logging_mode_enabled</PARAM_PATH>
                <SQL_COMMAND>
                      <![CDATA[  select 'force_logging_mode_enabled = '||force_logging from v$database;]]>
                </SQL_COMMAND>

                <SQL_COMMAND_REPORT>
                        <![CDATA[select 'Database force logging mode = '||force_logging from v$database;]]>
                </SQL_COMMAND_REPORT>
				
				<SQL_REPAIR_COMMAND>
		               <![CDATA[   ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;
                             ALTER DATABASE FORCE LOGGING;
                        ]]>
		         </SQL_REPAIR_COMMAND>
                <OPERATOR>=</OPERATOR>
                <COMPARE_VALUE>YES</COMPARE_VALUE>
                <CHECK_TIMEOUT>180</CHECK_TIMEOUT>
                <CANDIDATE_SYSTEMS>*</CANDIDATE_SYSTEMS>
                <COMPONENT_DEPENDENCY>RDBMS</COMPONENT_DEPENDENCY>
                <DATABASE_MODE>3</DATABASE_MODE>
                <DATABASE_TYPE>PDB:NORMAL</DATABASE_TYPE>
                <DATABASE_ROLE>PRIMARY</DATABASE_ROLE>
                <ALERT_LEVEL>FAIL</ALERT_LEVEL>
                <PASS_MSG>Database FORCE LOGGING mode is enabled as recommended</PASS_MSG>
                <FAIL_MSG>Database FORCE LOGGING mode is NOT enabled as recommended</FAIL_MSG>
                <BENEFIT_IMPACT>
                      <![CDATA[  Forced logging should be enabled in the database to ensure that all changes are written to the redo logs.]]>
                </BENEFIT_IMPACT>
                <RISK>
                      <![CDATA[  With FORCE LOGGING not enabled some data may not be recoverable]]>
                </RISK>
                <ACTION_REPAIR>
                        <![CDATA[Enable FORCE LOGGING mode.  See the referenced MOS note for more details.]]>
                </ACTION_REPAIR>
                <LINKS>
                        <LINK>Note: 290161.1 - The Gains and Pains of Nologging Operations in a Data Guard Environment</LINK>
                </LINKS>
        </CHECK>

<!-- END USER DEFINED CHECKS -->

</UserDefinedChecks>


