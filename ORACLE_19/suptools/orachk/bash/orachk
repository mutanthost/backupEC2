#!/bin/env bash
{
# MODIFIED (MM/DD/YY)
#    rkchaura 11/13/16 - BDA dom support
#    apriyada 10/27/16 - Change JSON format
#    rkchaura 08/21/16 - CM upgrade
#    mengwliu 08/09/16 - Add support for OCM-e TOR switch
#    rkchaura 07/19/16 - BUG 23642701
#    rkchaura 06/23/16 - Bug 23607297
#    rkchaura 06/16/16 - Bug 23585932
#    gadiga   05/23/16 - zfs timeout in watchdog
#    rkchaura 05/17/16 - Bug 23289834
#    gadiga   05/13/16 - bug 23280240: increase zfs timeout to 20 seconds
#    gadiga   05/11/16 - old way for crs version
#    gadiga   05/11/16 - fix RAT_DB
#    gadiga   05/10/16 - zfssa tag in zfs opc run
#    apriyada 05/03/16 - Determine download URL dynamically
#    gadiga   05/03/16 - ignore excluded checks
#    mengwliu 05/03/16 - Bug fix for External ZFS checks
#    rkchaura 04/28/16 - CM DB upload permission fix
#    mengwliu 04/28/16 - Generate aksh script for external ZFS
#    rkchaura 04/28/16 - Dig command fix
#    rkchaura 04/28/16 - Bug 23074163
#    apriyada 04/19/16 - Bug 21947833
#    gadiga   04/12/16 - json chanes
#    apriyada 04/12/16 - Bug 20018893
#    rkchaura 04/11/16 - Bug 23074512
#    apriyada 04/11/16 - Do not display profile name if it is hidden
#    mengwliu 04/08/16 - Fix bugs in external ZFS code
#    rkchaura 04/06/16 - CM enhancement
#    apriyada 04/05/16 - Bug 22619220
#    mengwliu 03/29/16 - Add commandline argument to override external ZFS
#    apriyada 03/28/16 - Enhancement to acchk
#    gadiga   03/25/16 - ZFS in opc
#    mengwliu 03/25/16 - Add support for external ZFS
#    apriyada 03/24/16 - Option to print critical issues
#    apriyada 03/22/16 - When print view is clicked, only the current state
#                        should be expanded and printed
#    apriyada 03/14/16 - EM version support
#    rkchaura 03/10/16 - Filechecker Integration
#    gadiga   03/10/16 - XbranchMerge gadiga_opc_preprod_fixes from
#                        st_tfa_orachk121026
#    mengwliu 03/08/16 - Add foxtrot_icsvm and foxtrot_mcsvm modules
#    apriyada 02/25/16 - Add vmpscan to report
#    rkchaura 02/24/16 - Daemon autorun fixes
#    rkchaura 02/19/16 - Bug 22746951
#    rkchaura 02/12/16 - send email from cell
#    apriyada 02/11/16 - Add link to check-id
#    gadiga   03/03/16 - fixes for opc preprod
#    gadiga   02/04/16 - fix patch rec for restart
#    mengwliu 01/29/16 - Change Exaware IP for privileged controlvm.
#    apriyada 01/28/16 - Delete input directory
#    gadiga   01/28/16 - fix 22609850 : imageinfo fails
#    gadiga   01/25/16 - cell output in json
#    gadiga   01/21/16 - check exclude
#    gadiga   01/20/16 - fix email
#    rkchaura 01/14/16 - wallet without password
#    benyliu  01/12/16 - Change system identifier information to Oracle Public
#                        Cloud Machine; Change Text "Exalogic" to Oracle Public
#                        Cloud Machine or OPCM on html report heading.
#    rkchaura 01/10/16 - BUG 22444387
#    rkchaura 01/07/16 - BUG 22150715
#    apriyada 01/05/16 - UI changes
#    apriyada 01/05/16 - Bug 22280001
#    rkchaura 12/27/15 - Bug 21492579
#    rkchaura 12/18/15 - BUG 22242829
#    apriyada 12/18/15 - Display check details inline
#    rkchaura 12/17/15 - BUG 22267177
#    gadiga   12/10/15 - json changes
#    gadiga   12/10/15 - use unzip -o
#    rkchaura 12/08/15 - Oracle Wallet
#    gadiga   12/10/15 - use unzip -o
#    apriyada 12/07/15 - Bug 20949513
#    gadiga   12/04/15 - support nimbula in exalogic
#    gadiga   12/02/15 - add opc support
#    rkchaura 11/26/15 - Bug 22253121
#    apriyada 11/16/15 - Create json files for results and exceptions
#    rkchaura 11/13/15 - command line option to lock-unlock cells using exacli
#    apriyada 10/26/15 - Remove password from debug file
#    apriyada 09/30/15 - PeopleSoft Support
#    apriyada 09/30/15 - Bug 21924255
#    rkchaura 09/28/15 - EXACLI functionality to run exachk on storage server
#                        in lock down mode
#    apriyada 09/25/15 - html changes for lrg parsing
#    rkchaura 09/16/15 - Bug 21088902-updated to validate autorun_schedule
#                        values
#    apriyada 09/15/15 - Bug 21488601
#    rkchaura 09/10/15 - Bug-21775407 does not hang if nm2user has wrong pwd
#    benyliu  09/09/15 - Update exachk_exalogic.conf parsing from exaware
#                        output in exalogic oracle_compute mode
#    apriyada 09/09/15 - Execute once : OIM checks
#    apriyada 09/07/15 - Add IDM checks in IDM sectionExecute only should run
#                        on oim machine and not local node
#    apriyada 09/07/15 - Add IDM checks in IDM section
#    rkchaura 09/04/15 - BUG 21767752 - Print daemon log file path on screen
#    rkchaura 09/02/15 - added class attribute in html report
#    rkchaura 08/31/15 - upgrade(pre and post) is now able to use daemon data
#    rkchaura 08/23/15 - orachk -u return to console after throwing error
#    rkchaura 08/13/15 - changes to html report to easily iterate over the
#                        checks
#    rkchaura 08/12/15 - validate for correct input
#    apriyada 07/31/15 - Bug 20872968
#    apriyada 07/22/15 - Bug 21444188
#    gadiga   06/30/15 - fix si issue when dbnames have prefix
#    apriyada 06/05/15 - Siebel profile checks
#    apriyada 05/18/15 - Add custom checks
#    rojuyal  05/07/15 - Fix EM Issues
#    rojuyal  05/05/15 - BUG-20983254
#    apriyada 04/28/15 - Bug 20772086
#    gadiga   04/12/15 - IDM support
#    gadiga   12/23/14 - IDM support
#    apriyada 04/05/15 - Integrate acchk
#    apriyada 03/09/15 - Fix metadata IPAddr issue
#    apriyada 02/19/15 - cygwin warning
#    apriyada 02/11/15 - new report format for orachk/exachk
#    apriyada 02/03/15 - BUG 20441625
#    rojuyal  02/01/15 - Exalogic Foxtrot Changes
#    rojuyal  01/21/15 - Exalogic Spin Switch and Storage Changes
#    apriyada 01/21/15 - set EMAGENT_INST
#    rojuyal  12/19/14 - Fixed Script Injection Vulnerabilities
#    apriyada 12/18/14 - corroborate profile
#    rojuyal  12/12/14 - Added Infrastructure Software and Configuration Summary Section
#    rojuyal  12/10/14 - BUG 18022854(PART 1)
#    apriyada 12/10/14 - Platinum in report
#    rojuyal  11/27/14 - BUG 18393291
#    rojuyal  11/27/14 - BUG 19897409,20089352, RAT_ZFS_ROOT_TIMEOUT for ZFS, instead of RAT_ROOT_TIMEOUT
#    apriyada 11/26/14 - Em header
#    rojuyal  11/20/14 - BUG 19881738
#    rojuyal  11/20/14 - Change in discovery code for uneven oracle homes.
#    rojuyal  11/19/14 - Bug 19385724 , Moved Main debug log inside log directory
#    apriyada 11/18/14 - BUG 19869334
#    apriyada 11/11/14 - Bug 19304345
#    apriyada 11/09/14 - EBS SPECIFIC MESSAGE ABOUT TIMEOUT IN EBS SECTION OF
#                        ORACHK REPORT
#    rojuyal  11/05/14 - silent and force option
#    rojuyal  11/13/14 - Bug 17308279
#    rojuyal  11/04/14 - Mos URL changes
#    cgirdhar 10/24/14 - X5 support
#    apriyada 10/23/14 - Fix noupgrade issue
#    apriyada 10/22/14 - EM Agent
#    cgirdhar 10/22/14 - zLinux support
#    rojuyal  10/16/14 - Changes related to ORACLE_BASE and RAT_OUTPUT
#    apriyada 10/16/14 - Reduce score only for logic info checks
#    cgirdhar 10/16/14 - OL 7 support
#    rojuyal  10/15/14 - Custom Alert level
#    cgirdhar 10/15/14 - Oracle Linux 6 support for Exadta
#    apriyada 09/30/14 - Fix read only issue in auto upgrade
#    gadiga   09/30/14 - fix RAT_IBSWITCH_USER
#    apriyada 09/15/14 - Fix Issues in profile only
#    apriyada 09/11/14 - Auto upgrade changes
#    gadiga   09/11/14 - exalytics
#    gadiga   09/10/14 - fix 19483326.. remove passwords in debug
#    gadiga   09/10/14 - fix 19514154 - wrong asm patch file name
#    rojuyal  09/09/14 - Bug:18861189
#    gadiga   09/08/14 - sudo root
#    rojuyal  09/04/14 - Bug:14008679
#    gadiga   09/05/14 - SC checks
#    gadiga   09/05/14 - dblra issues
#    gadiga   09/04/14 - add EM section in report
#    gadiga   09/04/14 - dblra discovery issue
#    rojuyal  09/01/14 - Running script as ROOT user(psqlplus changes)
#    cgirdhar 08/12/14 - Changes to support DBLRA appliance
#    rojuyal  08/08/14 - Bug 19386798
#    apriyada 08/05/14 - Diff the collections between two runs
#    apriyada 07/22/14 - Switch IP Verification at Prompt
#    rojuyal  07/21/14 - BUG:18993064
#    apriyada 07/20/14 - Merge checks for report
#    apriyada 07/17/14 - Add Hardware Version Information
#    rojuyal  07/15/14 - EM Changes - BUG:17818263
#    apriyada 07/10/14 - Score Mechanism when components are skipped
#    apriyada 06/19/14 - Merging same check with different exit value
#    rojuyal  07/03/14 - BUG: 18382908 , 19135947
#    apriyada 06/18/14 - Sudo support for guest domU
#    apriyada 06/19/14 - Exachk support "no Ping" (SSH is enabled)
#    apriyada 06/19/14 - New profile module - EXALOGIC_PROFILEONLY
#    rojuyal  06/10/14 - Running script as ROOT user
#    rojuyal  06/10/14 - EM Changes - BUG:17818221
#    apriyada 06/17/14 - ZFSSA fix
#    gadiga   06/10/14 - support cygwin
#    apriyada 05/21/14 - Fix ^M issue
#    apriyada 05/13/14 - Auto upgrade
#    rojuyal  05/13/14 - Platform related changes
#    gadiga   05/09/14 - system patch reco
#    rojuyal  05/09/14 - Mulitple Autorun schedules
#    gadiga   05/08/14 - exalogic dns issue
#    rojuyal  05/07/14 - BUG 18690575 18719926
#    rojuyal  05/07/14 - Parsing top time consuming checks
#    gadiga   05/07/14 - exalogic dns issue
#    rojuyal  05/02/14 - Fixed Single Instance discovry Issue
#    rojuyal  05/02/14 - Fixed BUG 18382908
#    apriyada 05/05/14 - Add Duration
#    rojuyal  04/30/14 - Fixed BUG 18665313,18665217,18665077,18664811,18675977,18350335
#    cgirdhar 04/28/14 - PDB to CDB mapping
#    apriyada 04/28/14 - Context Sensitive Help
#    cgirdhar 04/24/14 - X4-8 support
#    rojuyal  04/23/14 - Fixed BUG 18514932,18515349,18515449,18515507,18515463,18361278
#    rojuyal  04/23/14 - Fixed BUG 18456411
#    rojuyal  04/22/14 - Store localcmd.sh files for debugging, Modifications for merge functionality
#    rojuyal  04/22/14 - hostname corresponding to hostname in equivalency message
#    rojuyal  04/21/14 - Fixed BUG 18442011, 18530656, 18530680, 18541816, 18358758(/usr/bin/expect -> $EXPECT)
#    rojuyal  03/27/14 - support for DB parallaization 
#    cgirdhar 03/19/14 - Report command support for clusterwide checks
#    cgirdhar 03/17/14 - pre/post upgrade suport for single instance
#    cgirdhar 03/14/14 - logging to pdb without password
#    rojuyal  03/14/14 - Fixed BUGS:18392717,18392778,18398256
#    cgirdhar 02/28/14 - 2.2.4 proudction
#    rojuyal  01/24/14 - expect changes, script debugging
#    cgirdhar 01/14/14 - uploaded installed patches to database
#    cgirdhar 12/10/13 - support for multipleline checks and report commands
#    rojuyal  11/26/13 - BUG Fix: 17882201,17896809,17620698,17849308
#    rojuyal  11/26/13 - Exalogic GuestVM and Hybrid changes
#    rojuyal  11/22/13 - Merge collections(for different profiles, nodes and users)
#    cgirdhar 11/19/13 - GoldenGate application support
#    gadiga   11/05/13 - inittab changes
#    cgirdhar 11/01/13 - count storage server checks in healthscore
#    cgirdhar 10/30/13 - Move root script from /tmp
#    cgirdhar 10/28/13 - Added support for location file
#    rojuyal  10/18/13 - new option : -excludeprofile <profile> 
#    rojuyal  10/17/13 - EBS support
#    cgirdha  10/16/13 - Fixed patch upload issue for ASM_HOME
#    cgirdha  09/17/13 - zip file upload support
#    gadiga   09/10/13 - bug 17061012
#    gadiga   09/06/13 - password prompts
#    gadiga   09/06/13 - fix exalogic issue with parallel
#    rojuyal  08/21/13 - Fix for BUG 16702324
#    gadiga   08/20/13 - daemon run at specific time and day
#    gadiga   08/20/13 - store all answers in daemon
#    gadiga   08/20/13 - fix second db home expand (er 4888)
#    cgirdhar 08/12/13 - X4-2 support
#    cgirdhar 08/08/13 - disable software/firmware reprot for Exadata
#    rojuyal  08/02/13 - Fix for 16979212,17226854,17220748
#    cgirdhar 07/24/13 - Fix for 17209210
#    rojuyal  07/24/13 - Changes for root collections on compute, cells and switches 
#    cgirdhar 07/18/13 - skip checks based on name and list them in final report
#    rojuyal  07/18/13 - Support for BDA(Big Data Appliance)
#    cgirdhar 07/16/13 - X3-2 support for supercluster
#    gadiga   07/15/13 - echo exallogic
#    gadiga   07/15/13 - run exachk at specific time and day using Daemon
#    rojuyal  07/11/13 - Fixed Running DB discovery
#    gadiga   07/11/13 - fix remote ASM
#    rojuyal  07/08/13 - Fix for 17081319 and various other modifications
#    rojuyal  07/08/13 - Changes for consolidated Echo VM(Exalogic)
#    cgirdhar 07/05/13 - Fix for 17061977
#    cgirdhar 07/03/13 - Fix for odachk bug 16832171
#    rojuyal  07/03/13 - Integrate auto downloader
#    rojuyal  06/24/13 - TimesTen support in exalytics
#    gadiga   06/14/13 - dont run exalogic discovery if exalytics
#    rojuyal  06/03/13 - Fix for BUG:16894500
#    cgirdhar 05/24/13 - Making beta for 2.2.2
#    gadiga   05/22/13 - source /etc/profile
#    rojuyal  05/21/13 - create_version.pl Integration
#    gadiga   05/20/13 - remove extra - in links
#    rojuyal  05/20/13 - Integrate create_version.pl
#    rojuyal  05/17/13 - add create_version.pl .
#    gadiga   05/15/13 - root password using expect
#    rojuyal  05/15/13 - Changes For BUG 16520619
#    gadiga   05/06/13 - root issue in parallel and handle missing md5sum
#    gadiga   05/03/13 - flags in auto mode
#    cgirdhar 05/02/13 - regular health check with post ugprade
#    cgirdhar 05/01/13 - fix for 16687669
#    gadiga   04/29/13 - adding -set option
#    gadiga   04/25/13 - check for password changes in daemon mode
#    gadiga   04/25/13 - ssh password prompt
#    gadiga   04/24/13 - exalytics minor fixes
#    gadiga   04/24/13 - database prompts
#    gadiga   04/24/13 - different root passwords
#    gadiga   04/23/13 - daemon with commands
#    gadiga   04/23/13 - bug 16519731
#    gadiga   04/23/13 - upgrade issue in parallel
#    gadiga   04/22/13 - silent on cell and switch
#    gadiga   04/22/13 - bug 16680382
#    gadiga   04/22/13 - exalytics changes
#    cgirdhar 04/18/13 - multiple version support for upgrade
#    cgirdhar 04/11/13 - OBIEE support in exalytics
#    gadiga   04/09/13 - OPSTAT issue on switch
#    cgirdhar 04/08/13 - fix for 14534296
#    cgirdhar 04/04/13 - distinguish between spine and leaf switch
#    cgirdhar 04/02/13 - Fix for mixed hardware types storage servers bug
#                        16243437
#    gadiga   04/01/13 - fix 16561752
#    gadiga   04/01/13 - fix solaris exalogic issue and multiple db with
#                        similar names
#    cgirdhar 03/28/13 - handling IS_SYSDBA for multiple databases
#    gadiga   03/27/13 - daemon mode support
#    cgirdhar 03/27/13 - output directory re-oraganization
#    cgirdhar 03/25/13 - avm support
#    cgirdhar 03/22/13 - check for higher version of PSU,fixed -m and -r for
#                        SIDB
#    cgirdhar 03/20/13 - finished zfs support for super cluster
#    cgirdhar 03/15/13 - same code zfs on exalogic and SuperCluster
#    cgirdhar 03/14/13 - zfs best practice checking for super cluster
#    cgirdhar 03/12/13 - started changes for exalytics support
#    cgirdhar 03/11/13 - fix for 16441191
#    cgirdhar 02/21/13 - remove HAchecks for exadata
#    gadiga   02/19/13 - raw data browser integration
#    gadiga   02/13/13 - exalogic system identifier
#    cgirdhar 02/07/13 - making 2.2.1 beta
#    gadiga   01/31/13 - cells and switches on command line
#    gadiga   01/29/13 - profiles
#    gadiga   01/27/13 - profiles
#    gadiga   01/25/13 - skipped nodes in report
#    gadiga   01/23/13 - move cp errors to /dev/null
#    cgirdhar 01/22/13 - making hacheck default. same as maa scorecard
#    gadiga   01/20/13 - remove strict host check
#    gadiga   01/14/13 - WRKDIR should have write permission
#    gadiga   01/14/13 - rpm issue
#    cgirdhar 01/11/13 - fix for 16050940
#    gadiga   01/10/13 - fix 16096009
#    cgirdhar 01/09/13 - fix for 15992146
#    gadiga   01/07/13 - stop watchdog after run finishes
#    cgirdhar 01/07/13 - Fix for bug 16081291
#    gadiga   12/27/12 - compute node parallel run
#    cgirdhar 12/21/12 - VM support on ODA
#    cgirdhar 12/12/12 - executing sql collections on pdbs
#    cgirdhar 12/11/12 - executing checks on pdbs
#    cgirdhar 11/29/12 - cross component check support
#    cgirdhar 11/28/12 - spine switch support
#    cgirdhar 11/27/12 - pdb discovery for 12c support
#    cgirdhar 11/26/12 - enhancement in ssh setup to restore system in original
#                        state
#    gadiga   11/20/12 - cleanup cell and ib before new run
#    gadiga   11/15/12 - copy exalogic conf file to outputdir
#    gadiga   11/13/12 - issue when first db down
#    gadiga   11/06/12 - add maa note
#    cgirdhar 11/02/12 - Exadata 1/8 rack support
#    cgirdhar 10/29/12 - changes for 2.2.0 beat
#    cgirdhar 10/26/12 - maa scorecard, profile trap and version change
#    cgirdhar 10/25/12 - X3-8 support
#    gadiga   10/25/12 - SI patch rec
#    gadiga   10/23/12 - new MAA entry
#    gadiga   10/23/12 - exalogic changes
#    gadiga   10/22/12 - cleanup to redirect errors to /dev/null
#    cgirdhar 10/18/12 - clusterwide checks for Exalogic control VMs
#    gadiga   10/12/12 - assign all dbs for locanode
#    gadiga   10/12/12 - separate report for control servers
#    gadiga   10/11/12 - OVS node is not EC
#    cgirdhar 10/11/12 - Fix to handle upper case hostname in v-instance view
#    gadiga   10/11/12 - html report bugs
#    gadiga   10/10/12 - separate ssh prompt for exalogic
#    cgirdhar 10/09/12 - Support for mixed hardware in Exadata
#    gadiga   10/04/12 - exalogic VM support
#    cgirdhar 10/03/12 - Support for hacheck
#    cgirdhar 10/02/12 - Fix for bug 14383945 and ways to pass component from
#                        command line
#    cgirdhar 10/01/12 - Changed RC-00* error messages
#    gadiga   09/24/12 - SI support
#    cgirdhar 09/21/12 - MAA scorecard for supercluster
#    cgirdhar 09/19/12 - Fix for 14559998-delete inputdir on nfs
#    cgirdhar 09/17/12 - changes for supercluster
#    cgirdhar 09/12/12 - ASR healthcheck integration
#    cgirdhar 09/06/12 - component re-organization
#    cgirdhar 09/04/12 - component re-org
#    cgirdhar 08/22/12 - Enhancement to add more columns in upload result table
#                        bug # 14521204
#    cgirdhar 08/15/12 - Added validation to check prompt in profile
#    gadiga   08/13/12 - BUG 13992787: ADA Compliance
#    cgirdhar 08/12/12 - Assign module on each node to support hybrid rack
#    cgirdhar 08/10/12 - Fix for bug 14175874
#    cgirdhar 08/09/12 - bug fixes for 14262805 14227779 and 14319077
#    gadiga   08/09/12 - maa scorecard changes
#    cgirdhar 08/08/12 - Fix for bug 14148335
#    gadiga   08/03/12 - print na for asm home post 112
#    cgirdhar 08/02/12 - Solaris Express support for Exalogic
#    cgirdhar 08/01/12 - fix for bug 14336802
#    gadiga   08/01/12 - hp-ux support
#    cgirdhar 07/31/12 - Added message in log file before removing node from
#                        list in ssh setup function
#    gadiga   07/11/12 - run parallel on cells and swicthes
#    gadiga   06/21/12 - fix dir issue
#    gadiga   05/30/12 - oda single instance bug
#    cgirdhar 05/24/12 - made 2.1.5 prod
#    gadiga   05/22/12 - xml for rac and oda
#    cgirdhar 05/10/12 - final changes before going beta
#    cgirdhar 05/09/12 - change for root password check login delay on linux
#                        database and storage servers
#    cgirdhar 05/02/12 - new way to execute checks on remote nodes
#    gadiga   04/23/12 - skip zfs cell
#    gadiga   04/23/12 - handle case in hostname
#    cgirdhar 04/19/12 - upgrade support in ODA
#    gadiga   04/19/12 - skip merging for -p
#    cgirdhar 04/18/12 - Support for virtual compute nodes in Exalogic
#    gadiga   04/16/12 - cellscript name, disable merge for post
#    gadiga   04/16/12 - arg cnt
#    gadiga   04/15/12 - Fix: opstat in multi db takes last value
#    gadiga   04/13/12 - reset arrays in port & pre
#    gadiga   04/12/12 - RackIdentifier
#    gadiga   04/10/12 - modelversion in xml
#    gadiga   04/08/12 - systemwide in exalogic
#    gadiga   04/02/12 - check name as heading instead of first message
#    gadiga   04/01/12 - fix zfs cell report issue
#    cgirdhar 03/30/12 - Changes to execute storage server collection and
#                        checks
#    gadiga   03/30/12 - exalogic xml updates
#    gadiga   03/29/12 - exalogic zfs cell support
#    gadiga   03/29/12 - link jumps when same check is in pass/fail
#    cgirdhar 03/27/12 - Added validation for Exalogic rack type
#    cgirdhar 03/20/12 - change to run in slient mode for Exalogic
#    cgirdhar 03/19/12 - Changes for Exalogic node discovery and added EXALOGIC
#                        module
#    gadiga   03/06/12 - remove toplevel MAA checks
#    gadiga   03/05/12 - fix -s & -u issue
#    gadiga   03/02/12 - dont run checks on cell in silent
#    cgirdhar 02/14/12 - Solaris 11 Express not supported
#    gadiga   02/14/12 - multiple version support in os_collect
#    gadiga   02/07/12 - consider HOME_PATH for multiple version
#    gadiga   02/05/12 - merge giri's changed
#    gadiga   01/31/12 - multiple db version support
#    gadiga   01/27/12 - comp summary, remote db fixes, bug 13608775
#    gadiga   01/20/12 - merge exalogic support
#    cgirdhar 01/19/12 - Fixed environment checking on remote nodes
#    cgirdhar 01/18/12 - support to copy utility files and skip database if its
#                        upgraded
#    gadiga   01/04/12 - add Installed components summary report
#    gadiga   01/03/12 - add option -t
#    cgirdhar 12/28/11 - reporting improvements in oracle patch checking
#    gadiga   12/27/11 - report patch checks
#    cgirdhar 12/27/11 - enhanced framwork for checking Oracle patches
#    cgirdhar 12/23/11 - support for pre and post upgrade checks
#    gadiga   12/20/11 - bug 13516696
#    gadiga   12/19/11 - handle input parameters
#    gadiga   12/12/11 - remote database
#    gadiga   12/08/11 - 2.1.3 exachk bug fixes
#    gadiga   12/08/11 - version 2.1.4
#    cgirdhar 11/29/11 - Added NEEDS_RUNNING for CLUSTERWIDE_CHECKS for EM
#    cgirdhar 11/22/11 - added support to copy xmls on localnode also for ER
#                        13018831
#    cgirdhar 11/21/11 - improved offline run for MAA scorecard
#    cgirdhar 11/18/11 - ER 13039130 for EM to add two new tags in result and
#                        exception xml
#    gadiga   11/18/11 - add dbname
#    cgirdhar 11/11/11 - detail data for passed clusterwide checks
#    cgirdhar 11/09/11 - fixed RAT_PASSWORDCHECK_TIMEOUT env variable
#    gadiga   11/09/11 - system health score
#    cgirdhar 11/08/11 - changed -m flag functionality for exachk
#    cgirdhar 11/07/11 - fixed bug 13325647 and enhanced root collection
#                        logging
#    cgirdhar 11/04/11 - maa score card testing on standby database
#    gadiga   11/01/11 - maa report
#    cgirdhar 11/01/11 - new argument for maa scroe card
#    cgirdhar 10/27/11 - changes to support multiple components
#    cgirdhar 10/25/11 - imroved to handle standby databases for MAA score card
#    gadiga   10/23/11 - fix typo
#    gadiga   10/21/11 - passed cell checks
#    gadiga   10/18/11 - system wide check
#    cgirdhar 10/18/11 - ER 12977998 for systemwide checks testing
#    cgirdhar 10/17/11 - ER 12977998 for systemwide checks
#    cgirdhar 10/13/11 - fix for bug 12820321
#    cgirdhar 10/11/11 - fixed bug 12815752
#    cgirdhar 10/10/11 - no patch recommendation for odachk
#    cgirdhar 10/05/11 - change for oracle database appliances
#    cgirdhar 10/04/11 - changes for oracle database appliance
#    gadiga   09/27/11 - edit link and program name
#    cgirdhar 09/27/11 - fixed actual value for kumar to match html report to
#                        RAT report
#    gadiga   09/26/11 - missing outfile
#    cgirdhar 09/26/11 - change for rat reprot to match html report
#    cgirdhar 09/23/11 - ER 13017633 and no cell checks in silent mode
#    cgirdhar 09/19/11 - bug fix 12993594
#    cgirdhar 09/17/11 - made it beta for 2.1.3
#    gadiga   09/13/11 - edit html
#    gadiga   09/08/11 - html file name to have date time
#    cgirdhar 09/01/11 - exachk 2.1.2 production version
#    cgirdhar 08/18/11 - copying cells.out to $TMPDIR/.$program_name} for checkDiskFGMapping.sh
#    gadiga 08/18/11 - napply missing patches
#    gadiga 08/17/11 - param without instance name
#    gadiga 08/17/11 - remove .program dir on cells
#    cgirdh 08/16/11 - testing html report
#    gadiga 08/16/11 - format versions html
#    gadiga 08/16/11 - null pass message
#    cgirdh 08/11/11 - changes after x2-2 testing
#    cgirdh 08/10/11 - testing tmp dir changes
#    gadiga 08/10/11 - include versions.html when available
#    gadiga 08/10/11 - show only parameter from instance
#    gadiga 08/09/11 - append versions.html into program.html
#    gadiga 08/09/11 - use /tmp/.program instead of /tmp to create tmp files
#    gadiga 08/09/11 - changes from giri to support x2-x8
#    gadiga 08/01/11 - improve check_id_number perf
#    gadiga 07/28/11 - Show o/p from failed storage server only
#    gadiga 07/28/11 - show zero CRS patch message
#    gadiga 07/28/11 - ORACLE_HOME type
#    cgirdh 07/27/11 - changes on July 27,2011
#    gadiga 07/26/11 - Format changes for patch report
#    cgirdh 07/26/11 - checking out to fix bug 12800318
#    gadiga 07/26/11 - Show patch summary only for raccheck
#    gadiga 07/26/11 - update tool names
#    gadiga 07/25/11 - add patch summary report
#    gadiga 07/25/11 - Fix check-type for exceptions
#    gadiga 07/25/11 - storage server fix
#    gadiga 07/24/11 - fix cwc issue & incorporate review
#    gadiga 07/19/11 - add PASS messages
#    cgirdhar 07/18/11 - testing it on exadata cluster
#    cgirdhar 01/22/09 - Added clusterwide checks functionality 
#    cgirdhar 04/18/08 - Creation
# Define a function to printut usage of this command
#one line if command if [ $expected = $actual ]; then echo "1"; else echo "0";fi;
#export PS4='$0.$LINENO+ '

#change this line before going beta 
program_version="12.2.0.1.3"

GREEN="\033[1;32;40m"
#ORANGE="\033[33;40m"
ORANGE="\033[33;44m"
#RED="\033[1;31;40m"
RED="\033[1;37;41m"
#BLUE="\033[1;34;40m"
BLUE="\033[1;30;46m"
CYAN="\033[1;36;40m"
NORM="\033[0m"
BOLD="\033[1m"
#BLINK="\033[5m"
GREEN="\033[1;32;40m"
ORANGE="\033[33;40m"
RED="\033[1;31;40m"
BLUE="\033[1;34;40m"

PROBE_QUES_CNT=1
G_CELL=0
G_SWITCH=0
G_TORSWITCH=0
G_COMPUTE=0
G_EC=0
G_PC=0
G_DB=0
G_OVMM=0

APPTYPE="GENERIC";
EBS_VER=""
table_printed=0
maa_checkbox=0
pc_checkbox=0
cor_checkbox=0
em_checkbox=0
patch_rec=0
valid_installation=0
mb_emagent_home=""
check2run=""
oimnode=""
oudnode=""
oamnode=""
show_pass_in_report=0

is_windows=0
is_opc=0
no_upgrade=0
skip_usr_def_checks=0
run_check=0
exclude_check=0
debugflagset=0

BAT=""
BIN="bin"
if [ `/bin/uname |grep -c CYGWIN` -gt "0" ] ; then
  export PATH=/usr/bin:/bin:$PATH
  export SHELLOPTS 
  set -o igncr 
  is_windows=1
  BAT=".bat"
  BIN="exe"
  #RAT_COMPUTE_RUNMODE="serial"
  #RAT_LOCALONLY=1

  perl_exe=$(which perl|sed 's/\r//')
  if [ -z "$perl_exe" ] ; then
    echo "";
    echo "Failed to find perl exectable in PATH. Perl is needed to discover Oracle stack components automatically. Please set PATH and run again.";
    echo "";
    exit;
  fi
fi

if [ -z "$RAT_DB_APP_USER" ] ; then
  RAT_DB_APP_USER="apps"
fi


RAT_UPGRADE_LOC=`env | grep RAT_UPGRADE_LOC`


if [[ -z "$RAT_UPGRADE_LOC" ]]
then
 if [[ -n "$RAT_ORATAB_LOC" ]]
 then
  ORATAB=$RAT_ORATAB_LOC;
 else
  case `/bin/uname` in
    Linux)
      ORATAB=/etc/oratab
      ;;
    SunOS)
      ORATAB="/var/opt/oracle/oratab"
      ;;
    HP-UX)
      ORATAB=/etc/oratab
      ;;
    AIX)
      ORATAB=/etc/oratab
      ;;
    CYGWIN_NT-[0-9].[0-9])
      ORATAB="win_oratab.out"
      ;;
    *)
      /bin/echo "ERROR: Unknown Operating System"
      ;;
  esac
 fi
  #ora_home=$(cat $ORATAB |grep ":/" |grep -v "+"|grep -v "^#"|cut -d: -f2|tr '\n' "/suptools,")
  if [ -f "$ORATAB" ]
  then
    #for var in `cat $ORATAB |grep ":/" |grep -v "+"|grep -v "^#"|cut -d: -f2`
    for var in `grep ":/" $ORATAB |grep -v "+"|grep -v "^#"|cut -d: -f2`
    do
      ora_home="$ora_home,$var/suptools"
    done

    RAT_UPGRADE_LOC=$(echo $ora_home| sed 's/^,//') 
  fi
fi

cur_dir=`pwd`

RAT_UPGRADE_LOC="$RAT_UPGRADE_LOC,$cur_dir"

RAT_PLA_AREA="WF,DiscreteMFGExecutionandFinancials,FIXEDASSETS,HUMANRESOURCES,ORDERMANAGEMENT,PAYABLES,PROCESSMANUFACTURING,PROCUREMENT,PROJECTS,RECEIVABLES,SALESANDMARKETING,SERVICEANDCONTRACTS,PRICEMANAGEMENT,UNKNOWN";
RAT_PLA_GRP="Workflow, Sales and Marketing, Service and Contracts, Fixed Assets, Payables, Projects, Receivables, Human Resources Management System, Process Manufacturing, Procurement, Order Management, Discrete Manufacturing, Price Management";

check_upgrade_ret_val="";

more_cmd=$(which more 2>/dev/null);
if [ -z "$more_cmd" ]; then
  display_mode=1
else
  display_mode=2
fi

usage_IDM()
{
  if [ $is_windows -eq "1" ] ; then return; fi
echo -e "	
	Identity Management Options:
		-idm -h: Prints help for Identity Management
		- [<idmpreinstall|idmpostinstall|idmruntime|idmdbpreinstall|idmdbpostinstall|idmdbruntime>] [-idm_config "\<IDMCONFIG\>"] [-idmdiscargs "\<IDMDISCARGS\>"] [-idmhcargs "\<IDMHCARGS\>"]
                idmpreinstall   : Run all preinstall checks on Identity Management System
                idmpostinstall	: Run all postinstall checks on Identity Management System
                idmruntime      : Run all runtime checks on Identity Management System
                idmdbpreinstall : Run preinstall database checks on Identity Management System
                idmpdbostinstall: Run postinstall database checks on Identity Management System
                idmdbruntime    : Run runtime database checks on Identity Management System
                idm_config	: Pass OAM, OIM and one of the OUD host from clusters. 
		idmdiscargs	: Pass arguments to Identity Management Discovery Tool.
		idmhcargs	: Pass arguments to Identity Management Healthcheck Tool.

		    example	: 
		  		  Run preinstall checks
				  ${program_name} -idmpreinstall -idm_config \"OUD_HOST=h1,h2;OIM_HOST=h3,h4;OAM_HOST=h5,h6,h7;OHS_HOST=h8,h9\"

		  		  Run preinstall database checks
				  ${program_name} -idmdbpreinstall

		  		  Run postinstall checks on single node Identity Management setup
				  ${program_name} -idmpostinstall -idm_config \"singlenode\" 

				  Run runtime checks on multinode Identity Management setup
				  ${program_name} -idmruntime -idm_config \"OUD_HOST=host1,host2;OAM_HOST=host3;OIM_HOST=host4\" 

				  Run OIM runtime checks on multinode Identity Management setup
				  ${program_name} -idmruntime -idm_config \"OUD_HOST=host1,host2;OAM_HOST=host3;OIM_HOST=host4\" -profile \"OIM\" 

		  		  Run OIM & OAM postinstall checks on single node Identity Management setup
				  ${program_name} -idmpostinstall -idm_config \"singlenode\" -profile \"OIM,OAM\"

			   	  Run runtime checks with loglevel specified for Identity Management Discovery and Healthcheck tool.
				  ${program_name} -idmruntime -idmdiscargs \"-DlogLevel=FINEST\" -idmhcargs \"-DlogLevel=FINEST\"	

		-<idmpreinstall|idmpostinstall|idmruntime> -topology <topology.xml> -credconfig <credconfig>
		Run checks directly passing topology.xml and credconfig location
"
}

usage_AR()
{
  if [ $is_windows -eq "1" ] ; then return; fi
echo -e "	
	Auto Restart Options:
		-auto_restart -h: Prints help for this option
		-<initsetup|initdebugsetup|initrmsetup|initcheck|initpresetup>
                initsetup       : Setup auto restart. Auto restart functionality automatically brings up ${program_name} daemon when node starts
                initdebugsetup  : Setup auto restart in debug mode 
                initrmsetup     : Remove auto restart functionality
                initcheck       : Check if auto restart functionality is setup or not
                initpresetup    : Sets root user equivalency for COMPUTE, STORAGE and IBSWITCHES.(root equivalency for COMPUTE nodes is mandatory for setting up auto restart functionality)

"
}

usage_report()
{
echo -e "	
	Report Options:
	-nopass
                Skip PASS'ed check to print in ${program_name} report and upload to database.

        -noscore
                Do not print healthscore in HTML report.

	-showpass 
		Show PASS'ed checks in the ${program_name} report by default
	-show_critical
                Show Critical checks in the ${program_name} report by default

        -diff <Old Report> <New Report> [-outfile <Output HTML>] [-force]
                Diff two ${program_name} reports. Pass directory name or zip file or html report file as <Old Report> & <New Report> 
		-force : To compare different profiles collections or profile with non-profile collection.
 
        -exadiff <Exalogic collection1> <Exalogic collection2>
                Compare two different Exalogic rack and see if both are from the same release.Pass directory name or zip file as <Exalogic collection1> & <Exalogic collection2>(applicable for Exalogic only)

	-merge [-force]
                Pass comma separated collection names(directory or zip files) to merge collections and prepare single report.
                eg:- ./${program_name} -merge ${program_name}_hostname1_db1_120213_163405.zip,${program_name}_hostname2_db2_120213_164826.zip

                -force
	                Merge collections from dom0 and domu or global and local zones.
			eg:- ./${program_name} -merge ${program_name}_hostname1_db1_120213_163405.zip,${program_name}_hostname2_db2_120213_164826.zip -force

        -tag <tagname>
                Appends <tagname> to Report Name. <Tagname> must contain only alphanumeric characters.
		for eg: ./${program_name} -tag newtag123 will append 'newtag123' to report name like '${program_name}_hostname1_db1_100914_123456_newtag123.html'
"
}

usage_dopt()
{
echo -e "        
        -d <start|start_debug|stop|status|info|stop_client|nextautorun|-h>
                start           	: Start the ${program_name} daemon
                start_debug		: Start the ${program_name} daemon in debug mode
                stop            	: Stop the ${program_name} daemon
                status          	: Check if the ${program_name} daemon is running
                info            	: Print information about running ${program_name} daemon
                stop_client     	: Stop the ${program_name} daemon client

                nextautorun [-id <ID>]  : print the next auto run time
		                          if '-id <ID>' is specified, it will print the next auto run time for specified autorun schedule ID

		-h              	: Prints help for this option
"
}

usage_daemon()
{
echo -e "	
        Daemon Options:
"
	usage_dopt;
echo -e "

        -daemon
                run ${program_name} only if daemon is running
        -nodaemon
                Do not use daemon to run ${program_name} 
        [-id <ID>] -set
                configure ${program_name} daemon parameter like 'param1=value1;param2=value2... '
 	 	if '-id <ID>' is specified, it will configure ${program_name} daemon parameter(s) for specified autorun schedule ID	
               
                 Supported parameters are:-
 
                 (Deprecated) - AUTORUN_INTERVAL <n[d|h]> :- Automatic rerun interval in daemon mode. Set it zero to disable automatic rerun which is zero.
                                                                  
 
                 AUTORUN_SCHEDULE * * * *       :- Automatic run at specific time in daemon mode. AUTORUN_INTERVAL will be ignored when AUTORUN_SCHEDULE is used.
                                  - - - -
                                  ? ? ? ?
                                  ? ? ? +----- day of week (0 - 6) (0 to 6 are Sunday to Saturday)
                                  ? ? +---------- month (1 - 12)
                                  ? +--------------- day of month (1 - 31)
                                  +-------------------- hour (0 - 23)
 
                     example: ${program_name} -set 'AUTORUN_SCHEDULE=8,20 * * 2,5' will schedule runs on Tuesday and Friday at 8 and 20 hour.
                  
                 AUTORUN_FLAGS <flags> : ${program_name} flags to use for auto runs.
         
                     example: ${program_name} -set 'AUTORUN_INTERVAL=12h;AUTORUN_FLAGS=-profile sysadmin' to run sysadmin profile every 12 hours
 
                              ${program_name} -set 'AUTORUN_INTERVAL=2d;AUTORUN_FLAGS=-profile dba' to run dba profile once every 2 days.
 
                 NOTIFICATION_EMAIL : Comma separated list of email addresses used for notifications by daemon if mail server is configured.

                 PASSWORD_CHECK_INTERVAL <number of hours> : Interval to verify passwords in daemon mode

                 collection_retention <number of days> : Purge ${program_name} collection directories and zip files older than specified days. 

        [-id <ID>] -unset <parameter | all>
                unset the parameter
 	        if '-id <ID>' is specified, it will unset the parameter for specified autorun schedule ID
                  example: ${program_name} -unset "AUTORUN_SCHEDULE"

        [-id <ID>] -get <parameter | all>
                Print the value of parameter. 
	        if '-id <ID>' is specified,  it will print the value of parameter for specified autorun schedule ID

"
}

usage_profilesw()
{
echo -e " 
        Profile Run Options:
        -profile
	        Pass specific profile. 
                With -h prints help.
                List of supported profiles:
"

if [ -e $SCRIPTPATH/.cgrep/profiles.dat ]
then
    if [[ ${program_name} = "raccheck" || ${program_name} = "odachk" ]] ; then
      grep -v "^.-" $SCRIPTPATH/.cgrep/profiles.dat| sort |grep -ivw "ControlVM" | grep -ivw "Switch" | grep -v "storage"|grep -v "debug_check" |grep -v pdit | grep -v "virtual_infra" |grep -v "el_" |grep -v "timesten" |grep -v "obiee"|awk -F"|" '{printf "                 %-15s %-20s\n",$1,$NF}'
    else # Show all
      grep -v "^.-" $SCRIPTPATH/.cgrep/profiles.dat|grep -v "debug_check" |grep -v pdit |grep -v "|1$"|sort | awk -F"|" '{printf "                 %-15s %-20s\n",$1,$(NF-1)}'
    fi
fi

}

usage_profiles()
{
   usage_profilesw;
echo -e "
        -excludeprofile
                Pass specific profile.
                List of supported profiles is same as for -profile.
"

}

usage_granular()
{
  if [[ $1 == "-a" ]] ; then
    echo -e "	
        -a      All (Perform best practice check and recommended patch check)
    "
  elif [[ $1 == "-b" ]] ; then
    echo -e "	
	-b      Best Practice check only. No recommended patch check
    "
  elif [[ $1 == "-v" ]] ; then
    echo -e "	
        -v      Show version
    "
  elif [[ $1 == "-p" ]] ; then
    echo -e "	
        -p      Patch check only
    "
  elif [[ $1 == "-m" ]] ; then
    echo -e "	
        -m      exclude checks for Maximum Availability Architecture (MAA) scorecards(see user guide for more details)
    "
  elif [[ $1 == "-u" ]] ; then
    echo -e "	
        -u      Run ${program_name} to check pre-upgrade or post-upgrade best practices for 11.2.0.4 and above
                -o pre or -o post is mandatory with -u option like ./${program_name} -u -o pre
    "
  elif [[ $1 == "-f" ]] ; then
    echo -e "	
        -f      Run Offline. Checks will be performed on data already collected from the system
    "
  elif [[ $1 == "-o" ]] ; then
    echo -e "	
        -o      Argument to an option. if -o is followed by v,V,Verbose,VERBOSE or Verbose, it will print checks which passs on the screen
                if -o option is not specified it will print only failures on screen. for eg: ${program_name} -a -o v
    "
  elif [[ $1 == "-clusternodes" ]] ; then
    echo -e "	
        -clusternodes      Pass comma separated node names to run ${program_name} only on subset of nodes.
    "
  elif [[ $1 == "-output" ]] ; then
    echo -e "	-output	   Set RAT_OUTPUT internally. Create ${program_name} collection zip file and output directory to non-default(current) location.
		      eg: - ./${program_name} -output <PATH>
    "
  elif [[ $1 == "-syslog" ]] ; then
    echo -e "   -syslog    Set RAT_SEND_TO_RSYSLOG internally. ${program_name} will write the JSON results to syslog.
                      eg: - ./${program_name} -syslog
    "
  elif [[ $1 == "-showpass" ]] ; then
    echo -e "   -showpass  Show PASS'ed checks in the ${program_name} report by default
                      eg: - ./${program_name} -showpass
    "
  elif [[ $1 == "-show_critical" ]] ; then
    echo -e "   -show_citical  Show Critical checks in the ${program_name} report by default
                      eg: - ./${program_name} -show_critical
    "
  elif [[ $1 == "-dbnames" ]] ; then
    echo -e "
        -dbnames      Pass comma separated database names to run ${program_name} only on subset of databases
    "
  elif [[ $1 == "-localonly" ]] ; then
    echo -e "	
        -localonly      Run ${program_name} only on local node.
    "
  elif [[ $1 == "-dbnone" ]] ; then
    echo -e "	
        -dbnone      Do not prompt database selection and skip all database related checks.
    "
  elif [[ $1 == "-dball" ]] ; then
    echo -e "	
        -dball      Do not prompt database selection and run database related checks on all databases discovered on system.
    "
  elif [[ $1 == "-c" ]] ; then
    echo -e "	
        -c     Used only under the guidance of Oracle support or development to override default components
    "
  elif [[ $1 == "-merge" ]] ; then
    echo -e "   
        -merge [-force] 
                Pass comma separated collection names(directory or zip files) to merge collections and prepare single report.
                eg:- ./${program_name} -merge ${program_name}_hostname1_db1_120213_163405.zip,${program_name}_hostname2_db2_120213_164826.zip

		-force	
			Merge collections from dom0 and domu or global and local zones.
			eg:- ./${program_name} -merge ${program_name}_hostname1_db1_120213_163405.zip,${program_name}_hostname2_db2_120213_164826.zip -force
		
  "
  elif [[ $1 == "-diff" ]] ; then
    echo -e "   
        -diff <Old Report> <New Report> [-outfile <Output HTML>] [-force]
                Diff two ${program_name} reports. Pass directory name or zip file or html report file as <Old Report> & <New Report>
		-force : To compare different profiles collections or profile with non-profile collection.
  "
  elif [[ $1 == "-upgrade" ]] ; then
    echo -e "   
        -upgrade 
                Used to force upgrade the version of ${program_name} being run if a newer version is available under the location specified by RAT_UPGRADE_LOC.
  "
  elif [[ $1 == "-noupgrade" ]] ; then
    echo -e "   
        -noupgrade 
                User can specify this option if he does not want to be prompted for an upgrade even if a later version is available under the location specified by RAT_UPGRADE_LOC.
 "
elif [[ $1 == "-skip_usr_def_checks" ]] ; then
    echo -e "   
        -skip_usr_def_checks
                User can specify this option if he does not want orachk to run the checks specified in user defined xml even if the file is present.
 "
  elif [[ $1 == "-dbserial" ]] ; then
    echo -e "   
        -dbserial 
                Run SQL, SQL_COLLECT and OS Checks in serial.
  "
  elif [[ $1 == "-dbparallel" ]] ; then
    echo -e "   
        -dbparallel 
		Run SQL, SQL_COLLECT and OS Checks in parallel.
                n       : Specified number of Child processes. Default is 25% of CPUs.
  "
  elif [[ $1 == "-dbparallelmax" ]] ; then
    echo -e "   
        -dbparallelmax 
                Run SQL, SQL_COLLECT and OS Checks in parallel.Number of Child processes will be equal to minimum out of number of CPUs and number of databases.
  "
  elif [[ $1 == "-daemon" ]] ; then
    echo -e "   
        -daemon 
                run ${program_name} only if daemon is running.
  "
  elif [[ $1 == "-nodaemon" ]] ; then
    echo -e "   
        -nodaemon 
                Dont use daemon to run ${program_name}.
  "
  elif [[ $1 == "-cells" ]] ; then
    echo -e "   
        -cells 
                Pass comma separated storage server names to run ${program_name} only on selected storage servers.\n
  "
  elif [[ $1 == "-ibswitches" ]] ; then
    echo -e "   
        -ibswitches 
                Pass comma separated infiniband switch names to run ${program_name} only on selected infiniband switches.\n
  "
  elif [[ $1 == "-torswitches" ]] ; then
    echo -e "   
        -torswitches 
                Pass comma separated Top of Rack switch names to run ${program_name} only on selected Top of Rack switches.\n
  "
  elif [[ $1 == "-tag" ]] ; then
    echo -e "   
        -tag <tagname>
                Appends <tagname> to Report Name. <Tagname> must contain only alphanumeric characters.
		for eg: ./${program_name} -tag newtag123 will append 'newtag123' to report name like '${program_name}_hostname1_db1_100914_123456_newtag123.html'
  "
  elif [[ $1 == "-excludeprofile" ]] ; then
  echo -e "
        -excludeprofile
                Pass specific profile to exclude.
                List of supported profiles is same as for -profile.
"
  elif [[ $1 == "-debug" ]] ; then
  echo -e "
  	-debug
                Run ${program_name} in debug mode. Debug log will be generated. 
                eg:- ./${program_name} -debug
"

  elif [[ $1 == "-hybrid" ]] ; then
    echo -e "
  	-hybrid [-phy]
                phy     :Pass comma separated physical compute nodes(applicable for Exalogic only)
                         eg:- ./${program_name} -hybrid -phy phy_node1,phy_node2
"

  elif [[ $1 == "-vmguest" ]] ; then
  echo -e "
   	-vmguest
                Pass comma separated filenames containing exalogic guest VM list(applicable for Exalogic only)
"
  elif [[ $1 == "-exadiff" ]] ; then
  echo -e "
   	-exadiff <Exalogic collection1> <Exalogic collection2>
                Compare two different Exalogic rack and see if both are from the same release. Pass directory name or zip file as <Exalogic collection1> & <Exalogic collection2>(applicable for Exalogic only)
"

  elif [[ $1 == "-testemail" ]] ; then
  echo -e "
  	-testemail <all | \"NOTIFICATION_EMAIL=email addresses separated by comma\">
               Sends a test email to validate email configuration.

               all: This option is used to validate daemon email configuration.

               -usecompute : If storage cells on exadata are unable to send email then we have alternate option -usecompute to send mail from database server.
                         eg: ./${program_name} -testemail \"NOTIFICATION_EMAIL=abc@company.com,xyz@company.com\" -usecompute
"

  elif [[ $1 == "-unlockcells" ]] ; then
  echo -e "
  	-unlockcells <all | -cells [cell names or cell IPs separated by comma]>
               Used to unlock the storage cells.
               Applicable only for exadata and supercluster.
               Options:
                       all: unlocks all the available cells
                         eg:- ./${program_name} -unlockcells all

                       -cells <cell names or cell IPs separated by comma>
"

  elif [[ $1 == "-lockcells" ]] ; then
  echo -e "
  	-lockcells <all | -cells [cell names or cell IPs separated by comma]>
               Used to lock the storage cells.
               Applicable only for exadata and supercluster.
               Options:
                       all: locks all the available cells
                         eg:- ./${program_name} -lockcells all

                       -cells <cell names or cell IPs separated by comma>
"

  elif [[ $1 == "-checkfaileduploads" ]] ; then
  echo -e "
  	-checkfaileduploads
               Prints list of collections for which upload failed
                         eg:- ./${program_name} -checkfaileduploads
"

  elif [[ $1 == "-uploadfailed" ]] ; then
  echo -e "
  	-uploadfailed <all | [List of collections separated by comma]>
               Uploads the collections in Database.
               Options:
                       all: Re-uploads all collections for which upload failed.
                         eg:- ./${program_name} -uploadfailed all
                              ./${program_name} -uploadfailed \"/tmp/orachk_rws1270065_042016_232011.zip\"
"

  elif [[ $1 == "-fileattr" ]] ; then
  echo -e "
  	-fileattr   
               Used to check file attribute changes.
               Options:
                      start: Takes file attributes snapshot of discovered directories.
                        eg: ./$program_name -fileattr start
                      check: Takes a recent snapshot of discovered directories and compares with the previous snapshot.
                        eg: ./$program_name -fileattr check
                      remove: Removes file attribute snapshots and related files.
                        eg: ./$program_name -fileattr remove

                        -includedir: Includes directories given by user at command-line to check file attributes.
                          eg: ./$program_name -fileattr start -includedir \"/root/home,/etc\"
                          eg: ./$program_name -fileattr check -includedir \"/root/home,/etc\"

                        -excludediscovery: Excludes the discovered directories.
                          eg: ./$program_name -fileattr start -includedir \"/root/home,/etc\" -excludediscovery

                        -baseline <baseline snapshot path>
                          eg: ./${program_name} -fileattr check -baseline \"/tmp/Snapshot\" 

                        -fileattronly: This option performs file attributes check only and exits $program_name
                          eg: ./$program_name -fileattr check -fileattronly
"
              
  elif [[ $1 == "-setdbupload" ]] ; then
  echo -e "
  	-setdbupload 
               Sets the Environment variables in the wallet to upload ${program_name} run result in the database.
               Values must be entered without using double quote.
               options-
                       all: sets all the variables in the wallet.
                         eg: ./${program_name} -setdbupload all

                       <variable names separated by comma>: sets only those variables given on command line.
                         eg: ./${program_name} -setdbupload RAT_UPLOAD_CONNECT_STRING,RAT_UPLOAD_PASSWORD
"

  elif [[ $1 == "-unsetdbupload" ]] ; then
  echo -e "
  	-unsetdbupload 
               unsets the Environment variables in the wallet used to upload ${program_name} run result in the database.
               options-
                       all: unsets all the variables in the wallet.
                         eg: ./${program_name} -unsetdbupload all

                       <variable names separated by comma>: unsets only those variables given on command line.
                         eg: ./${program_name} -unsetdbupload RAT_UPLOAD_CONNECT_STRING,RAT_UPLOAD_PASSWORD
"
  elif [[ $1 == "-checkdbupload" ]] ; then
  echo -e "
  	-checkdbupload
		Checks the status if variables are set correctly for uploading ${program_name} run results in the database.
"
  elif [[ $1 == "-getdbupload" ]] ; then
  echo -e "
  	-getdbupload
		Prints the environment variables with their values from wallet for uploading ${program_name} run result in the database.

"
 elif [[ $1 == "-cmupgrade" ]] ; then
  echo -e "
        -cmupgrade
                Upgrades the collection manager if new version of collection manager is available and DB upload parameters are set in $program_name wallet. 
"

 elif [[ $1 == "-set" ]] ; then
  echo -e "
        [-id <ID>] -set
                configure ${program_name} daemon parameter like 'param1=value1;param2=value2... '
                if '-id <ID>' is specified, it will configure ${program_name} daemon parameter(s) for specified autorun schedule ID     
               
                 Supported parameters are:-
 
                 (Deprecated) - AUTORUN_INTERVAL <n[d|h]> :- Automatic rerun interval in daemon mode. Set it zero to disable automatic rerun which is zero.
                                                                  
 
                 AUTORUN_SCHEDULE * * * *       :- Automatic run at specific time in daemon mode. AUTORUN_INTERVAL will be ignored when AUTORUN_SCHEDULE is used.
                                  - - - -
                                  ? ? ? ?
                                  ? ? ? +----- day of week (0 - 6) (0 to 6 are Sunday to Saturday)
                                  ? ? +---------- month (1 - 12)
                                  ? +--------------- day of month (1 - 31)
                                  +-------------------- hour (0 - 23)
 
                     example: ${program_name} -set 'AUTORUN_SCHEDULE=8,20 * * 2,5' will schedule runs on Tuesday and Friday at 8 and 20 hour.
                  
                 AUTORUN_FLAGS <flags> : ${program_name} flags to use for auto runs.
         
                     example: ${program_name} -set 'AUTORUN_INTERVAL=12h;AUTORUN_FLAGS=-profile sysadmin' to run sysadmin profile every 12 hours
 
                              ${program_name} -set 'AUTORUN_INTERVAL=2d;AUTORUN_FLAGS=-profile dba' to run dba profile once every 2 days.
 
                 NOTIFICATION_EMAIL : Comma separated list of email addresses used for notifications by daemon if mail server is configured.

                 PASSWORD_CHECK_INTERVAL <number of hours> : Interval to verify passwords in daemon mode

                 collection_retention <number of days> : Purge ${program_name} collection directories and zip files older than specified days. 
"

  elif [[ $1 == "-unset" ]] ; then
  echo -e "
        [-id <ID>] -unset <parameter | all>
                unset the parameter
                if '-id <ID>' is specified, it will unset the parameter for specified autorun schedule ID
                  example: ${program_name} -unset "AUTORUN_SCHEDULE"

"

elif [[ $1 == "-get" ]] ; then
  echo -e "
        [-id <ID>] -get <parameter | all>
                Print the value of parameter. 
                if '-id <ID>' is specified,  it will print the value of parameter for specified autorun schedule ID
"

  elif [[ $1 == "-sendemail" ]] ; then
  echo -e "
	Emails the ${program_name} run report.
               Options-
                     NOTIFICATION_EMAIL : Comma separated list of email addresses used for sending report
                       eg:./${program_name} -sendemail \"NOTIFICATION_EMAIL=abc@company.com,xyz@company.com\"

                     -usecompute :  If storage cells on exadata are unable to send email then we have alternate option -usecompute to send mail from database server.
                       eg: ./${program_name} -sendemail \"NOTIFICATION_EMAIL=abc@company.com,xyz@company.com\" -usecompute
"
  elif [[ $1 == "-usecompute" ]] ; then
  echo -e "
  	-usecompute
		This option is available for exadata. With this option mail will be sent from database server and not from storage cells.
                  eg: ./${program_name} -testemail \"NOTIFICATION_EMAIL=abc@company.com,xyz@company.com\" -usecompute
                      ./${program_name} -sendemail \"NOTIFICATION_EMAIL=abc@company.com,xyz@company.com\" -usecompute
"

  elif [[ $1 == "-allserial" ]] ; then
  echo -e "
  	-allserial
	 	Run ${program_name} in serial on compute nodes, storage servers, switches etc.
"
  elif [[ $1 == "-dbnodeserial" ]] ; then
  echo -e "
  	-dbnodeserial
	 	Run ${program_name} in serial on compute nodes.
"
  elif [[ $1 == "-cellserial" ]] ; then
  echo -e "
  	-cellserial
	 	Run ${program_name} in serial on storage servers.
"
  elif [[ $1 == "-switchserial" ]] ; then
  echo -e "
  	-switchserial
	 	Run ${program_name} in serial on switches.
"
  else
    display_usage; 
  fi	
}

usage()
{
if [ "$program_name" = "odachk" ]
then
  echo "Usage : oakcli ${program_name} [-abvhpfmsuSo:c:t:]"
else
  echo "Usage : ./${program_name} [-abvhpfmsuSo:c:t:] "
fi
echo -e "
	-h      Prints this page.
        -a      All (Perform best practice check and recommended patch check)
        -b      Best Practice check only. No recommended patch check
        -v      Show version 
        -p      Patch check only
        -m      exclude checks for Maximum Availability Architecture (MAA) scorecards(see user guide for more details)
        -u      Run ${program_name} to check pre-upgrade or post-upgrade best practices for 11.2.0.4 and above
                -o pre or -o post is mandatory with -u option like ./${program_name} -u -o pre
        -f      Run Offline.Checks will be performed on data already collected from the system
        -o      Argument to an option. if -o is followed by v,V,Verbose,VERBOSE or Verbose, it will print checks which passs on the screen
                if -o option is not specified,it will print only failures on screen. for eg: ${program_name} -a -o v 

        -clusternodes
                Pass comma separated node names to run ${program_name} only on subset of nodes.
	-output
               Create ${program_name} collection zip file and ouptut directory to non-default(current) location.
        -dbnames
               	Pass comma separated database names to run ${program_name} only on subset of databases
        -localonly
               	Run ${program_name} only on local node.
	-debug
	     	Run ${program_name} in debug mode. Debug log will be generated. 
	       	eg:- ./${program_name} -debug
        -dbnone
                Do not prompt database selection and skip all database related checks.   
        -dball
                Do not prompt database selection and run database related checks on all databases discovered on system.

        -c     	Used only under the guidance of Oracle support or development to override default components 

	-upgrade 
		Used to force upgrade the version of ${program_name} being run.
	-noupgrade
		Do not prompt for an upgrade even if a later version is available under the location specified by RAT_UPGRADE_LOC.
	-syslog
               Write JSON results from ${program_name} run to syslog.
	-skip_usr_def_checks
		Do not run checks present in user defined xml file.
"
echo -e "
        -unlockcells <all | -cells [cell names or cell IPs separated by comma]>
               Used to unlock the storage cells.
               Applicable only for exadata and supercluster.
               Options:
                       all: unlocks all the available cells
                         eg:- ./${program_name} -unlockcells all

                       -cells <cell names or cell IPs separated by comma>

        -lockcells <all | -cells [cell names or cell IPs separated by comma]>
               Used to lock the storage cells.
               Applicable only for exadata and supercluster.
               Options:
                       all: locks all the available cells
                         eg:- ./${program_name} -lockcells all

                       -cells <cell names or cell IPs separated by comma>

"
echo -e "
        -checkfaileduploads
               Prints list of collections for which upload failed
                         eg:- ./${program_name} -checkfaileduploads

        -uploadfailed <all | [List of collections separated by comma]>
               Uploads the collections in Database.
               Options:
                       all: Re-uploads all collections for which upload failed.
                         eg:- ./${program_name} -uploadfailed all
                              ./${program_name} -uploadfailed \"/tmp/orachk_rws1270065_042016_232011.zip\"
"
echo -e "
        -fileattr 
               Used to check file attribute changes.
               Options:
                      start: Takes file attributes snapshot of discovered directories.
                        eg: ./${program_name} -fileattr start
                      check: Takes a recent snapshot of discovered directories and compares with the previous snapshot.
                        eg: ./${program_name} -fileattr check
                      remove: Removes file attribute snapshots and related files.
                        eg: ./${program_name} -fileattr remove

                        -includedir: Includes directories given by user at command-line to check file attributes.
                          eg: ./${program_name} -fileattr start -includedir \"/root/home,/etc\"
                          eg: ./${program_name} -fileattr check -includedir \"/root/home,/etc\"

                        -excludediscovery: Excludes the discovered directories.
                          eg: ./${program_name} -fileattr start -includedir \"/root/home,/etc\" -excludediscovery

                        -baseline <baseline snapshot path>
                          eg: ./${program_name} -fileattr check -baseline \"/tmp/Snapshot\" 

                        -fileattronly: This option performs file attributes check only and exits ${program_name}
                          eg: ./${program_name} -fileattr check -fileattronly
"

echo -e "
       -testemail <all | \"NOTIFICATION_EMAIL=email addresses seperated by comma\">
               Sends a test email to validate email configuration.
               all: This option is used to validate daemon email configuration.
"
echo -e "
       -usecompute
               This option is available for exadata. With this option mail will be sent from database server and not from storage cells.
"
echo -e "
       -setdbupload 
               Sets the Environment variables in the wallet to upload ${program_name} run result in the database.
               Values must be entered without using double quote.
               options-
                       all: sets all the variables in the wallet.
                         eg: ./${program_name} -setdbupload all

                       <variable names separated by comma>: sets only those variables given on command line.
                         eg: ./${program_name} -setdbupload RAT_UPLOAD_CONNECT_STRING,RAT_UPLOAD_PASSWORD

       -unsetdbupload 
               Unsets the Environment variables in the wallet to not to upload ${program_name} run result in the database.
               options-
                       all: unsets all the variables in the wallet.
                         eg: ./${program_name} -unsetdbupload all

                       <variable names separated by comma>: unsets only those variables given on command line.
                         eg: ./${program_name} -unsetdbupload RAT_UPLOAD_CONNECT_STRING,RAT_UPLOAD_PASSWORD

       -checkdbupload
               Checks the status if variables are set correctly for uploading ${program_name} run results in the database.

       -getdbupload
               Prints the environment variables with their values from wallet for uploading ${program_name} run result in the database.

       -cmupgrade 
               Upgrades the collection manager if new version of collection manager is available and DB upload parameters are set in $program_name wallet.

       -sendemail
               Emails the ${program_name} run report.
               Options-
                       NOTIFICATION_EMAIL : Comma separated list of email addresses used for sending report
                         eg:./${program_name} -sendemail \"NOTIFICATION_EMAIL=abc@company.com,xyz@company.com\"
"
	usage_report;
	usage_AR;
        usage_daemon;
echo -e "
	-vmguest
		Pass comma separated filenames containing exalogic guest VM list(applicable for Exalogic only)

	-hybrid [-phy]
		phy	:Pass comma separated physical compute nodes(applicable for Exalogic only)
			 eg:- ./${program_name} -hybrid -phy phy_node1,phy_node2	
"
	usage_profiles;	
echo -e " 
        -check
                To execute specific set of checks, pass check_ids at command prompt
                With -h prints help.
";
echo -e "
        -excludecheck
                To exclude specific set of checks, pass check_ids at command prompt
                With -h prints help.
";

echo -e " 
        acchk options:
        1) -acchk
                Env variables to be set:
                  RAT_AC_ASMJAR=path to asm-all-5.0.3.jar       
                  RAT_JAVA_HOME=path to jdk8       
                  RAT_AC_JARDIR=Directory where jar files are present for concrete class       
                  RAT_AC_TRCDIR=Directory where trace files are present for coverage class
                Runs acchk. Expects env variables to be set
        2) Run orachk without any parameter. 
                If the above env variables are set, orachk can be run without any parameter to run acchk.
        3) Passing values in command line instead of env variables.
                ./orachk -acchk -javahome <path to jdk8> -asmhome <path to asm-all-5.0.3.jar > -appjar <directory where jar files are present for concrete class > -apptrc <directory where trace files are present for coverage class>

        Optional variable RAT_ACTRACEFILE_WINDOW variable can be set to <number of days> . Based on this value, files older than the RAT_ACTRACEFILE_WINDOW days are ignored.

                With -h prints help.
"

echo -e "        
        -cells
                Pass comma separated storage server names to run ${program_name} only on selected storage servers.\n
        -ibswitches
                Pass comma separated infiniband switch names to run ${program_name} only on selected infiniband switches.\n
        -torswitches
                Pass comma separated Top of Rack switch names to run ${program_name} only on selected Top of Rack switches.\n
        -zfsnodes
                Pass comma separated ZFS storage appliance names to run ${program_name} only on selected storage appliances.
        -extzfsnodes
                Pass comma separated external ZFS storage appliance names to run ${program_name} only on selected external storage appliances.
        -zfssa
                Pass comma separated ZFS storage appliance names to run ${program_name}.

        -dbserial
                Run SQL, SQL_COLLECT and OS Checks in serial.

        -dbparallel [n]
                Run SQL, SQL_COLLECT and OS Checks in parallel.
                n       : Specified number of Child processes. Default is 25% of CPUs.

        -dbparallelmax
                Run SQL, SQL_COLLECT and OS Checks in parallel.Number of Child processes will be equal to minimum out of number of CPUs and number of databases.

	-allserial
		Run ${program_name} in serial on compute nodes, storage servers, switches etc.	

	-dbnodeserial
		Run ${program_name} in serial on compute nodes.

	-cellserial
		Run ${program_name} in serial on storage servers.

	-switchserial
		Run ${program_name} in serial on switches.
	"
	usage_winonly;
	usage_IDM;
exit 1
}

function usage_winonly ()
{
  if [ $is_windows -eq "0" ] ; then return; fi
echo -e "        
        -oracle_restart
                Oracle Restart environment.\n
"
}

function display_usage ()
{
  if [[ -n $RAT_DISPLAY_HELP && $RAT_DISPLAY_HELP -eq "1" ]]; then display_mode=1; usage; return; fi
  if [[ $display_mode -eq "2" ]]; then
    usage|more
  else 
    usage;
  fi
}

set_grp_val ()
{
	grpval="";
	if [[ $1 = "WF" ]]
        then
		grpval="Workflow";
	elif [[ $1 = "SALESANDMARKETING" ]]
        then
		grpval="Sales and Marketing";
	elif [[ $1 = "SERVICEANDCONTRACTS" ]]
        then
                grpval="Service and Contracts";
	elif [[ $1 = "FIXEDASSETS" ]]
        then
                grpval="Fixed Assets";
	elif [[ $1 = "PAYABLES" ]]
        then
                grpval="Payables";
        elif [[ $1 = "PROJECTS" ]]
        then
                grpval="Projects";
        elif [[ $1 = "RECEIVABLES" ]]
        then
                grpval="Receivables";
        elif [[ $1 = "HUMANRESOURCES" ]]
        then
                grpval="Human Resources Management System";
        elif [[ $1 = "PROCESSMANUFACTURING" ]]
        then
                grpval="Process Manufacturing";
        elif [[ $1 = "PROCUREMENT" ]]
        then
                grpval="Procurement";
        elif [[ $1 = "ORDERMANAGEMENT" ]]
        then
                grpval="Order Management";
	elif [[ $1 = "DiscreteMFGExecutionandFinancials" ]]
        then
                grpval="Discrete Manufacturing";
	elif [[ $1 = "PRICEMANAGEMENT" ]]
        then
                grpval="Price Management";
	else
		grpval="Other";
	fi
}

set_alvl ()
{
  if [ $i != $localnode ] ; then 
    SCPDIR=$RTEMPDIR
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then SCPDIR=$TMP_OUTPUT; fi

    $SCOPY ${i}:${localcmdval} ${SCPDIR} >/dev/null 2>&1; 
    $SSHELL $i "rm -f ${localcmdval} >/dev/null 2>&1"
  fi

  if [ -e ${localcmdval} ]; then
    ALVL=$(grep 'ALVL=' "${localcmdval}" | cut -d"=" -f2)
    ALVL_CHECK=$ALVL
    rm -f ${localcmdval} >/dev/null 2>&1;
  else
    if [[ -n "$1" && $1 -eq "10" ]]
    then
      ALVL="INFO";returncode=0;
    elif [[ -n "$1" && $1 -eq "11" ]]
    then
      ALVL="WARNING";returncode=0;
    elif [[ -n "$1" && $1 -eq "12" ]]
    then
      ALVL="ERROR";returncode=0;
    elif [[ -n "$1" && $1 -eq "13" ]]
    then
      ALVL="FAIL";returncode=0;
    fi
  fi
}

score_per_component ()
{
  if [ $1 = "compute_node" ]
  then
    G_COMPUTE=$(expr $G_COMPUTE + 1);
  elif [ $1 = "switch" ]
  then
    G_SWITCH=$(expr $G_SWITCH + 1);
  elif [ $1 = "torswitch" ]
  then
    G_TORSWITCH=$(expr $G_TORSWITCH + 1);
  elif [ $1 = "cell" ]
  then
    G_CELL=$(expr $G_CELL + 1);
  elif [ $1 = "ec" ]
  then
    G_EC=$(expr $G_EC + 1);
  elif [ $1 = "pc" ]
  then
    G_PC=$(expr $G_PC + 1);
  elif [ $1 = "db" ]
  then
    G_DB=$(expr $G_DB + 1);
  elif [ $1 = "ovmm" ]
  then
    G_OVMM=$(expr $G_OVMM + 1);
  fi
}

validate_needs_running ()
{
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
  then
    if [[ "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
    then
      score_per_component "cell";
    elif [[ "$NEEDS_RUNNING" = "SWITCH" || $NEEDS_RUNNING = "SPINE_SWITCH" ]]
    then
      score_per_component "switch";
    elif [[ "$NEEDS_RUNNING" = "TOR_SWITCH" ]]
    then
      score_per_component "torswitch";
    else
      score_per_component "compute_node";
      if [[ `echo $check_components|grep -wc "EXALOGIC_DB"` -ge 1 ]]
      then
        score_per_component "db";
      fi
      if [[ `echo $check_components|grep -wc "EXALOGIC_EC"` -ge 1 ]]
      then
        score_per_component "ec";
      fi
      if [[ `echo $check_components|grep -wc "EXALOGIC_OVMM"` -ge 1 ]]
      then
        score_per_component "ovmm";
      fi
      if [[ `echo $check_components|grep -wc "EXALOGIC_PC"` -ge 1 ]]
      then
        score_per_component "pc";
      fi
    fi
  fi

}

get_dbserverscnt ()
{
  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    MASTERFIL1=$OUTPUTDIR/check_env.out
  else
    MASTERFIL1=$OUTPUTDIR/raccheck_env.out
  fi
  if [ -n "$MERGEFILES" ]
  then
    MASTERFIL1=$NEW_MASTERFIL1;
    rm -f $HOSTLIST
    HOSTLIST=$WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge
  fi

  el_db_node=""
  el_ec1_node=""
  el_ovmm_node=""
  el_pc_nodes=""
  el_pc1_node=""
  el_pc2_node=""
  el_exclude=""
  if [[ -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ;then
    el_db_node=$(grep '\.COMPONENT = .*EXALOGIC_DB' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_ec1_node=$(grep '\.COMPONENT = .*EXALOGIC_EC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_ovmm_node=$(grep '\.COMPONENT = .*EXALOGIC_OVMM' $MASTERFIL1 |sed 's/\.COMPONENT.*//' | sort -u| sed 's/ //g')
    el_pc_nodes=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_pc1_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | head -1| sed 's/ //g')
    el_pc2_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | tail -1| sed 's/ //g')
  fi

  if [ -e "$HOSTLIST" ]
  then
    dbserverscnt=0
    p_dbservers_cnt=0
    v_dbservers_cnt=0
    elsnodecnt=0
    exa_vcomp_list=""
    for hostname in `grep "[a-zA-Z0-9]" $HOSTLIST`
    do
      skip_this_node=0
      for xdir in $dirarr
      do
        xdir=$(echo $xdir|sed 's/\.zip//g');
        run_oncell=$(grep RUNNING_ONCELL ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
        if [[ -n "$run_oncell" && $run_oncell -eq "1" ]]; then
 	  TCELLDIR="$xdir/.CELLDIR";
          if [[ -n "$TCELLDIR" && -e "$TCELLDIR/cells.out" ]]; then
      	    if [[ `grep -icw "$hostname" $TCELLDIR/cells.out` -gt "0" ]]; then skip_this_node=1; break; fi
      	  fi
        fi
      done
      if [[ -n "$skip_this_node" && $skip_this_node -eq "1" ]]; then continue; fi

      if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]]
      then
        skipnode=`grep LOCALNODE $MASTERFIL1 |awk '{print $3}'`
        if [ $hostname = $skipnode ]
        then
          continue
        fi
      fi

      if [[  -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ; then
        if [[ $hostname != $el_db_node && $hostname != $el_ec1_node && $hostname != $el_ovmm_node && `grep -ic "$hostname\.COMPONENT.*EXALOGIC_PC" $MASTERFIL1` -eq "0" ]] ; then
          dbserverscnt=$(expr $dbserverscnt + 1);
        else
          elsnodecnt=$(expr $elsnodecnt + 1)
        fi
      else
        dbserverscnt=$(expr $dbserverscnt + 1);
      fi
    done
  fi
}

#-s  Run silent mode, does not ask if environment is set correctly, assumes it is.  Also runs with sudo for oracle assumed.
#set up for changing colors of output lines
#site for examples of colors http://oinkzwurgl.org/bashrc

#Added validation to make sure supported bash version is there
bash_version=$(bash -version|grep version|head -1|sed 's/[^0-9]//g'|cut -c1-2)
bash_version_msg=$(bash -version|head -1|awk '{print $4}'|cut -d. -f1-2)
program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
if [[ -n "$bash_version" && $bash_version -lt 30 ]]
then
  echo -e "\n${RED}${program_name} is not supported on bash version ${bash_version_msg}. It requires bash version 3.2 and above. Use bash -version command to verify ${NORM}\n"
  exit 1
fi
AWK=$(command -v gawk 2>/dev/null)
if [ ! -f "$AWK" ];then  AWK=awk;fi

copy_cgrep()
{
#Following section to copy right executable at working directory
if [[ ! -e $REFFIL && `grep -ic FILE_ID $SCRIPTPATH/collections.dat` -le 0 ]]; then 
  data_file_type=0;
else
  data_file_type=$(grep -ic FILE_ID $REFFIL)
fi

DECRYPT_VDAT=0
if [ ! -e $EXADATA_CELL_COLLECTIONS ]; then touch $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1;fi
if [[ -n "$data_file_type" && $data_file_type -le 0 ]]
then
  if [ -e $SCRIPTPATH/.cgrep/cgrep ]
  then
    cp -f $SCRIPTPATH/.cgrep/cgrep $WRKDIR/cgrep >/dev/null 2>&1
  elif [ $cgrep_platform = "Linux" ]
  then
    if [ -e /etc/redhat-release ]
    then
      #os_version=$(cat /etc/redhat-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version_json=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d'(' -f1|sed 's/ //g'|head -1)

      if [ $os_version -eq 3 ]
      then
        cp -f $SCRIPTPATH/.cgrep/lcgrep3 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 4 ]
      then
        cp -f $SCRIPTPATH/.cgrep/lcgrep4 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 5 ]
      then
        #cp -f $SCRIPTPATH/.cgrep/lcgrep5 $WRKDIR/cgrep >/dev/null 2>&1
        if [ $(uname -p) = "s390x" ]
        then
          cp -f $SCRIPTPATH/.cgrep/zlcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        else
          cp -f $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        fi
      elif [ $os_version -ge 6 ]
      then
        if [ $(uname -p) = "s390x" ]
        then
          cp -f $SCRIPTPATH/.cgrep/zlcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        elif [ $(uname -p) = "sparc64" ]
        then
          cp -f $SCRIPTPATH/.cgrep/lcgrep6s $WRKDIR/cgrep >/dev/null 2>&1        
        else
          cp -f $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        fi
      fi
      #$READ -p "what_os=$what_os is_exalogic_machine=$is_exalogic_machine and os_version=$os_version"
    elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      os_version=6
      os_version_json=6.4
      cp -f $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
    elif [ -e /etc/SuSE-release ]
    then
      #os_version=$(cat /etc/SuSE-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      #if [ -z "$os_version" ]; then os_version=$(cat /etc/SuSE-release|grep -i version|awk '{print $3}');fi
      os_version=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version_json=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [ -z "$os_version" ]; then os_version=$(grep -i version /etc/SuSE-release|awk '{print $3}');fi
      if [ $os_version -eq 9 ]
      then
        cp -f $SCRIPTPATH/.cgrep/lcgreps9 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 10 ]
      then
        cp -f $SCRIPTPATH/.cgrep/lcgreps10 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -ge 11 ]
      then
        if [ $(uname -p) = "s390x" ]
        then
          cp -f $SCRIPTPATH/.cgrep/zlcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
        else
          cp -f $SCRIPTPATH/.cgrep/lcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
        fi
      fi
    fi
  elif [ $cgrep_platform = "SunOS" ]
  then
    if [ `uname -p` = "sparc" ]
    then
      cp -f $SCRIPTPATH/.cgrep/scgrep $WRKDIR/cgrep >/dev/null 2>&1
    elif [ `uname -p|grep -ic 86` -ge 1 ]
    then
      cp -f $SCRIPTPATH/.cgrep/scgrepx86 $WRKDIR/cgrep >/dev/null 2>&1
    fi
  elif [ $cgrep_platform = "AIX" ]
  then
    cp -f $SCRIPTPATH/.cgrep/acgrep $WRKDIR/cgrep >/dev/null 2>&1
  elif [ $cgrep_platform = "HP-UX" ]
  then
    cp -f $SCRIPTPATH/.cgrep/hiacgrep $WRKDIR/cgrep >/dev/null 2>&1
  #elif [[ $cgrep_platform = "CYGWIN_NT-6.3" || $cgrep_platform = "CYGWIN_NT-6.1" ]]
  elif [[ $cgrep_platform = "CYGWIN_NT-6.3" || $cgrep_platform = "CYGWIN_NT-6.2" || $cgrep_platform = "CYGWIN_NT-6.1" || $cgrep_platform = "CYGWIN_NT-5.2" ]]
  then
    win_v=$(echo $cgrep_platform | sed 's/CYGWIN_NT-//' | sed 's/\.//');

    if [ "$win_v" -lt 61 ]; then 
	echo -e "\n${RED}${program_name} is not supported on this version of windows (Windows Version - $win_v)..\n\n ${program_name} exiting .....\n${NORM}"
        exit 1;	 
    fi

    if [[ "$win_v" = "62" || "$win_v" = "52" ]]; then win_v=61; fi
    cp -f $SCRIPTPATH/.cgrep/cgrepwin$win_v $WRKDIR/cgrep >/dev/null 2>&1
  fi
  security_fix "fix_file_attributes" "$WRKDIR/cgrep" "" "540"
  if [ ! -e $WRKDIR/cgrep ]
  then
    errm="RC-001- Unable to read driver files.  Please refer to the section for this error code in Appendix A - Troubleshooting Scenarios of the ${program_name} User Guide"
    echo -e "\n${RED}RC-001- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
    update_errm_in_syslog
    exit 1;
  fi
  export PATH=$PATH:.
  if [[ ! -e $REFFIL ]]; then 
    cgrep_test=$($WRKDIR/cgrep FILE_ID $SCRIPTPATH/collections.dat>/dev/null 2>&1)
  else
    cgrep_test=$($WRKDIR/cgrep FILE_ID $REFFIL>/dev/null 2>&1)
  fi
  if [ $? -ne 0 ]
  then
    #$READ -p "grep =$GREP cgrep_test=$cgrep_test"
    errm="RC-001- Unable to read driver files.  Please refer to the section for this error code in Appendix A - Troubleshooting Scenarios of the ${program_name} User Guide"
    echo -e "\n${RED}RC-002- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
    update_errm_in_syslog
    exit 1;
  fi
  GREP=$WRKDIR/cgrep
  DECRYPT_VDAT=1
else
  GREP=/bin/grep
fi

}

call_acchk()
{
  # Pass jdk8, path to acchk.jar and asm-all-5.0.3.jar other jar files. $(SRCHOME)/tfa/src/orachk/src/acchk/demo
  JDK=$RAT_JAVA_HOME
  JAVA=$JDK/bin/java
  
  RTJAR=$JDK/jre/lib/rt.jar
  
  ACJAR=$SCRIPTPATH/.cgrep/acchk.jar
  
  R_CLASSPATH="$RAT_AC_ASMJAR:$RTJAR:$ACJAR"
  
  `$JAVA -cp $R_CLASSPATH oracle.acchk.concrete.FindConcreteClass $RAT_AC_JARDIR > $acchk_out`
  
  `$JAVA -cp $R_CLASSPATH oracle.acchk.coverage.ExtractServerTrace $RAT_AC_TRCDIR >> $acchk_out`
}

upgrade_orachk()
{
  PRERDIR=`pwd`;
  if [ `touch $PRERDIR/testfile 2> /dev/null; echo "$?"` -eq 0 ]; then
    perl_exe=$(which perl|tr -d '\r');
    $perl_exe $SCRIPTPATH/.cgrep/auto_upgrade.pl $program_version ${program_name} "-upgrade" $RAT_UPGRADE_LOC $WRKDIR $check_upgrade_ret_val;
    rm -f $PRERDIR/testfile;
    readonlyval=0;
  else
    readonlyval=1;
    echo "
  Cannot upgrade. The current directory is read-only.
  ";
  fi 
}

check_upgrade()
{
  func_what_platform
  copy_cgrep
  PRERDIR=`pwd`;
  perl_exe=$(which perl|tr -d '\r');
  check_upgrade_ret_val=`$perl_exe $SCRIPTPATH/.cgrep/auto_upgrade.pl $program_version ${program_name} "-check" $RAT_UPGRADE_LOC $WRKDIR $check_upgrade_ret_val`;
}

#Function to Fix exacli password
fixExacliPassword ()
{
  inputPassword=$1
  exacli_password=$(echo "$inputPassword" | sed  -e 's/\\/\\\\/g' -e 's/\[/\\[/g' -e 's/"/\\"/g')

  hasDollar=$(echo "$exacli_password"|grep -c "$");
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  if [[ -n "$hasDollar" && $hasDollar -ge "1" ]]; then
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    exacli_password=$(echo "$exacli_password"|sed 's/\$/\\$/g');
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  fi
}

#Function to Fix root password
fixRootPassword ()
{
  inputPassword=$1
  fixedRootPassword=$(echo "$inputPassword" | sed  -e 's/\\/\\\\/g' -e 's/\[/\\[/g' -e 's/"/\\"/g')

  hasDollar=$(echo "$fixedRootPassword"|grep -c "$");
  if [[ -n "$hasDollar" && $hasDollar -ge "1" ]]; then 
    fixedRootPassword=$(echo "$fixedRootPassword"|sed 's/\$/\\$/g');
  fi
}

get_check_env_file ()
{
  #Cluster, platform details are read from end file in offline mode
  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    check_env_file=$OUTPUTDIR/check_env.out
  else
    check_env_file=$OUTPUTDIR/raccheck_env.out
  fi
}

read_env_file_for_cs_nodes ()
{
  get_check_env_file;

  el_db_node=""
  el_ec1_node=""
  el_ovmm_node=""
  el_pc_nodes=""
  el_pc1_node=""
  el_pc2_node=""

  if [[ -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ;then
    el_db_node=$(grep '\.COMPONENT = .*EXALOGIC_DB' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | sed 's/ //g')
    el_ec1_node=$(grep '\.COMPONENT = .*EXALOGIC_EC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | sed 's/ //g')
    el_ovmm_node=$(grep '\.COMPONENT = .*EXALOGIC_OVMM' $check_env_file |sed 's/\.COMPONENT.*//' | sort -u| sed 's/ //g')
    el_pc_nodes=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_pc1_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | head -1| sed 's/ //g')
    el_pc2_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | tail -1| sed 's/ //g')
  fi
}

get_el_prefix()
{
  if [[ -z "$el_db_node" ]] ; then
    read_env_file_for_cs_nodes
  fi

  el_hname=$(echo $1 | sed 's/ //g')
  case $el_hname in
    $el_db_node)
      el_prefix="DB";;
    $el_ec1_node)
      el_prefix="EC";;
    $el_ovmm_node)
      el_prefix="OVMM";;
    "$el_pc1_node"|"$el_pc2_node")
      el_prefix="PC";;
    *)
      el_prefix="CN";;
  esac
}

prompt_for_pass()
{
  #$usern $hname
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]]
    then #Get type of node
      case $hname in 
        $ea_db_node)
          el_prefix="DB";;
        $ea_ec1_node)
          el_prefix="EC";;
        $ea_ovmm_node)
          el_prefix="OVMM";;
        "$ea_pc1_node"|"$ea_pc2_node")
          el_prefix="PC";;
        *)
          el_prefix="CN";;
      esac
    fi

    ask_pass=0
    go_back=0
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" && $el_prefix = "CN" && -n "$use_expect_for_ssh_cn" && $use_expect_for_ssh_cn -eq "1" ]]
    then # Already prompted for compute node password in new exalogic..
      go_back=1
      if [[ -n "$node_samerootpassword_cn" && $node_samerootpassword_cn -eq "0" ]] ; then ask_pass=1 ; fi
    elif [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" && $el_prefix != "CN" && -n "$use_expect_for_ssh_vm" && $use_expect_for_ssh_vm -eq "1" ]]
    then # Already prompted for control server password in new exalogic..
      go_back=1
      if [[ -n "$node_samerootpassword_vm" && $node_samerootpassword_vm -eq "0" ]] ; then ask_pass=1 ; fi
    elif [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" && $in_ec_exalogic -eq "0" ]]
    then # Already prompted for password, so we have details
      go_back=1
      if [[ -n "$node_samerootpassword" && $node_samerootpassword -eq "0" ]] ; then ask_pass=1 ; fi
    fi

    if [[ $go_back -eq "1" ]] ; then
      if [[ $ask_pass -eq "1" ]]
      then # Get nodepassword
        echo -e "\n"
	if [[ -n "$prepare_init" && $prepare_init -eq "1" ]] && [[ -z "$compute_samerootpassword_YesNo" || `echo "$compute_samerootpassword_YesNo" |grep -ic "n"` -eq 0 ]]
        then
          printf  "Enter ${node_ssh_user} password ${NORM} :- "
        else
          printf  "Enter ${node_ssh_user} password on $hname ${NORM} :- "
        fi

	if [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  read_probe_xml "<text>$hname</text>"
	  node_rootpassword=$xml_rvalue
	else
          tty -s && stty -echo
          $READ -r node_rootpassword
          tty -s && stty echo
	fi
        printf "\n\nVerifying ${node_ssh_user} password.\n\n. . ";
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        checkUserPassword "$hname" "$node_ssh_user" "$node_rootpassword" "3"
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	node_rootpassword=$passwordToCheck
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
      return 0;
    fi

    use_expect_for_ssh=1

    node_type="nodes"
    node_type2=""
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]] ; then
      if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] ;  then
	use_expect_for_ssh_cn=1
	node_type="Guest Virtual Machines"
      elif [[ $el_prefix = "CN" ]] ; then 
        use_expect_for_ssh_cn=1
        node_type="Compute Nodes"
      else
        node_type="Control VM's"
        node_type2="(EC,OVMM,DB,PC)"
        use_expect_for_ssh_vm=1
      fi
    fi

    echo -e  "$program_name can configure ssh on all $node_type $node_type2 without prompting for password on each host if password is same on all $node_type."

    if [[ $EM_XMLD_MODE -eq 1 ]]
    then
      echo -e "Is ${node_ssh_user} password same on all $node_type?[y/n][y]"

      read_probe_xml "Use the same {1} password on all nodes"
      node_samerootpassword_yes=$xml_rvalue
    else
      exec 3<&2; exec 2<&0
      $READ -p  "Is ${node_ssh_user} password same on all $node_type?[y/n][y]" node_samerootpassword_yes
      read_code=`echo $?`;
      exec 2<&3
      process_prompt "$read_code" "node_samerootpassword_yes" "y"
    fi
    case $node_samerootpassword_yes in
      n|N|No|NO|no)
        node_samerootpassword=0
        echo "Enter password for each host when prompted."
        echo -e "\n"
        printf  "Enter ${node_ssh_user} password on $hname ${NORM} :- "

	if [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  read_probe_xml "<text>$hname</text>"
	  node_rootpassword=$xml_rvalue
	else
          tty -s && stty -echo
          $READ -r node_rootpassword
          tty -s && stty echo
	fi
        printf "\n\nVerifying ${node_ssh_user} password.\n\n. . ";
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        checkUserPassword "$hname" "$node_ssh_user" "$node_rootpassword" "3"
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	node_rootpassword=$passwordToCheck
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        ;;
      *)
        echo -e "\n"
        printf  "Enter ${node_ssh_user} password ${NORM} :- "
	
	if [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  read_probe_xml "n67_nlsid"
	  node_rootpassword=$xml_rvalue	
	else
          tty -s && stty -echo
          $READ -r node_rootpassword
          tty -s && stty echo
	fi
        printf "\n\nVerifying ${node_ssh_user} password.\n\n. . ";
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        checkUserPassword "$hname" "$node_ssh_user" "$node_rootpassword" "3"
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	node_rootpassword=$passwordToCheck
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
        then
          node_samerootpassword=1
        else
          node_samerootpassword=0
        fi
        ;;
    esac

    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]] ; then
      if [[ $el_prefix = "CN" ]] ; then
        node_samerootpassword_cn=$node_samerootpassword
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        node_rootpassword_cn=$node_rootpassword
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      else
        node_samerootpassword_vm=$node_samerootpassword
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        node_rootpassword_vm=$node_rootpassword
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
    fi
  fi

  if [ -e "$EXPECT" ] ; then
    node_rootpassword=$passwordToCheck;
    if [[ -z "$node_rootpassword" || $passwordCheckStatus -ne 0 ]]
    then  
      if [[ -n "$prepare_init" && $prepare_init -eq "1" ]] && [[ -z "$compute_samerootpassword_YesNo" || `echo "$compute_samerootpassword_YesNo" |grep -ic "n"` -eq 0 ]]
      then
        printf  "Enter ${node_ssh_user} password ${NORM} :- "
      else
        printf  "Enter ${node_ssh_user} password on $hname ${NORM} :- "
      fi

      if [[ $EM_XMLD_MODE -eq 1 ]]
      then
    	read_probe_xml "<text>$hname</text>"
	node_rootpassword=$xml_rvalue
      else
        tty -s && stty -echo
        $READ -r node_rootpassword
        tty -s && stty echo
      fi
      printf "\n\nVerifying ${node_ssh_user} password.\n\n. . ";
    fi
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    checkUserPassword "$hname" "$node_ssh_user" "$node_rootpassword" "3"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    node_rootpassword=$passwordToCheck
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
    then
      if [ -z "$node_index" ] ; then node_index=0; fi
      a_node_names[$node_index]=$hname;
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      a_node_passwords[$node_index]="$node_rootpassword";
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      node_index=$(expr $node_index + 1)
      use_expect_for_ssh=1
    fi
  fi
}

#follwoing fuction is to setup ssh at given node
func_setup_ssh ()
{ 
  if [ -z $READ ]; then
    READ="read"
    if [[ $prompt_timeout -eq 1 ]]
    then
      if [[ -z $RAT_PROMPT_TIMEOUT ]]; then export RAT_PROMPT_TIMEOUT=0; fi
      READ="read -t $RAT_PROMPT_TIMEOUT"
    fi
  fi

  SSH_PASS_STATUS=0
  passwordCheckStatus=0
  
  prompt_for_pass  # Ask user if we need to setup automatically.
  
  if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -ne 0 ]]
  then 
    SSH_PASS_STATUS=1
    return 1
  fi
  
  local numargs=$#
  local ADVANCED=false
  local HOSTNAME=`hostname`
  local CONFIRM=no
  local SHARED=false
  local i=1
  local USR=$USER
  if  test -z "$TEMP"
  then
    local TEMP=$TMPDIR
  fi
  if [ $is_windows -eq "1" ] ; then
    if [[ -z $RAT_SSH_ENCR ]]; then
      local IDENTITY=id_rsa
    else
      local IDENTITY=id_${RAT_SSH_ENCR}
    fi
  else
    if [[ -z $RAT_SSH_ENCR ]]; then
      local IDENTITY=id_dsa
    else
      local IDENTITY=id_${RAT_SSH_ENCR}
    fi
  fi
  #local LOGFILE=$TEMP/sshUserSetup_`date +%F-%H-%M-%S`.log
  local LOGFILE=/dev/null
  local VERIFY=false
  local EXHAUSTIVE_VERIFY=false
  local HELP=false
  local PASSPHRASE=no
  local RERUN_SSHKEYGEN=no
  local NO_PROMPT_PASSPHRASE=yes
  local j=""
  local HOSTS=""
  local USR=""
  while [ $i -le $numargs ]
  do
    j=$1 
    if [ $j = "-hosts" ] 
    then
      HOSTS=$2
      shift 1
      i=`expr $i + 1`
    fi
    if [ $j = "-user" ] 
    then
      USR=$2
      shift 1
      i=`expr $i + 1`
    fi
    if [ $j = "-logfile" ] 
    then
      LOGFILE=$2
      shift 1
      i=`expr $i + 1`
    fi
    if [ $j = "-confirm" ] 
    then
      CONFIRM=yes
    fi
    if [ $j = "-hostfile" ] 
    then
      CLUSTER_CONFIGURATION_FILE=$2
      shift 1
      i=`expr $i + 1`
    fi
    if [ $j = "-usePassphrase" ] 
    then
      PASSPHRASE=yes
    fi
    if [ $j = "-noPromptPassphrase" ] 
    then
      NO_PROMPT_PASSPHRASE=yes
    fi
    if [ $j = "-shared" ] 
    then
      SHARED=true
    fi
    if [ $j = "-exverify" ] 
    then
      EXHAUSTIVE_VERIFY=true
    fi
    if [ $j = "-verify" ] 
    then
      VERIFY=true
    fi
    if [ $j = "-advanced" ] 
    then
      ADVANCED=true
    fi
    if [ $j = "-help" ] 
    then
      HELP=true
    fi
    i=`expr $i + 1`
    shift 1
  done
  

  if [ $HELP = "true" ]
  then
    echo "Usage $0 -user <user name> [ -hosts \"<space separated hostlist>\" | -hostfile <absolute path of cluster configuration file> ] [ -advanced ]  [ -verify] [ -exverify ] [ -logfile <desired absolute path of logfile> ] [-confirm] [-shared] [-help] [-usePassphrase] [-noPromptPassphrase]"
  exit 1
  fi
  
  if test -z "$HOSTS"
  then
    if test -n "$CLUSTER_CONFIGURATION_FILE" && test -f "$CLUSTER_CONFIGURATION_FILE"
    then
       HOSTS=`awk '$1 !~ /^#/ { str = str " " $1 } END { print str }' $CLUSTER_CONFIGURATION_FILE` 
    elif ! test -f "$CLUSTER_CONFIGURATION_FILE"
    then
      echo "Please specify a valid and existing cluster configuration file."
    fi
  fi
  
  if  test -z "$HOSTS" || test -z $USR
  then
    echo "Either user name or host information is missing"
    echo "Usage $0 -user <user name> [ -hosts \"<space separated hostlist>\" | -hostfile <absolute path of cluster configuration file> ] [ -advanced ]  [ -verify] [ -exverify ] [ -logfile <desired absolute path of logfile> ] [-confirm] [-shared] [-help] [-usePassphrase] [-noPromptPassphrase]" 
    return 1
  fi

  #echo Hosts are $HOSTS | tee -a $LOGFILE
  #echo user is  $USR | tee -a $LOGFILE
  SSH="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
  SSH_KEYGEN="/usr/bin/ssh-keygen"
  calculateOS()
  {
    platform=`uname -s`
    case "$platform"
    in
       "SunOS")  SSH="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
                 SSH_KEYGEN="/usr/bin/ssh-keygen"
                 os=solaris;;
       "Linux")  os=linux;;
       "HP-UX")  os=hpunix;;
         "AIX")  os=aix;;
        CYGWIN_NT-[0-9].[0-9])
                 os=windows;;
             *)  echo "Sorry, $platform is not currently supported." | tee -a $LOGFILE
                 return 1;;
    esac
  
    #echo "Platform:- $platform " | tee -a $LOGFILE
  }
  calculateOS
  BITS=1024
  if [ $is_windows -eq "1" ] ; then
    if [[ -z $RAT_SSH_ENCR ]]; then
      ENCR="rsa"
    else
      ENCR="$RAT_SSH_ENCR"
    fi
  else
    if [[ -z $RAT_SSH_ENCR ]]; then
      ENCR="dsa"
    else
      ENCR="$RAT_SSH_ENCR"
    fi
  fi
  
  deadhosts=""
  alivehosts=""
  PING_W_FLAG=""
  echo Checking if the remote hosts are reachable >> $LOGFILE

  for host in $HOSTS
  do
    test_node_reachability "$host";
    if [ $el_node_ping -eq "1" ]
    then
      alivehosts="$alivehosts $host"
    else
      deadhosts="$deadhosts $host"
    fi
  done
  
  if test -z "$deadhosts"
  then
    echo Remote host reachability check succeeded >> $LOGFILE
    #echo The following hosts are reachable: $alivehosts.  | tee -a $LOGFILE
    #echo The following hosts are not reachable: $deadhosts.  | tee -a $LOGFILE
    #echo All hosts are reachable. Proceeding further...  | tee -a $LOGFILE
  else
    echo Remote host reachability check failed.  >>$LOGFILE
    #echo The following hosts are reachable: $alivehosts.  | tee -a $LOGFILE
    #echo The following hosts are not reachable: $deadhosts.  | tee -a $LOGFILE
    #echo Please ensure that all the hosts are up and re-run the script.  | tee -a $LOGFILE
    #echo Exiting now...  | tee -a $LOGFILE
    return 1
  fi

  if [ $platform = "HP-UX" ]
  then
    firsthost=`echo $HOSTS | awk '{print $1}; END { }'`
    echo firsthost $firsthost
    numhosts=`echo $HOSTS | awk '{ }; END {print NF}'`
    echo numhosts $numhosts
  else
    declare -a HOSTSARR="( $HOSTS )"
    firsthost=${HOSTSARR[0]}
    typeset -i numhosts=${#HOSTSARR[@]} 
  fi
  
  if [ $VERIFY = "true" ]
  then
    echo Since user has specified -verify option, SSH setup will not be performed. Existing SSH setup will be verified instead. >>$LOGFILE
    continue
  else
    #echo The script will setup SSH connectivity from the host ''`hostname`'' to all  | tee -a $LOGFILE 
    #echo the remote hosts. After the script is executed, the user can use SSH to run  | tee -a $LOGFILE 
    #echo commands on the remote hosts or copy files between this host ''`hostname`'' | tee -a $LOGFILE 
    #echo and the remote hosts without being prompted for passwords or confirmations. | tee -a $LOGFILE 
    #echo  | tee -a $LOGFILE 
    #echo NOTE 1: | tee -a $LOGFILE 
    #echo As part of the setup procedure, this script will use 'ssh' and 'scp' to copy | tee -a $LOGFILE 
    #echo files between the local host and the remote hosts. Since the script does not  | tee -a $LOGFILE 
    #echo store passwords, you may be prompted for the passwords during the execution of  | tee -a $LOGFILE 
    #echo the script whenever 'ssh' or 'scp' is invoked. | tee -a $LOGFILE 
    #echo  | tee -a $LOGFILE 
    #echo NOTE 2: | tee -a $LOGFILE 
    #echo "AS PER SSH REQUIREMENTS, THIS SCRIPT WILL SECURE THE USER HOME DIRECTORY" | tee -a $LOGFILE 
    #echo AND THE .ssh DIRECTORY BY REVOKING GROUP AND WORLD WRITE PRIVILEDGES TO THESE  | tee -a $LOGFILE 
    #echo "directories." | tee -a $LOGFILE 
    #echo  | tee -a $LOGFILE 
    #echo "Do you want to continue and let the script make the above mentioned changes (yes/no)?" | tee -a $LOGFILE 
    
    #Added by to overwrite variable
    CONFIRM=yes
    if [ "$CONFIRM" = "no" ] 
    then 
      $READ CONFIRM 
      read_code=`echo $?`;
      process_prompt "$read_code" "CONFIRM" "yes"
    else
      echo "Confirmation provided on the command line" >>$LOGFILE
    fi 
       
    #echo  | tee -a $LOGFILE 
    #echo The user chose ''$CONFIRM'' | tee -a $LOGFILE 
 
    if [ "$CONFIRM" = "no" ] 
    then 
      echo "SSH setup has not been performed." >> $LOGFILE 
      return 1 
    else 
      NO_PROMPT_PASSPHRASE=yes
      if [ $NO_PROMPT_PASSPHRASE = "yes" ]
      then
        echo "User chose to skip passphrase related questions."  >>$LOGFILE
      else
        typeset -i PASSPHRASE_PROMPT
        if [ $SHARED = "true" ]
        then
              PASSPHRASE_PROMPT=2*${numhosts}+1
        else
              PASSPHRASE_PROMPT=2*${numhosts} 
        fi
        echo "Please indicate whether you want to specify a passphrase for the private key this script will create for the local host. The passphrase is used to encrypt the private key and makes SSH much more secure. Type 'yes' or 'no' and then press enter. If you press 'yes', you will need to enter the passphrase whenever the script executes ssh or scp. " >>$LOGFILE
        echo "The estimated number of times the user will be prompted for a passphrase is $PASSPHRASE_PROMPT. In addition, if the private-public files are also newly created, the user would have to specify the passphrase on one additional occasion. " | tee -a $LOGFILE
        echo "Enter 'yes' or 'no'." >>$LOGFILE

	if [ $PASSPHRASE = "no" ]
        then
          $READ PASSPHRASE
	  read_code=`echo $?`;
	  process_prompt "$read_code" "PASSPHRASE" "no"
        else
          echo "Confirmation provided on the command line" >>$LOGFILE
        fi 

        echo  | tee -a $LOGFILE 
        echo The user chose ''$PASSPHRASE'' >> $LOGFILE 

        if [ "$PASSPHRASE" = "yes" ] 
        then 
          RERUN_SSHKEYGEN="yes"
	  #Checking for existence of ${IDENTITY} file
          if test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
          then
            echo "The files containing the client public and private keys already exist on the local host. The current private key may or may not have a passphrase associated with it. In case you remember the passphrase and do not want to re-run ssh-keygen, press 'no' and enter. If you press 'no', the script will not attempt to create any new public/private key pairs. If you press 'yes', the script will remove the old private/public key files existing and create new ones prompting the user to enter the passphrase. If you enter 'yes', any previous SSH user setups would be reset. If you press 'change', the script will associate a new passphrase with the old keys." | tee -a $LOGFILE
            echo "Press 'yes', 'no' or 'change'" >> $LOGFILE
            $READ RERUN_SSHKEYGEN 
	    read_code=`echo $?`;
	    process_prompt "$read_code" "RERUN_SSHKEYGEN" "no"
            echo The user chose ''$RERUN_SSHKEYGEN'' >> $LOGFILE 
          fi 
        else
          if test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
          then
            echo "The files containing the client public and private keys already exist on the local host. The current private key may have a passphrase associated with it. In case you find using passphrase inconvenient(although it is more secure), you can change to it empty through this script. Press 'change' if you want the script to change the passphrase for you. Press 'no' if you want to use your old passphrase, if you had one."
            $READ RERUN_SSHKEYGEN 
	    read_code=`echo $?`;
	    process_prompt "$read_code" "RERUN_SSHKEYGEN" "no"
            echo The user chose ''$RERUN_SSHKEYGEN'' >> $LOGFILE 
          fi
        fi
      fi

      #echo Creating .ssh directory on local host, if not present already | tee -a $LOGFILE
      mkdir -p $HOME/.ssh | tee -a $LOGFILE
      #echo Creating authorized_keys file on local host  | tee -a $LOGFILE
      touch $HOME/.ssh/authorized_keys  | tee -a $LOGFILE
      #echo Changing permissions on authorized_keys to 644 on local host  | tee -a $LOGFILE
      chmod 644 $HOME/.ssh/authorized_keys  | tee -a $LOGFILE
      mv -f $HOME/.ssh/authorized_keys  $HOME/.ssh/authorized_keys.tmp | tee -a $LOGFILE
      #echo Creating known_hosts file on local host  | tee -a $LOGFILE
      touch $HOME/.ssh/known_hosts  | tee -a $LOGFILE
      #echo Changing permissions on known_hosts to 644 on local host  | tee -a $LOGFILE
      chmod 644 $HOME/.ssh/known_hosts  | tee -a $LOGFILE
      mv -f $HOME/.ssh/known_hosts $HOME/.ssh/known_hosts.tmp | tee -a $LOGFILE
      
      #echo Creating config file on local host | tee -a $LOGFILE
      #echo If a config file exists already at $HOME/.ssh/config, it would be backed up to $HOME/.ssh/config.backup.
      echo "Host *" > $HOME/.ssh/config.tmp | tee -a $LOGFILE
      echo "ForwardX11 no" >> $HOME/.ssh/config.tmp | tee -a $LOGFILE
      
      if test -f $HOME/.ssh/config 
      then
        cp -f $HOME/.ssh/config $HOME/.ssh/config.backup
      fi
      
      mv -f $HOME/.ssh/config.tmp $HOME/.ssh/config  | tee -a $LOGFILE
      #Fix for BUG NO 5157782
      chmod 644 $HOME/.ssh/config
      if [ $RERUN_SSHKEYGEN = "yes" ]
      then
        #echo Removing old private/public keys on local host | tee -a $LOGFILE
        rm -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
        rm -f $HOME/.ssh/${IDENTITY}.pub | tee -a $LOGFILE
        #echo Running SSH keygen on local host | tee -a $LOGFILE
        $SSH_KEYGEN -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY}   | tee -a $LOGFILE
      elif [ $RERUN_SSHKEYGEN = "change" ]
      then
        echo Running SSH Keygen on local host to change the passphrase associated with the existing private key | tee -a $LOGFILE
        $SSH_KEYGEN -p -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
      elif test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
      then
        echo "">>$LOGFILE
        #continue
      else
        #echo Removing old private/public keys on local host | tee -a $LOGFILE
        rm -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
        rm -f $HOME/.ssh/${IDENTITY}.pub | tee -a $LOGFILE
        #echo Running SSH keygen on local host with empty passphrase | tee -a $LOGFILE
        $SSH_KEYGEN -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY} -N ''  | tee -a $LOGFILE
      fi
      if [ $SHARED = "true" ]
      then
        if [ $USER = $USR ]
        then
          #No remote operations required
          echo Remote user is same as local user >> $LOGFILE
          REMOTEHOSTS=""
          chmod og-w $HOME $HOME/.ssh >> $LOGFILE
        else    
          REMOTEHOSTS="${firsthost}"
        fi
      else
        REMOTEHOSTS="$HOSTS"
      fi
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi 
      fixRootPassword "$node_rootpassword"
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi

      for host in $REMOTEHOSTS
      do
        #echo Creating .ssh directory and setting permissions on remote host $host | tee -a $LOGFILE
        #echo "THE SCRIPT WOULD ALSO BE REVOKING WRITE PERMISSIONS FOR "group" AND "others" ON THE HOME DIRECTORY FOR $USR. THIS IS AN SSH REQUIREMENT." | tee -a $LOGFILE
        #echo The script would create ~$USR/.ssh/config file on remote host $host. If a config file exists already at ~$USR/.ssh/config, it would be backed up to ~$USR/.ssh/config.backup. | tee -a $LOGFILE
        #echo The user may be prompted for a password here since the script would be running SSH on host $host. | tee -a $LOGFILE
        if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
        then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          $EXPECT -f - << IBEOF
                              set timeout 10
                              set le_node_rootpassword "$fixedRootPassword"
                              log_user 0
                              if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                                exp_internal 1
                              } 
                              spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"  mkdir -p .ssh ; chmod og-w . .ssh;   touch .ssh/authorized_keys .ssh/known_hosts .ssh/config;  chmod 644 .ssh/authorized_keys  .ssh/known_hosts .ssh/config; mv -f  .ssh/authorized_keys .ssh/authorized_keys.tmp ;  mv -f .ssh/known_hosts .ssh/known_hosts.tmp; echo \\"Host *\\" > .ssh/config.tmp; echo \\"ForwardX11 no\\" >> .ssh/config.tmp; if test -f  .ssh/config ; then cp -f .ssh/config .ssh/config.backup; fi ; mv -f .ssh/config.tmp .ssh/config\";chmod 644 .ssh/config"
                              match_max 100000
                              expect {
      	     	                -nocase "permission denied *" {
	      	     		  exit 4;
      	     		 	}
                                -nocase "no)?" {
                                  send -- "yes\n"
                                }
                                -nocase "*?assword:*" {
                                  send -- "\$le_node_rootpassword\n" 
                                }
                                -nocase eof {
                                  exit 0
                                }
                              }
                              expect {
                                -nocase "*?assword:*" {
         	     		  send -- "\$le_node_rootpassword\n"
                                }
                                -nocase eof {
                                  exit 0
                                }
                              }
IBEOF
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        else
          $SSH -x -l $USR $host "/bin/sh -c \"  mkdir -p .ssh ; chmod og-w . .ssh;   touch .ssh/authorized_keys .ssh/known_hosts .ssh/config;  chmod 644 .ssh/authorized_keys  .ssh/known_hosts .ssh/config; mv -f  .ssh/authorized_keys .ssh/authorized_keys.tmp ;  mv -f .ssh/known_hosts .ssh/known_hosts.tmp; echo \\"Host *\\" > .ssh/config.tmp; echo \\"ForwardX11 no\\" >> .ssh/config.tmp; if test -f  .ssh/config ; then cp -f .ssh/config .ssh/config.backup; fi ; mv -f .ssh/config.tmp .ssh/config\";chmod 644 .ssh/config" | tee -a $LOGFILE
        fi
        echo Done with creating .ssh directory and setting permissions on remote host $host.>> $LOGFILE
      done

      for host in $REMOTEHOSTS
      do
        #echo Copying local host public key to the remote host $host | tee -a $LOGFILE
        #echo The user may be prompted for a password or passphrase here since the script would be using SCP for host $host. | tee -a $LOGFILE
        if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
        then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          $EXPECT -f - << IBEOF
                              set timeout 100
      			      set le_node_rootpassword "$fixedRootPassword"
                              log_user 0
                              if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                exp_internal 1
                              }
                              spawn $SCOPY $HOME/.ssh/${IDENTITY}.pub  $USR@$host:.ssh/authorized_keys
                              match_max 100000
                              expect {
      			        -nocase "permission denied *" {
      				  exit 4;
      				}
                                -nocase "no)?" {
                                  send -- "yes\n"
                                }
                                -nocase "*?assword:*" {
      				  send -- "\$le_node_rootpassword\n"
                                }
                                -nocase eof {
                                  exit 0
                                }
                              }
                              expect {
                                -nocase "*?assword:*" {
      				  send -- "\$le_node_rootpassword\n"
                                }
                                -nocase eof {
                                  exit 0
                                }
                              }
IBEOF
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        else
          scp $HOME/.ssh/${IDENTITY}.pub  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
        fi
        echo Done copying local host public key to the remote host $host >> $LOGFILE
      done

      PUBLIC_KEY=$(cat $HOME/.ssh/${IDENTITY}.pub)
      if [[ `grep -ic "$PUBLIC_KEY" $HOME/.ssh/authorized_keys.tmp` -eq 0 ]]; then cat $HOME/.ssh/${IDENTITY}.pub >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE; fi
      
      for host in $HOSTS
      do
        if [ $ADVANCED = "true" ] 
        then
          echo Creating keys on remote host $host if they do not exist already. This is required to setup SSH on host $host. >> $LOGFILE
          if [ $SHARED = "true" ]
          then
            IDENTITY_FILE_NAME=${IDENTITY}_$host
            COALESCE_IDENTITY_FILES_COMMAND="cat .ssh/${IDENTITY_FILE_NAME}.pub >> .ssh/authorized_keys"
          else
            IDENTITY_FILE_NAME=${IDENTITY}
          fi
      
          if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
          then
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            $EXPECT -f - << IBEOF
                                 set timeout 10
      			         set le_node_rootpassword "$fixedRootPassword"
                                 log_user 0
                                 if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                                   exp_internal 1
                                 }
                                 spawn -noecho $SSH  -x -l $USR $host " /bin/sh -c \"if test -f  .ssh/${IDENTITY_FILE_NAME}.pub && test -f  .ssh/${IDENTITY_FILE_NAME}; then echo; else rm -f .ssh/${IDENTITY_FILE_NAME} ;  rm -f .ssh/${IDENTITY_FILE_NAME}.pub ;  $SSH_KEYGEN -t $ENCR -b $BITS -f .ssh/${IDENTITY_FILE_NAME} -N '' ; fi; ${COALESCE_IDENTITY_FILES_COMMAND} \"" | tee -a $LOGFILE
                                 match_max 100000
                                 expect {
      			           -nocase "permission denied *" {
      				      exit 4;
      				    }
                                    -nocase "no)?" {
                                      send -- "yes\n"
                                    }
                                    -nocase "*?assword:*" {
      				      send -- "\$le_node_rootpassword\n"	
                                    }
                                    -nocase eof {
                                      exit 0
                                    }
                                 }
                                 expect {
                                    -nocase "*?assword:*" {
      				      send -- "\$le_node_rootpassword\n"
                                    }
                                    -nocase eof {
                                      exit 0
                                    }
                                 }
IBEOF
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
          else
            $SSH  -x -l $USR $host " /bin/sh -c \"if test -f  .ssh/${IDENTITY_FILE_NAME}.pub && test -f  .ssh/${IDENTITY_FILE_NAME}; then echo; else rm -f .ssh/${IDENTITY_FILE_NAME} ;  rm -f .ssh/${IDENTITY_FILE_NAME}.pub ;  $SSH_KEYGEN -t $ENCR -b $BITS -f .ssh/${IDENTITY_FILE_NAME} -N '' ; fi; ${COALESCE_IDENTITY_FILES_COMMAND} \"" | tee -a $LOGFILE
          fi
        else 
          #At least get the host keys from all hosts for shared case - advanced option not set
          if test  $SHARED = "true" && test $ADVANCED = "false"
          then
            if [ $PASSPHRASE = "yes" ]
            then
               echo "The script will fetch the host keys from all hosts. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." >>$LOGFILE
            fi

            if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
            then
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              $EXPECT -f - << IBEOF
                                 set timeout 10
              		   	 set le_node_rootpassword "$fixedRootPassword"
                                 log_user 0
                                 if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                   exp_internal 1
                                 }
                                 spawn -noecho $SSH  -x -l $USR $host "/bin/sh -c true"
                                 match_max 100000
                                 expect {
              		     	   -nocase "permission denied *" {
              			      exit 4;
              			   }
                                   -nocase "no)?" {
                                      send -- "yes\n"
                                   }
                                   -nocase "*?assword:*" {
              			      send -- "\$le_node_rootpassword\n"
                                   }
                                   -nocase eof {
                                      exit 0
                                   }
                                 }
                                 expect {
                                   -nocase "*?assword:*" {
              			      send -- "\$le_node_rootpassword\n"
                                   }
                                   -nocase eof {
                                      exit 0
                                   }
                                }
IBEOF
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            else
              $SSH  -x -l $USR $host "/bin/sh -c true"
            fi
          fi
        fi
      done

      for host in $REMOTEHOSTS
      do
        if test $ADVANCED = "true" && test $SHARED = "false"  
        then
          if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
          then
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            $EXPECT -f - << IBEOF
                                set timeout 10
      	 			set le_node_rootpassword "$fixedRootPassword"
                                log_user 0
                                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                  exp_internal 1
                                }   
                                spawn -noecho scp $USR@$host:.ssh/${IDENTITY}.pub $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
                                match_max 100000
                                expect {
				  -nocase "permission denied *" {
      	       		 	    exit 4;
      	       		 	  }
                                  -nocase "no)?" {
                                    send -- "yes\n"
                                  }
                                  -nocase "*?assword:*" {
				    send -- "\$le_node_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 0
                                  }
                                expect {
                                  -nocase "*?assword:*" {
	       			    send -- "\$le_node_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 0
                                  }
                                }
IBEOF
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
          else
            scp $USR@$host:.ssh/${IDENTITY}.pub $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
          fi
          cat $HOME/.ssh/${IDENTITY}.pub.$host >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE
          rm -f $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
        fi
      done

      for host in $REMOTEHOSTS
      do
        if [ $ADVANCED = "true" ]
        then
          if [ $SHARED != "true" ]
          then
            echo Updating authorized_keys file on remote host $host >>$LOGFILE
            if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
            then
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              $EXPECT -f - << IBEOF
                              set timeout 10
      	     	   	      set le_node_rootpassword "$fixedRootPassword"
                              log_user 0
                              if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                exp_internal 1
                              }
                              spawn -noecho scp $HOME/.ssh/authorized_keys  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
                              match_max 100000
                              expect {
			       -nocase "permission denied *" {
      	     		         exit 4;
      	     		       }
                               -nocase "no)?" {
                                 send -- "yes\n"
                               }
                               -nocase "*?assword:*" {
      	     		 	 send -- "\$le_node_rootpassword\n"
                               }
                               -nocase eof {
                                 exit 0
                               }
                             }
                             expect {
                               -nocase "*?assword:*" {
      	     		 	 send -- "\$le_node_rootpassword\n"
                               }
                               -nocase eof {
                                 exit 0
                               }
                             }
IBEOF
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            else
              scp $HOME/.ssh/authorized_keys  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
            fi
          fi 

          echo Updating known_hosts file on remote host $host >>$LOGFILE
          if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
          then
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            $EXPECT -f - << IBEOF
                                set timeout 10
             		        set le_node_rootpassword "$fixedRootPassword"
                                log_user 0
                                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                  exp_internal 1	
                                }
                                spawn -noecho scp $HOME/.ssh/known_hosts $USR@$host:.ssh/known_hosts | tee -a $LOGFILE
                                match_max 100000
                                  expect {
             		            -nocase "permission denied *" {
             			      exit 4;
             			    }
                                    -nocase "no)?" {
                                      send -- "yes\n"
                                    }
                                    -nocase "*?assword:*" {
             			      send -- "\$le_node_rootpassword\n"
                                    }
                                    -nocase eof {
                                      exit 0
                                    }
                                  }
                                  expect {
                                    -nocase "*?assword:*" {
             			      send -- "\$le_node_rootpassword\n"
                                    }
                                    -nocase eof {
                                      exit 0
                                    }
                                  }
IBEOF
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
          else
            scp $HOME/.ssh/known_hosts $USR@$host:.ssh/known_hosts | tee -a $LOGFILE
          fi
        fi
        if [ $PASSPHRASE = "yes" ]
        then
          echo "The script will run SSH on the remote machine $host. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." >> $LOGFILE
        fi
        if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
        then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          $EXPECT -f - << IBEOF
                                set timeout 10
             		        set le_node_rootpassword "$fixedRootPassword"
                                log_user 0
                                if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                                  exp_internal 1
                                }		
                                if { "$AutoLoginCheckYes" == "1" } {
                                  spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts; rm -f  .ssh/known_hosts.tmp  .ssh/authorized_keys.tmp\"" | tee -a $LOGFILE
                                } else { 
                                  spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts\"" | tee -a $LOGFILE
                                }
                                match_max 100000
                                expect {
             		          -nocase "permission denied *" {
             			    exit 4;
             			  }
                                  -nocase "no)?" {
                                    send -- "yes\n"
                                  }
                                  -nocase "*?assword:*" {
             			    send -- "\$le_node_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 0
                                  }
                                }
                                expect {
                                  -nocase "*?assword:*" {
             			    send -- "\$le_node_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 0
                                  }
                               }
IBEOF
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        else
          if [[ -n "$AutoLoginCheckYes" && $AutoLoginCheckYes -eq 1 ]]            
          then  
              $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts; rm -f  .ssh/known_hosts.tmp  .ssh/authorized_keys.tmp\"" | tee -a $LOGFILE
          else   
              $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts\"" | tee -a $LOGFILE
          fi
        fi
      done

      if [ -f $HOME/.ssh/known_hosts.tmp ]
      then
          cat  $HOME/.ssh/known_hosts.tmp >> $HOME/.ssh/known_hosts | tee -a $LOGFILE
      fi
      if [ $HOME/.ssh/authorized_keys.tmp ]
      then
          cat  $HOME/.ssh/authorized_keys.tmp >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE
      fi
      #Added chmod to fix BUG NO 5238814
      chmod 644 $HOME/.ssh/authorized_keys
      chmod 644 $HOME/.ssh/config
      rm -f  $HOME/.ssh/known_hosts.tmp $HOME/.ssh/authorized_keys.tmp | tee -a $LOGFILE
      echo SSH setup is complete. >> $LOGFILE
    fi
  fi
  #echo                                                                          | tee -a $LOGFILE
  #echo ------------------------------------------------------------------------ | tee -a $LOGFILE
  #echo Verifying SSH setup | tee -a $LOGFILE
  #echo =================== | tee -a $LOGFILE
  #echo The script will now run the 'date' command on the remote nodes using ssh | tee -a $LOGFILE
  #echo to verify if ssh is setup correctly. IF THE SETUP IS CORRECTLY SETUP,  | tee -a $LOGFILE
  #echo THERE SHOULD BE NO OUTPUT OTHER THAN THE DATE AND SSH SHOULD NOT ASK FOR | tee -a $LOGFILE
  #echo PASSWORDS. If you see any output other than date or are prompted for the | tee -a $LOGFILE
  #echo password, ssh is not setup correctly and you will need to resolve the  | tee -a $LOGFILE
  #echo issue and set up ssh again. | tee -a $LOGFILE
  #echo The possible causes for failure could be:  | tee -a $LOGFILE
  #echo   1. The server settings in /etc/ssh/sshd_config file do not allow ssh | tee -a $LOGFILE
  #echo      for user $USR. | tee -a $LOGFILE
  #echo   2. The server may have disabled public key based authentication.
  #echo   3. The client public key on the server may be outdated.
  #echo   4. ~$USR or  ~$USR/.ssh on the remote host may not be owned by $USR.  | tee -a $LOGFILE
  #echo   5. User may not have passed -shared option for shared remote users or | tee -a $LOGFILE
  #echo     may be passing the -shared option for non-shared remote users.  | tee -a $LOGFILE
  #echo   6. If there is output in addition to the date, but no password is asked, | tee -a $LOGFILE
  #echo   it may be a security alert shown as part of company policy. Append the | tee -a $LOGFILE
  #echo   "additional text to the <OMS HOME>/sysman/prov/resources/ignoreMessages.txt file." | tee -a $LOGFILE
  #echo ------------------------------------------------------------------------ | tee -a $LOGFILE
  #$READ -t 30 dummy
  for host in $HOSTS
  do
    #echo --$host:-- | tee -a $LOGFILE
    #echo Running $SSH -x -l $USR $host date to verify SSH connectivity has been setup from local host to $host.  | tee -a $LOGFILE
    #echo "IF YOU SEE ANY OTHER OUTPUT BESIDES THE OUTPUT OF THE DATE COMMAND OR IF YOU ARE PROMPTED FOR A PASSWORD HERE, IT MEANS SSH SETUP HAS NOT BEEN SUCCESSFUL. Please note that being prompted for a passphrase may be OK but being prompted for a password is ERROR." | tee -a $LOGFILE
    if [ $PASSPHRASE = "yes" ]
    then
      echo "The script will run SSH on the remote machine $host. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." | tee -a $LOGFILE
    fi
    #$SSH -l $USR $host "/bin/sh -c date"  | tee -a $LOGFILE
    echo ------------------------------------------------------------------------ >> $LOGFILE
  done

  if [ $EXHAUSTIVE_VERIFY = "true" ]
  then
    for clienthost in $HOSTS
    do
      if [ $SHARED = "true" ]
      then
        REMOTESSH="$SSH -i .ssh/${IDENTITY}_${clienthost}"
      else
        REMOTESSH=$SSH
      fi
  
      for serverhost in  $HOSTS
      do
        echo ------------------------------------------------------------------------ >> $LOGFILE
        echo Verifying SSH connectivity has been setup from $clienthost to $serverhost  | tee -a $LOGFILE
        echo ------------------------------------------------------------------------ | tee -a $LOGFILE
        $SSH -l $USR $clienthost "$REMOTESSH $serverhost \"/bin/sh -c date\""  | tee -a $LOGFILE
        echo ------------------------------------------------------------------------ >> $LOGFILE
      done  
      echo -Verification from $clienthost complete- | tee -a $LOGFILE
    done
  else
    if [ $ADVANCED = "true" ]
    then
      if [ $SHARED = "true" ]
      then
        REMOTESSH="$SSH -i .ssh/${IDENTITY}_${firsthost}"
      else
        REMOTESSH=$SSH
      fi
      for host in $HOSTS
      do
        echo ------------------------------------------------------------------------ >>$LOGFILE
        echo Verifying SSH connectivity has been setup from $firsthost to $host  | tee -a $LOGFILE
        $SSH -l $USR $firsthost "$REMOTESSH $host /bin/sh -c date" | tee -a $LOGFILE
        echo ------------------------------------------------------------------------ >> $LOGFILE
      done
      echo -Verification from $clienthost complete- | tee -a $LOGFILE
    fi
  fi
  echo "SSH verification complete." >>$LOGFILE
  printf ". "
}
#End - fun_setup_ssh

generate_result_json_for_cell () 
{
#  echo "\"${xml_prefix1}Result \":[" >> $JSONREPFIL 
  if [ -z "$RackIdentifier" ] ; then
	RackIdentifier=$cluster_name
  fi

  echo "{\"modelVersion\":\"$modelVersion\", \"RackType\":\"$rack_type\",\"EngineeredSystems\":\"$engs_machine\",\"RackIdentifier\":\"$RackIdentifier\", \"OSVersion\":\"$os_version_json\",\"DBVersion\":\"${stack_dbinst_version[$stack_counter]}\",\"ExadataVersion\":\"$current_exadata_version\",\"HardwareType\":\"$EXADATA_VERSION\", "  >> $JSONREPFIL

echo "\"${program_name}ExecTimestamp\":\"$check_execution_time\"," >> $JSONREPFIL
  update_rsyslog_json "{\"modelVersion\":\"$modelVersion\", \"RackType\":\"$rack_type\",\"EngineeredSystems\":\"$engs_machine\",\"RackIdentifier\":\"$RackIdentifier\", \"OSVersion\":\"$os_version_json\",\"DBVersion\":\"${stack_dbinst_version[$stack_counter]}\",\"ExadataVersion\":\"$current_exadata_version\",\"HardwareType\":\"$EXADATA_VERSION\",
\"${program_name}\": {
	\"${program_name}ExecTimestamp\":\"$check_execution_time\", "

  echo "\"${program_name}ID\":\"$CHECK_ID\"," >> $JSONREPFIL
  update_rsyslog_json "	\"${program_name}ID\":\"$CHECK_ID\", "
  my_checkid=$CHECK_ID
    
  check_execution_start_epoch=$(grep CHECK:$my_checkid $CHK_TIMINGS |grep "Execution Start Time:" |head -1|awk '{print $NF}')
  if [ -z "$check_execution_start_epoch" ] ; then
    check_execution_start_epoch=$(grep CHECK:$my_checkid $CHK_TIMINGS |grep "Start Time:" |head -1 |awk '{print $NF}')
  fi
  check_execution_end_epoch=$(grep CHECK:$my_checkid $CHK_TIMINGS |grep "Execution End Time:" |tail -1 |awk '{print $NF}')
  if [ -z "$check_execution_end_epoch" ] ; then
    check_execution_end_epoch=$(grep CHECK:$my_checkid $CHK_TIMINGS |grep "End Time:" | tail -1 |awk '{print $NF}')
  fi
  #check_execution_secs=$(perl -e "printf \"%.0f\", (($check_execution_end_epoch-$check_execution_start_epoch)/1000);");
  check_execution_ms=
  if [[ -n "$check_execution_start_epoch" && -n "$check_execution_end_epoch" ]] ; then
    check_execution_ms=$(perl -e "print ($check_execution_end_epoch-$check_execution_start_epoch);");
  fi
  #echo "\"${program_name}ExecTime\":\"$check_execution_ms\", " >> $JSONREPFIL
  update_rsyslog_json "\"${program_name}ExecTime\":\"$check_execution_ms\", "

  echo "\"${program_name}Type\":\"$COMTYPE\"," >> $JSONREPFIL
  update_rsyslog_json "\"${program_name}Type\":\"$COMTYPE\", "

  echo "\"${program_name}AlertType\":\"$ALVL_CHECK\"," >> $JSONREPFIL

  echo  "\"${program_name}TargetType\":\"$TARGET_TYPE\", " >> $JSONREPFIL
  opc_target_type=$TARGET_TYPE;
  if [[ "$NEEDS_RUNNING" = "ZFS" ]] ; then opc_target_type="ZFSSA"; fi
  update_rsyslog_json "\"${program_name}TargetType\":\"$opc_target_type\", "

  echo "\"${program_name}Status\":\"$CID_STATUS\", " >> $JSONREPFIL

  if [ "$CID_STATUS" = "PASS" ] ; then
	CID_STATUS_CODE=0
  elif [ "$CID_STATUS" = "INFO" ] ; then
	CID_STATUS_CODE=1
  elif [[ "$CID_STATUS" = "WARN" || "$CID_STATUS" = "WARNING" ]] ; then
	CID_STATUS_CODE=2
  else
	CID_STATUS_CODE=3
  fi
  echo "\"${program_name}StatusCode\":\"$CID_STATUS_CODE\", " >> $JSONREPFIL

  if [ "$CID_STATUS" = "PASS" ] ; then
      jsonStatus="PASS";
      json_sev="INFO";
      CID_STATUS_CODE=0
  else
      jsonStatus="FAIL";
      json_sev="WARN";
      if [ "$CID_STATUS" = "FAIL" ] ; then
        json_sev="CRIT";
      fi
      CID_STATUS_CODE=3
  fi
  update_rsyslog_json " \"${program_name}Status\":\"$jsonStatus\", "
  update_rsyslog_json " \"${program_name}StatusCode\":\"$CID_STATUS_CODE\", "
  echo "\"${program_name}message\":\"$(echo $cch_cname|sed 's/\"/\\\"/g')\", " >> $JSONREPFIL
  update_rsyslog_json "\"${program_name}message\":\"$(echo $cch_cname|sed 's/\"/\\\"/g') \", "
  update_rsyslog_json "\"${program_name}MsgDetail\":\""
  c_output=
  if [[ -n "$G_SOURCEFIL_REPORT" && -f "$G_SOURCEFIL_REPORT" ]] ; then
    cp -f $G_SOURCEFIL_REPORT $CID_HTML_REPFILE.rawout
  else # When -nopass is selected, o/p is not printed
    echo > $CID_HTML_REPFILE.rawout
  fi

  if [ -f "$CID_HTML_REPFILE.rawout" ] ; then
    c_output=$($perl_exe -ne '$print = 0 if ( $print == 1 && /DATA FROM/); $print = 1 if ( /DATA FROM '$cellname'/i ); print if ( $print == 1 )'  $CID_HTML_REPFILE.rawout|head -100| sed 's/\\/\\\\/g' | sed 's/\"/\\\"/g' | $perl_exe -p -e 's/\n/\\n/g;s/\t/\\t/g;s/\r//g;s/[^\x20-\x7e]/ /g')
    update_rsyslog_json "$c_output"
  fi
  echo "\"${program_name}MsgDetail\":\"$c_output\"," >> $JSONREPFIL
  update_rsyslog_json "\","

  if [[ -n "$SOURCEFIL" && -e $SOURCEFIL ]] && [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
  then
    SOURCEFIL4XML=$(basename $SOURCEFIL)
    update_rsyslog_json " \"OutfilePath\":\"$SOURCEFIL4XML\","
  fi 
  #echo "\"ColumnValues\":[ " >> $JSONREPFIL
  #update_rsyslog_json "\"ColumnValues\":[ "
  
  if [[ -n $print_xml_exalogic && $print_xml_exalogic -eq "1" ]]; then
    celln=`echo $cellname|$AWK -F. '{print $1}'`
     echo " \"NodeName\":\"$celln\", " >> $JSONREPFIL
     update_rsyslog_json " \"NodeName\":\"$celln\", "
     echo " \"IPAddress\":\"$cellname_ip\"  " >> $JSONREPFIL
     update_rsyslog_json " \"IPAddress\":\"$cellname_ip\" "
  elif [[ -n $print_xml_exalogic && $print_xml_exalogic -eq "2" ]]; then
    celln=`echo $icellname|$AWK -F. '{print $1}'`
    echo " \"NodeName\":\"$celln\", " >> $JSONREPFIL
    update_rsyslog_json " \"NodeName\":\"$celln\", "
    echo " \"IPAddress\":\"$cellname_ip\" " >> $JSONREPFIL
    update_rsyslog_json " \"IPAddress\":\"$cellname_ip\"  "
  else
    celln=`echo $cellname|$AWK -F. '{print $1}'`
    echo " \"NodeName\":\"$celln\" " >> $JSONREPFIL
    update_rsyslog_json " \"NodeName\":\"$celln\" "
  fi

  #echo " ]" >>$JSONREPFIL
  echo "  }" >> $JSONREPFIL
  update_rsyslog_json "  }"

  #echo "Send $json_to_rsyslog to logger"
  sev_syslog="ERR"
  if [ "$ALVL" = "FAIL" ] ; then sev_syslog="ERR"; fi
  if [ "$ALVL" = "WARNING" ] ; then sev_syslog="WARN"; fi
  if [ "$ALVL" = "INFO" ] ; then sev_syslog="INFO"; fi

  if [[ -n "$RAT_SEND_TO_RSYSLOG_CMDLINE" && $RAT_SEND_TO_RSYSLOG_CMDLINE -eq 1 ]] ; then
    logger -t ${program_name} -p user.$json_sev "@cee: $json_to_rsyslog"
  fi

  if [[ -n "$RAT_CREATE_CLOUD_JSON" && $RAT_CREATE_CLOUD_JSON -eq 1 ]] ; then
    drfc=$(date --rfc-3339=ns)
    echo "[$drfc] [exachk] [$json_sev] [] exachk: [HOST_ID: $localnode] -- @cee: $json_to_rsyslog" >> $CLOUDLOG
  fi
}


generate_result_xml_for_cell () 
{
  echo "   <${xml_prefix1}Result executionTimestamp=\"$check_execution_time\">" >> $XMLREPFIL
  echo "     <CheckID>$CHECK_ID</CheckID>" >>$XMLREPFIL
  echo "     <CheckType>$COMTYPE</CheckType>" >>$XMLREPFIL 
  echo "     <AlertType>$ALVL_CHECK</AlertType>" >>$XMLREPFIL 
  echo "     <TargetType>$TARGET_TYPE</TargetType>" >>$XMLREPFIL
  echo "     <Status>$CID_STATUS</Status>" >>$XMLREPFIL 

  if [[ -n "$SOURCEFIL" && -e $SOURCEFIL ]] && [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
  then
    SOURCEFIL4XML=$(basename $SOURCEFIL)               
    echo "     <OutfilePath>$SOURCEFIL4XML</OutfilePath>" >>$XMLREPFIL               
  fi
  echo "     <ColumnValues>" >>$XMLREPFIL               

  if [[ -n $print_xml_exalogic && $print_xml_exalogic -eq "1" ]]; then
    celln=`echo $cellname|$AWK -F. '{print $1}'`
    #echo "       <ColumnValue Name=\"NodeName\" value=\"$celln\" IPAddress=\"$cellname_ip\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"NodeName\" value=\"$celln\"/>" >>$XMLREPFIL
    echo "	 <ColumnValue Name=\"IPAddress\" value=\"$cellname_ip\"/>" >>$XMLREPFIL
  elif [[ -n $print_xml_exalogic && $print_xml_exalogic -eq "2" ]]; then
    celln=`echo $icellname|$AWK -F. '{print $1}'`
    #echo "       <ColumnValue Name=\"NodeName\" value=\"$celln\" IPAddress=\"$cellname_ip\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"NodeName\" value=\"$celln\"/>" >>$XMLREPFIL
    echo "	 <ColumnValue Name=\"IPAddress\" value=\"$cellname_ip\"/>" >>$XMLREPFIL
  else 
    celln=`echo $cellname|$AWK -F. '{print $1}'`
    echo "       <ColumnValue Name=\"NodeName\" value=\"$celln\"/>" >>$XMLREPFIL
  fi

  echo "     </ColumnValues>" >>$XMLREPFIL               
  echo "   </${xml_prefix1}Result>" >> $XMLREPFIL

}

update_rsyslog_json ()
{
  if [[ -n "$RAT_SEND_TO_RSYSLOG" && $RAT_SEND_TO_RSYSLOG -eq 1 ]] ; then
    #line2write=$(echo "$1" | sed 's/\"/\\\"/g')
    line2write=$1
    json_to_rsyslog=$json_to_rsyslog$line2write
  fi
}

update_errm_in_syslog ()
{
  jfile_path=$(dirname $JSONREPFIL)
  if [ ! -d $jfile_path ] ; then return; fi

  if [ -f "$SCRIPTPATH/.cgrep/.opcbuild" ] ; then
    RAT_SEND_TO_RSYSLOG=1
    RAT_CREATE_CLOUD_JSON=1
  fi
  check_execution_time=$(date '+%Y-%m-%d %H:%M:%S %Z')


  if [ -z "$RackIdentifier" ] ; then
        RackIdentifier=$cluster_name
  fi

  echo "{\"modelVersion\":\"$modelVersion\", \"RackType\":\"$rack_type\",\"EngineeredSystems\":\"$engs_machine\",\"RackIdentifier\":\"$RackIdentifier\", \"OSVersion\":\"$os_version_json\",\"DBVersion\":\"${stack_dbinst_version[$stack_counter]}\",\"ExadataVersion\":\"$current_exadata_version\",\"HardwareType\":\"$EXADATA_VERSION\",

\"${program_name}ExecTimestamp\" : \"$check_execution_time\", 
\"${program_name}ID\":\"\", 
\"${program_name}ExecTime\":\"\", 
\"${program_name}Type\":\"\", 
\"${program_name}Name\":\"Error\", 
\"${program_name}TargetType\":\"HOST\", 
\"${program_name}Status\" : \"WARNING\", 
\"${program_name}message\" : \"Failure during $program_name run. $errm\", 
\"${program_name}MsgDetail\":\"\",
\"NodeName\":\"\"}" >> $JSONREPFIL


  if [[ -z "$RAT_SEND_TO_RSYSLOG" ]] ; then return; fi
  if [[ -n "$RAT_SEND_TO_RSYSLOG_CMDLINE" && $RAT_SEND_TO_RSYSLOG_CMDLINE -eq 1 ]] ; then
    logger -t ${program_name} -p user.err "@cee:{\"modelVersion\":\"$modelVersion\", \"RackType\":\"$rack_type\",\"EngineeredSystems\":\"$engs_machine\",\"RackIdentifier\":\"$RackIdentifier\",\"OSVersion\":\"$os_version_json\",\"DBVersion\":\"${stack_dbinst_version[$stack_counter]}\",\"ExadataVersion\":\"$current_exadata_version\",\"HardwareType\":\"$EXADATA_VERSION\", \"${program_name}ExecTimestamp\" : \"$check_execution_time\", \"${program_name}ID\":\"\", \"${program_name}ExecTime\":\"\", \"${program_name}Type\":\"\", \"${program_name}Name\":\"Error\", \"${program_name}TargetType\":\"HOST\", \"${program_name}Status\" : \"WARNING\", \"message\" : \"Failure during $program_name run. $errm\", \"${program_name}MsgDetail\":\"\", \"NodeName\":\"$i\"}"
  fi
  if [[ -n "$RAT_CREATE_CLOUD_JSON" && $RAT_CREATE_CLOUD_JSON -eq 1 ]] ; then
    drfc=$(date --rfc-3339=ns)
    #echo "[$drfc] [exachk] [NOTICE] [] exachk: [HOST_ID: $localnode]$opc_syslog_tag -- @cee:{\"${program_name}ExecTimestamp\" : \"$check_execution_time\", \"${program_name}ID\":\"$CHECK_ID\", \"${program_name}ExecTime\":\"\", \"${program_name}Type\":\"$COMTYPE\", \"${program_name}Name\":\"$audit_check_name\", \"${program_name}TargetType\":\"HOST\", \"${program_name}Status\" : \"INFO\", \"message\" : \"$errm\", \"${program_name}MsgDetail\":\"\",\"NodeName\":\"$i\"}" >> $CLOUDLOG
    echo "[$drfc] [exachk] [NOTICE] [] exachk: [HOST_ID: $localnode]$opc_syslog_tag -- @cee: {\"${program_name}ExecTimestamp\" : \"$check_execution_time\", \"${program_name}ID\":\"$CHECK_ID\", \"${program_name}ExecTime\":\"\", \"${program_name}Type\":\"$COMTYPE\", \"${program_name}Name\":\"$audit_check_name\", \"${program_name}TargetType\":\"HOST\", \"${program_name}Status\" :\"INFO\", \"message\" : \"$errm\", \"${program_name}MsgDetail\":\"\", \"${program_name}ColumnValues\":[]}" >> $CLOUDLOG
  fi
}

generate_result_xml ()
{
  insert_stmt_printed=0
  target="$i"
  ACT_TARGET="$i"
  P_TARGET_TYPE=$TARGET_TYPE
  CID_STATUS=$1

  #if [[ -n "$NO_WRITE_PASS" && $NO_WRITE_PASS -eq 1 ]]; then return; fi;

  #code to write xml for em plug-in starts here
  status_on_target="";
  check_execution_time=$(date '+%Y-%m-%d %H:%M:%S %Z')

  json_to_rsyslog=""
  is_exalogic_or_foxtrot=0
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    is_exalogic_or_foxtrot=1
  fi

  #if [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS' ]] && [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
  if [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS' ]] && [[ -n "$is_exalogic_or_foxtrot" && $is_exalogic_or_foxtrot -eq "1" ]]; then
    cellname_counter=0
    insert_stmt_printed=1

    if [[ -e $WRKDIR/o_storage.out ]]; then
      cellnames=`cat $WRKDIR/o_storage.out`
      if [[ -e $WRKDIR/o_external_storage.out ]]; then
        cellnames=`cat $WRKDIR/o_storage.out; cat $WRKDIR/o_external_storage.out`
      fi
      for cellname in $cellnames
      do
	print_xml_exalogic=0
        is_name=$(echo $cellname|grep -c '[A-Za-z]')
        if [[ -n $is_name && $is_name -gt 0 ]]; then
          celln=`echo $cellname|$AWK -F. '{print $1}'`
        else
          celln=$cellname
        fi
        #celln=`echo $cellname|$AWK -F. '{print $1}'`
	if [ -e $EAOUT ]; then
	  if [[ -n $is_name && $is_name -gt 0 ]]; then
            ctype=$(grep "$celln" $EAOUT | head -1|cut -d= -f1|sed 's/_hostname/=/g')
            ctype_test=$(echo "$ctype"|grep -c '[A-Za-z]')
	  else
	    ctype_test=$(echo "$celln"|grep -c '[A-Za-z]')
          fi
	else
	  ctype_test=$(echo "$celln"|grep -c '[A-Za-z]')
	fi
        if [[ -n $ctype_test && $ctype_test -gt 0 ]]; then
	  if [ -e $EAOUT ]; then
            cellname_ip=$(grep "$ctype" $EAOUT | cut -d= -f2)
	  else
	    cellname_ip=`nslookup "$celln" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`;
	  fi
	  is_cell_ip=$(echo "$cellname_ip"|grep -c '[A-Za-z]')
	  if [[ -n $is_cell_ip && $is_cell_ip -eq 0 ]]; then
	    print_xml_exalogic=1
	    generate_result_xml_for_cell	     
	    generate_result_json_for_cell
	  fi
	else
	  cellname_ip=$celln
	  icellname=`nslookup "$cellname_ip"|grep -w name|$AWK '{print $NF}'|sed 's/.$//'`;
	  is_cell_name=$(echo "$icellname"|grep -c '[A-Za-z]')
	  if [[ -n $is_cell_name && $is_cell_name -ne 0 ]]; then
	    print_xml_exalogic=2
	    generate_result_xml_for_cell
      	    generate_result_json_for_cell
	  fi
	fi
        cellname_counter=$(expr $cellname_counter + 1 )
      done
      unset print_xml_exalogic
    fi
  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS_OUT_CHECK' ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] ; then
    cellname_counter=0
    insert_stmt_printed=1
    for cellname in ${a_cellname[@]}
    do
      CID_STATUS=${a_cellCheckStatus[$cellname_counter]}
      generate_result_xml_for_cell
      generate_result_json_for_cell
      cellname_counter=$(expr $cellname_counter + 1)
    done
  else
    echo "   <${xml_prefix1}Result executionTimestamp=\"$check_execution_time\">" >> $XMLREPFIL
  if [ -z $RackIdentifier ] ; then
        RackIdentifier=$cluster_name
  fi
    echo "{\"modelVersion\":\"$modelVersion\", \"RackType\":\"$rack_type\",\"EngineeredSystems\":\"$engs_machine\",\"RackIdentifier\":\"$RackIdentifier\", \"OSVersion\":\"$os_version_json\",\"DBVersion\":\"${stack_dbinst_version[$stack_counter]}\",\"ExadataVersion\":\"$current_exadata_version\",\"HardwareType\":\"$EXADATA_VERSION\",
\"${program_name}ExecTimestamp\":\"$check_execution_time\", "  >> $JSONREPFIL

    update_rsyslog_json "{\"${program_name}ExecTimestamp\":\"$check_execution_time\", "
    if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
    then
      echo "     <CheckID>${crs_check_id[$crs_check_file_counter]}</CheckID>" >>$XMLREPFIL
      echo "\"${program_name}ID\":\"${crs_check_id[$crs_check_file_counter]}\"," >> $JSONREPFIL
      update_rsyslog_json "\"${program_name}ID\":\"${crs_check_id[$crs_check_file_counter]}\", "
      my_checkid=${crs_check_id[$crs_check_file_counter]}
    else
      echo "     <CheckID>$CHECK_ID</CheckID>" >>$XMLREPFIL
      echo "\"${program_name}ID\":\"$CHECK_ID\"," >> $JSONREPFIL
      update_rsyslog_json "\"${program_name}ID\":\"$CHECK_ID\", "
      my_checkid=$CHECK_ID
    fi

    check_execution_start_epoch=$(grep CHECK:$my_checkid $CHK_TIMINGS |grep "Execution Start Time:" |head -1|awk '{print $NF}')
    if [ -z "$check_execution_start_epoch" ] ; then
      check_execution_start_epoch=$(grep CHECK:$my_checkid $CHK_TIMINGS |grep "Start Time:" |head -1 |awk '{print $NF}')
    fi
    check_execution_end_epoch=$(grep CHECK:$my_checkid $CHK_TIMINGS |grep "Execution End Time:" |tail -1 |awk '{print $NF}')
    if [ -z "$check_execution_end_epoch" ] ; then
      check_execution_end_epoch=$(grep CHECK:$my_checkid $CHK_TIMINGS |grep "End Time:" | tail -1 |awk '{print $NF}')
    fi
    #check_execution_secs=$(perl -e "printf \"%.0f\", (($check_execution_end_epoch-$check_execution_start_epoch)/1000);");
    check_execution_ms=
    if [[ -n "$check_execution_start_epoch" && -n "$check_execution_end_epoch" ]] ; then
      check_execution_ms=$(perl -e "print ($check_execution_end_epoch-$check_execution_start_epoch);");
    fi
    #echo "\"${program_name}ExecTime\":\"$check_execution_ms\", " >> $JSONREPFIL
    update_rsyslog_json "\"${program_name}ExecTime\":\"$check_execution_ms\", "

    if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' ]]; then OLD_COMTYPE=$COMTYPE; COMTYPE='CROSS_NODE_CHECK'; fi

    echo "     <CheckType>$COMTYPE</CheckType>" >>$XMLREPFIL 
    echo "     <AlertType>$ALVL_CHECK</AlertType>" >>$XMLREPFIL 

    echo "     <TargetType>$TARGET_TYPE</TargetType>" >>$XMLREPFIL
    echo "     <Status>$1</Status>" >>$XMLREPFIL 
    echo "\"${program_name}Type\":\"$COMTYPE\"," >> $JSONREPFIL
    update_rsyslog_json "\"${program_name}Type\":\"$COMTYPE\", "
    echo "\"${program_name}Name\":\"$(echo $cch_check_name|sed 's/\"/\\\"/g')\", "  >> $JSONREPFIL
    update_rsyslog_json "\"${program_name}Name\":\"$(echo $cch_check_name|sed 's/\"/\\\"/g')\", "
    echo "\"${program_name}AlertType\":\"$ALVL_CHECK\"," >> $JSONREPFIL
    echo  "\"${program_name}TargetType\":\"$TARGET_TYPE\", " >> $JSONREPFIL
    opc_target_type=$TARGET_TYPE;
    if [[ "$NEEDS_RUNNING" = "ZFS" ]] ; then opc_target_type="ZFSSA"; fi
    update_rsyslog_json " \"${program_name}TargetType\":\"$opc_target_type\", "
    echo "\"${program_name}Status\":\"$1\", " >> $JSONREPFIL
    if [ "$CID_STATUS" = "PASS" ] ; then
        CID_STATUS_CODE=0
    elif [ "$CID_STATUS" = "INFO" ] ; then
        CID_STATUS_CODE=1
    elif [[ "$CID_STATUS" = "WARN" || "$CID_STATUS" = "WARNING" ]] ; then
        CID_STATUS_CODE=2
    else
        CID_STATUS_CODE=3
    fi

    echo "\"${program_name}StatusCode\":\"$CID_STATUS_CODE\", " >> $JSONREPFIL

    if [ $1 = "PASS" ] ; then 
      jsonStatus="PASS"; 
      json_sev="INFO";
      CID_STATUS_CODE=0
    else 
      CID_STATUS_CODE=3
      jsonStatus="FAIL"; 
      json_sev="WARN";
      if [ $1 = "FAIL" ] ; then
        json_sev="CRIT";
      fi
    fi

    update_rsyslog_json " \"${program_name}Status\":\"$jsonStatus\", "
    echo " \"${program_name}Status\":\"$CID_STATUS_CODE\", " >> $JSONREPFIL
    echo "\"${program_name}message\":\"$(echo $cch_cname|sed 's/\"/\\\"/g')\", " >> $JSONREPFIL
    update_rsyslog_json "\"${program_name}message\":\"$(echo $cch_cname|sed 's/\"/\\\"/g') \", "
    update_rsyslog_json " \"${program_name}MsgDetail\":\""
    c_output=
    if [ -f "$CID_HTML_REPFILE.rawout" ] ; then
      c_output=$(cat $CID_HTML_REPFILE.rawout| head -100 | sed 's/\\/\\\\/g' | sed 's/\"/\\\"/g' | $perl_exe -p -e 's/\n/\\n/g;s/\t/\\t/g;s/\r//g;s/[^\x20-\x7e]/ /g')
      update_rsyslog_json "$c_output"
    fi
    echo "\"${program_name}MsgDetail\":\"$c_output\"," >> $JSONREPFIL
    update_rsyslog_json " \""
    if [[ -n "$SOURCEFIL" && -e $SOURCEFIL ]] && [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
    then
      SOURCEFIL4XML=$(basename $SOURCEFIL)               
      echo "     <OutfilePath>$SOURCEFIL4XML</OutfilePath>" >>$XMLREPFIL               
      echo " \"OutfilePath\":\"$SOURCEFIL4XML\"," >>$JSONREPFIL
      update_rsyslog_json " \"${program_name}OutfilePath\":\"$SOURCEFIL4XML\","
    fi

    echo "     <ColumnValues>" >>$XMLREPFIL               
    #echo "\"${program_name}ColumnValues\":[ " >> $JSONREPFIL
    update_rsyslog_json ",\"${program_name}ColumnValues\":[ "

    if [[ $TARGET_TYPE = 'RDBMS' || $TARGET_TYPE = 'ASM' ]] && [[ $COMTYPE = 'SQL_PARAM' ]] ; then
      echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"InitORAParameterName\" value=\"$PARAM_PATH\"/>" >>$XMLREPFIL
      echo " \"DBName\":\"$db_name_to_check\", " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"DBName\",\"value\":\"$db_name_to_check\"}, "
      echo " \"InstanceName\":\"$inst_name\", " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"InstanceName\",\"value\":\"$inst_name\"}, "
      echo " \"InitORAParameterName\":\"$PARAM_PATH\" " >> $JSONREPFIL  
      update_rsyslog_json " {\"Name\":\"InitORAParameterName\",\"value\":\"$PARAM_PATH\"} " 
    elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'OS' ]] ; then
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$i\", " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$i\"}, "
      echo " \"InstanceName\":\"$inst_name\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"InstanceName\",\"value\":\"$inst_name\"} " 
    elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'OS' ]] ; then
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$i\", " >> $JSONREPFIL
      echo " \"InstanceName\":\"$inst_name\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$i\"}, "
      update_rsyslog_json " {\"Name\":\"InstanceName\",\"value\":\"$inst_name\"} "
    elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
      echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
      echo " \"DBName\":\"$db_name_to_check\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"DBName\",\"value\":\"$db_name_to_check\"} " 
    elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
      echo "       <ColumnValue Name=\"ASMName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL       
      echo " \"ASMName\":\"$db_name_to_check\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"ASMName\",\"value\":\"$db_name_to_check\"} "
    elif [[ $TARGET_TYPE = 'RDBMS' ]] && [[ $COMTYPE = 'SQL' || $COMTYPE = 'SQL_OUT_CHECK' ]] ; then
      echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
      echo " \"DBName\":\"$db_name_to_check\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"DBName\",\"value\":\"$db_name_to_check\"} " 
    elif [[ $TARGET_TYPE = 'RDBMS_HOME' && $COMTYPE = 'OS' ]] ; then
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$i\", " >> $JSONREPFIL
      echo " \"HomePath\":\"${mb_db_homes}\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$i\"}, "
      update_rsyslog_json " {\"Name\":\"HomePath\",\"value\":\"${mb_db_homes}\"} "
    elif [[ $TARGET_TYPE = 'TIMESTEN_HOME' && $COMTYPE = 'OS' ]] ; then
      ACT_TARGET=${mb_db_homes}
      target="${mb_db_homes}"
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$i\", " >> $JSONREPFIL
      echo " \"HomePath\":\"${mb_db_homes}\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$i\"}, "
      update_rsyslog_json " {\"Name\":\"HomePath\",\"value\":\"${mb_db_homes}\"} " 
    elif [[ $TARGET_TYPE = 'GOLDENGATE_HOME' && $COMTYPE = 'OS' ]] ; then
      ACT_TARGET=${mb_ogg_home}
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_ogg_home}\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$i\"," >> $JSONREPFIL
      echo " \"HomePath\":\"${mb_ogg_home}\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$i\"}, "
      update_rsyslog_json " {\"Name\":\"HomePath\",\"value\":\"${mb_ogg_home}\"} "
    elif [[ $TARGET_TYPE = 'CLUSTER' && $COMTYPE = 'CLUSTERWIDE_CHECK' ]] ; then
      result_xml_entry=0 
      echo " \"NodeName\":\"$i\" " >> $JSONREPFIL

    elif [[ $TARGET_TYPE = 'CRS' || $TARGET_TYPE = 'CRS_HOME' ]] && [[ $COMTYPE = 'OS' ]] ; then
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$i\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$i\"} "
    elif [[ $TARGET_TYPE = 'SPINE_SWITCH' || $TARGET_TYPE = 'SWITCH' ]] && [[ $COMTYPE = 'OS_OUT_CHECK' || $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
      target="$switchname"
      ACT_TARGET="$switchname"
      echo "       <ColumnValue Name=\"NodeName\" value=\"$switchname\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$switchname\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$switchname\"} "
    elif [[ $TARGET_TYPE = 'BI_INSTANCE' && $COMTYPE = 'OS' ]] ; then
      target="$bi_instance"
      ACT_TARGET="$bi_instance"
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"WeblogicDomainName\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
      echo "       <ColumnValue Name=\"InstanceName\" value=\"$bi_instance\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$i\", " >> $JSONREPFIL
      echo " \"WeblogicDomainName\":\"${mb_db_homes}\", " >> $JSONREPFIL
      echo " \"InstanceName\":\"$bi_instance\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$i\"}, "
      update_rsyslog_json " {\"Name\":\"WeblogicDomainName\",\"value\":\"${mb_db_homes}\"}, "
      update_rsyslog_json " {\"Name\":\"InstanceName\",\"value\":\"$bi_instance\"} "
    elif [[ "$NEEDS_RUNNING" = "ZFS" ]] ; then
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$cellname\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$cellname\"} "
      zfs_cellname_ip=`nslookup "$cellname" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`;
      opc_syslog_tag=" [HOST: $cellname] [IPADDRESS: $zfs_cellname_ip]"
    else
      echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
      echo " \"NodeName\":\"$i\" " >> $JSONREPFIL
      update_rsyslog_json " {\"Name\":\"NodeName\",\"value\":\"$i\"} "
    fi;

    echo "     </ColumnValues>" >>$XMLREPFIL               
  #  echo " ]" >>$JSONREPFIL
    update_rsyslog_json " ]"
    echo "}" >> $JSONREPFIL
    update_rsyslog_json "  }"
    echo "   </${xml_prefix1}Result>" >> $XMLREPFIL
  fi

  #echo "Send $json_to_rsyslog to logger"
  sev_syslog="err"
  if [ "$ALVL" = "FAIL" ] ; then sev_syslog="err"; fi
  if [ "$ALVL" = "WARNING" ] ; then sev_syslog="warn"; fi
  if [ "$ALVL" = "INFO" ] ; then sev_syslog="info"; fi
    
  if [[ -n "$RAT_SEND_TO_RSYSLOG_CMDLINE" && $RAT_SEND_TO_RSYSLOG_CMDLINE -eq 1 ]] ; then
    logger -t ${program_name} -p user.$json_sev "@cee: $json_to_rsyslog"
  fi
  if [[ -n "$RAT_CREATE_CLOUD_JSON" && $RAT_CREATE_CLOUD_JSON -eq 1 ]] ; then
    drfc=$(date --rfc-3339=ns)
    echo "[$drfc] [exachk] [$json_sev] [] exachk: [HOST_ID: $localnode]$opc_syslog_tag -- @cee: $json_to_rsyslog" >> $CLOUDLOG
  fi

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' && -n $OLD_COMTYPE ]]; then COMTYPE=$OLD_COMTYPE; fi

  echo "$CHECK_ID|$cch_status|$COMTYPE|$status_on_target|$db_name_to_check|$inst_name|$mb_db_homes|$message4Home|$cch_cname|$g_hosts" >> $OUTPUTDIR/slave_results_${localnode}.out

  if [[ $TARGET_TYPE = 'RDBMS_HOME' ]];
  then
    ACT_TARGET=${mb_db_homes}
  elif [[ $TARGET_TYPE = 'CRS' || $TARGET_TYPE = 'CRS_HOME' || $TARGET_TYPE = 'ASM_HOME' ]];
  then
    if [[ $TARGET_TYPE = 'CRS' ]]; then P_TARGET_TYPE='CRS_HOME'; fi
    ACT_TARGET="$CRS"
  elif [[ $TARGET_TYPE = 'ASM' ]];
  then
    ACT_TARGET=$inst_name
  elif [[ $TARGET_TYPE = 'RDBMS' ]]; 
  then
    if [[ $COMTYPE = 'OS' || $COMTYPE = 'SQL_PARAM' ]]; 
    then
      P_TARGET_TYPE='RDBMS_INSTANCE'
      ACT_TARGET=$inst_name
    else
      ACT_TARGET=$db_name_to_check
    fi
  fi

  print_audit_check_name=$audit_check_name;
  if [[ -z "$audit_check_name" || "$audit_check_name" = "" ]]; then 
    print_audit_check_name=$PARAM_PATH 
  fi
  print_audit_check_name=$(echo "$print_audit_check_name"|sed "s/'//g")
}

generate_exceptions_json ()
{
  if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  then
    echo " {\"${program_name}ID\":\"${crs_check_id[$crs_check_file_counter]}\", " >> $JSONSKIPFIL
  else
    echo " {\"${program_name}CheckID\":\"$CHECK_ID\", " >> $JSONSKIPFIL
  fi

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' ]]; then OLD_COMTYPE=$COMTYPE; COMTYPE='CROSS_NODE_CHECK'; fi

   echo "\"${program_name}Type\":\"$COMTYPE\", " >> $JSONSKIPFIL
   echo "\"${program_name}AlertType\":\"$ALVL_CHECK\"," >> $JSONSKIPFIL
   echo " \"${program_name}TargetType\":\"$TARGET_TYPE\", " >> $JSONSKIPFIL

   if [[ $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" || $COMTYPE = "SQL_PARAM" ]]
  then
    echo "\"${program_name}Name\":\"$PARAM_NAME\", " >> $JSONSKIPFIL 
  else
    echo "\"${program_name}Name\":\"$(echo $audit_check_name|sed 's/\[DBMV2]//g' |sed 's/</less than/g' | sed 's/>/greater than/g')\", " >> $JSONSKIPFIL 
  fi

  if [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
  then
    if [ -e $SOURCEFIL ]; then SOURCEFIL4XML=$(basename $SOURCEFIL 2>/dev/null);fi
  fi


  if [[ $TARGET_TYPE = 'RDBMS' || $TARGET_TYPE = 'ASM' ]] && [[ $COMTYPE = 'SQL_PARAM' ]] ; then
    echo " \"DBName\":\"$db_name_to_check\", " >> $JSONSKIPFIL
    echo " \"InstanceName\":\"$inst_name\", " >> $JSONSKIPFIL
    echo " \"InitORAParameterName\":\"$PARAM_PATH\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'OS' ]] ; then
    echo " \"NodeName\":\"$i\", " >> $JSONSKIPFIL
    echo " \"InstanceName\":\"$inst_name\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'OS' ]] ; then
    echo " \"NodeName\":\"$i\", " >> $JSONSKIPFIL
    echo " \"InstanceName\":\"$inst_name\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo " \"DBName\":\"$db_name_to_check\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo " \"ASMName\":\"$db_name_to_check\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'RDBMS' ]] && [[ $COMTYPE = 'SQL' || $COMTYPE = 'SQL_OUT_CHECK' ]] ; then
    echo " \"DBName\":\"$db_name_to_check\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'RDBMS_HOME' && $COMTYPE = 'OS' ]] ; then
    echo " \"NodeName\":\"$i\", " >> $JSONSKIPFIL
    echo " \"HomePath\":\"${mb_db_homes}\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'TIMESTEN_HOME' && $COMTYPE = 'OS' ]] ; then
    echo " \"NodeName\":\"$i\", " >> $JSONSKIPFIL
    echo " \"HomePath\":\"${mb_db_homes}\" " >> $JSONSKIPFIL
  elif [[ $TARGET_TYPE = 'GOLDENGATE_HOME' && $COMTYPE = 'OS' ]] ; then
    echo " \"NodeName\":\"$i\", " >> $JSONSKIPFIL
    echo " \"HomePath\":\"${mb_ogg_home}\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'CLUSTER' && $COMTYPE = 'CLUSTERWIDE_CHECK' ]] ; then
    exception_xml_entry=0
    echo " \"NodeName\":\"$i\" " >> $JSONSKIPFIL
  elif [[ $TARGET_TYPE = 'CRS' || $TARGET_TYPE = 'CRS_HOME' ]] && [[ $COMTYPE = 'OS' ]] ; then
    echo " \"NodeName\":\"$i\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS' ]] && [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    echo " \"NodeName\":\"$i\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS_OUT_CHECK' ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] ; then
    echo " \"NodeName\":\"$cellname\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'SPINE_SWITCH' || $TARGET_TYPE = 'SWITCH' ]] && [[ $COMTYPE = 'OS_OUT_CHECK' || $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo " \"NodeName\":\"$switchname\" " >> $JSONSKIPFIL

  elif [[ $TARGET_TYPE = 'BI_INSTANCE' && $COMTYPE = 'OS' ]] ; then
    echo " \"NodeName\":\"$i\", " >> $JSONSKIPFIL
    echo " \"WeblogicDomainName\":\"${mb_db_homes}\", " >> $JSONSKIPFIL
    echo " \"InstanceName\":\"$bi_instance\" " >> $JSONSKIPFIL

  else
    echo " \"NodeName\":\"$i\" " >> $JSONSKIPFIL

  fi

  echo ",\"Message\":\"$1\" " >> $JSONSKIPFIL
  echo "}" >> $JSONSKIPFIL

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' && -n $OLD_COMTYPE ]]; then COMTYPE=$OLD_COMTYPE; fi
  errm=$1
  update_errm_in_syslog
}

generate_exceptions_xml ()
{
  echo "   <${xml_prefix1}Exclusion>" >> $XMLSKIPFIL
  if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  then
    echo "     <CheckID>${crs_check_id[$crs_check_file_counter]}</CheckID>" >>$XMLSKIPFIL
  else
    echo "     <CheckID>$CHECK_ID</CheckID>" >>$XMLSKIPFIL
  fi

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' ]]; then OLD_COMTYPE=$COMTYPE; COMTYPE='CROSS_NODE_CHECK'; fi

  echo "     <CheckType>$COMTYPE</CheckType>" >>$XMLSKIPFIL
  echo "     <AlertType>$ALVL_CHECK</AlertType>" >>$XMLSKIPFIL

  echo "     <TargetType>$TARGET_TYPE</TargetType>" >>$XMLSKIPFIL

  if [[ $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" || $COMTYPE = "SQL_PARAM" ]]
  then
    echo "     <CheckName><![CDATA[$PARAM_NAME]]></CheckName>" >>$XMLSKIPFIL
  else
    echo "     <CheckName><![CDATA[$(echo $audit_check_name|sed 's/\[DBMV2]//g' |sed 's/</less than/g' | sed 's/>/greater than/g')]]></CheckName>" >>$XMLSKIPFIL
  fi

  if [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
  then
    if [ -e $SOURCEFIL ]; then SOURCEFIL4XML=$(basename $SOURCEFIL 2>/dev/null);fi               
    echo "     <OutfilePath>$SOURCEFIL4XML</OutfilePath>" >>$XMLSKIPFIL               
  fi    

  echo "     <ColumnValues>" >>$XMLSKIPFIL 
  if [[ $TARGET_TYPE = 'RDBMS' || $TARGET_TYPE = 'ASM' ]] && [[ $COMTYPE = 'SQL_PARAM' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InitORAParameterName\" value=\"$PARAM_PATH\"/>" >>$XMLSKIPFIL

  elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLSKIPFIL

  elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLSKIPFIL

  elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
   
  elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"ASMName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'RDBMS' ]] && [[ $COMTYPE = 'SQL' || $COMTYPE = 'SQL_OUT_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'RDBMS_HOME' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_db_homes}\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'TIMESTEN_HOME' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_db_homes}\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'GOLDENGATE_HOME' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_ogg_home}\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'CLUSTER' && $COMTYPE = 'CLUSTERWIDE_CHECK' ]] ; then
    exception_xml_entry=0  

  elif [[ $TARGET_TYPE = 'CRS' || $TARGET_TYPE = 'CRS_HOME' ]] && [[ $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS' ]] && [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS_OUT_CHECK' ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$cellname\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'SPINE_SWITCH' || $TARGET_TYPE = 'SWITCH' ]] && [[ $COMTYPE = 'OS_OUT_CHECK' || $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$switchname\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'BI_INSTANCE' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"WeblogicDomainName\" value=\"${mb_db_homes}\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$bi_instance\"/>" >>$XMLSKIPFIL
       
  else
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL

  fi;

  echo "     </ColumnValues>" >>$XMLSKIPFIL               
  echo "     <Message><![CDATA[$1]]></Message>" >>$XMLSKIPFIL               
  echo "   </${xml_prefix1}Exclusion>" >> $XMLSKIPFIL

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' && -n $OLD_COMTYPE ]]; then COMTYPE=$OLD_COMTYPE; fi

}

log_pass ()
{
  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch 
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:log_pass Start Time: $epoch_time" >> $CHK_TIMINGS
  fi

  #if we're in SILENT mode then all we want to suppress some of this logging
  #BUT not all of the logging which we may need for debugging purposes
  #pass/fail is not a concept fo rSILENT mode
  #$READ -p "calling log pass"
  #echo "row=$ROW COMTYPE=$COMTYPE command=$COM PARAM_PATH=$PARAM_PATH ISBRANCH=$ISBRANCH REQUIRES_ROOT_OS=$REQUIRES_ROOT_OS NEEDS_RUNNING=$NEEDS_RUNNING execute once=$execute_once"	
  case $COMTYPE in

  OS_COLLECT)
    echo "------------------------------" >>$LOGFIL 
    #echo "------------------------------" >>$REPFIL
    echo "  SEE OS OUTPUT FILE $OUTFIL" >>$LOGFIL
    #echo "  SEE OS OUTPUT FILE $OUTFIL" >>$REPFIL
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "" >>$LOGFIL
    #echo "" >>$REPFIL
    ;;
  SQL_COLLECT)
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "  SEE SQL OUTPUT FILE $OUTFIL" >>$LOGFIL
    #echo "  SEE SQL OUTPUT FILE $OUTFIL" >>$REPFIL
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "" >>$LOGFIL
    #echo "" >>$REPFIL
    ;;
  #CLUSTERWIDE_CHECK)
  #   echo "it called the right fuction"
  #  ;;
  *)
    if [[ $ISBRANCH -eq "1" && $SILENT -eq "0" ]]
    then
      echo "BRANCH CONDITION TRUE" >>$LOGFIL
      echo "---------------------------------------------" >>$LOGFIL
    else
      #gadiga.. added for SHS
      if [[ $OFFLINE -eq 0 ]]; 
      then
        cell_ib_fail_count=$(grep 'FAIL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
        cell_ib_warn_count=$(grep 'WARN' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
        cell_ib_info_count=$(grep 'INFO' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
        cell_ib_total_count=$(grep 'TOTAL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      fi

      if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
      then
        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$outcheck_cell_counter;
        validate_needs_running;
        cell_ib_total_count=$(expr $cell_ib_total_count + $outcheck_cell_counter);
         
        if [[ $OFFLINE -eq 0 ]];
      	then
          echo "FAIL = $cell_ib_fail_count" >> $CELLIBNTFILE.new
          echo "WARN = $cell_ib_warn_count" >> $CELLIBNTFILE.new
          echo "INFO = $cell_ib_info_count" >> $CELLIBNTFILE.new
          echo "TOTAL = $cell_ib_total_count" >> $CELLIBNTFILE.new

          rm -f $CELLIBNTFILE 2>/dev/null
          mv -f $CELLIBNTFILE.new $CELLIBNTFILE 2>/dev/null         
        fi
      else
        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1;
        validate_needs_running
      fi
      outcheck_cell_counter=0   
      if [ $SILENT -eq "0" ]
      then     
        echo "" >>$LOGFIL 
        #if [ "$ALVL" != "INFO" ]
        #then
        #    ACREPCOUNT=`expr $ACREPCOUNT + 1`
        #fi
        #echo "------------------------------" >>$LOGFIL
        echo  "PASS =>  $PMSG" >>$LOGFIL
        #echo "------------------------------" >>$LOGFIL
        echo "" >>$LOGFIL
        #Commented this if condition on Oct 02 to print info pass messages in all reports
        #if [[ -n $ALVL && $ALVL != "INFO" ]]
        #then 
        if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
        then
          echo "" >>$CWCREPFIL_PASS
          echo  "Check:- PASS => $PMSG" >>$CWCREPFIL_PASS
          echo  "Check:- PASS => $PMSG" >>$SCWCREPFIL_PASS
        else
          if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
          then
            echo "" >>$CELLREPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$CELLREPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$CELLSREPFIL_PASS
          elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
          then
            echo "" >>$IBREPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$IBREPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$IBSREPFIL_PASS
          else
            echo "" >>$REPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$REPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$SREPFIL_PASS
          fi
        fi
        if [[ $COMTYPE != "OS_PACKAGE" && -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]
        then
          if [[  $COMTYPE = "CLUSTERWIDE_CHECK"  ]]
          then
            echo -e "Success factor name = $SF \n">>$CWCREPFIL_PASS
          else
            if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
            then
              echo -e "Success factor name = $SF \n">>$CELLREPFIL_PASS
            elif [[ $COMTYPE = "OS_OUT_CHECK"  ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
            then
              echo -e "Success factor name = $SF \n">>$IBREPFIL_PASS
            else
              echo -e "Success factor name = $SF \n">>$REPFIL_PASS
            fi
          fi
        fi
        if [ $COMTYPE = "OS_PACKAGE" ]
        then
          echo  "Audit check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@PASS =>   $PMSG@$rpm_status@$rpm_arch">>$OSCHECKRESULT
        else
          if [ -z "$audit_check_name" ]
          then
            audit_check_name=$COM
          fi
          echo  "Audit check # $ACREPCOUNT@$audit_check_name@$VAL@$COMP@PASS =>   $PMSG">>$OSCHECKRESULT
          #audit_check_name=""
        fi 
        #echo "------------------------------" >>$REPFIL
        if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
        then 
          echo "" >>$CWCREPFIL_PASS
        else
          if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
          then
            echo "" >>$CELLREPFIL_PASS
          elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
          then
            echo "" >>$IBREPFIL_PASS
          else 
            echo "" >>$REPFIL_PASS
          fi 
        fi
        if [[ $CREATE_HTML_REPORT -eq 1 ]]
        then # gadiga - for html reporting
          init_arrays_html "PASS"
          write_additional_info;
        fi

        if [[ $ISBRANCH -ne 1 ]] ; then
          generate_result_xml "PASS"     
        fi

        #fi 
        BPMSG=0  
        BPMSG=`echo $PMSG|grep -c "BRANCH CONDITION TRUE"`
        if [[ $BPMSG -lt 1 && $ALVL != "INFO" && -n $ALVL && $print_pass_on_screen -eq 1 ]]
        then
          echo -e "$GREEN PASS =>   $NORM $PMSG"
        else
	  #to stop printing info in pass, just redirect follwing line to devnull 
          if [[ -n "$RAT_INFOPASS" && $RAT_INFOPASS -eq 1 && $print_pass_on_screen -eq 1 ]]
          then
            echo -e "$CYAN $ALVL =>   $NORM $PMSG" 
          else
            echo -e "$CYAN $ALVL =>   $NORM $PMSG" > /dev/null
            #echo -e "$CYAN $ALVL =>   $NORM $PMSG"
          fi
        fi
        echo -e "CHECK ID = $CHECK_ID \nAUDIT CHECK NAME = $audit_check_name\n">>$LOGFIL
        echo "---------------------------------------------" >>$LOGFIL
      fi
    fi
  ;;
  esac

  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch 
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:log_pass End Time: $epoch_time" >> $CHK_TIMINGS
  fi
}

function assign_usern ()
{
  case `/bin/uname` in
    Linux)
    usern=`whoami`
    ;;
    SunOS)
    usern=`id|awk '{print $1}'|cut -d'(' -f2|cut -d')' -f1`
    ;;
    HP-UX)
    usern=`whoami`
    ;;
    AIX)
    usern=`whoami`
    ;;     
    *)
    usern=`whoami`
    ;;     
  esac
}

P_CONF_NAMES[0]="AUTORUN_INTERVAL"
P_CONF_NAMES[1]="AUTORUN_SCHEDULE"
P_CONF_NAMES[2]="AUTORUN_FLAGS"
P_CONF_NAMES[3]="NOTIFICATION_EMAIL"
P_CONF_NAMES[4]="PASSWORD_CHECK_INTERVAL"
P_CONF_NAMES[5]="COLLECTION_RETENTION"

function check_p_conf_validity ()
{
  p_name=$1
  p_conf_valid=0
  for v_n in "${P_CONF_NAMES[@]}"
  do
    if [[ `echo $v_n | grep -icw "$p_name"` -gt "0" ]] ; then
      p_conf_valid=1
      return
    fi
  done
}

#    FILE			FORMAT
#=============================================
#1. last_autorun_report 	@ID:<ID> - REPORT
#2. autorun_list		@ID:<ID> - COLLECTION_NAME
#3. last_autorun_time		@ID=><ID> - TIME
#4. autorun_conf		@<ID>_START...@<ID>_END

function modify_conf_file ()
{
  if [[ $cmd_line_email -eq 1 ]];then 
    p_conf_file="$WRKDIR/.${program_name}_nodaemon.dmp"
  fi
  if [ -e "$p_conf_file" ]
  then
    numids=$(grep -c "^\s*@.*_START\s*$" $p_conf_file | sed 's/ //g')  
    if [[ $numids -eq "0" ]]
    then
      echo "@${autorun_id}_START"	> "$p_conf_file.tmp"
      cat "$p_conf_file" 	 	>>"$p_conf_file.tmp"
      echo "@${autorun_id}_END"		>>"$p_conf_file.tmp"
      mv -f "$p_conf_file.tmp" "$p_conf_file"
    fi
  fi

  if [ -e $autorun_list ]; then
    if [[ `grep -c "^@ID:" $autorun_list` -eq 0 ]]; then
	sed -e "s/^/@ID:${program_name}.default - /" $autorun_list > $autorun_list.bak && mv -f $autorun_list.bak $autorun_list 
    fi
  fi

  if [ -e $RTEMPDIR_D/last_autorun_report ]; then
    if [[ `grep -c "^@ID:" $RTEMPDIR_D/last_autorun_report` -eq 0 ]]; then
	sed  -e "s/^/@ID:${program_name}.default - /" $RTEMPDIR_D/last_autorun_report > $RTEMPDIR_D/last_autorun_report.bak && mv -f $RTEMPDIR_D/last_autorun_report.bak $RTEMPDIR_D/last_autorun_report
    fi
  fi
}

function show_conf_file ()
{
  i_name=$1
  if [ -z "$i_name" ] ; then i_name="all"; fi
  matched_conf=0
  if [ ! -f "$p_conf_file" ] ; then
    echo
    echo "None of parameters are set"
    echo
    return
  fi

  if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "0" ]]
  then
    look_p_conf=`cat $p_conf_file`
  else
    is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')
    if [[ $is_id_exist -eq "0" ]]; then
      echo
      echo -e "${RED}Specified ID[${autorun_id}] doesn't exist.${NORM}"
      echo
      exit 1
    fi
    look_p_conf=`sed -n "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/p" $p_conf_file`
  fi

  OIFS="${IFS}";
  NIFS=$'\n';
  IFS="${NIFS}";

  for l_option in $look_p_conf
  do
    if [[ `echo "$l_option" | grep -c "^\s*$"` -gt "0" ]]; then continue; fi

    if [[ `echo "$l_option" | grep -c "^\s*@.*_START\s*$"` -gt "0" ]]
    then
      echo
      l_option=$(echo "$l_option" | sed 's/_START$//g' | sed 's/^@//g')
      echo "ID: $l_option"
      echo "----------------------------------"
    elif [[ `echo "$l_option" | grep -c "^\s*@.*_END\s*$"` -gt "0" ]]
    then
      continue
    else
      if [[ `echo "$l_option" |grep -c "^\s*$"` -gt "0" ]]
      then
        continue
      fi
      o_name=$(echo "$l_option" | cut -d"=" -f1 | sed 's/ //g')
      o_val=$(echo "$l_option" | cut -d"=" -f2 | sed 's/^ *//g' | sed 's/ *$//')
      if [[ -n "$i_name" &&  `echo $o_name | grep -iwc $i_name` -gt "0" ]] ; then
        echo "$o_name = $o_val";
        matched_conf=1
      elif [[ "$i_name" = "all" ]] ; then
        echo "$o_name = $o_val";
        matched_conf=1
      fi
    fi
  done
  IFS="${OIFS}";

  if [[ $matched_conf -eq "0" ]] ; then
    echo
    echo -e "${RED}Invalid parameter name : $i_name${NORM}"
  fi
  echo
}

function validate_autorun_id ()
{
  if [ -f "$p_conf_file" ]; then
    numids=$(grep -c "^\s*@.*_START\s*$" "$p_conf_file" | sed 's/ //g')  
    is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')

    if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "0" ]]; then
      if [[ $numids -gt "1" ]]; then
        echo
        echo -e "${RED}Multiple autorun schedules exists. Please specify ID with -id option${NORM}"
        usage_daemon;
        echo
        exit 1
      else
        if [[ $is_id_exist -eq "0" ]]; then
          echo
          echo -e "${RED}Please specify ID with -id option${NORM}"
          usage_daemon;
          echo
          exit 1
        fi
      fi
    else
      if [[ $is_id_exist -eq "0" ]]; then
        if [[ -n $setting_conf && $setting_conf -ne "1" ]]; then
          echo
          echo -e "${RED}Autorun schedule does not exist for specified ID[$autorun_id].${NORM}"
          echo
          exit 1
        fi
      fi
    fi
  fi
}

function update_conf_file ()
{
  old_ifs=$IFS
  IFS=";"
  if [[ ! $cmd_line_email -eq 1 ]];then
    validate_autorun_id
  fi
  if [[ -n "$setting_conf" && $setting_conf -eq "1" ]]; then    
    for l_option in $options2set
    do
      o_name=$(echo "$l_option" | cut -d"=" -f1 | sed 's/ //g')
      o_val=$(echo "$l_option" | cut -d"=" -f2 | sed 's/^ *//g' | sed 's/ *$//')
      if [[ $cmd_line_email -eq 1 ]];then
        new_o_val=$(echo "$o_val"|sed 's/,/;/g')
        for o_val in `echo "${new_o_val}"`;
        do
          if [[ -n "$o_name" && -n "$o_val" ]] ; then
            check_p_conf_validity "$o_name"
            if [[ $p_conf_valid -eq "1" ]] ; then
              do_update_conf
            else
              echo
              echo -e "${RED}Invalid parameter name $p_name${NORM}";
              echo
            fi
          else
            echo
            echo -e "${RED}Invalid parameter name${NORM}";
            echo
          fi
        done
      else
        if [[ -n "$o_name" && -n "$o_val" ]] ; then
          check_p_conf_validity "$o_name"
          if [[ $p_conf_valid -eq "1" ]] ; then
            do_update_conf
          else
            echo
            echo -e "${RED}Invalid parameter name $p_name${NORM}";
            echo
          fi
        else
          echo
          echo -e "${RED}Invalid parameter name${NORM}";
          echo
        fi
      fi
    done
  elif [[ -n "$unset_conf" && $unset_conf -eq "1" ]]; then
    if [[ -f "$p_conf_file" || -f .${program_name}_nodaemon.dmp ]] ; then
      echo
    else
      echo
      echo "None of parameters are set"
      echo
      return
    fi
	
    if [[ "$options2unset" = "all" ]]; then
      if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "0" ]]; then
        rm -f $p_conf_file >/dev/null 2>&1;
        rm -f .${program_name}_nodaemon.dmp >/dev/null 2>&1;
        rm -f $RTEMPDIR_D/last_autorun_time >/dev/null 2>&1;
        echo
        echo "Removed all autorun schedules"
        echo
      else
        is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')
        if [[ $is_id_exist -eq "0" ]]; then
          echo
          echo -e "${RED}Autorun schedule does not exist for specified ID[$autorun_id].${NORM}"
          echo
          return
        else
          if [[ $numids -eq "1" ]]; then
            rm -f $p_conf_file >/dev/null 2>&1;
            rm -f $RTEMPDIR_D/last_autorun_time >/dev/null 2>&1;
          else
            sed "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/d" $p_conf_file > $p_conf_file.tmp
            mv -f $p_conf_file.tmp $p_conf_file

	    sed "/^ID=>${autorun_id} - /d" $RTEMPDIR_D/last_autorun_time > $RTEMPDIR_D/last_autorun_time.tmp
            mv -f $RTEMPDIR_D/last_autorun_time.tmp $RTEMPDIR_D/last_autorun_time 
          fi
        fi
        echo
        echo "Removed autorun schedule for ID[${autorun_id}]"
        echo
      fi
    else
      validate_autorun_id
      for l_option in $options2unset
      do
        o_name=$(echo "$l_option"|sed 's/ //g')
        if [[ -n "$o_name" ]] ; then
          check_p_conf_validity "$o_name"
          if [[ $p_conf_valid -eq "1" ]] ; then
            do_update_conf
          else
            echo
            echo -e "${RED}Invalid parameter name $p_name${NORM}";
            echo
          fi
        else
          echo
          echo -e "${RED}Invalid parameter name${NORM}";
          echo
        fi
      done
    fi
  fi
  IFS="$old_ifs"
}

function do_update_conf ()
{
  lc_o_name=$(echo "$o_name"|tr "[A-Z]" "[a-z]")

  if [[ -n "$setting_conf" && $setting_conf -eq "1" ]]
  then
    if [[ -f "$p_conf_file" ]]; then
      is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')
      if [[ $is_id_exist -eq "0" ]]; then
        echo "@${autorun_id}_START" >> "$p_conf_file"
        echo "$lc_o_name=$o_val"    >> "$p_conf_file"  
        echo "@${autorun_id}_END"   >> "$p_conf_file"

        echo
        echo "Created $lc_o_name for ID[${autorun_id}]"
        echo
      else
        is_update=0
        sed -n "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/p" "$p_conf_file" 	> "$p_conf_file.tmp"
	sed "/^@${autorun_id}_END$/d" "$p_conf_file.tmp" 				> "$p_conf_file.tmp.3"

        if [[ `grep -ic "$o_name" $p_conf_file.tmp` -gt "0" ]] ; then
          is_update=1
          if [[ $cmd_line_email -eq 1 ]];then
            email_already_exist=$(grep -c "$o_val" "$p_conf_file")
          fi
          if [[ $cmd_line_email -eq 1 && $email_already_exist -ge 1 ]];then
            echo
          else
	    sed "/^$lc_o_name/d" "$p_conf_file.tmp.3" > "$p_conf_file.tmp.4" 
	    mv -f "$p_conf_file.tmp.4" "$p_conf_file.tmp.3"
          fi
	fi
        if [[ $cmd_line_email -eq 1 ]];then
          email_already_exist=$(grep -c "$o_val" "$p_conf_file")
        fi

        if [[ $cmd_line_email -eq 1 && $email_already_exist -ge 1 ]];then
          echo  
        elif [[ $cmd_line_email -eq 1 ]];then
          echo "@${autorun_id}_START"   >> "$p_conf_file"
          echo "$lc_o_name=$o_val"      >> "$p_conf_file"
          echo "@${autorun_id}_END"     >> "$p_conf_file"
        else  
          echo "$lc_o_name=$o_val"    >> "$p_conf_file.tmp.3"
          echo "@${autorun_id}_END"   >> "$p_conf_file.tmp.3"
          sed "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/d" $p_conf_file > "$p_conf_file.tmp.2"

          cat "$p_conf_file.tmp.2"     > "$p_conf_file"
          cat "$p_conf_file.tmp.3"    >> "$p_conf_file"
        fi    

        rm -f "$p_conf_file.tmp" "$p_conf_file.tmp.2" "$p_conf_file.tmp.3"

        echo
        if [[ $is_update -eq 0 ]]; then
	  echo "Created $lc_o_name for ID[${autorun_id}]"
        else
          if [[ ! $cmd_line_email -eq 1 ]];then
	    echo "Updated $lc_o_name for ID[${autorun_id}]"
          fi
        fi
        echo
      fi
    else
      echo "@${autorun_id}_START"   >> "$p_conf_file"
      echo "$lc_o_name=$o_val"      >> "$p_conf_file"  
      echo "@${autorun_id}_END"     >> "$p_conf_file"

      echo
      echo "Created $lc_o_name for ID[${autorun_id}]"
      echo
    fi

    log_daemon "Updating config - set $lc_o_name for ID[${autorun_id}]"
  elif [[ -n "$unset_conf" && $unset_conf -eq "1" ]]
  then
    sed -n "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/p" "$p_conf_file" > "$p_conf_file.tmp" 
    if [[ -f "$p_conf_file.tmp" && `grep -ic "$o_name" $p_conf_file.tmp` -gt "0" ]] ; then
      perl -i -p -e 's/'$lc_o_name'=.*//gi' "$p_conf_file.tmp"
      perl -i -n -e "print if /\S/" "$p_conf_file.tmp"

      sed "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/d" $p_conf_file > "$p_conf_file.tmp.2"
      cat "$p_conf_file.tmp.2"	>  $p_conf_file
      cat "$p_conf_file.tmp" 	>> $p_conf_file
      rm -f "$p_conf_file.tmp" "$p_conf_file.tmp.2"

      echo
      echo "Removed $lc_o_name for ID[${autorun_id}]"
      echo

      log_daemon "Updating config - unset $lc_o_name for ID[${autorun_id}]"
    else
      echo
      echo -e "${RED}$lc_o_name was not set for ID[${autorun_id}].${NORM}";
      echo
    fi
  fi
}

function read_conf ()
{
  if [ ! -f "$p_conf_file" ] ; then
    p_conf_value=""
    return
  fi
  p_conf_value=$(grep -i "$1=" $p_conf_file | cut -d"=" -f2)
	
  if [[ `echo "$p_conf_value"| grep -c '^[0-9]*$'` -gt "0" && `echo "$1"|grep -icw "AUTORUN_INTERVAL"` -gt "0" ]] ; then
    p_conf_value=$(expr $p_conf_value \* 24)
  fi

  if [[ `echo "$p_conf_value"| grep -ic '^[0-9]*d$'` -gt "0" ]] ; then
    p_conf_num=$(echo "$p_conf_value"| sed 's/d$//');
    p_conf_num=$(echo "$p_conf_num"| sed 's/D$//');
    p_conf_value=$(expr $p_conf_num \* 24)
  elif [[ `echo "$p_conf_value"| grep -ic '^[0-9]*h$'` -gt "0" ]] ; then
    p_conf_value=$(echo "$p_conf_value"| sed 's/h$//');
    p_conf_value=$(echo "$p_conf_value"| sed 's/H$//');
  fi
}

mail_server_running=0
function check_if_mail_exists ()
{
  t_attachment=$1
  mail_cmd=$(which mailx 2>/dev/null);
  if [ -z "$mail_cmd" ] ; then mail_cmd=$(which mail 2>/dev/null); fi
  if [ -n "$mail_cmd" ] ; then mail_server_running=1; fi

  if [[ -n "$t_attachment" && $t_attachment -eq "1" ]]; then mail_server_running=1; fi
}

#Function to validate email address. it return 1 if the email address is valid and 0 otherwise
function validate_email ()
{
  e_mail_id="$1"
  OLDIFS=$IFS;
  IFS="@"
  set -- $e_mail_id
  if [ "${#@}" -ne 2 ];then
    valid_email_flag=0;
    return $valid_email_flag;
  fi
  IFS=$OLDIFS;

  if [[ $e_mail_id == *..* || $e_mail_id == *. || $e_mail_id == .* || $e_mail_id == *- ]];then
    valid_email_flag=0;
  elif [[ "$e_mail_id" == *['('')''<''>''['']'','';'':''\\']* ]]; then
    valid_email_flag=0;
  else
    valid_email_flag=1;
  fi

  return $valid_email_flag;
}

function send_email_with_attachment ()
{
  which mailx >/dev/null 2>&1 
  if [ `echo $?` -eq 0 ]
  then
    echo "$matter" > $TMPDIR/mail.out

    log_daemon "Sending Email with attachment to [ $remail ] using [ mailx ]."

    if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
    then
      mailx -s "$subject" -a "$html_report" $remail < $TMPDIR/mail.out >/dev/null 2>&1;
      mail_status=`echo $?`
    else
      mailx -s "$subject" -a "$prev_report" -a "$html_report" -a "$diff_report" $remail < $TMPDIR/mail.out >/dev/null 2>&1;
      mail_status=`echo $?`
    fi

    rm -rf $TMPDIR/mail.out >/dev/null 2>&1;
  else
    which mutt >/dev/null 2>&1
    if [ `echo $?` -eq 0 ]
    then
      echo "$matter" > $TMPDIR/mail.out

      log_daemon "Sending Email with attachment to [ $remail ] using [ mutt ]."

      if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
      then
        mutt -s "$subject" -a "$html_report" -- $remail < $TMPDIR/mail.out >/dev/null 2>&1;
	mail_status=`echo $?`
      else
        mutt -s "$subject" -a "$prev_report" -a "$html_report" -a "$diff_report" -- $remail < $TMPDIR/mail.out >/dev/null 2>&1;
	mail_status=`echo $?`
      fi
       
      rm -rf $TMPDIR/mail.out >/dev/null 2>&1;
    else
      which sendmail >/dev/null 2>&1
      if [ `echo $?` -eq 0 ]
      then
        log_daemon "Sending Email with attachment to [ $remail ] using [ sendmail ]."

	from=""
	to="$remail"
	subject="$subject"
	boundary="ZZ_/afg6432dfgkl.94531q"
	body="$matter"
	declare -a attachments
 
        if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
        then
	  attachments=( "$html_report" )
        else
	  attachments=( "$prev_report" "$html_report" "$diff_report" )
        fi
{
	printf '%s\n' "From: $from
To: $to
Subject: $subject
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary=\"$boundary\"

--${boundary}

$body
"
	for file in "${attachments[@]}"; do
          if [ -z "$file" ]; then continue; fi

	  [ ! -f "$file" ] && echo "Warning: attachment $file not found, skipping" >&2 && continue
  	  mimetype=$(file --mime "$file"|cut -d: -f2|cut -d\; -f2|sed 's/ //g') 

	  printf '%s\n' "--${boundary}
Content-Type: $mimetype
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=\"$file\"
"
	  base64 "$file"
	  echo
	done
	printf '%s\n' "--${boundary}--"
} | sendmail -t -oi
	mail_status=`echo $?`
      else
        log_daemon "Sending Email without attachment to [ $remail ] using [ $mail_cmd ]. Configure email client for sending attachments."

        echo "$matter" | $mail_cmd -s "$subject" $remail
	mail_status=`echo $?`
      fi
    fi
  fi

  if [[ -n $mail_status && $mail_status -eq 0 ]]; then
    if [[ $test_email_config -eq 1 ]];then
      echo -e "\nTest mail successfully sent to $remail from $HOSTNAME\n\n"
    else
      log_daemon "Email successfully sent."
    fi
  else
    if [[ $test_email_config -eq 1 ]];then
      echo -e "\nSending test mail failed to $remail from $HOSTNAME\n\n"
    else
      log_daemon "Email sending failed."
    fi
  fi

}

#Use: send_email "subject" "body" "attachment(0|1)" "recipients(all| value for current_run)"
function send_email ()
{
  subject="$1"
  matter="$2"
  attachment="$3"
  recipients="$4"

  check_if_mail_exists "$attachment"

  if [[ ! -z $recipients && $recipients = "all" ]]; then
    if [[ ! $autorun -eq "1" ]];then
      if [[ ! ($test_email_config -eq 1 || $cm_upgrade_status -eq 1)]];then
        p_conf_file=".${program_name}_nodaemon.dmp"
      fi
    fi
    if [[ -f "$p_conf_file" && `grep -ic "NOTIFICATION_EMAIL" $p_conf_file` -gt "0" ]] ; then
      for emails in `grep -i "NOTIFICATION_EMAIL" "$p_conf_file"`
      do
        all_emails=$all_emails","$(echo "$emails" | cut -d"=" -f2);
      done 
      #following code is used so we have unique email ids which are coming from config file
      all_emails=$(echo "$all_emails"|$AWK 'BEGIN{RS=","}{print $0}'|sort|uniq)
      all_emails=$(echo "$all_emails"|tr '\n' ',')  
      remail=$(echo "$all_emails"|sed 's/^,//'|sed 's/,$//')
      if [[ ! $autorun -eq "1" ]];then
        if [[ $cmd_line_email -eq 1 ]];then   
          remail=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-sendemail") print $(i+1)}')
          remail=$(echo "$remail" | $AWK -F"=" '{print $2}' | awk '{print $1}')
        elif [[ $cmd_line_email -eq 2 ]];then
          remail=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-testemail") print $(i+1)}')
          remail=$(echo "$remail" | $AWK -F"=" '{print $2}' | awk '{print $1}')
        fi
      fi
    elif [[ $cmd_line_email -eq 2 && -z $remail ]];then
      remail=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-testemail") print $(i+1)}')
      remail=$(echo "$remail" | $AWK -F"=" '{print $2}' | awk '{print $1}')
    else
      if [[ $autorun -eq "1" ]];then
        echo 
        echo -e "${RED}Email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications.${NORM}"
        log_daemon "Failed to send email as email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications."
        echo
      elif [[ $test_email_config -eq 1 && $(echo $command_arguments|grep -ic "all") -eq 1 ]];then
        echo -e "\n\n${RED}Email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications.${NORM}\n\n"
      fi
      return
    fi
  else
    swap_p_conf_file "$cur_p_conf_file"

    if [[ -f "$p_conf_file" && `grep -ic "NOTIFICATION_EMAIL" $p_conf_file` -gt "0" ]] ; then
      echo >/dev/null
    else
      if [[ $autorun -eq "1" ]];then
        echo 
        echo -e "${RED}Email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications.${NORM}"
        log_daemon "Failed to send email as email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications."
        echo
      else
        echo -e "${RED}Email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications.${NORM}" >> $LOGFIL
      fi
      return
    fi
    read_conf "NOTIFICATION_EMAIL"
    remail=$p_conf_value
  fi

  if [[ -n "$mail_server_running" && $mail_server_running -eq "1" ]] ; then
    if [[ -e "$RTEMPDIR_D/.cells.txt" && -z $use_dbserver_mail ]] ; then
      send_mail_using_cell
    else
      if [[ -n "$attachment" && "$attachment" -eq "1" ]]
      then
	send_email_with_attachment
      else
	log_daemon "Sending Email without attachment to [ $remail ] using [ $mail_cmd ]."
        echo "$matter" | $mail_cmd -s "$subject" $remail
	
 	if [ `echo $?` -eq 0 ]; then
          if [[ $test_email_config -eq 1 ]];then
            echo -e "\nTest mail successfully sent to $remail from $HOSTNAME\n\n"
          else
            log_daemon "Email successfully sent."
          fi
	else
          if [[ $test_email_config -eq 1 ]];then
            echo -e "\nSending test mail failed to $remail from $HOSTNAME\n\n"
          else
            log_daemon "Email sending failed."
          fi
	fi	
      fi
    fi
  fi
}

function add_to_skipped_nodes ()
{
  skipped_host=$1
  skipped_reason=$2
  if [[ -e "$OUTPUTDIR/${program_name}_skipped_nodes.log" && `grep -iwc "$skipped_host" $OUTPUTDIR/${program_name}_skipped_nodes.log` -gt "0" ]] ; then
    return; # The node is already in skipped host list
  fi

  if [ ! -e "$OUTPUTDIR/${program_name}_skipped_nodes.log" ] ; then
    echo "<table summary=\"Summary of skipped nodes\"><tr><th scope=\"col\">Host Name</th><th>Reason</th></tr>" > $OUTPUTDIR/${program_name}_skipped_nodes.log
  fi
  echo "<tr><td scope=\"row\">$skipped_host</td><td scope=\"row\">$skipped_reason</td></tr>" >> $OUTPUTDIR/${program_name}_skipped_nodes.log
  echo "$skipped_host" >> $OUTPUTDIR/${program_name}_skipped_nodes_txt.log
}

# Global variables for System Health Score for a cluster
# System Health Score will be a number b/w 0 - 100
# At the top of report print the score
# The logic used is (From Giri)
# Every check has 10 points
# If check status = FAIL reduce 10 points
#                   WARN reduce 5 points
#                   INFO reduce 3 points
# The total checks = checks in log_pass + checks in log_fail
# Also total check is count of all checks executed on all nodes, means,
# if same check is executed on two nodes, add 2 to total
G_TOTAL_CHECKS=0
G_FAIL_CHECKS=0
G_WARN_CHECKS=0
G_INFO_CHECKS=0
G_INFO_CHECKS_SCORE=0
G_SKIP_CHECKS=0
# Heath score is
# ((G_TOTAL_CHECKS*10)-(G_FAIL_CHECKS*10+G_WARN_CHECKS*5+G_INFO_CHECKS*3+G_SKIP_CHECKS*3))/(G_TOTAL_CHECKS*10)

# Added by gadiga for creating html reports
# After writing failed message to corresponding .rep file, 
# write the message to <checkid>.html. If the file exists already, just 
# concatinate the .out file contents. Create <a name=<checkid>_details> anchor.
# Also create "Top" link, which will jump back to the message in summary table with 
# name <checkid>_summary. All <checkid>.html files are concatinated later to 
# create raccheck.html file

g_cch_cnt=0                 # check id count
g_cid=0                     # index for a check id
g_type=""                   # Type of check
g_hosts=""                  # Host names where check failed
declare -a G_CHECKIDS       # All failed check ids
declare -a G_CHECKID_INFO   # Collection name
declare -a G_CHECKID_TYPE   # Check Type
declare -a G_CHECKID_STATUS   # Status Pass failed etc
declare -a G_CHECKID_MAA_SF
declare -a G_CHECKID_HOSTS    # Host names
declare -a G_CHECKID_HOSTS_PASSED    # Host names
declare -a G_CHECKID_ALLHOSTS # Host names
CID_HTML_REPFILE=""         # checkid file
G_SOURCEFIL_REPORT=""       # Saved SOURCEFIL_REPORT
G_SOURCEFIL_REPORT_NEW=""   # Saved SOURCEFIL_REPORT_NEW
G_LINKS=""                  # Saved links finormation
CREATE_HTML_REPORT=1        # Set to zero to disable html reporting
TOOL_NAME="raccheck"        # Tool name to display. Changed later based on program name.
G_OUT_LINES=20               # Number of lines to display from .out file. default 20
G_HOST_CNT=5                # Number of host/db names to display in summary table. Default 5
                            # To change G_HOST_CNT, update the number in function get_host_string_html (In cut command)
# Below variables track the summary counts
G_TOTAL_CHECKS=0           
G_PASS_CNT=0           
G_WARNING_CNT=0           
G_ERROR_CNT=0           
G_FAIL_CNT=0           
G_INFO_CNT=0           

g_tr_index=0 # Index for deletebutton

G_SFS_TO_IGNORE[0]='GENERIC OS DATA COLLECTIONS';
G_SFS_TO_IGNORE[1]='OVM GUEST AUDIT CHECKS';
G_SFS_TO_IGNORE[2]='ARCHIVED AUDIT CHECKS';
G_SFS_TO_IGNORE[3]='DBMACHINE X2-2, X2-8 GENERIC AUDIT CHECKS'
G_SFS_TO_IGNORE[4]='DBMACHINE X2-2 AND X2-8 AUDIT CHECKS'
G_SFS_TO_IGNORE[5]='SQL DATA COLLECTIONS AND CHECKS'
G_SFS_TO_IGNORE[6]='GENERIC ORACLE PRE-UPGRADE AND POST-UPGRADE COLLECTIONS AND AUDIT CHECKS'
G_SFS_TO_IGNORE[7]='SFRAC'
G_SFS_TO_IGNORE[8]='OVM SERVER AUDIT CHECKS'
G_SFS_TO_IGNORE[9]='HA CHECKS'
G_SFS_TO_IGNORE[10]='SOLARIS DATA COLLECTIONS'
G_SFS_TO_IGNORE[11]='EXALOGIC AUDIT CHECKS'
G_SFS_TO_IGNORE[12]='LINUX RPM AUDIT CHECKS'
G_SFS_TO_IGNORE[13]='ACFS- OS COLLECTIONS AND OS CHECKS'
G_SFS_TO_IGNORE[14]='ORACLE DATABASE APPLIANCE (ODA)'
G_SFS_TO_IGNORE[15]='LINUX DATA COLLECTIONS AND AUDIT CHECKS'
G_SFS_TO_IGNORE[16]='HP-UX DATA COLLECTIONS'
G_SFS_TO_IGNORE[17]='AIX DATA COLLECTIONS'
G_SFS_TO_IGNORE[18]='AIX OS PACKAGES AND PATCHES'
G_SFS_TO_IGNORE[19]='SOLARIS OS PACKAGES AND PATCHES'
G_SFS_TO_IGNORE[20]='EXALYTICS AUDIT CHECKS'
G_SFS2INGORE=21
#--

ignore_sf_name=0
set_ignore_sf_name ()
{
  l_sf_counter=0
  while [[ $l_sf_counter -lt $G_SFS2INGORE ]] ; do
    l_sfname=${G_SFS_TO_IGNORE[$l_sf_counter]}
    if [[ $SF = $l_sfname ]] ; then
      ignore_sf_name=1
      return;
    else
      ignore_sf_name=0
    fi
    l_sf_counter=$(expr $l_sf_counter + 1)
  done
}

# Identifies the check type. Logic copied from generate_result_xml
# Output
#     $g_type : Check type
#     $g_hosts: machine/db/switch names
get_check_type ()
{
  g_type=""
  g_hosts=""
  g_hosts_passed="" # On cell no new message for passed checked

  if [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
  then
    cwc_failed=0
    if [[ "$cell_outcheck_type" = "cwc" ]]
    then # failed on one node = failed on all nodes
      cellname_counter=0
      for cellname in ${a_cellname[@]}
      do
        if [[ ${a_cellCheckStatus[$cellname_counter]} != "PASS" ]]
        then
          cwc_failed=1
        fi
        cellname_counter=$(expr $cellname_counter + 1 )
      done
    fi

    g_type="Storage Server Check"
    cellname_counter=0
    for cellname in ${a_cellname[@]}
    do
      cell_status=${a_cellCheckStatus[$cellname_counter]}
      if [[ "$cell_outcheck_type" = "cwc" && $cwc_failed = "1" ]]
      then
        cell_status="FAIL"
      fi

      if [[ $cell_status != "PASS" ]]
      then
        if [[ `echo $g_hosts | grep -ic $cellname` -eq 0 ]] ; then
          g_hosts="$cellname, $g_hosts"
        fi
        # Storage server check status is stored in a array. 
        # For PASS, a new message is not created
      else
        if [[ `echo $g_hosts_passed | grep -ic $cellname` -eq 0 ]] ; then
          g_hosts_passed="$cellname, $g_hosts_passed"
        fi
      fi
      update_check_status "$cell_status" $cch_check_id
      cellname_counter=$(expr $cellname_counter + 1 )
    done
    g_hosts_saved=$g_hosts
    g_hosts=$(echo $g_hosts_saved | sed 's/,$//')
    g_hosts_saved=$g_hosts_passed
    g_hosts_passed=$(echo $g_hosts_saved | sed 's/,$//')
  elif [[ $NEEDS_RUNNING = "RDBMS" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    g_type="TimesTen Database Check"
    g_hosts="$i:$db_name_to_check"	
  elif [[ $PARAM = "TIMESTEN" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    g_type="TimesTen Installation Check"
    g_hosts="$i:$mb_db_homes"	
  elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
  then
    g_type="Switch Check"
    g_hosts="$switchname"
  elif [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
  then
    g_type="OS Check"
    g_hosts="$i"
  elif [[ $COMTYPE = "OS" ]] || [[ $COMTYPE = "IDMHC_CHECK" ]]
  then
    if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
    then
      g_type="Database Check"
      g_hosts="$i:$db_name_to_check"
    elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]
    then
      g_type="ORACLE_HOME Check"
      if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
      then
      	g_type="OBIEE_HOME Check"
	if [[ `echo $audit_check_name|grep -iEc "^OBIEE configuration"` -ge 1 ]]
        then
          g_type="OBIEE configuration for TimesTen"
        fi
      fi
      g_hosts=" $i:$mb_db_homes"
    elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "BI_INSTANCE" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]
    then
      g_type="BI_INSTANCE Check"
      g_hosts=" $i:$mb_db_homes:$bi_instance"
    elif [[ "$NEEDS_RUNNING" = "ASM" ]]
    then
      g_type="ASM Check"
      g_hosts="$i"
    elif [[ "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
    then
      g_type="Storage Server Check"
      g_hosts="$cellname"
    elif [[ "$NEEDS_RUNNING" = "ZFS" ]]
    then
      g_type="ZFS Storage Appliance Check"
      g_hosts="$cellname"
    elif [[ "$NEEDS_RUNNING" = "EXTERNAL_ZFS" ]]
    then
      g_type="External ZFS Storage Appliance Check"
      g_hosts="$cellname"
    elif [[ "$NEEDS_RUNNING" = "TOR_SWITCH" ]]
    then
      g_type="OCM Ethernet Switch Check"
      g_hosts="$cellname"
    elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" && -n "$NEEDS_RUNNING" && $NEEDS_RUNNING != "UNSPECIFIED" ]]
    then
      g_type="$NEEDS_RUNNING Check"
      g_hosts="$i"
    else
      g_type="OS Check"
      g_hosts="$i"
      if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 && "$PARAM" = "RDBMS" ]]
      then
	g_type="OBIEE_HOME Check"	
	if [[ `echo $audit_check_name|grep -iEc "^OBIEE configuration"` -ge 1 ]]
        then
          g_type="OBIEE configuration for TimesTen"
        fi
        g_hosts="$i:$mb_db_homes"
      fi
    fi
  elif [[ $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]]
  then
    g_type="SQL Check"
    g_hosts="$db_name_to_check"
  elif [[ $COMTYPE = "SQL_PARAM" ]]
  then
    g_type="SQL Parameter Check"
    g_hosts="$inst_name"
  elif [[ $COMTYPE = "CLUSTERWIDE_CHECK" || $COMTYPE = "CROSS_NODE_CHECK" ]]
  then
    g_type="$html_rack_type Wide Check"
    g_hosts="$html_rack_type Wide"
  elif [ $COMTYPE = "SYSTEMWIDE_CHECK" ]
  then
    g_type="System Wide Check"
    g_hosts="System Wide"
  elif [ $COMTYPE = "ORACLE_PATCH" ] && [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" || $HOME_PATH = "RDBMS" ]]
  then
    g_type="Patch Check"
    if [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" ]]
    then
      g_hosts="$i:$message4Home"
    elif [ $HOME_PATH = "RDBMS" ]
    then
      g_hosts="$i:$mb_db_homes"
    fi
  elif [ $COMTYPE = "ORACLE_PATCH" ] 
  then
    g_type="Patch Check"
    g_hosts="$i"
  else
    echo "Could not find the check type/target"
    g_type="Unknown"
    g_hosts="Unknown"
  fi
}

# Array G_CHECKIDS holds all check id's, one entry for each status
# Key is check_id and status
# This function will insert a check id into the array if does not exists
# Input:
#   Status
#   Check id
# Output:
#   $g_cid : Index number in array for the i/p check id
get_check_id_number ()
{
  gci_index=0;
  g_cid=-1;
  gci_cid="A${2}_$1"
  if [ -z $(eval echo \${$gci_cid}) ]
  then # First time
  #while [ $gci_index -lt $g_cch_cnt ]
  #do
  #  chk_status=$(echo ${G_CHECKID_STATUS[$gci_index]} | awk -F":" '{print $1}')
  #  if [[ "${G_CHECKIDS[$gci_index]}" = "$2" && $chk_status = "$1" ]]
  #  then # Already there
  #    g_cid=$gci_index;
  #    break;
  #  fi
  #  let gci_index=$gci_index+1
  #done

  #if [ $g_cid -eq -1 ] 
  #then # Assign a new id
    eval $gci_cid=$g_cch_cnt
    g_cid=$g_cch_cnt
    G_CHECKIDS[$g_cid]=$2
    let g_cch_cnt=$g_cch_cnt+1
  else
    g_cid=$(eval echo \${$gci_cid});
  fi
}

# Find the right check_id and initialize variable $cch_check_id
# Output:
#   $cch_check_id
get_check_id ()
{
  if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  then 
    cch_check_id=${crs_check_id[$crs_check_file_counter]}
  else
    cch_check_id=$CHECK_ID
  fi
}

# This function will create a variable by name <checkid> using eval and assigns below values
# = 1 if the status is PASS
# = -1 if the status is FAIL
# = 2 if the status has both pass and fail
update_check_status ()
{
  ucs_status=$1
  ucs_cid="A$2" # Variable names can't start with number. So append dummy letter A

  if [ -z $(eval echo \${$ucs_cid}) ]
  then # First time
    #let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1 # unique check count
    if [ $ucs_status = "PASS" ] 
    then
      eval $ucs_cid=1
    else
      eval $ucs_cid=-1
    fi
  else # We have results for the check from another host/db
    ucs_current=$(eval echo \${$ucs_cid}) # Status from previous host/db
    if [[ $ucs_current -eq "1" && $ucs_status != "PASS" ]]
    then # Passed in earlier hosts, failed in the new host
      eval $ucs_cid=2
    elif [[ $ucs_current -eq "-1" && $ucs_status = "PASS" ]]
    then # Failed in earlier hosts, passed in the new host
      eval $ucs_cid=2
    fi
  fi
  
}

# for PASS messages log_pass does not initialize ONFAIL and LINK variable
# This function does that
write_additional_info ()
{
  #ALVL="PASS"
  if [[ -n "$NO_WRITE_PASS" && $NO_WRITE_PASS -eq 1 ]]; then return; fi;
  alvl_value="PASS"
  if [ -n "$1" ] ; then alvl_value="$1"; fi
  if [ $COMTYPE != "OS_PACKAGE-DISABLED" ]
  then
    #grab the details from the appendix
    LINKNUM=0
    LINK=
    if [ $op_mode -eq 0 ]
    then
      LINKNUM=`grep -c _$ROW-LINK $REFFIL1`
      BEGPAT="_$ROW-BEGIN_COMMENTS"
      ENDPAT="_$ROW-END_COMMENTS"
    else
      if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
      then 
        CHECK_ID=${crs_check_id[$crs_check_file_counter]}
      fi 
      LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
      BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
      ENDPAT="_$CHECK_ID-END_COMMENTS"
    fi
    ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
    PLA_LINE=`grep "_"$CHECK_ID"-PLA_LINE"" " $REFFIL1 | sed -n 's/.*-PLA_LINE//p' | sed 's/^\s*//g' | sed 's/\s*$//g'`

    #Added this line to add pass/fail message as rational if its ORACLE_PATH and ratinoal is empty
    if [[ "$COMTYPE" = "ORACLE_PATCH" && `echo $ONFAIL|sed '/^$/d'|wc -l` -eq 0 ]];then ONFAIL=$PMSG;fi
    if [ $LINKNUM -gt 0 ]
    then
      #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
      for ((j=1;j<=$LINKNUM;j+=1));
      do
        #echo "j=$j, ROW=$ROW" >>$REPFIL
        if [ $op_mode -eq 0 ]
        then
          LINK=`grep "_"$ROW"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
        else
          LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
        fi
        if [ $CREATE_HTML_REPORT -eq 1 ]
        then
          append_links_html "$alvl_value"
        fi
      done
    fi

    if [ $CREATE_HTML_REPORT -eq 1 ]
    then # gadiga - for html reports
      create_checkid_html "$alvl_value"
      write_output_to_html "$alvl_value"
    fi
  else
    if [ $CREATE_HTML_REPORT -eq 1 ]
    then  # gadiga - for html reports
      write_output_to_html "$alvl_value"
    fi
  fi # end if not to print in report file for OS_PACAKGE
}

# Info related to a check are stored in different arrays using the same index
# which is used in checkid array G_CHECKIDS
# Output:
#   Global arrays which hold the info on each check
init_arrays_html ()
{
  NO_WRITE_PASS=0
  cch_check_id=""

  G_SOURCEFIL_REPORT=
  G_SOURCEFIL_REPORT_NEW=

  get_check_id
  if [[ $1 = "PASS" ]]
  then
    if [[ -n "$ORIG_PMSG" && `echo "$PMSG" | grep -ic "$ORIG_PMSG"` -ge 1 ]]
    then # ORIG_PMSG has message without db names
      cch_cname="$ORIG_PMSG"
    else
      cch_cname="$PMSG"
    fi
    if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then 
      cch_status="PASS"
      return; 
    fi

    if [[ -n "$skip_maa_scorecard" && $skip_maa_scorecard -eq 0  ]]; then
      if [[ `echo $cch_cname|grep -ic "System is not exposed"` -ge 1 && -z "$RAT_SHOW_CRITICAL_INTERNAL" ]]; then
	NO_WRITE_PASS=1;
	cch_status="PASS"
	return;
      fi
    fi
	  
    get_check_id_number "PASS" $cch_check_id
    update_check_status "PASS" $cch_check_id
    cch_status="PASS"
  else # FAIL 
    get_check_id_number "$ALVL" $cch_check_id
    update_check_status "FAIL" $cch_check_id
    if [[ -n "$ORIG_FMSG" && `echo "$FMSG" | grep -ic "$ORIG_FMSG"` -ge 1 ]]
    then # ORIG_FMSG has message without db names
      cch_cname="$ORIG_FMSG"
    else
      cch_cname="$FMSG"
    fi
    cch_status="$ALVL"
  fi
  get_check_type

  if [ -n "$MERGEFILES" ];
  then
    components=$(grep -i "COMPONENTS" $NEW_MASTERFIL1|head -1|cut -d"=" -f2|sed 's/ //g');	
    #if [[ `grep -i "COMPONENTS" $NEW_MASTERFIL1|grep -ic ':MAA'` -gt 0 ]]; then components=$components:MAA; fi
  fi

  if [[ -n "$skip_maa_scorecard" && $skip_maa_scorecard -eq 0  ]]; then
    if [[ `echo $check_components|grep -ic "MAA"` -ge 1 && `echo $components|grep -ic "MAA"` -ge 1 ]]
    then
      G_CHECKID_MAA_SF[$g_cid]=$SF
      if [[ $is_exadata_dom0_machine -eq "1" || $is_ssc_globalzone_machine -eq 1 ]] && [ "$SF" != "SOFTWARE MAINTENANCE BEST PRACTICES" ]; then G_CHECKID_MAA_SF[$g_cid]=""; fi
    elif [[ `echo $check_components|grep -ic "MAA"` -ge 1 ]] && [[ $is_exadata_dom0_machine -eq "1" || $is_ssc_globalzone_machine -eq 1 ]]
    then
       G_CHECKID_MAA_SF[$g_cid]=$SF
       if [ "$SF" != "SOFTWARE MAINTENANCE BEST PRACTICES" ]; then G_CHECKID_MAA_SF[$g_cid]=""; fi
    elif [[ `echo $cch_cname|grep -ic "System is not exposed"` -ge 1  || `echo $cch_cname|grep -ic "System is exposed"` -ge 1 || `echo $cch_cname|grep -ic "DB01-DB04"` -ge 1 || `echo $cch_cname|grep -ic "System may be exposed"` -ge 1 ]]
    then
      if [[ -n "$maa_scorecard" && $maa_scorecard -eq 0 ]] ; then
        G_CHECKID_MAA_SF[$g_cid]=""
      else
        if [[ $cch_status = "PASS" && -z "$RAT_SHOW_CRITICAL_INTERNAL" ]]
	then
	  NO_WRITE_PASS=1;
	  G_CHECKID_MAA_SF[$g_cid]=""
	else 
	  G_CHECKID_MAA_SF[$g_cid]='SOFTWARE MAINTENANCE BEST PRACTICES'
	fi
      fi
    else
      G_CHECKID_MAA_SF[$g_cid]=""
    fi
  else
    G_CHECKID_MAA_SF[$g_cid]=""
  fi

  CID_HTML_REPFILE="$OUTPUTDIR/$cch_check_id.html"
  #G_CHECKIDS[$g_cch_cnt]=$cch_check_id
  G_CHECKID_INFO[$g_cid]="${cch_cname}"
  G_CHECKID_TYPE[$g_cid]="$g_type"
  G_CHECKID_STATUS[$g_cid]="$cch_status:$1" # Some INFO can be PASS.. So we store INFO:PASS

  # Append host names for each each
  if [ -z "${G_CHECKID_HOSTS[$g_cid]}" ]
  then
    G_CHECKID_HOSTS[$g_cid]="$g_hosts"
  else
    G_CHECKID_HOSTS[$g_cid]="${G_CHECKID_HOSTS[$g_cid]}, $g_hosts";
  fi

  # Append host names for each each
  if [ -z "${G_CHECKID_HOSTS_PASSED[$g_cid]}" ]
  then
    G_CHECKID_HOSTS_PASSED[$g_cid]="$g_hosts_passed"
  else
    G_CHECKID_HOSTS_PASSED[$g_cid]="${G_CHECKID_HOSTS_PASSED[$g_cid]}, $g_hosts_passed";
  fi

  # Save for use in write_output_to_html. These varibales are unset before we call function
  G_SOURCEFIL_REPORT="$SOURCEFIL_REPORT"
  G_SOURCEFIL_REPORT_NEW="$SOURCEFIL_REPORT_NEW"
}

set_cch_check_name ()
{
  if [[ $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" || $COMTYPE = "SQL_PARAM" ]]
  then
    if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
    cch_check_name="Check for parameter $p_name"
  elif [[ $COMTYPE = "ORACLE_PATCH" ]]
  then
    if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
    cch_check_name="Check ORACLE_PATCH $p_name for $HOME_PATH home"
  else
    cch_check_name=$(echo $audit_check_name|sed 's/\[DBMV2]//g')
  fi
}

# Additional details on a check are stored in a <checkid>.html as discussed before.
# The information needs to be written only once for each check.
# Output:
#   <checkid>.html  - temporary files.. deleted after creating raccheck.html
create_checkid_html ()
{
  if [[ $1 = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi
  if [ ! -e "$CID_HTML_REPFILE" ]
  then
    set_ignore_sf_name;
    if [[ $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" || $COMTYPE = "SQL_PARAM" ]]
    then
      if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
      cch_check_name="Check for parameter $p_name"
    elif [[ $COMTYPE = "ORACLE_PATCH" ]]
    then
      if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
      cch_check_name="Check ORACLE_PATCH $p_name for $HOME_PATH home"
    else
      cch_check_name=$(echo $audit_check_name|sed 's/\[DBMV2]//g')
    fi

    #echo "<hr>" >> $CID_HTML_REPFILE
    echo "<a name=\"${cch_check_id}_details\"></a>" >> $CID_HTML_REPFILE
    #echo "<a href=\"#${cch_check_id}_summary\" class=\"a_bgw\">Top</a><br>" >> $CID_HTML_REPFILE
    echo "<h3 align=\"center\" style=\"background:#F2F5F7\">${cch_check_name}</h3>" >> $CID_HTML_REPFILE
    echo "<table border="0" width=800 summary="Summary of audit check and SF" role="presentation">" >> $CID_HTML_REPFILE
    if [[ $ignore_sf_name -eq "0" ]] ; then
      echo "<tr ><td>Success Factor</td><td>${SF}</td></tr>" >> $CID_HTML_REPFILE
    fi
    #cch_onfail=$(echo $ONFAIL | sed 's/</&lt;/g' | sed 's/>/&gt;/g' | sed 's/ /&nbsp;/g' | sed 's/\n/<br>/g')
    cch_onfail=$(echo "$ONFAIL" | sed 's/</\&lt;/g' | sed 's/>/\&gt;/g' | sed 's/\n/<br>/g' )
    cch_onfail="<pre>$cch_onfail</pre>";
    echo "<tr><td scope=\"row\">Recommendation</td><td scope=\"row\">$cch_onfail</td></tr>" >> $CID_HTML_REPFILE
    # Write links and close table.
    if [ ! -z "$G_LINKS" ] ; then
      echo "<tr><td scope=\"row\">Links</td><td scope=\"row\"><ol>$G_LINKS</ol></td></tr>" >> $CID_HTML_REPFILE
    fi;
    # At this point we don't know all hosts where check was run. So just create a placeholder
    # which is replaced with actual host names before writing rachcheck.html
    echo "<tr><td scope=\"row\"><a name=\"${cch_check_id}_machines\"></a>Needs attention on</td><td scope=\"row\">PLACEHOLDER_TO_REPLACE_FAIL</td></tr>" >> $CID_HTML_REPFILE
    echo "<tr><td scope=\"row\"></a>Passed on</td><td>PLACEHOLDER_TO_REPLACE_PASS</td></tr>" >> $CID_HTML_REPFILE
    echo "</table>" >> $CID_HTML_REPFILE

    generate_recommendations_xml "${cch_check_id}" "$cch_onfail" "$G_LINKS"
  fi
  unset G_LINKS
}

show_file ()
{
  sfh_id=$(echo $G_SOURCEFIL_REPORT | awk -F"/" '{print $NF}' | sed 's/\./_/g')
  sfh_hosts="$g_hosts"
  sfh_suffix="$cch_check_id"

  if [[ -n "$parse_passed_list" && $parse_passed_list -eq "1" ]]
  then
    sfh_hosts="$g_hosts_passed"
    sfh_suffix=$cch_check_id"_passed"
  fi

  sfh_suffix=$RANDOM
  echo "<a name=\"${sfh_id}_more_text${sfh_suffix}_a\"></a>" >> $CID_HTML_REPFILE

  echo "<div id=\"${sfh_id}_more_text${sfh_suffix}\" class='scrollc'>" >> $CID_HTML_REPFILE
  old_IFS=$IFS
  IFS=$'\n'

  sed 's/<!-- HTML OUTPUT -->//' ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
  sed 's/<!-- HTML OUTPUT -->//' ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE.rawout

  IFS=$old_IFS
  echo "</div>" >> $CID_HTML_REPFILE
  echo "</div><a id=\"${sfh_id}_more_text${sfh_suffix}_mh\" class=more_less_style onclick=\"javascript:ExpandContract('${sfh_id}_more_text$sfh_suffix')\" href=\"javascript:;\" >Click for more data</a>" >> $CID_HTML_REPFILE
}

# Show the contents of .out file.
# If the file has more than $G_OUT_LINES (default 20) lines (excluding blank lines), 
#  show a more link and truncate rest of contents
# div id for hidden region will be <filename>_more_text
# id for more/hide link is <filename>_more_text_mh
# In file name replace "." with "_"

show_file_in_html_perl ()
{
    perl_exe=$(which perl| tr -d '\r');
    $perl_exe - -f "$G_SOURCEFIL_REPORT" -o "$CID_HTML_REPFILE" -c "$sfh_rcnt" -i "$sfh_id" -x "$sfh_suffix" -h "$sfh_hosts" -w "$wh_hosts" -l "$G_OUT_LINES" -n "$woh_line_cnt" <<PERLEOF
	use strict;
	use warnings;
	
	use Getopt::Long;
	
	my (\$SOURCEFILE);
	my (\$SFH_RCNT);
	my (\$SFH_HOSTS);
	my (\$WH_HOSTS);
	my (\$CID_HTML_REPFILE);
	my (\$SFH_ID);
	my (\$SFH_SUFFIX);
	my (\$G_OUT_LINES)       = 20;
	my (\$WOH_LINE_CNT);
	
	sub usage {
	    print "Usage: \$0 -f SOURCEFILE -o CID_HTML_REPFILE -c SFH_CNT -i SFH_ID -x SFH_SUFFIX -h SFH_HOSTS -w WH_HOSTS -l G_OUT_LINES -n WOH_LINE_CNT\n";
	    exit;
	}
	
	GetOptions(
	    "f=s" => \\\$SOURCEFILE,
	    "o=s" => \\\$CID_HTML_REPFILE,
	    "c=n" => \\\$SFH_RCNT,
	    "i=s" => \\\$SFH_ID,
	    "x=s" => \\\$SFH_SUFFIX,
	    "h=s" => \\\$SFH_HOSTS,
	    "w=s" => \\\$WH_HOSTS,
	    "l=n" => \\\$G_OUT_LINES,
	    "n=n" => \\\$WOH_LINE_CNT,
	) or usage();
	
	my (\$SFH_DINDEX)        = 0;
	my (\$SFH_INDEX)         = 0;
	my (\$SFH_SHOW_LINE)     = 1;
	my (\$SFH_DISPLAY_MORE)  = 0;
	
	open( my \$FH, "<", "\$SOURCEFILE" ) or die "Cannot open \$SOURCEFILE: \$!";
	open( my \$CHR, ">>", "\$CID_HTML_REPFILE" ) or die "Cannot open \$CID_HTML_REPFILE: \$!";
	open( my \$CHROUT, ">", "\$CID_HTML_REPFILE.rawout" ) or die "Cannot open \$CID_HTML_REPFILE.rawout: \$!";
	while(my \$sfh_line = <\$FH>) {
		chomp(\$sfh_line);
	        my (\$sfh_lined) =       \$sfh_line;
	        \$sfh_lined =~ s/TO REVIEW COLLECTED //;
	        \$sfh_lined =~ s/>/\&gt;/g;
	        \$sfh_lined =~ s/</\&lt;/g;
	
	        my (\$SFH_MNAME);
	        my (\$INST_NAME);
	
	        if ( \$SFH_RCNT > 1 && \$sfh_line =~ m/TO REVIEW COLLECTED DATA/i ) {
	            if ( \$sfh_line =~ m/ DATABASE -/i or \$sfh_line =~ m/ ORACLE_HOME -/i ) {
	                \$SFH_MNAME      = (split ' ', \$sfh_line)[7];
	            }
	            else {
	                \$SFH_MNAME      = (split ' ', \$sfh_line)[5];
	            }
	
	            if ( \$SFH_HOSTS =~ m/\$SFH_MNAME/i ) {
	                \$SFH_SHOW_LINE  = 1;
	            }
	            else {
	                \$SFH_SHOW_LINE  = 0;
	            }
	
	            if ( \$sfh_line =~ m/ DATABASE_HOME -/i or \$sfh_line =~ m/DATABASE_HOME - TIMESTEN/i ) {
	                \$SFH_MNAME      = (split ' ', \$sfh_line)[7];
	                if ( \$sfh_line =~ m/BI_INSTANCE -/i ) {
	                    if ( \$WH_HOSTS =~ m/\$SFH_MNAME:/i ) {
	                        \$INST_NAME      = (split ' ', \$sfh_line)[10];
	                        if ( \$WH_HOSTS =~ m/\$INST_NAME/i ) {
	                            \$SFH_SHOW_LINE  = 1;
	                        }
	                        else {
	                            \$SFH_SHOW_LINE  = 0;
	                        }
	                    }
	                    else {
	                        \$SFH_SHOW_LINE = 0;
	                    }
	                }
	                else {
	                    if ( \$WH_HOSTS =~ m/\$SFH_MNAME\$/i ) {
	                        \$SFH_SHOW_LINE  = 1;
	                    }
	                    else {
	                        \$SFH_SHOW_LINE  = 0;
	                    }
	                }
	            }
	        }
	
	        if ( \$SFH_SHOW_LINE == 1 ) {
	            if ( \$SFH_DINDEX == \$G_OUT_LINES ) {
	                print \$CHR "<div id=\$SFH_ID" . '_more_text' . \$SFH_SUFFIX . ' style="DISPLAY: none">' . "\n";
	
	                \$SFH_DISPLAY_MORE = 1;
	            }
	            print \$CHR "\$sfh_lined"."\n";
	            print \$CHROUT "\$sfh_lined"."\n";
	
	            \$SFH_DINDEX++;
	        }
	        \$SFH_INDEX++;
	
	        if ( \$SFH_INDEX >= \$WOH_LINE_CNT && \$SFH_DINDEX > \$G_OUT_LINES && \$SFH_DISPLAY_MORE == 1 ) {
	            print \$CHR qq{</div><a id="\$SFH_ID} . qq{_more_text\$SFH_SUFFIX} . qq{_mh" class=more_less_style onclick="javascript:ShowHide('} . qq{\$SFH_ID} . qq{_more_text\$SFH_SUFFIX')" href="javascript:;">Click for more data</a>\n};
	        }
	
	}
	close(\$CHR);
	close(\$CHROUT);
	close(\$FH);
PERLEOF
}

show_file_in_html ()
{
  sfh_index=0
  sfh_dindex=0
  sfh_show_line=1
  sfh_id=$(echo $G_SOURCEFIL_REPORT | awk -F"/" '{print $NF}' | sed 's/\./_/g')
  sfh_display_more=0

  sfh_hosts="$g_hosts"
  sfh_suffix="$cch_check_id"
  if [[ -n "$parse_passed_list" && $parse_passed_list -eq "1" ]]
  then
    sfh_hosts="$g_hosts_passed"
    sfh_suffix=$cch_check_id"_passed"
  fi

  sfh_suffix=$RANDOM

  sfh_rcnt=$(grep -ic "TO REVIEW COLLECTED" $G_SOURCEFIL_REPORT)
  if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ] ; then  sfh_rcnt=0; fi;

  echo "<a name=\"${sfh_id}_more_text${sfh_suffix}_a\"></a>" >> $CID_HTML_REPFILE

  if [[ -z $RAT_NO_SHOW_FILE ]]
  then
    show_file_in_html_perl
    return;
  fi

  old_IFS=$IFS
  IFS=$'\n'

  while read sfh_line
  do
    sfh_lined=$(echo "$sfh_line" | sed 's/TO REVIEW COLLECTED //' | sed 's/>/\&gt;/g' | sed 's/</\&lt;/g')

    if [[ $sfh_rcnt -gt "1" && `echo "$sfh_line" | grep -ic "TO REVIEW COLLECTED DATA"` -gt 0 ]]
    then # Multiple o/p in a single file
      if [[ `echo "$sfh_line" | grep -ic " DATABASE -"` -gt "0" || `echo "$sfh_line" | grep -ic " ORACLE_HOME -"` -gt "0" ]]
      then # by db/instance/oracle_home name
        sfh_mname=$(echo "$sfh_line" | awk '{print $8}')
      else # by host name
        sfh_mname=$(echo "$sfh_line" | awk '{print $6}')
      fi
      if [[ `echo $sfh_hosts | grep -icw $sfh_mname` -gt 0 ]]
      then # Its from failed host
        sfh_show_line=1
      else # Its not from failed host
        sfh_show_line=0
      fi
      #-------------------------TimesTen
      if [[ `echo "$sfh_line" | grep -ic " DATABASE_HOME -"` -gt "0" || `echo "$sfh_line" | grep -ic "DATABASE_HOME - TIMESTEN"` -gt "0" ]]
      then
        sfh_mname=$(echo "$sfh_line" | awk '{print $8}')
	if [[ `echo "$sfh_line" | grep -ic "BI_INSTANCE -"` -gt "0" ]]
	then
	  if [[ `echo "$wh_hosts" |  grep -ic "$sfh_mname:"` -gt "0" ]]
          then
	    inst_name=$(echo "$sfh_line" | awk '{print $11}')
	    if [[ `echo "$wh_hosts" |  grep -ic "$inst_name"` -gt "0" ]]
	    then
	      sfh_show_line=1
	    else
	      sfh_show_line=0	
	    fi
	  else
            sfh_show_line=0
	  fi  
	else
	  if [[ `echo "$wh_hosts" |  grep -ic "$sfh_mname$"` -gt "0" ]]
          then
            sfh_show_line=1
	  else
            sfh_show_line=0
	  fi  
	fi     
      fi      
      #-------------------------
    fi
    if [ $sfh_show_line -eq "1" ]
    then
      if [[ $sfh_dindex -eq $G_OUT_LINES ]]
      then # After $G_OUT_LINES lines are displayed, hide rest of lines
        echo "<div id=\"${sfh_id}_more_text$sfh_suffix\" style=\"DISPLAY: none\">" >> $CID_HTML_REPFILE
        sfh_display_more=1
      fi

      echo "$sfh_lined" >> $CID_HTML_REPFILE
      let sfh_dindex=$sfh_dindex+1
    fi

    let sfh_index=$sfh_index+1
    # sfh_index may not be visible outside while.. so below workaround
    if [[ $sfh_index -ge $woh_line_cnt && $sfh_dindex -gt $G_OUT_LINES && $sfh_display_more -eq 1 ]]
    then
      echo "</div><a id=\"${sfh_id}_more_text${sfh_suffix}_mh\" class=more_less_style onclick=\"javascript:ShowHide('${sfh_id}_more_text$sfh_suffix')\" href=\"javascript:;\" >Click for more data</a>" >> $CID_HTML_REPFILE
    fi
  done < ${G_SOURCEFIL_REPORT}
  IFS=$old_IFS

  # Alternatives
  # 1. cat ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
  # 2. a.txt has 48 lines. then
  # head -20 a.txt > 1.txt
  # Display div
  # tail -28 readme.txt >> 1.txt
  # Close div
}

# Append the .out file contents  to <checkid>.html from each run for the check.
write_output_to_html ()
{
  wh_status="$1"
  parse_passed_list=0
  wh_hosts=$g_hosts

  if [[ $wh_status = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi

  if [ ! -e "$CID_HTML_REPFILE" ]
  then # OS_PACKAGE does not print from appendix. So create_checkid_html was never called
    echo "<hr><br>" >> $CID_HTML_REPFILE
    echo "<a name=\"${cch_check_id}_details\"></a>" >> $CID_HTML_REPFILE
    echo "<a href=\"#${cch_check_id}_summary\" class=\"a_bgw\">Top</a><br>" >> $CID_HTML_REPFILE
  fi

  if [[ `echo ${G_SOURCEFIL_REPORT} |grep -ic "$CHECK_ID.html"` -gt 0 ]] ; then
    # just append contents
    lines=$(grep -n -w "Status on $sl_hosts" ${G_SOURCEFIL_REPORT} | cut -d":" -f1 | head -1)
    if [ -z "$lines" ] ; then lines=0; fi;
    tlines=$(wc -l ${G_SOURCEFIL_REPORT}| awk '{print $1}')
    lines_to_tail=$(expr $tlines - $lines)
    lines_to_tail=$(expr $lines_to_tail + 1)
    #tail -$lines_to_tail ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
    tail -$lines_to_tail ${G_SOURCEFIL_REPORT} > ${G_SOURCEFIL_REPORT}.tailed
    if [[ `grep -ic "<b>Status on" ${G_SOURCEFIL_REPORT}.tailed` -gt 1 ]] ; then
      hlines=$(grep -n "<b>Status on" ${G_SOURCEFIL_REPORT}.tailed | cut -d":" -f1 |head -2 |tail -1)
      hlines=$(expr $hlines - 1)    
      
      if [[ -n "$MERGEFILES" && -z "$sl_hosts" ]]; then
        head -$hlines ${G_SOURCEFIL_REPORT}.tailed > $CID_HTML_REPFILE
      else
        head -$hlines ${G_SOURCEFIL_REPORT}.tailed >> $CID_HTML_REPFILE
      fi
    else
      if [[ -n "$MERGEFILES" && -z "$sl_hosts" ]]; then
        cat ${G_SOURCEFIL_REPORT}.tailed > $CID_HTML_REPFILE
      else
        cat ${G_SOURCEFIL_REPORT}.tailed >> $CID_HTML_REPFILE
      fi
    fi
    #rm -f ${G_SOURCEFIL_REPORT}
    return;
  fi

  if [[ -n "$g_hosts_passed" && $wh_status = "PASS" ]]
  then # On cells when check passed on all cells
    wh_hosts=$g_hosts_passed
    parse_passed_list=1
  fi

  show_full_file=1
  if [[ `echo $COMTYPE | grep -ic "PARAM"` -gt 0 ]]
  then
    show_full_file=0
  fi

  if [[  $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
  then
    show_full_file=0
  fi
  if [[ "$PARAM_PATH" = "UNSPECIFIED" ]]
  then
    show_full_file=1
  fi

  if [ -e "${G_SOURCEFIL_REPORT}" ]
  then
    # Write status only if there is output
    echo "<br>" >> $CID_HTML_REPFILE
    echo "<table width=100% class=\"td_output\" summary=\"Audit check output\"><tr class=\"td_output\"><td class=\"td_output\" scope=\"row\"><p class=a_bgw><b>Status on $wh_hosts</b>:<br/><span class=\"status_$wh_status\">$wh_status</span> => ${cch_cname}</p></td></tr>" >> $CID_HTML_REPFILE
    woh_line_cnt=$(cat $G_SOURCEFIL_REPORT | wc -l | sed 's/ //g')
    if [ $woh_line_cnt -gt 0 ]
    then # We dont want to show row if file is blank
      echo "<tr class=\"td_output\"><td class=\"td_output\" scope=\"row\"><pre>" >> $CID_HTML_REPFILE
      if [[ $show_full_file -eq 1 ]]
      then
        html_comment_tag=$(grep -ic '<!-- HTML OUTPUT -->' ${G_SOURCEFIL_REPORT});
        if [[ $html_comment_tag -gt 0 ]];
        then
          show_file ${G_SOURCEFIL_REPORT}
	else
          show_file_in_html ${G_SOURCEFIL_REPORT}
        fi
      else
        # When the check is about a parameter, dont display the whole file. 
        # Just grep for parameter
        #Added -w to following three grep exression becuase pfile check is displaying spfile parameters 
        woth_param=$(echo $PARAM_PATH | awk -F"|" '{print $1}') # PARAM_PATH can be like gcc|4.0.1 In such cases we only grep first token
        #echo "PARAM_PATH=$PARAM_PATH ${g_hosts}.$woth_param" >> $CID_HTML_REPFILE
        wot_param_line=$(grep -iw "${g_hosts}.$woth_param" ${G_SOURCEFIL_REPORT})
        if [ -z "$wot_param_line" ]
        then # Instance name is not added to parameter name. So grep just param name
          grep -iw "$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
          grep -iw "$woth_param" ${G_SOURCEFIL_REPORT} > $CID_HTML_REPFILE.rawout
        else
          grep -iw "${g_hosts}.$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
          grep -iw "${g_hosts}.$woth_param" ${G_SOURCEFIL_REPORT} > $CID_HTML_REPFILE.rawout
        fi
      fi
      echo "</pre></td></tr>" >> $CID_HTML_REPFILE
    fi # end if  $woh_line_cnt -gt 0 
    echo "</table><hr color=\"#F2F5F7\" style=\"background:#F2F5F7\">" >> $CID_HTML_REPFILE
  fi # end if -e $G_SOURCEFIL_REPORT

  if [[ -n "$g_hosts_passed" && $wh_status != "PASS" ]]
  then #Passed on some cells. No seperate message.
    if [ -e "${G_SOURCEFIL_REPORT}" ]
    then
      echo "<br>" >> $CID_HTML_REPFILE
      echo "<table width=100% class=\"td_output\" summary=\"Audit check output\"><tr class=\"td_output\"><td class=\"td_output\" scope=\"row\"><p class=a_bgw><b>Status on $g_hosts_passed</b>:<br/><span class=\"status_PASS\">PASS</span></p></td></tr>" >> $CID_HTML_REPFILE
      woh_line_cnt=$(cat $G_SOURCEFIL_REPORT | wc -l | sed 's/ //g')
      if [ $woh_line_cnt -gt 0 ]
      then # We dont want to show row if file is blank
        echo "<tr class=\"td_output\"><td class=\"td_output\" scope=\"row\"><pre>" >> $CID_HTML_REPFILE
        if [[ $show_full_file -eq 1 ]]
        then
          parse_passed_list=1
          html_comment_tag=$(grep -ic '<!-- HTML OUTPUT -->' ${G_SOURCEFIL_REPORT});
          if [[ $html_comment_tag -gt 0 ]];
          then
            show_file ${G_SOURCEFIL_REPORT}
	  else
            show_file_in_html ${G_SOURCEFIL_REPORT}
          fi
          parse_passed_list=0
        else
          # When the check is about a parameter, dont display the whole file. 
          # Just grep for parameter
          woth_param=$(echo $PARAM_PATH | awk -F"|" '{print $1}') # PARAM_PATH can be like gcc|4.0.1 In such cases we only grep first token
          wot_param_line=$(grep -i "${g_hosts_passed}.$woth_param" ${G_SOURCEFIL_REPORT})
          if [ -z "$wot_param_line" ]
          then # Instance name is not added to parameter name. So grep just param name
            grep -i "$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
            grep -i "$woth_param" ${G_SOURCEFIL_REPORT} > $CID_HTML_REPFILE.rawout
          else
            grep -i "${g_hosts_passed}.$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
            grep -i "${g_hosts_passed}.$woth_param" ${G_SOURCEFIL_REPORT} > $CID_HTML_REPFILE.rawout
          fi
        fi
        echo "</pre></td></tr>" >> $CID_HTML_REPFILE
      fi # end if  $woh_line_cnt -gt 0 
      echo "</table><hr color=\"#F2F5F7\" style=\"background:#F2F5F7\">" >> $CID_HTML_REPFILE
    fi # end if -e $G_SOURCEFIL_REPORT
  fi
}

# Link can be like
# 1 VMM Page Replacement Tuning - http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.prftungd/doc/prftungd/values_minperm_maxperm_param.htm
# 2 Virtual Memory Mgmt -Tuning Parameter: lru_file_repage (PDF) - http://www-03.ibm.com/support/techdocs/atsmastr.nsf/5cb5ed706d254a8186256c71006d2e0a/125bda8fe26e45008625718000719309/$FILE/LruFileRepage.pdf
# 3 Optimizing AIX 5L performance: Tuning your memory settings - http://www.ibm.com/developerworks/aix/library/au-aixoptimization-memtun1/index.html?ca=drs-
# 4 Note: 811293.1 - RAC Starter Kit (AIX) - 
#
# When there is a http://, just create text before that as a link to http url.
# When there is a note, link like below
#      https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=<noteid>
append_links_html ()
{
  if [[ $1 = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi

  # Remove the first digit
  alh_link=$(echo $LINK | sed 's/^[0-9]* //')
  if [[ `echo "$alh_link" | grep -ic "http:"` -ge 1 ]]
  then # Link exists in variable
    alh_link_text=$(echo $alh_link | sed 's/http:.*//'| sed 's/- *$//')
    alh_link_url=$(echo $alh_link | sed 's/.*http:/http:/'| sed 's/ *$//')
    alh_link="<a href=\"$alh_link_url\" target=\"_blank\">$alh_link_text</a>";
  elif [[ `echo "$alh_link" | grep -ic "https:"` -ge 1 ]]
  then # Link exists in variable
    alh_link_text=$(echo $alh_link | sed 's/https:.*//'| sed 's/- *$//')
    alh_link_url=$(echo $alh_link | sed 's/.*https:/https:/'| sed 's/ *$//')
    alh_link="<a href=\"$alh_link_url\" target=\"_blank\">$alh_link_text</a>";
  elif [[ `echo "$alh_link" | grep -ic "Note: "` -ge 1 ]]
  then # MOS Note
    alh_link_text=$(echo "$alh_link" | sed 's/[ -]*$//g')
    alh_note_id=$(echo $alh_link | sed 's/Note: *//' | awk -F"-" '{print $1}' | sed 's/ //g')
    alh_link="<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=$alh_note_id\" target=\"_blank\">$alh_link_text</a>";
    #alh_link="<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=${alh_note_id}&cid=${TOOL_ID}${PLA_LINE}report\" target=\"_blank\">$alh_link_text</a>";
    #alh_link="<a href=\"https://support.oracle.com/CSP/main/article?id=${alh_note_id}&cid=${TOOL_ID}${PLA_LINE}report\" target=\"_blank\">$alh_link_text</a>";
    alh_link="<a href=\"https://support.oracle.com/epmos/faces/DocumentDisplay?parent=${program_name}Report&sourceId=${PLA_LINE}&id=${alh_note_id}\" target=\"_blank\">$alh_link_text</a>";
  fi
  G_LINKS="$G_LINKS<li>$alh_link</li>"
}

get_tail_html ()
{
    # MAA
    is_maa=0
    if [ ! -z "${G_CHECKID_MAA_SF[$crh_cnt]}" ]
    then # Show in maa scorecard. Files will be SF_STATUS_
      # echo "${G_CHECKID_MAA_SF[$crh_cnt]}"
      is_maa=1
      if [ ${G_CHECKID_MAA_SF[$crh_cnt]} = "DBMACHINE X2-2 AND X2-8 AUDIT CHECKS" ]
      then # some exadata sql checks should be updated manualy
        G_CHECKID_MAA_SF[$crh_cnt]="DATA CORRUPTION PREVENTION BEST PRACTICES"
      fi

      maa_msg=$(echo "${G_CHECKID_INFO[$crh_cnt]}" | tr "[a-z]" "[A-Z]")
      maa_sf_uc=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |tr "[a-z]" "[A-Z]")
      maa_sfname=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |  sed 's/[^a-zA-Z0-9]//g')
      if [[ $maa_msg = $maa_sf_uc ]]
      then # The SF = MSG. dont display view.
        if [ ! -e "${OUTPUTDIR}/${maa_sfname}_TOP.html" ]
        then
          MAA_IDS[$maa_id]=$maa_sfname
          let maa_id=$maa_id+1
        fi
        CHECK_ID=${G_CHECKIDS[$crh_cnt]}
        LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
        BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
        ENDPAT="_$CHECK_ID-END_COMMENTS"
        ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
        PLA_LINE=`grep "_"$CHECK_ID"-PLA_LINE"" " $REFFIL1 | sed -n 's/.*-PLA_LINE//p' | sed 's/^\s*//g' | sed 's/\s*$//g'`
        if [ $LINKNUM -gt 0 ]
        then
          unset G_LINKS
          for ((j=1;j<=$LINKNUM;j+=1));
          do
            LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
            append_links_html "INFO"
          done
          if [ ! -z "$G_LINKS" ] ; then
            ONFAIL="<b>Description</b><br>$ONFAIL<br><b>Best Practices</b><br><ol>$G_LINKS</ol>"
          fi
        fi

        echo "<tr class=\"PLACEHOLDER_FO\"><td colspan=7 scope=\"row\">.</td></tr>" > ${OUTPUTDIR}/${maa_sfname}_TOP.html
        echo "<tr class=\"PLACEHOLDER_FO\"><td valign=center rowspan=PLACEHOLDER_TO_REPLACE>${G_CHECKID_MAA_SF[$crh_cnt]}</td><td name='checkid' style='DISPLAY: none'></td><td scope=\"row\">PLACEHOLDER_STATUS</td><td colspan=4><pre>$ONFAIL</pre></td></tr>" >> ${OUTPUTDIR}/${maa_sfname}_TOP.html
	#echo "<tr class=\"expandmaa\" style='DISPLAY: none'><td valign=center rowspan=PLACEHOLDERTOREPLACE>${G_CHECKID_MAA_SF[$crh_cnt]}</td><td name='checkid' style='DISPLAY: none'></td><td scope=\"row\">PLACEHOLDER_STATUS</td><td colspan=4><pre>$ONFAIL</pre></td></tr>" >> ${OUTPUTDIR}/${maa_sfname}_TOP.html
      else # Normal message
        maa_ofile="${maa_sfname}_${chk_status}_SF.html"
	maaidx=`echo ${maa_sfname}|sed 's/A//g'|sed 's/E//g'`
        if [ ! -e "${OUTPUTDIR}/$maa_ofile" ]
        then
          MAA_IDS[$maa_id]=$maa_sfname
          let maa_id=$maa_id+1
        fi

        echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('maasctbl_inner_${maaidx}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/$maa_ofile

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/$maa_ofile
      fi
    fi

    if [ -z "${G_CHECKIDS[$crh_cnt]}" ]; then continue; fi;
    if [[ $is_maa -eq "0" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -ge 1 ]]
    then # Passed check
      if [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${gg_id}.prf"` -gt 0 ]]
      then
        gg_cnt=1
        gg_type='PASS'
        if [ ! -r "${OUTPUTDIR}/GG_${gg_type}.html" ]; then
          touch "${OUTPUTDIR}/GG_${gg_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('GoldenGate', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/GG_${gg_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/GG_${gg_type}.html

	elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${peoplesoft_id}.prf"` -gt 0 ]]
      then
        peoplesoft_cnt=1
        peoplesoft_type='PASS'
        if [ ! -r "${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_type}.html" ]; then
          touch "${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('peoplesoft', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${siebel_id}.prf"` -gt 0 ]]
      then
        siebel_cnt=1
        siebel_type='PASS'
        if [ ! -r "${OUTPUTDIR}/SIEBEL_${siebel_type}.html" ]; then
          touch "${OUTPUTDIR}/SIEBEL_${siebel_type}.html"
        fi

	 echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('siebel', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/SIEBEL_${siebel_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/SIEBEL_${siebel_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${corroborate_id}.prf"` -gt 0 ]]
      then
        corroborate_cnt=1
        corroborate_type='PASS'
        if [ ! -r "${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html" ]; then
          touch "${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html"
        fi

	 echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('corroborate', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oam_id}.prf"` -gt 0 ]]
      then
        oam_cnt_pass=1
        oam_type='PASS'
        if [ ! -r "${OUTPUTDIR}/OAM_${oam_type}.html" ]; then
          touch "${OUTPUTDIR}/OAM_${oam_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('oam', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/OAM_${oam_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/OAM_${oam_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oud_id}.prf"` -gt 0 ]]
      then
        oud_cnt_pass=1
        oud_type='PASS'
        if [ ! -r "${OUTPUTDIR}/OUD_${oud_type}.html" ]; then
          touch "${OUTPUTDIR}/OUD_${oud_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('oud', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/OUD_${oud_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/OUD_${oud_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oim_id}.prf"` -gt 0 ]]
      then
        oim_cnt_pass=1
        oim_type='PASS'
        if [ ! -r "${OUTPUTDIR}/OIM_${oim_type}.html" ]; then
          touch "${OUTPUTDIR}/OIM_${oim_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('oim', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/OIM_${oim_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/OIM_${oim_type}.html

      elif [[ -e $UDC && `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$UDC"` -gt 0 ]]
      then
        udc_cnt=1
        udc_type='PASS'
        if [ ! -r "${OUTPUTDIR}/UDC_${udc_type}.html" ]; then
          touch "${OUTPUTDIR}/UDC_${udc_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('udc', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/UDC_${udc_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/UDC_${udc_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${platinum_id}.prf"` -gt 0 ]]
      then
        platinum_cnt=1
        platinum_type='PASS'
        if [ ! -r "${OUTPUTDIR}/PLATINUM_${platinum_type}.html" ]; then
          touch "${OUTPUTDIR}/PLATINUM_${platinum_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('platinum', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/PLATINUM_${platinum_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/PLATINUM_${platinum_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${ebs_id}.prf"` -gt 0 ]]
      then
	CHECK_ID=${G_CHECKIDS[$crh_cnt]}
	PLA_AREA=`grep "_"$CHECK_ID"-PLA_AREA"" " $REFFIL1 | sed -n 's/.*-PLA_AREA//p' | sed 's/^\s*//g' | sed 's/\s*$//g'|sed 's/ //g'`
	set_grp_val $PLA_AREA
	if [ $grpval = "Other" ] 
	then
		PLA_AREA="UNKNOWN"
	fi
        ebs_cnt=1
        ebs_type='PASS'
        if [ ! -r "${OUTPUTDIR}/EBS_${PLA_AREA}_${ebs_type}.html" ]; then
          touch "${OUTPUTDIR}/EBS_${PLA_AREA}_${ebs_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('E-Business_Suite', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/EBS_${PLA_AREA}_${ebs_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/EBS_${PLA_AREA}_${ebs_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${em_id}.prf"` -gt 0 ]]
      then
        em_cnt=1
        em_type='PASS'
        if [ ! -r "${OUTPUTDIR}/EM_${em_type}.html" ]; then
          touch "${OUTPUTDIR}/EM_${em_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('Enterprise_Manager', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/EM_${em_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/EM_${em_type}.html

      else
        if [ ! -r "${OUTPUTDIR}/PASS_${crh_rep_prefix}.html" ]
        then # Write the header
          if [[ -n "$crh_rep_ptext_h" ]] ; then crh_rep_ptext=$crh_rep_ptext_h; fi;
          if [[ -n "$crh_rep_ptext_h" ]] ; then crh_rep_ptext=$crh_rep_ptext_h; fi;
        
	cat > ${OUTPUTDIR}/PASS_${crh_rep_prefix}_header.html <<EOF
             <a name="failed_checks_${crh_rep_prefix}"></a>
             <H2>$crh_rep_ptext</h2>
             <table border=1 id="failedtbl_${crh_rep_prefix}" summary="Failed checks">
             <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
             <th scope="col">Status</th>
             <th scope="col">Type</th>
             <th scope="col">Message</th>
             <th scope="col">Status On</th>
             <th scope="col">Details</th></tr>
EOF
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_${crh_rep_prefix}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/PASS_${crh_rep_prefix}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/PASS_${crh_rep_prefix}.html
      fi
    elif [ $is_maa -eq "0" ]
    then
      # Split the checks into different html files to sort the table based on severity
      if [[ $chk_status = "ERROR" || $chk_status = "FAIL" || $chk_status = "WARNING" || $chk_status = "INFO" ]]
      then
        if [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${gg_id}.prf"` -gt 0 ]]
        then
          gg_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then gg_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then gg_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then gg_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then gg_type="INFO";
          fi
	elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${peoplesoft_id}.prf"` -gt 0 ]]
        then
          peoplesoft_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then peoplesoft_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then peoplesoft_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then peoplesoft_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then peoplesoft_type="INFO";
          fi
	elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${siebel_id}.prf"` -gt 0 ]]
        then
          siebel_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then siebel_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then siebel_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then siebel_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then siebel_type="INFO";
          fi
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${corroborate_id}.prf"` -gt 0 ]]
        then
          corroborate_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then corroborate_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then corroborate_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then corroborate_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then corroborate_type="INFO";
          fi

        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oam_id}.prf"` -gt 0 ]]
        then
          oam_cnt_fail=1
          if [[ "$chk_status" = "ERROR" ]]; then oam_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then oam_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then oam_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then oam_type="INFO";
          fi

        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oud_id}.prf"` -gt 0 ]]
        then
          oud_cnt_fail=1
          if [[ "$chk_status" = "ERROR" ]]; then oud_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then oud_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then oud_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then oud_type="INFO";
          fi

        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oim_id}.prf"` -gt 0 ]]
        then
          oim_cnt_fail=1
          if [[ "$chk_status" = "ERROR" ]]; then oim_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then oim_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then oim_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then oim_type="INFO";
          fi
	elif [[ -e $UDC && `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$UDC"` -gt 0 ]]
        then
          udc_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then udc_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then udc_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then udc_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then udc_type="INFO";
          fi
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${platinum_id}.prf"` -gt 0 ]]
        then
          platinum_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then platinum_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then platinum_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then platinum_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then platinum_type="INFO";
          fi
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${ebs_id}.prf"` -gt 0 ]]
        then
          ebs_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then ebs_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then ebs_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then ebs_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then ebs_type="INFO";
          fi
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${em_id}.prf"` -gt 0 ]]
        then
          em_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then em_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then em_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then em_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then em_type="INFO";
          fi
        else
          crh_file_name="${OUTPUTDIR}/${chk_status}_${crh_rep_prefix}.html"
        fi
      else
        if [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${gg_id}.prf"` -gt 0 ]]
        then
          gg_cnt=1
          gg_type="OTHER"
	elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${peoplesoft_id}.prf"` -gt 0 ]]
        then
          peoplesoft_cnt=1
          peoplesoft_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${siebel_id}.prf"` -gt 0 ]]
        then
          siebel_cnt=1
          siebel_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${corroborate_id}.prf"` -gt 0 ]]
        then
          corroborate_cnt=1
          corroborate_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oam_id}.prf"` -gt 0 ]]
        then
          oam_cnt_fail=1
          oam_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oud_id}.prf"` -gt 0 ]]
        then
          oud_cnt_fail=1
          oud_type="OTHER"

        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oim_id}.prf"` -gt 0 ]]
        then
          oim_cnt_fail=1
          oim_type="OTHER"
	elif [[ -e $UDC && `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$UDC"` -gt 0 ]]
        then
          udc_cnt=1
          udc_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${platinum_id}.prf"` -gt 0 ]]
        then
          platinum_cnt=1
          platinum_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${ebs_id}.prf"` -gt 0 ]]
        then
          ebs_cnt=1
          ebs_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${em_id}.prf"` -gt 0 ]]
        then
          em_cnt=1
          em_type="OTHER"
        else
          crh_file_name="${OUTPUTDIR}/OTHER_${crh_rep_prefix}.html"
        fi
      fi

      if [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${gg_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/GG_${gg_type}.html" ]; then
          touch "${OUTPUTDIR}/GG_${gg_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('GoldenGate', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/GG_${gg_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/GG_${gg_type}.html


	elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${peoplesoft_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_type}.html" ]; then
          touch "${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('peoplesoft', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${siebel_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/SIEBEL_${siebel_type}.html" ]; then
          touch "${OUTPUTDIR}/SIEBEL_${siebel_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('siebel', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/SIEBEL_${siebel_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/SIEBEL_${siebel_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${corroborate_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html" ]; then
          touch "${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('corroborate', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oam_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/OAM_${oam_type}.html" ]; then
          touch "${OUTPUTDIR}/OAM_${oam_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('oam', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/OAM_${oam_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/OAM_${oam_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oud_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/OUD_${oud_type}.html" ]; then
          touch "${OUTPUTDIR}/OUD_${oud_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('oud', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/OUD_${oud_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/OUD_${oud_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${oim_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/OIM_${oim_type}.html" ]; then
          touch "${OUTPUTDIR}/OIM_${oim_type}.html"
        fi
	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('oim', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/OIM_${oim_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/OIM_${oim_type}.html

      elif [[ -e $UDC && `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$UDC"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/UDC_${udc_type}.html" ]; then
          touch "${OUTPUTDIR}/UDC_${udc_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('udc', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td class=\"check-name\"><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/UDC_${udc_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/UDC_${udc_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${platinum_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/PLATINUM_${platinum_type}.html" ]; then
          touch "${OUTPUTDIR}/PLATINUM_${platinum_type}.html"
        fi

	 echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('platinum', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/PLATINUM_${platinum_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/PLATINUM_${platinum_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${ebs_id}.prf"` -gt 0 ]]
      then
	CHECK_ID=${G_CHECKIDS[$crh_cnt]}
        PLA_AREA=`grep "_"$CHECK_ID"-PLA_AREA"" " $REFFIL1 | sed -n 's/.*-PLA_AREA//p' | sed 's/^\s*//g' | sed 's/\s*$//g'|sed 's/ //g'`
        set_grp_val $PLA_AREA
        if [ $grpval = "Other" ]
        then
                PLA_AREA="UNKNOWN"
        fi
        if [ ! -r "${OUTPUTDIR}/EBS_${PLA_AREA}_${ebs_type}.html" ]; then
          touch "${OUTPUTDIR}/EBS_${PLA_AREA}_${ebs_type}.html"
        fi
	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('E-Business_Suite', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/EBS_${PLA_AREA}_${ebs_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/EBS_${PLA_AREA}_${ebs_type}.html

      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${em_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/EM_${em_type}.html" ]; then
          touch "${OUTPUTDIR}/EM_${em_type}.html"
        fi

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('Enterprise_Manager', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> ${OUTPUTDIR}/EM_${em_type}.html

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> ${OUTPUTDIR}/EM_${em_type}.html

      else

	echo "<tr class = \"$chk_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'><a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\">${G_CHECKIDS[$crh_cnt]}</a></td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_${crh_rep_prefix}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status1</td><td class=\"check-name\">${G_CHECKID_TYPE[$crh_cnt]}</td><td class=\"check-message\" scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td class=\"check-status-on\">$crh_hosts</td><td class=\"check-view-link\"><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_view\" class=\"view\">View</div><div id=\"${G_CHECKIDS[$crh_cnt]}_contents_hide\" class=\"hide\" style='DISPLAY: none'>Hide</div></a></td></tr>" >> $crh_file_name

	echo "<tr class=\"${G_CHECKIDS[$crh_cnt]}_contents\" style='DISPLAY: none'><td colspan=6 scope=\"row\"><div id="${G_CHECKIDS[$crh_cnt]}_contents_t"></div></td></tr>" >> $crh_file_name
      fi
    fi
    let g_tr_index=$g_tr_index+1
}

# Display only $G_HOST_CNT hosts and display more link
# When all hosts, then display All
# Output:
#   $crh_hosts with html for displaying in summary table
get_host_string_html ()
{
  ghs_cid="A${G_CHECKIDS[$crh_cnt]}"
  ghs_status=$(eval echo \${$ghs_cid})

  el_prefix=""
  ghs_ctype=""
  crh_rep_ptext_h=""
  crh_rep_prefix="compute" # Compute node check is default
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    crh_rep_ptext="Compute Node"
    if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
      crh_first_host=$1
      el_prefix=$2
      if [[ $el_prefix = "DB" ]] ; then
        crh_rep_ptext="Control DB Node"
      elif [[ $el_prefix = "EC" ]] ; then
        crh_rep_ptext="Enterprise Controller"
      elif [[ $el_prefix = "PC" ]] ; then
        crh_rep_ptext="Proxy Controller"
      elif [[ $el_prefix = "OVMM" ]] ; then
        crh_rep_ptext="OVM Manager Node"
      elif [[ $el_prefix = "CS" ]] ; then
        crh_rep_ptext="Control vServer"
      fi
      if [[ $el_prefix != "CN" ]] ; then
        crh_rep_prefix="cvserver"
        crh_rep_ptext_h="Control vServer"
        ghs_status="2"
      fi
    fi
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]]
    then
      crh_rep_ptext="Guest VM";
    fi    
  elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] ; then
    crh_rep_ptext="Node"
  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]] ; then
    crh_rep_ptext="Compute Node"
  elif [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] ; then
    crh_rep_ptext="Compute Node"
  elif [[ -n "$is_opc" && $is_opc -eq 1 ]] ; then
    crh_rep_ptext="Compute Node"
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]] ; then
    crh_rep_ptext="Node"
  else
    crh_rep_ptext="Database Server"
  fi
  

  case ${G_CHECKID_TYPE[$crh_cnt]} in
  "Storage Server Check")
                       ghs_ctype="Storage Servers"
                       crh_rep_prefix="cell" 
                       crh_rep_ptext="Storage Server"
                       ;;
  "ZFS Storage Appliance Check")
                       ghs_ctype="ZFS Storage Appliances"
                       crh_rep_prefix="zfscell" 
                       crh_rep_ptext="ZFS Storage Appliance"
                       ;;
  "External ZFS Storage Appliance Check")
                       ghs_ctype="External ZFS Storage Appliances"
                       crh_rep_prefix="extzfscell"
                       crh_rep_ptext="External ZFS Storage Appliance"
                       ;;
  "Switch Check")
                       ghs_ctype="InfiniBand Switches"
                       crh_rep_prefix="switch" 
                       crh_rep_ptext="InfiniBand Switch"
                       ;;
  "OCM Ethernet Switch Check")
                       ghs_ctype="TOR Switches"
                       crh_rep_prefix="torswitch"
                       crh_rep_ptext="TOR Switch"
                       ;;
  "OS Check")
                       ghs_ctype="${crh_rep_ptext}s"
                       ;;
  "Database Check"|"SQL Check")
                       ghs_ctype="Databases"
                       ;;
  "Patch Check")
                       ghs_ctype="Homes"
                       ;;
  "ORACLE_HOME Check")
                       ghs_ctype="ORACLE_HOME's"
                       ;;
  "ASM Check")
                       ghs_ctype="ASM Instances"
                       ;;
  "SQL Parameter Check")
                       ghs_ctype="Instances"
                       ;;

  *)
                       if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 && `echo "${G_CHECKID_TYPE[$crh_cnt]}" | grep -c "Check"` -gt 0 ]] ; then
                         runcomp=$(echo "${G_CHECKID_TYPE[$crh_cnt]}" | sed 's/ Check//')
                         ghs_ctype="${runcomp} Servers"
                       else
                         ghs_ctype="${crh_rep_ptext}s"
                       fi
                       ;;
  esac

  tmp_crh_hosts=""
  par_match=0
  if [ $ghs_status -eq "2" ]
  then
    #exalogic hybrid(virtual + physical division)
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
    then
      if [[ ! -z "$phy_nodes" ]] && [[ $crh_rep_prefix = "compute" ]]
      then
        tmp_crh_hosts=$(echo "${G_CHECKID_HOSTS[$crh_cnt]}"|sed 's/ //g')
        if [[ "$tmp_crh_hosts" = "$phy_nodes" ]] 
	then
          crh_hosts="All Physical Compute Nodes"
        else
	  phy_cnt=0
	  
	  tmp_ifs=$IFS
	  IFS=$',';
	  for ind_phy_node in `echo "$phy_nodes"`
	  do
	    if [ `echo "$tmp_crh_hosts"|grep -icw "$ind_phy_node"` -gt 0 ]
	    then
	      phy_cnt=1
	    fi
	  done
	  IFS=$tmp_ifs

	  if [ $phy_cnt -eq 1 ]
	  then
	     par_match=1	
	  else
	     if [[ "$tmp_crh_hosts" = "$exa_vcomp_list" ]]
	     then 
	       crh_hosts="All Virtual Compute Nodes"
	     else
	       par_match=1	
	     fi
	  fi
        fi
      else
        par_match=1
      fi
    else
      par_match=1
    fi
    if [ $par_match -eq 1 ]
    then
      ghs_cnt=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print NF}')
      if [ $ghs_cnt -gt $G_HOST_CNT ]
      then
        crh_host_names=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | cut -d"," -f"1-5") #First 5 hosts
        crh_hosts="<a href=\"#${G_CHECKIDS[$crh_cnt]}_machines\" title=\"${G_CHECKID_HOSTS[$crh_cnt]}\">${crh_host_names}  more</a>";
      else
        crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}
      fi
    fi
  else
    if [ "${G_CHECKID_TYPE[$crh_cnt]}" = "$html_rack_type Wide Check" ]
    then
      crh_hosts="$html_rack_type Wide"
      crh_rep_prefix="cluster"
	if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	  crh_rep_prefix="system"
        fi
      crh_rep_ptext="$html_rack_type Wide"
    else
      if [ "${G_CHECKID_TYPE[$crh_cnt]}" = "System Wide Check" ]
      then
        crh_hosts="System Wide"
        crh_rep_prefix="system"
        crh_rep_ptext="System Wide"
      else
        #exalogic hybrid(virtual + physical division)
        if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
	then
          crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}
        else
          if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
          then
            if [[ ! -z "$phy_nodes" ]] && [[ $crh_rep_prefix = "compute" ]]
	    then
              tmp_crh_hosts=$(echo "${G_CHECKID_HOSTS[$crh_cnt]}"|sed 's/ //g');
              if [ `echo "$tmp_crh_hosts"|grep -ic "$phy_nodes"` -gt 0 ]
	      then
		if [[ "$tmp_crh_hosts" = "$phy_nodes" ]] 
		then
		  crh_hosts="All Physical Compute Nodes"
		else
		  crh_hosts="All Compute Nodes"
		fi
              else
                phy_match_cnt=0
	  	tmp_ifs=$IFS
		IFS=$',';
                for exa_phy_node in `echo "$phy_nodes"`
                do
                  if [ `echo "$tmp_crh_hosts"|grep -icw "$exa_phy_node"` -gt 0 ]
	     	  then 
	       	    phy_match_cnt=1 
		  fi
                done
		IFS=$tmp_ifs

                if [[ $phy_match_cnt -eq 0 ]]
                then
                  crh_hosts="All Virtual Compute Nodes"
                else
                  ghs_cnt=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print NF}')
                  if [ $ghs_cnt -gt $G_HOST_CNT ]
                  then
                    crh_host_names=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | cut -d"," -f"1-5")
                    crh_hosts="<a href=\"#${G_CHECKIDS[$crh_cnt]}_machines\" title=\"${G_CHECKID_HOSTS[$crh_cnt]}\">${crh_host_names}  more</a>";
                  else
                    crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}
                  fi
                fi
              fi
            else
              crh_hosts="All $ghs_ctype"
            fi
	  elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	    l_ea_dom0_nodes=$(echo "$ea_dom0_nodes"|sort)
	    l_nodearr=$(echo "$nodearr"|sort)

	    if [[ $l_ea_dom0_nodes = $l_nodearr ]]; then
	      crh_hosts="All $ghs_ctype"
	    else
	      FOXTROT_DOM0_CNT=$(echo "$ea_dom0_nodes"|wc -l|sed 's/ //g');	      
	      FOXTROT_COMPUTE_CNT=$(echo "$ea_dom0_nodes"|wc -l|sed 's/ //g');
	      HOST_CNT=$(cat $HOSTLIST|wc -l|sed 's/ //g');
	
	      DOM0_COM_CNT=$(expr $FOXTROT_DOM0_CNT + $FOXTROT_COMPUTE_CNT);

	      if [[ $HOST_CNT -eq $DOM0_COM_CNT ]]; then
		crh_hosts="All $ghs_ctype"
	      else  	
	        crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}	
	      fi
	    fi	    	
          else
            crh_hosts="All $ghs_ctype"
          fi
        fi
      fi
    fi
  fi
  if [[ $crh_rep_prefix = "torswitch" ]]; then
    crh_hosts="All TOR Switches"
  fi
}

# Below function writes a row report directly to the <status>.html which later gets appended
# to raccheck.html. Some cluster-wide-checks does not use log_fail infrastructure. 
# This function is called in such cases. Status on is always "All" as its cluster-wide-check
# Input:
#    Status (FAIL/PASS etc)
#    Message (Actual message)
# Output:
#    <status>.html
write_cwc_status_html ()
{
  wts_status=$1
  wts_msg=$2

  if [[ $wts_status = "PASS" ]]
  then
	cat > ${OUTPUTDIR}/PASS_cluster_header.html <<EOF
             <a name="failed_checks_cluster"></a>
             <H2>$html_rack_type Wide</h2>
             <table border=1 id="failedtbl_cluster" summary="Failed checks">
             <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
             <th scope="col">Status</th>
             <th scope="col">Type</th>
             <th scope="col">Message</th>
             <th scope="col">Status On</th>
             <th scope="col">Details</th></tr>
EOF
        wts_status1="<span class=\"status_PASS\">PASS</span>"

    echo "<tr class = \"$wts_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'>-</td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_cluster', this,'')\">$wts_status1</td><td class=\"check-name\">$html_rack_type Wide Check</td><td class=\"check-message\" scope=\"row\">$wts_msg</td><td class=\"check-status-on\">$html_rack_type Wide</td><td class=\"check-view-link\">-</td></tr>" >> ${OUTPUTDIR}/PASS_cluster.html
  else
    if [[ $wts_status = "ERROR" || $wts_status = "FAIL" || $wts_status = "WARNING" || $wts_status = "INFO" ]]
    then
      wts_file_name="${OUTPUTDIR}/${wts_status}_cluster.html"
    else
      wts_file_name="${OUTPUTDIR}/OTHER_cluster.html"
    fi

    if [[ $wts_status = "FAIL" ]]
    then
        wts_status1="<span class=\"status_FAIL\">FAIL</span>"
    elif [[ $wts_status = "WARNING" ]]
    then
        wts_status1="<span class=\"status_WARNING\">WARNING</span>"
    else
        wts_status1="<span class=\"status_INFO\">INFO</span>"
    fi

    echo "<tr class = \"$wts_status check-result\"><td class=\"check-id\" name='checkid' style='DISPLAY: none'>-</td><td class=\"check-result\"><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_cluster', this,'')\">$wts_status1</td><td class=\"check-name\">$html_rack_type Wide Check</td><td class=\"check-message\" scope=\"row\">$wts_msg</td><td class=\"check-status-on\">$html_rack_type Wide</td><td class=\"check-view-link\">-</td></tr>" >> $wts_file_name
  fi
  let g_tr_index=$g_tr_index+1
}

# This function creates the raccheck.html file by appending all the <checkid>.html files
# Output:
#   raccheck.html
create_raccheck_html ()
{
  crh_obname=$(basename $OUTPUTDIR)
  HTML_REPFILE=${OUTPUTDIR}/${crh_obname}.html 
  HTML_PASS_FILE=${OUTPUTDIR}/passed_checks.html
  HTML_FAILED_FILE=${OUTPUTDIR}/failed_checks.html
  HTML_MAA_SC=${OUTPUTDIR}/maa_scorecard.html
  HTML_ACCHK_SC=${OUTPUTDIR}/acchk_scorecard.html
  HTML_ACCHK_SC_PASS=${OUTPUTDIR}/acchk_scorecard_pass.html
  TOOL_NAME=$program_name
  if [[ -n "$ZFSIP" && ! -e $ZFSIP && -e $OUTPUTDIR/zfsip.ora ]] ; then
    ZFSIP=$OUTPUTDIR/zfsip.ora
  fi
  if [[ -n "$EXTZFSIP" && ! -e $EXTZFSIP && -e $OUTPUTDIR/extcellip.ora ]] ; then
    EXTZFSIP=$OUTPUTDIR/extcellip.ora
  fi

  # Append all ACCHK files
  if [[ -n "$run_acchk" && $run_acchk -eq "1" ]]
  then
    acchk_toc_entry="<li><a href=\"#acchk_scorecard\">Application Continuity Summary</a></li>"
    cat > $HTML_ACCHK_SC <<EOF
      <a href="#"  class="a_bgw">Top</a>
      <a name="acchk_scorecard"></a>
      <H2>Application Continuity Summary</h2>
           <table border=1 id="acchksctbl_${crh_rep_prefix}" summary="Application Continuity Summary">
           <tr><th>Outage Type</th>
           <th scope="col">Status</th>
           <th scope="col">Message</th></tr><tr>.</tr>
EOF

    if [[ $print_pass_on_screen -eq 0 ]]
    then
      cat > $HTML_ACCHK_SC_PASS <<EOF
      <a href="#"  class="a_bgw">Top</a>
      <a name="acchk_scorecard"></a>
      <H2>Application Continuity Summary</h2>
           <table border=1 id="acchksctbl_${crh_rep_prefix}" summary="Application Continuity Summary">
           <tr><th>Outage Type</th>
           <th scope="col">Status</th>
           <th scope="col">Message</th></tr><tr>.</tr>
EOF
    fi

    for acchk_sf2 in "concrete" "coverage"
    do
      file=`ls ${OUTPUTDIR}/*$acchk_sf2*`
      ot=`echo $acchk_sf2|tr "[a-z]" "[A-Z]"`
      if [ ! -e $file ]
      then
      	continue;
      fi

      if [ $acchk_sf2 == "concrete" ]
      then
	#msg=`grep "Total :" $file`
        #echo "<tr><td>Concrete class checks</td><td></td><td>" >> $HTML_ACCHK_SC
       
	TOT=`grep "Total :" $file|awk -F':' '{print $2}'|sed -e 's/ Passed //'|sed -e 's/^[ \t]*//'`
	PASSED=`grep "Total :" $file|awk -F':' '{print $3}'|sed -e 's/ Warning //'|sed -e 's/^[ \t]*//'`
	WARNING=`grep "Total :" $file|awk -F':' '{print $4}'|sed -e 's/ Failed //'|sed -e 's/^[ \t]*//'`
	FAILED=`grep "Total :" $file|awk -F':' '{print $5}'|sed -e 's/^[ \t]*//'`
	msg=`grep "Total :" $file`

	if [ -n "$msg" ]
	then
	  echo "<tr><td>Concrete class checks</td><td></td><td>" >> $HTML_ACCHK_SC
	  echo "<b>$msg (Failed check count is one per file)</b></td></tr>" >> $HTML_ACCHK_SC	

          if [[ $print_pass_on_screen -eq 0 ]]
          then
           echo "<tr><td>Concrete class checks</td><td></td><td>" >> $HTML_ACCHK_SC_PASS
           echo "<b>$msg</b></td></tr>" >> $HTML_ACCHK_SC_PASS
          fi
	else
	  TOT=0;PASSED=0;WARNING=0;FAILED=0;
	fi

        for fail in `grep "\[FAILED\]" $file`
        do
          stat=`echo $fail|awk -F'=>' '{print $1}'|sed -e 's/\[//'|sed -e 's/\]//'`
          msg=`echo $fail|awk -F'=>' '{print $2}'|sed 's/ //'`
	  if [[ $msg = \[oracle/xdb* || $msg = \[oracle/jdbcj* || $msg = \[oracle/sql* || $msg = \[oracle/jpub* ]]
          then
	    echo "" >> $LOGFIL
	  else
            echo "<tr><td></td><td scope=\"col\">$stat</td><td scope=\"col\">$msg</td></tr>" >> $HTML_ACCHK_SC
	  fi
        done
        for fail in `grep "\[INFO\]" $file`
        do
          stat=`echo $fail|awk -F'=>' '{print $1}'|sed -e 's/\[//'|sed -e 's/\]//'`
          msg=`echo $fail|awk -F'=>' '{print $2}'|sed 's/ //'`
	  if [[ $msg = \[oracle/xdb* || $msg = \[oracle/jdbcj* || $msg = \[oracle/sql* || $msg = \[oracle/jpub* ]]
          then
	    echo "" >> $LOGFIL
	  else
            echo "<tr><td></td><td scope=\"col\">$stat</td><td scope=\"col\">$msg</td></tr>" >> $HTML_ACCHK_SC
	  fi
        done
        for fail in `grep "\[WARNING\]" $file`
        do
          stat=`echo $fail|awk -F'=>' '{print $1}'|sed -e 's/\[//'|sed -e 's/\]//'`
          msg=`echo $fail|awk -F'=>' '{print $2}'|sed 's/ //'`
	  if [[ $msg = \[oracle/xdb* || $msg = \[oracle/jdbcj* || $msg = \[oracle/sql* || $msg = \[oracle/jpub* ]]
          then
	    echo "" >> $LOGFIL
	  else
            echo "<tr><td></td><td scope=\"col\">$stat</td><td scope=\"col\">$msg</td></tr>" >> $HTML_ACCHK_SC
	  fi
        done
        for fail in `grep "\[PASS\]" $file`
        do
          stat=`echo $fail|awk -F'=>' '{print $1}'|sed -e 's/\[//'|sed -e 's/\]//'`
          msg=`echo $fail|awk -F'=>' '{print $2}'|sed 's/ //'`
	  if [[ $msg = \[oracle/xdb* || $msg = \[oracle/jdbcj* || $msg = \[oracle/sql* || $msg = \[oracle/jpub* ]] 
	  then
	    echo "" >> $LOGFIL
	  else
	   if [[ $print_pass_on_screen -eq 0 ]]
	   then
             echo "<tr><td></td><td scope=\"col\">$stat</td><td scope=\"col\">$msg</td></tr>" >> $HTML_ACCHK_SC_PASS
	   else
	     echo "<tr><td></td><td scope=\"col\">$stat</td><td scope=\"col\">$msg</td></tr>" >> $HTML_ACCHK_SC
	   fi
	  fi
        done
      fi
      if [ $acchk_sf2 == "coverage" ]
      then
        msg=`grep "TotalRequest =" $file`;TOT_COV=`grep "TotalRequest =" $file|awk -F'=' '{print $2}'|sed -e 's/^[ \t]*//'`;
	if [ -n "$msg" ]
	then
	  echo "<tr>.</tr><tr><td>Coverage checks</td><td></td><td>" >> $HTML_ACCHK_SC
	  echo "<b>$msg<br>" >> $HTML_ACCHK_SC
	 if [[ $print_pass_on_screen -eq 0 ]]
	 then
	  echo "<tr>.</tr><tr><td>Coverage checks</td><td></td><td>" >> $HTML_ACCHK_SC_PASS
          echo "<b>$msg<br>" >> $HTML_ACCHK_SC_PASS
	 fi
          msg=`grep "PASS =" $file`;PASS_COV=`grep "PASS =" $file|awk -F'=' '{print $2}'|sed -e 's/^[ \t]*//'`;
	  echo "$msg<br>" >> $HTML_ACCHK_SC
	 if [[ $print_pass_on_screen -eq 0 ]]
	 then
	  echo "$msg<br>" >> $HTML_ACCHK_SC_PASS
  	 fi
          msg=`grep "WARNING =" $file`;WARN_COV=`grep "WARNING =" $file|awk -F'=' '{print $2}'|sed -e 's/^[ \t]*//'`;
	  echo "$msg<br>" >> $HTML_ACCHK_SC
	if [[ $print_pass_on_screen -eq 0 ]]
        then
	  echo "$msg<br>" >> $HTML_ACCHK_SC_PASS
  	fi
          msg=`grep "FAIL =" $file`;FAIL_COV=`grep "FAIL =" $file|awk -F'=' '{print $2}'|sed -e 's/^[ \t]*//'`;
	  echo "$msg</b></td><tr>" >> $HTML_ACCHK_SC
	if [[ $print_pass_on_screen -eq 0 ]]
	then
	  echo "$msg</b></td><tr>" >> $HTML_ACCHK_SC_PASS
	fi
	else
	  TOT_COV=0;PASS_COV=0;WARN_COV=0;FAIL_COV=0;
	fi

	pass=0;

        for line in `cat $file`
        do
          line=`echo "$line" | sed -e 's/^[ \t]*//'`
          if [ ${line:0:1} == "[" ]; then
            stat=`echo $line|awk -F' ' '{print $1}'|sed -e 's/\[//'|sed -e 's/\]//'`
            msg=`echo $line|sed -e 's/$stat//'`
	    if [[ $stat == "PASS" &&  $print_pass_on_screen -eq 0 ]]; then
	      echo "<tr><td></td><td scope=\"col\">$stat</td><td scope=\"col\">$msg<br>" >> $HTML_ACCHK_SC_PASS
	      pass=1;
	    else
	      echo "<tr><td></td><td scope=\"col\">$stat</td><td scope=\"col\">$msg<br>" >> $HTML_ACCHK_SC
	    fi
          fi
          if [[ $line =~ "SERVICE NAME" ]]
          then
	    if [[ $pass -eq "1" ]]
	    then
	      echo "$line<br>" >> $HTML_ACCHK_SC_PASS
	    else
	      echo "$line<br>" >> $HTML_ACCHK_SC
	    fi
          fi
	if [[ $line =~ "Coverage" ]]
          then
            if [[ $pass -eq "1" ]]
            then
	     pass=0;	
              echo "$line</td></tr>" >> $HTML_ACCHK_SC_PASS
            else
              echo "$line</td></tr>" >> $HTML_ACCHK_SC
            fi
          fi

        done
      fi
    done

    HTML_ACCHK_SC_PASS_PRINT=${OUTPUTDIR}/reports/acchk_scorecard_pass.html
   if [[ $print_pass_on_screen -eq 0 ]]
   then
    echo "<tr><td></td><td scope=\"col\">PASS</td><td scope=\"col\">Report containing checks that passed: $HTML_ACCHK_SC_PASS_PRINT</td></tr>" >> $HTML_ACCHK_SC
    echo "<tr>.</tr></table>" >> $HTML_ACCHK_SC_PASS
   fi
    echo "<tr>.</tr></table>" >> $HTML_ACCHK_SC

    tot_acchk=$(perl -e "printf \"%.0f\", ($TOT+$TOT_COV)*10;")
    pass_acchk=$(perl -e "printf \"%.0f\", ($PASSED+$PASS_COV)*10;")
    warn_acchk=$(perl -e "printf \"%.0f\", ($WARNING+$WARN_COV)*5;")
    fail_acchk=$(perl -e "printf \"%.0f\", ($FAILED+$FAIL_COV)*10;")
  fi

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$is_ssc_machine" && $is_ssc_machine -eq 1 ]] ||  [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]] || [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
    #Generate Infrastructure Software and Configuration Summary
    #chmod 544 $SCRIPTPATH/.cgrep/isc_summary.pl >/dev/null 2>&1
    security_fix "fix_plugin_or_rtscript_attributes" "$RTEMPDIR/isc_summary.pl" "" "540"
    if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
      echo "$perl_exe $RTEMPDIR/isc_summary.pl -o ${OUTPUTDIR} -n ${OUTPUTDIR}/o_host_list.out -c ${CELLDIR}/cells.out -s ${OUTPUTDIR}/o_ibswitches.out -t \"is_db_machine_compute:$db_machine_compute,is_ssc_machine:$is_ssc_machine,is_exalytics_machine:$is_exalytics_machine\""
    fi
    $perl_exe $RTEMPDIR/isc_summary.pl -o ${OUTPUTDIR} -n ${OUTPUTDIR}/o_host_list.out -c ${CELLDIR}/cells.out -s ${OUTPUTDIR}/o_ibswitches.out -t "is_db_machine_compute:$db_machine_compute,is_ssc_machine:$is_ssc_machine,is_exalytics_machine:$is_exalytics_machine"
  fi

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
  then
    SYSTEM_NAME="Exadata"
    if [[ "$is_avm_machine" &&  $is_avm_machine -eq 1 ]]; then SYSTEM_NAME="Recovery Appliance";fi
    if [ -e "$OUTPUTDIR/check_env.out" ]
    then
      MASTERFIL1=$OUTPUTDIR/check_env.out
    else
      MASTERFIL1=$OUTPUTDIR/raccheck_env.out
    fi
    if [ -n "$MERGEFILES" ]
    then
      MASTERFIL1=$NEW_MASTERFIL1;
    fi
    #Generate Version Matrix (in MAA Section)
    #chmod 544 $SCRIPTPATH/.cgrep/create_version.pl >/dev/null 2>&1
    security_fix "fix_plugin_or_rtscript_attributes" "$RTEMPDIR/create_version.pl" "" "540"
    if [[ $OFFLINE -eq 1 ]];
    then
      if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
        echo "$perl_exe $RTEMPDIR/create_version.pl ${OUTPUTDIR} ${OUTPUTDIR} ${MASTERFIL1}"
      fi
      $perl_exe $RTEMPDIR/create_version.pl ${OUTPUTDIR} ${OUTPUTDIR} ${MASTERFIL1}
    else
      if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
        echo "$perl_exe $RTEMPDIR/create_version.pl ${OUTPUTDIR} ${OUTPUTDIR} ${MASTERFIL1}"
      fi
      $perl_exe $RTEMPDIR/create_version.pl ${OUTPUTDIR} ${INPUTDIR} ${MASTERFIL1}
    fi 
  elif [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
  then
    SYSTEM_NAME="Database Appliance"
  elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]
  then
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]
    then
      SYSTEM_NAME="Public Cloud Machine"
    else
      SYSTEM_NAME="Exalogic"
    fi
  elif [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]] ; then
    SYSTEM_NAME="ZFS Storage Appliance"
  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    SYSTEM_NAME="Exalytics"
  elif [[ -n "$single_instance_run" && $single_instance_run -eq 1 ]]
  then
    #report header change as requested by Support for EBS
    SYSTEM_NAME=${program_name}
    if [[  -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]]; then SYSTEM_NAME="Identity Management"; fi
  elif [[  -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
  then
    SYSTEM_NAME="Big Data Appliance"
  elif [[  -n "$is_opc" && $is_opc -eq 1 ]]
  then
    SYSTEM_NAME="Public Compute"
  elif [[  -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]]
  then
    SYSTEM_NAME="Identity Management"
  else
    SYSTEM_NAME="RAC"
  fi
  if [[ -n "$RAT_TORSWITCHES" ]]
  then
    SYSTEM_NAME="Top of Rack Switch"
  fi
  if [[ -n "$run_acchk" && $run_acchk -eq "1" ]]
  then
    SYSTEM_NAME="Application Continuity";
  fi 

  if [[ -n "$is_minicluster" && $is_minicluster -eq "1" ]]
  then
    SYSTEM_NAME="MiniCluster";
  fi

  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
    SYSTEM_NAME="Storage Server"
  fi

  if [[ -n "$upgrade_mode" && $upgrade_mode -gt 0 ]]
  then
    report_type="Upgrade Readiness"
  else
    report_type="Assessment"
  fi

  if [[ -n "$fmw_runmode" && $fmw_runmode = "pre" ]] ; then
    report_type="Pre-Install Assessment"
  elif [[ -n "$fmw_runmode" && $fmw_runmode = "post" ]] ; then
    report_type="Post-Install Assessment"
  fi

  # System Health Score
  let crh_failed_checks=$G_FAIL_CHECKS+$G_WARN_CHECKS+$G_INFO_CHECKS+$G_SKIP_CHECKS
  #let crh_failed_checks=$G_FAIL_CHECKS+$G_WARN_CHECKS+$G_INFO_CHECKS
  let crh_passed_checks=$G_TOTAL_CHECKS-$crh_failed_checks

  if [ -n "$MERGEFILES" ]
  then
    if [ -e "$CELLIBNTFILE" ]
    then
      up_cell_ib_fail_count=$(grep 'FAIL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      up_cell_ib_warn_count=$(grep 'WARN' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      up_cell_ib_info_count=$(grep 'INFO' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      up_cell_ib_total_count=$(grep 'TOTAL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      
      let cell_ib_failed_checks=$up_cell_ib_fail_count+$up_cell_ib_warn_count+$up_cell_ib_info_count
      let crh_failed_checks=$crh_failed_checks+$cell_ib_failed_checks
      let crh_passed_checks=$crh_passed_checks+$up_cell_ib_total_count-$cell_ib_failed_checks
      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$up_cell_ib_total_count; 
      validate_needs_running;
    fi
  fi
 
  if [[ -z $MERGEFILES ]]; then 
  echo "TOTAL=$G_TOTAL_CHECKS
PASS=$crh_passed_checks
FAIL=$G_FAIL_CHECKS
WARN=$G_WARN_CHECKS
INFO=$G_INFO_CHECKS
SKIP=$G_SKIP_CHECKS" > $CHECKSFILE;
  fi

  zfscnt=0
  ibscnt=0
  torscnt=0
  cncount=0
  dbserverscnt=0
  elsnodecnt=0
  cells_cnt=0
  
  if [ -e "$ZFSIP" ]
  then
    zfscnt=$(cat $ZFSIP|wc -l)
  fi
  
  if [ -e "$OUTPUTDIR/o_ibswitches.out" ]
  then
    ibscnt=$(cat $OUTPUTDIR/o_ibswitches.out|wc -l)
  fi
  
  if [ -n "$RAT_TORSWITCHES" ]
  then
    torscnt=$(echo -e "$RAT_TORSWITCHES" | tr ' ' '\n' | tr ',' '\n' | wc -l)
  fi

  get_dbserverscnt;
  
  if [ -e "$CELLDIR/cells.out" ]
  then
    cells_cnt=$(cat $CELLDIR/cells.out|wc -l)
  fi
  let cncount=$dbserverscnt+$cells_cnt+$elsnodecnt

  if [ $zfscnt -ne 0 ]
  then  
    #G_CELL=$(echo "$G_CELL/$zfscnt" | bc);
    let G_CELL=$G_CELL/$zfscnt;
  fi
  if [ $ibscnt -ne 0 ] 
  then
    #G_SWITCH=$(echo "$G_SWITCH/$ibscnt" | bc);
    let G_SWITCH=$G_SWITCH/$ibscnt;
  fi
  if [ $torscnt -ne 0 ] 
  then
    let G_TORSWITCH=$G_TORSWITCH/$torscnt;
  fi
  if [ $cncount -ne 0 ] 
  then
    if [ $is_windows -eq "1" ] ; then
      G_COMPUTE=$(perl -e "printf \"%.0f\", $G_COMPUTE/$cncount;")
    else
      #G_COMPUTE=$(echo "$G_COMPUTE/$cncount" | bc);
      let G_COMPUTE=$G_COMPUTE/$cncount;
    fi
  fi
  
 # Score reduction due to Skipped components 
 if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
 then
   if [[ -e "$OUTPUTDIR/${program_name}_skipped_nodes_txt.log" ]] ; then
     for nodeval in `cat $OUTPUTDIR/${program_name}_skipped_nodes_txt.log`
     do
       if [[ -e $WRKDIR/o_storage.out && `grep -iwc "$nodeval" $WRKDIR/o_storage.out` -gt "0" ]]
       then
         let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$G_CELL;
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+$G_CELL;
       elif [[ -e $WRKDIR/o_ibswitches.out && `grep -iwc "$nodeval" $WRKDIR/o_ibswitches.out` -gt "0" ]]
       then
         let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$G_SWITCH;
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+$G_SWITCH;
       else
         let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$G_COMPUTE;
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+$G_COMPUTE;
       fi
     done
    fi
  fi

  let crh_total_points=$G_TOTAL_CHECKS*10
 
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    let crh_err_points=$G_FAIL_CHECKS*10+$G_WARN_CHECKS*5+$G_INFO_CHECKS_SCORE*3+$G_SKIP_CHECKS*10
  else
    let crh_err_points=$G_FAIL_CHECKS*10+$G_WARN_CHECKS*5+$G_INFO_CHECKS_SCORE*3+$G_SKIP_CHECKS*3
  fi

  let crh_less_points=$crh_total_points-$crh_err_points
  crh_health=0
  crh_health_int=0
  crh_health_text="";
  if [[ $crh_total_points -gt "0" && `echo $components|grep -icw EXALOGIC_VM` -lt 1 ]]
  then
    crh_health=$(perl -e "printf \"%.0f\", int(($crh_less_points*100)/$crh_total_points);")
    crh_health_int=$(perl -e "printf \"%.0f\", ($crh_less_points*100)/$crh_total_points;")
    crh_health_text="";
  fi

  crh_bar_color="#00FF00" # Green.. everything is passed
  if [[ -n "$crh_health_int" &&  $crh_health_int -lt 75 ]]
  then # less than 75.. bad condition
    crh_bar_color="#FF0000"
  elif [[ $crh_health_int -ge 75 && $crh_health_int -lt 85 ]]
  then # Better.. dark orange
    crh_bar_color="#FF6600"
  elif [[ $crh_health_int -ge 85 && $crh_health_int -lt 100 ]]
  then # Better.. dark orange
    crh_bar_color="#FF9933"
  fi
  # Number of nodes in cluster by type
  dbservers_cnt=0
  cells_cnt=0
  ibs_cnt=0
  tors_cnt=0
  zfs_cnt=0
  dbservers_link=""
  cells_link=""
  ibs_link=""
  tor_sw_link=""
  ogg_homes_link=""

  # Cluster, platform details are read from end file in offline mode
  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    MASTERFIL1=$OUTPUTDIR/check_env.out
  else
    MASTERFIL1=$OUTPUTDIR/raccheck_env.out
  fi
  if [ -n "$MERGEFILES" ]
  then
    MASTERFIL1=$NEW_MASTERFIL1;
    #rm $HOSTLIST
    HOSTLIST=$WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge

    single_instance_run=`grep SINGLE_INSTANCE_RUN $MASTERFIL1 | awk '{print $3}'` 
    oracle_restart=`grep ORACLE_RESTART $MASTERFIL1 | awk '{print $3}'`
  fi

  el_db_node=""
  el_ec1_node=""
  el_ovmm_node=""
  el_pc_nodes=""
  el_pc1_node=""
  el_pc2_node=""
  el_exclude=""
  if [[ -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ;then
    el_db_node=$(grep '\.COMPONENT = .*EXALOGIC_DB' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_ec1_node=$(grep '\.COMPONENT = .*EXALOGIC_EC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_ovmm_node=$(grep '\.COMPONENT = .*EXALOGIC_OVMM' $MASTERFIL1 |sed 's/\.COMPONENT.*//' | sort -u| sed 's/ //g')
    el_pc_nodes=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_pc1_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | head -1| sed 's/ //g')
    el_pc2_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | tail -1| sed 's/ //g')
  fi

  if [ -e "$HOSTLIST" ]
  then
    dbservers_cnt=0
    p_dbservers_cnt=0
    v_dbservers_cnt=0
    el_snode_cnt=0
    exa_vcomp_list=""
    foxtrot_dom0_cnt=0
    foxtrot_dom0_link=""
    foxtrot_cvm_cnt=0
    foxtrot_cvm_link=""
    for hostname in `grep "[a-zA-Z0-9]" $HOSTLIST`
    do
      skip_this_node=0
      for xdir in $dirarr
      do
        xdir=$(echo $xdir|sed 's/\.zip//g');
        run_oncell=$(grep RUNNING_ONCELL ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
        if [[ -n "$run_oncell" && $run_oncell -eq "1" ]]; then
 	  TCELLDIR="$xdir/.CELLDIR";
          if [[ -n "$TCELLDIR" && -e "$TCELLDIR/cells.out" ]]; then
      	    if [[ `grep -icw "$hostname" $TCELLDIR/cells.out` -gt "0" ]]; then skip_this_node=1; break; fi
      	  fi
        fi
      done
      if [[ -n "$skip_this_node" && $skip_this_node -eq "1" ]]; then continue; fi

      db_server_component=""	
      if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
      then
        db_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep -w $hostname|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
        if [[ -n "$db_server_component" ]]
        then
	  if [[ "$db_server_component" = "NONE" ]]
	  then
	    db_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep -w $hostname|cut -d: -f2|sed 's/ //g'`
	  fi

          if [[ "$db_server_component" = "EXADATA" ]]
          then
            db_server_component="V2"
          elif [[ "$db_server_component" = "EDVM" ]]
          then
	    db_server_component="Exadata VM Guest"  
          elif [[ $(echo "$db_server_component"|grep -ic VMX) -ge 1 || $(echo "$db_server_component"|grep -ic VMEIGHTHX) -ge 1 ]]
          then 
            db_server_component=$(echo $db_server_component|sed 's/VM/DOM0 /g')
          fi
          db_server_component=' : '$db_server_component
        fi
      fi
	
      if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
      then
	skipnode=`grep LOCALNODE $MASTERFIL1 |awk '{print $3}'`
        if [ $hostname = $skipnode ]
        then
          continue
        fi
      fi

      if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] ; then
        db_server_component=$(grep -iw FMW_RUNNING_COMPS $MASTERFIL1 |grep -w $hostname|cut -d= -f2|sed 's/ //g'| sed 's/^://')
        db_server_component=" - $db_server_component"
      fi

      if [[  -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ; then
        if [[ $hostname != $el_db_node && $hostname != $el_ec1_node && $hostname != $el_ovmm_node && `grep -ic "$hostname\.COMPONENT.*EXALOGIC_PC" $MASTERFIL1` -eq "0" ]] ; then
          dbservers_cnt=$(expr $dbservers_cnt + 1);

	  is_it_physical_node=0	
	  if [ ! -z "$phy_nodes" ]
          then
	    if [ `echo "$phy_nodes"|grep -ic "$hostname"` -gt 0 ]
	    then
	      is_it_physical_node=1	
	    else
	      exa_vcomp_list=$exa_vcomp_list,$hostname
	    fi
	    
	    if [[ -n "$is_it_physical_node" && $is_it_physical_node -eq "1" ]]
            then
              p_dbservers_cnt=$(expr $p_dbservers_cnt + 1);
	      p_dbservers_link="<br>&nbsp;&nbsp;${hostname}${p_dbservers_link}"
	    else
              v_dbservers_cnt=$(expr $v_dbservers_cnt + 1);
              v_dbservers_link="<br>&nbsp;&nbsp;${hostname}${v_dbservers_link}" 
	    fi
	  else
	    dbservers_link="<br>&nbsp;&nbsp;${hostname}${dbservers_link}"
	  fi
        else
          el_snode_cnt=$(expr $el_snode_cnt + 1)
        fi
      elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        if [[ `echo "$ea_dom0_nodes" | grep -ic "$hostname"` -le 0 ]]; then
          foxtrot_cvm_cnt=$(expr $foxtrot_cvm_cnt + 1)
	  foxtrot_cvm_link="<br>&nbsp;&nbsp;${hostname}${foxtrot_cvm_link}"
        else
          foxtrot_dom0_cnt=$(expr $foxtrot_dom0_cnt + 1) 
	  foxtrot_dom0_link="<br>&nbsp;&nbsp;${hostname}${foxtrot_dom0_link}"
        fi
        dbservers_cnt=$(expr $dbservers_cnt + 1);
      else
        dbservers_cnt=$(expr $dbservers_cnt + 1);
        dbservers_link="<br>&nbsp;&nbsp;${hostname}${db_server_component}${dbservers_link}" 
      fi
    done
    exa_vcomp_list=$(echo "$exa_vcomp_list"|sed 's/^,//g'|sed 's/,$//g')

    if [ ! -z "$phy_nodes" ]
    then
      p_dbservers_link="<a href=\"javascript:ShowHideRegion('p_dbservers_summary');\">$p_dbservers_cnt</a><div id=\"p_dbservers_summary\" style=\"DISPLAY: none\">$p_dbservers_link<a href=\"javascript:ShowHideRegion('p_dbservers_summary');\"> ..Hide</a></div>"
      v_dbservers_link="<a href=\"javascript:ShowHideRegion('v_dbservers_summary');\">$v_dbservers_cnt</a><div id=\"v_dbservers_summary\" style=\"DISPLAY: none\">$v_dbservers_link<a href=\"javascript:ShowHideRegion('v_dbservers_summary');\"> ..Hide</a></div>"

      phy_node_dlink=""
      vir_node_dlink=""
      if [ $p_dbservers_cnt != "0" ];
      then
        phy_node_dlink="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Physical Compute Nodes</td><td>$p_dbservers_link</td></tr>"
      fi
      if [ $v_dbservers_cnt != "0" ];
      then
        vir_node_dlink="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Virtual Compute Nodes</td><td>$v_dbservers_link</td></tr>"
      fi
      dbservers_link="$dbservers_cnt"
    else
      dbservers_link="<a href=\"javascript:ShowHideRegion('dbservers_summary');\">$dbservers_cnt</a><div id=\"dbservers_summary\" style=\"DISPLAY: none\">$dbservers_link<a href=\"javascript:ShowHideRegion('dbservers_summary');\"> ..Hide</a></div>"
    fi
  fi
  if [ $dbservers_cnt = "0" ]
  then
    dbservers_link="0"
  fi
  #print goldengate homes and version in report header 
  if [[ -e $OGGHOMESVERSIONFIL && `cat $OGGHOMESVERSIONFIL|wc -l` -gt 0 ]];
  then
      ogg_home_count=0
      for mb_ogg_home_full in `cat  $OGGHOMESVERSIONFIL`
      do
        ogg_home_node=$(echo $mb_ogg_home_full|cut -d'|' -f1|cut -d= -f2)
        ogg_home_home=$(echo $mb_ogg_home_full|cut -d'|' -f2)
        ogg_home_version=$(echo $mb_ogg_home_full|cut -d'|' -f3)
        l_version=$ogg_home_version
        format_l_version 
        ogg_home_all=$(echo $ogg_home_node - $ogg_home_home - $l_version)
        ogg_homes_link="<br>&nbsp;&nbsp;${ogg_home_all}${ogg_homes_link}"
        ogg_home_count=$(expr $ogg_home_count + 1 )
      done     
      ogg_homes_link="<a href=\"javascript:ShowHideRegion('ogg_homes_summary');\">$ogg_home_count</a><div id=\"ogg_homes_summary\" style=\"DISPLAY: none\">$ogg_homes_link<a href=\"javascript:ShowHideRegion('ogg_homes_summary');\"> ..Hide</a></div>"
  else
      ogg_homes_link="0"
  fi 

  if [ -n "$MERGEFILES" ]
  then
    cell_password_status=$(grep CELL_PASSWORD_OPTION $MASTERFIL1 |awk '{print $3}')
    ibswitch_password_status=$(grep IBSWITCH_PASSWORD_OPTION $MASTERFIL1 |awk '{print $3}')	
    zfs_password_status=$(grep ZFS_PASSWORD_OPTION $MASTERFIL1 |awk '{print $3}')	

    #storagecells
    for xdir in $dirarr 
    do
      xdir=$(echo $xdir|sed 's/\.zip//g');
      cell_password_status=$(grep CELL_PASSWORD_OPTION ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
      cell_ssh_user=$(grep CELL_SSH_USER ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
      if [[ -n "$cell_password_status" && $cell_password_status -eq "1" ]] || [[ -n "$cell_password_status" && $cell_password_status -eq "0" && "$cell_ssh_user" = "root" ]]; then
        TCELLDIR="$xdir/.CELLDIR";
        if [[ -n "$TCELLDIR" && -e "$TCELLDIR/cells.out" ]]; then break; fi
      fi
    done

    #zfscells
    for xdir in $dirarr 
    do
      xdir=$(echo $xdir|sed 's/\.zip//g');
      zfs_password_status=$(grep ZFS_PASSWORD_OPTION ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
      if [[ -n "$zfs_password_status" && $zfs_password_status -eq "1" ]]; then 
        TZFSDIR="$xdir"; 
	ZFSIP="$TZFSDIR/.CELLDIR/zfsip.ora"; if [ $is_ssc_machine -eq 1 ]; then ZFSIP=$TZFSDIR/outfiles/zfsip.ora;fi
	if [ -e "$ZFSIP" ]; then break; fi
      fi
    done
    
    #ibswitches
    for xdir in $dirarr 
    do
      xdir=$(echo $xdir|sed 's/\.zip//g');
      ibswitch_password_status=$(grep IBSWITCH_PASSWORD_OPTION ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
      if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -eq "1" ]]; then TIBDIR="$xdir/outfiles"; break; fi
    done
  fi

  #if [[ -n "$CELLDIR" && -e "$CELLDIR/cells.out" && -n "$cell_password_status" && $cell_password_status -ne 3  ]] || [[ -n "$CELLDIR" && -e "$CELLDIR/cells.out" && -n "$MERGEFILES" ]]
  if [[ -n "$CELLDIR" && -e "$CELLDIR/cells.out" && -n "$cell_password_status" && $cell_password_status -ne 3  ]]
  then
    cells_cnt=$(cat $CELLDIR/cells.out|wc -l)
    for cellname in `cat $CELLDIR/cells.out | awk '{print $NF}' | cut -d. -f1`
    do
      storage_server_component=""
      #cellname_short=$(cat $CELLDIR/cells.out|grep -w $cellname|cut -d= -f1|cut -d: -f1|sed 's/ //g')
      cellname_short=$(grep -w $cellname $CELLDIR/cells.out|cut -d= -f1|cut -d: -f1|sed 's/ //g')
      storage_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep -w $cellname_short|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
      cells_link="<br>&nbsp;&nbsp;$cellname : $storage_server_component$cells_link"
    done
    cells_link="<a href=\"javascript:ShowHideRegion('cells_summary');\">$cells_cnt</a><div id=\"cells_summary\" style=\"DISPLAY: none\">$cells_link<a href=\"javascript:ShowHideRegion('cells_summary');\"> ..Hide</a></div>"
  fi
  cells_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Storage Servers</td><td>$cells_link</td></tr>"
  if [ "$cells_cnt" = "0" ]
  then
    cells_link=""
  fi
  #code to generate links for ZFS appliances
  zfs_link=""
  if [ $is_ssc_machine -eq 1 ]; then ZFSIP=$OUTPUTDIR/zfsip.ora;fi
  if [[ -n "$CELLDIR" && -e "$ZFSIP" && -n "$zfs_password_status" && $zfs_password_status -ne 3  ]]
  then
    zfs_cnt=$(cat $ZFSIP|wc -l)
    for zfsname in `cat $ZFSIP |cut -d= -f2 |sed 's/\"//g'`
    do
      zfs_link="<br>&nbsp;&nbsp;$zfsname$zfs_link"
    done
    zfs_link="<a href=\"javascript:ShowHideRegion('zfs_summary');\">$zfs_cnt</a><div id=\"zfs_summary\" style=\"DISPLAY: none\">$zfs_link<a href=\"javascript:ShowHideRegion('zfs_summary');\"> ..Hide</a></div>"
    zfs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;ZFS Storage Appliances</td><td>$zfs_link</td></tr>"
  fi
  #code to generate links for external ZFS appliances
  ext_zfs_link=""
  if [ $is_ssc_machine -eq 1 ]; then EXTZFSIP=$OUTPUTDIR/extcellip.ora;fi
  if [[ -n "$CELLDIR" && -e "$EXTZFSIP" && -n "$zfs_password_status" && $zfs_password_status -ne 3  ]]
  then
    ext_zfs_cnt=$(cat $EXTZFSIP|wc -l)
    for zfsname in `cat $EXTZFSIP |cut -d= -f2 |sed 's/\"//g'`
    do
      ext_zfs_link="<br>&nbsp;&nbsp;$zfsname$ext_zfs_link"
    done
    ext_zfs_link="<a href=\"javascript:ShowHideRegion('ext_zfs_summary');\">$ext_zfs_cnt</a><div id=\"ext_zfs_summary\" style=\"DISPLAY: none\">$ext_zfs_link<a href=\"javascript:ShowHideRegion('ext_zfs_summary');\"> ..Hide</a></div>"
    ext_zfs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;External ZFS Storage Appliances</td><td>$ext_zfs_link</td></tr>"
  fi
  tor_sw_link=""
  if [[ -n "$RAT_TORSWITCHES"  ]]
  then
    tor_sw_cnt=$(echo -e "$RAT_TORSWITCHES" | tr ' ' '\n' | tr ',' '\n' | wc -l)
    for switchname in `echo -e "$RAT_TORSWITCHES" | tr ' ' '\n' | tr ',' '\n'`
    do
      tor_sw_link="<br>&nbsp;&nbsp;$switchname$tor_sw_link"
    done
    tor_sw_link="<a href=\"javascript:ShowHideRegion('tor_sw_summary');\">$tor_sw_cnt</a><div id=\"tor_sw_summary\" style=\"DISPLAY: none\">$tor_sw_link<a href=\"javascript:ShowHideRegion('tor_sw_summary');\"> ..Hide</a></div>"
    tor_sw_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;TOR Switches</td><td>$tor_sw_link</td></tr>"
  fi
  
  if [[ -n "$OUTPUTDIR/o_ibswitches.out" && -e "$OUTPUTDIR/o_ibswitches.out" && -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]]
  then
    ibs_cnt=$(cat $OUTPUTDIR/o_ibswitches.out|wc -l)
    for switchname in `cat $OUTPUTDIR/o_ibswitches.out`
    do
      sw_pname=$switchname
      if [[ `echo $switchname | grep -ic '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -eq 0 ]] ; then
        sw_pname=$(echo $switchname |cut -d. -f1)
      fi
      ibs_link="<br>&nbsp;&nbsp;$sw_pname$ibs_link"
    done
    ibs_link="<a href=\"javascript:ShowHideRegion('ibs_summary');\">$ibs_cnt</a><div id=\"ibs_summary\" style=\"DISPLAY: none\">$ibs_link<a href=\"javascript:ShowHideRegion('ibs_summary');\"> ..Hide</a></div>"
  fi
  ibs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;IB Switches</td><td>$ibs_link</td></tr>"
  if [ "$ibs_cnt" = "0" ]
  then
    ibs_link=""
  fi

  if [ -n "$MERGEFILES" ]; then
    if [[ "$cells_cnt" = "0" && -n "$cell_password_status" && $cell_password_status -ne 3  ]]; then
      cells_cnt=$(cat $TCELLDIR/cells.out|wc -l)
      for cellname in `cat $TCELLDIR/cells.out | awk '{print $NF}' | cut -d. -f1`
      do
        storage_server_component=""
        cellname_short=$(grep -w $cellname $TCELLDIR/cells.out|cut -d= -f1|cut -d: -f1|sed 's/ //g')
        storage_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep -w $cellname_short|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
        cells_link="<br>&nbsp;&nbsp;$cellname : $storage_server_component$cells_link"
      done
      cells_link="<a href=\"javascript:ShowHideRegion('cells_summary');\">$cells_cnt</a><div id=\"cells_summary\" style=\"DISPLAY: none\">$cells_link<a href=\"javascript:ShowHideRegion('cells_summary');\"> ..Hide</a></div>"
      cells_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Storage Servers</td><td>$cells_link</td></tr>"
      if [ "$cells_cnt" = "0" ]; then cells_link=""; fi
    fi
    if [[ "$zfs_cnt" = "0" && -n "$zfs_password_status" && $zfs_password_status -ne 3  ]]; then
      ZFSIP="$TZFSDIR/.CELLDIR/zfsip.ora"
      if [ $is_ssc_machine -eq 1 ]; then ZFSIP=$TZFSDIR/outfiles/zfsip.ora;fi
      zfs_cnt=$(cat $ZFSIP|wc -l)
      for zfsname in `cat $ZFSIP |cut -d= -f2 |sed 's/\"//g'`
      do
        zfs_link="<br>&nbsp;&nbsp;$zfsname$zfs_link"
      done
      zfs_link="<a href=\"javascript:ShowHideRegion('zfs_summary');\">$zfs_cnt</a><div id=\"zfs_summary\" style=\"DISPLAY: none\">$zfs_link<a href=\"javascript:ShowHideRegion('zfs_summary');\"> ..Hide</a></div>"
      zfs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;ZFS Storage Appliances</td><td>$zfs_link</td></tr>"
  	if [ "$zfs_cnt" = "0" ]; then zfs_link=""; fi
    fi
    if [[ "$ibs_cnt" = "0" && -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]]; then
      ibs_cnt=$(cat $TIBDIR/o_ibswitches.out|wc -l)
      for switchname in `cat $TIBDIR/o_ibswitches.out`
      do
        sw_pname=$switchname
        if [[ `echo $switchname | grep -ic '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -eq 0 ]] ; then
          sw_pname=$(echo $switchname |cut -d. -f1)
        fi
        ibs_link="<br>&nbsp;&nbsp;$sw_pname$ibs_link"
      done
      ibs_link="<a href=\"javascript:ShowHideRegion('ibs_summary');\">$ibs_cnt</a><div id=\"ibs_summary\" style=\"DISPLAY: none\">$ibs_link<a href=\"javascript:ShowHideRegion('ibs_summary');\"> ..Hide</a></div>"
      ibs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;IB Switches</td><td>$ibs_link</td></tr>"
      if [ "$ibs_cnt" = "0" ]; then ibs_link="";  fi
    fi
  fi

  merge_collection_link=""
  profile_link=""
  ex_profile_link=""

  if [ -n "$MERGEFILES" ]; then
    for xdir in $dirarr
    do
      attribute_cnt=0
      xdir=$(echo $xdir|sed 's/\.zip//g');

      unset iprofiles2run iprofiles2exclude iexecuted_hdr icollection_date_hdr icluster_hdr iargsaved_hdr
      unset i_profile_link i_ex_profile_link i_executed_hdr i_argsaved_hdr i_collection_hdr i_cluster_hdr

      iprofiles2run=$(grep "PROFILE_NAMES =" ${xdir}/outfiles/check_env.out |grep -v "EXCLUDE"|cut -d= -f2)
      iprofiles2exclude=$(grep "EXCLUDE_PROFILE_NAMES =" ${xdir}/outfiles/check_env.out | cut -d= -f2)
      iexecuted_hdr=$(grep "CURRENT_USER =" ${xdir}/outfiles/check_env.out | cut -d= -f2)
      icollection_date_hdr=$(grep "COLLECTION DATE =" ${xdir}/outfiles/check_env.out | cut -d= -f2)
      icluster_hdr=$(grep "CLUSTER_NAME =" ${xdir}/outfiles/check_env.out | cut -d= -f2) 
      iargsaved_hdr=$(grep "RUN_ARGUMENTS =" ${xdir}/outfiles/check_env.out | cut -d= -f2) 
      
      if [ -n "$iprofiles2run" ]; then 
	i_profile_link="<tr><td class=\"td_column\">Selected Profiles</td><td>$iprofiles2run</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [ -n "$iprofiles2exclude" ]; then 
	i_ex_profile_link="<tr><td class=\"td_column\">Excluded Profiles</td><td>$iprofiles2exclude</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [ -n "$iexecuted_hdr" ]; then 
	i_executed_hdr="<tr><td class=\"td_column\">Executed by</td><td>$iexecuted_hdr</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [ -n "${iargsaved_hdr}" ] ; then
	i_argsaved_hdr="<tr><td class=\"td_column\">Arguments</td><td>$iargsaved_hdr</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [ -n "$icollection_date_hdr" ]; then 
	i_collection_hdr="<tr><td class=\"td_column\">Collection Date</td><td>$icollection_date_hdr</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [[ -n $SKIP_CRS_VAL && $SKIP_CRS_VAL -eq "1" ]]; then
        if [ -n "$icluster_hdr" ]; then 
	  i_cluster_hdr="<tr><td class=\"td_column\">Cluster Name</td><td>$icluster_hdr</td></tr>"; 
	  attribute_cnt=$(expr $attribute_cnt + 1); 
	fi
      fi

      i_collection_data="${i_cluster_hdr}${i_profile_link}${i_ex_profile_link}${i_executed_hdr}${i_argsaved_hdr}${i_collection_hdr}";

      base_xdir=`basename $xdir`
      collection_name="${base_xdir}"
      attribute_cnt=$(expr $attribute_cnt + 1);

      merge_link=$merge_link"<table width=100% border=0 id=\"$collection_name\" summary=\"$collection_name\"><tr><td width=60% class=\"td_column\" rowspan=\"$attribute_cnt\">$collection_name</td>$i_collection_data</table>"
    done    
    merge_collection_link="<tr><td class=\"td_column\">Merged Collections</td><td>$merge_link</td></tr>"
  else
    if [[ -n $internal_profile_set && $internal_profile_set -eq "0" ]]; then
      if [ -n "$profiles2run" ] ; then
        profile_link="<tr><td class=\"td_column\">Selected Profiles</td><td>$profiles2run</td></tr>"
      fi
      if [ -n "$profiles2exclude" ] ; then
        ex_profile_link="<tr><td class=\"td_column\">Excluded Profiles</td><td>$profiles2exclude</td></tr>"
      fi
    fi
  fi

  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
    nodes_cnt=$cells_cnt
  else
    let nodes_cnt=$dbservers_cnt+$cells_cnt+$ibs_cnt+$el_snode_cnt+$zfs_cnt
  fi

  # db names
  if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
  then # User selected none
    db_cnt=0
  else
    db_cnt=${#mb_db_names[@]}
  fi

  upg_link="";
  if [[ -n "$upgrade_mode" && $upgrade_mode -eq 2 ]] 
  then
    upg_link="<tr><td class=\"td_column\">Upgrade Mode</td><td>Pre-upgrade</td></tr>";
  elif [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 ]]
  then
    upg_link="<tr><td class=\"td_column\">Upgrade Mode</td><td>Post-upgrade</td></tr>";
  fi

  dbn_link=""
  if [ $db_cnt -gt "0" ]
  then
    for db_name_to_check in "${mb_db_names[@]}"
    do
      dbn_link="<br>&nbsp;&nbsp;$db_name_to_check$dbn_link"
    done
    dbn_link="<tr><td class=\"td_column\">Database Names</td><td><a href=\"javascript:ShowHideRegion('dbn_summary');\">$db_cnt</a><div id=\"dbn_summary\" style=\"DISPLAY: none\">$dbn_link<a href=\"javascript:ShowHideRegion('dbn_summary');\"> ..Hide</a></div></td></tr>"
  else
     if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
     then # User selected none
       dbn_link="None"
     else
       dbn_link="0"
     fi
     if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "0" ]]
     then
       dbn_link="<tr><td class=\"td_column\">Database Names</td><td>$dbn_link</td></tr>";
     else
       dbn_link=""
     fi
  fi
  
  # DB versions
  rm -f $OUTPUTDIR/mb_db_tmp.out
  mb_db_counter=0

  none_db_text="None Discovered"
  for mb_db_homes in `grep "RDBMS_ORACLE_HOME =" $MASTERFIL1 | awk -F"=" '{print $2}' | awk -F"|" '{print $1}' | sed 's/ //g'`
  do
    l_version=$(grep "RDBMS_ORACLE_HOME = $mb_db_homes" $MASTERFIL1 | awk -F"=" '{print $2}' | awk -F"|" '{print $2}' | sed 's/ //g')
    format_l_version
    oh_version=$l_version
    if [[ `grep "DB_NAME =" $MASTERFIL1 |grep $mb_db_homes | awk -F"=" '{print $2}' | awk -F"|" '{print $1}' |wc -l` -gt 0 ]]
    then
      for db_name_to_check in `grep "DB_NAME =" $MASTERFIL1 |grep $mb_db_homes | awk -F"=" '{print $2}' | awk -F"|" '{print $1}'|sed 's/ //g'`
      do
        running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL1 |awk '{print $3}'`
        echo "$mb_db_homes|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
      done
    else
      if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
      then
        none_db_text="None Selected"
      fi
      if [[ -n "$db_name_to_check_all" &&  $db_name_to_check_all -eq 1 ]]
      then
        none_db_text="None Discovered"
      else
        none_db_text="None Selected"
      fi
      echo "$mb_db_homes|${oh_version}|$none_db_text|$none_db_text" >> $OUTPUTDIR/mb_db_tmp.out
    fi
  done

  db_versions=""
  mb_db_counter=0

  if [ -n "$MERGEFILES" ];
  then
    MB_DB_TMP_FIL=$WRKDIR/.MERGED_COLLECTIONS/mb_db_tmp.out.merge
  else
    MB_DB_TMP_FIL=$OUTPUTDIR/mb_db_tmp.out
  fi

  if  [ -e $MB_DB_TMP_FIL ]
  then
    for mb_oh_name in `cut -d'|' -f1  $MB_DB_TMP_FIL |sort -u`
    do
      oh_version=$(grep "$mb_oh_name" $MB_DB_TMP_FIL |cut -d'|' -f2|sort -u)

      version_ofile="${OUTPUTDIR}/versions.html"
      if [[ -e $version_ofile ]]; then
        oh_version_wpatch=$(grep class=\"DBVERSION:${mb_oh_name}\" "$version_ofile"|head -1|sed "s/\s*//g"|sed "s/^.*>\(\([[:digit:]]\+\.*\)\+\)<.*$/\1/g")
        if [[ -n "$oh_version_wpatch" && `echo "$oh_version_wpatch"|grep -ic "\([0-9]\+\.\)\{4,\}"` -gt "0" ]]; then      
          oh_version=$oh_version_wpatch;
        fi
      fi
    
      db_cnt=$(grep "$mb_oh_name" $MB_DB_TMP_FIL |cut -d'|' -f3|sort -u|wc -l)
      if [ $db_cnt -gt 0 ]
      then
        if [ $db_cnt -gt 1 ]
        then
          running_db_line=""
          for running_db in `grep "$mb_oh_name" $MB_DB_TMP_FIL |cut -d'|' -f3|sort -u`
          do
            running_db_line="<br>&nbsp;&nbsp;$running_db$running_db_line"
          done # Finished printing db info for a OH
          dbn_link="<a href=\"javascript:ShowHideRegion('dbn_summary2_$mb_db_counter');\">$db_cnt</a><div id=\"dbn_summary2_$mb_db_counter\" style=\"DISPLAY: none\">$running_db_line<a href=\"javascript:ShowHideRegion('dbn_summary2_$mb_db_counter');\"> ..Hide</a></div>"
        else
          dbn_link=`grep "$mb_oh_name" $MB_DB_TMP_FIL |cut -d'|' -f3|sort -u`
        fi
        db_versions="${mb_oh_name} - ${oh_version} - $dbn_link<br>$db_versions";
      else
        db_versions="${mb_oh_name} - ${oh_version} - 0<br>$db_versions";
      fi
      mb_db_counter=$(expr $mb_db_counter + 1)
    done # Finished printing all homes
  fi
  mb_db_counter=0

  crs_home_path=$(grep "CRS_HOME =" $MASTERFIL1 | awk '{print $3}')

  if [ -z "$cluster_name" ] 
  then
    cluster_name=$(grep CLUSTER_NAME $MASTERFIL1 | awk -F"=" '{print $2}')
  fi

  if [[ -n "$el_pc_nodes" && `echo $el_pc_nodes | wc -w` -gt 1 ]]
  then
    el_pc_node_cnt=0
    for hostname in $el_pc_nodes
    do
      el_pc_node_link="<br>&nbsp;&nbsp;$hostname$el_pc_node_link"
      el_pc_node_cnt=$(expr $el_pc_node_cnt + 1)
    done
    el_pc_node_link="<a href=\"javascript:ShowHideRegion('el_pc_summary');\">$el_pc_node_cnt</a><div id=\"el_pc_summary\" style=\"DISPLAY: none\">$el_pc_node_link<a href=\"javascript:ShowHideRegion('el_pc_summary');\"> ..Hide</a></div>"
  else
    el_pc_node_link="$el_pc_nodes"
  fi

  if [[ -n "$run_acchk" && $run_acchk -eq "1" ]] || [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]
  then
    node_heading="Hostname"
    summary_heading="Summary"
  else
    node_heading="Database Server"
    summary_heading="Cluster Summary"
  fi

  oms_h_link=""
  unset mb_oms_home
  for mb_oms_home in ${oms_homes[@]}
  do
    mb_oms_homes="${mb_oms_home}<br>${mb_oms_homes}"
  done
  if [[ -n $mb_oms_homes ]]; then
    oms_h_link="<tr><td class=\"td_column\">OMS Home</td><td>$mb_oms_homes</td></tr>"
  fi

  if [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
  then
    summary_heading="Big Data Appliance Rack summary"
    skipped_checks_pass=0
    node_heading="Compute Node"
    if [[ -n $is_bda_domu && $is_bda_domu -eq 1 ]];then
      echo
    else
      exalogic_version_link="<tr><td class=\"td_column\">Big Data Appliance Version</td><td>$bda_actual_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$bda_identifier</td></tr>"
    fi
  elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
  then
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]
    then 
      summary_heading="OPCM Rack Summary"
    else
      summary_heading="Exalogic Rack Summary"
    fi
    skipped_checks_pass=0
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
    then
      node_heading="Guest VM"
      old_ifs=$IFS;IFS=$','
      for el_guest_file in `echo "$RAT_EL_GVM"`
      do
        if [ -e "$el_guest_file" ]
        then
          vmfiles=${vmfiles}${el_guest_file}"<br>" 
        fi
      done
      IFS=$old_ifs
      ex_vm_files="<tr><td class=\"td_column\">Guest VM Files</td><td>$vmfiles</td></tr>"
    elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      node_heading="Node"
    else
      node_heading="Compute Node"
    fi
    crs_hv_link=""
    asm_h_link=""
    em_h_link=""
    dbhv_link=""
    cname_link=""
    el_cs_row=""
    if [[ -n "$el_ec1_node" ]] ; then
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Enterprise Controller</td><td>$el_ec1_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Control DB Node</td><td>$el_db_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;OVM Manager Node</td><td>$el_ovmm_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Proxy Controllers</td><td>$el_pc_node_link</td></tr>"
    fi
    if [[ `grep -ic EXALOGIC_ACTUAL_VERSION_CN $MASTERFIL1` -gt 0 ]] ; then
      l_version=$(grep EXALOGIC_ACTUAL_VERSION_CN $MASTERFIL1 | tail -1 | awk -F"=" '{print $2}')
 
      l_version=$(echo "$l_version"|sed 's/^\s//g'|sed 's/\s$//g');
      if [ -z "$l_version" ] ; then l_version=$(grep EXALOGIC_ACTUAL_VERSION_CN $MASTERFIL1 | head -1 | awk -F"=" '{print $2}'); fi;
    else
      l_version=$exalogic_version_actual
    fi
    #format_l_version 1
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]
     then
 	exalogic_version_link="<tr><td class=\"td_column\">OPCM Version</td><td>$l_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$RackIdentifier</td></tr>"
     else
        exalogic_version_link="<tr><td class=\"td_column\">Exalogic Version</td><td>$l_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$RackIdentifier</td></tr>"
     fi

  # ZFS SSA
  elif [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]] ; then
    summary_heading="ZFS Storage Appliance System Summary"
    skipped_checks_pass=0
    node_heading="Compute Node"
    crs_hv_link=""
    asm_h_link=""
    em_h_link=""
    dbhv_link=""
    cname_link=""
    l_version=$CRSVERSION

  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    summary_heading="Exalytics System Summary"
    skipped_checks_pass=0
    node_heading="Compute Node"
    crs_hv_link=""
    asm_h_link=""
    em_h_link=""
    dbhv_link=""
    cname_link=""
    el_cs_row=""
    if [[ `grep -ic EXALYTICS_VERSION_ACTUAL $MASTERFIL1` -gt 0 ]] ; then
      l_version=$(grep EXALYTICS_VERSION_ACTUAL $MASTERFIL1 | tail -1 | awk -F"= " '{print $2}')
    else
      l_version=$exalytics_version
    fi
    #format_l_version 1
    obiee_homes_link=""
    #-------------------------TimesTen
    tt_homes_link=""
    str=""
    if [ -e "$OUTPUTDIR/mb_db_homes_distinct.out" ] ; then
      for bi_home in `cat $OUTPUTDIR/mb_db_homes_distinct.out`
      do
	match=0;
	dbs="";
	ver="";
	if [ `echo $str|grep -ic "$bi_home "` -gt 0 ]
	then
	  continue;
	else
	  str="$str $bi_home";
	fi
	mcount=0;
	for (( i=1; i<=${#ttx_home[@]};i++ ))
	do
	  if [ ${ttx_home[$i]} = $bi_home ]
	  then
	    match=1;
	    mcount=$(expr $mcount + 1)
	    dbs="$dbs<br>${ttx_dbpath[$i]}"
	    ver="${ttx_version[$i]}"
	  fi
	done
	if [ $match -eq 1 ]
	then
	  if [ $mcount -le 1 ]
	  then
	    tt_homes="$bi_home - $ver - $dbs<br>$tt_homes";
	  else
	    tstr="<a href=\"javascript:ShowHideRegion('$bi_home');\">$mcount</a><div id=$bi_home style=\"DISPLAY: none\">$dbs<a href=\"javascript:ShowHideRegion('$bi_home');\"> ..Hide</a></div>";
	    tt_homes="$bi_home - $ver - $tstr<br>$tt_homes";
	  fi
	else
	  ver=$(grep -i 'OBIEE Release Version:' $MASTERFIL| grep -i "$bi_home " | awk -F"=" '{print $2}' | sed 's/ //g');
	  obiee_homes="$bi_home - $ver<br>$obiee_homes";
	fi
      done
      if [ -n "$obiee_homes" ] ; then
	obiee_homes_link="<tr><td class=\"td_column\">OBIEE Homes - Versions</td><td>$obiee_homes</td></tr>";
      fi
      if [ -n "$tt_homes" ] ; then
        tt_homes_link="<tr><td class=\"td_column\">TimesTen Homes - Versions - Names</td><td>$tt_homes</td></tr>";
      fi
      #---------------------------------
    fi

    exalogic_version_link="<tr><td class=\"td_column\">Base Image Version</td><td>$l_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$RackIdentifier</td></tr>"
  else
   #changed this to 0 for bug 14148335
    skipped_checks_pass=0
    exalogic_version_link=""
    el_cs_row=""
    if [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]]
    then
       em_h_link=""
       asm_h_link=""
       crs_hv_link=""
       dbhv_link=""
       cname_link=""
    elif [[ $is_opc -eq 1 ]] ; then
       summary_heading="Summary"
       node_heading="Compute Node"
       em_h_link=""
       asm_h_link=""
       crs_hv_link=""
       dbhv_link=""
       cname_link=""
    elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]] 
    then
      summary_heading="Oracle Identity Management Summary"
      node_heading="Node"
      asm_h_link=""
      crs_hv_link=""
      dbhv_link=""
      cname_link=""
  
      if [[ -n $db_versions ]]; then
	if [[ -n "$crs_home_path" ]]; then 
          crs_hv_link="<tr><td class=\"td_column\">CRS Home - Version</td><td>$crs_home_path - ${stack_crs_version[0]}</td></tr>"
        fi
        if [[ -n "$db_versions" ]]; then 
          dbhv_link="<tr><td class=\"td_column\">DB Home - Version - Names</td><td>$db_versions</td></tr>"
	fi
	if [[ -n "$cluster_name" ]]; then 
          cname_link="<tr><td class=\"td_column\">Cluster Name</td><td>$cluster_name</td></tr>"
	fi
      fi
    else
      if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
        asm_h_link="<tr><td class=\"td_column\">GRID Home</td><td>$CRS</td></tr>"
      else
        asm_h_link=""
      fi

      if [ -n "$MERGEFILES" ] ; then
        for xdir in $dirarr
        do
	  xdir=$(echo $xdir|sed 's/\.zip//g');

	  if [ -z $mb_emagent_home ]; then mb_emagent_home=`grep "EMAGENT_HOME" ${xdir}/outfiles/check_env.out | awk '{print $3}'| head -1 | sed 's/ //g'`; fi
          if [[ -z "${stack_crs_version[0]}" ]]; then stack_crs_version[0]=`grep -i "CRS_ACTIVE_VERSION" ${xdir}/outfiles/check_env.out | awk '{print $3}'| head -1 | sed 's/ //g'`; fi
	  if [[ -z "$crs_home_path" ]]; then crs_home_path=`grep "CRS_HOME =" ${xdir}/outfiles/check_env.out | awk '{print $3}' | head -1 | sed 's/ //g'`; fi

   	  cluster_name=$(echo "$cluster_name"|sed 's/ //g'); 
	  if [[ -z "$cluster_name" ]]; then cluster_name=`grep "CLUSTER_NAME =" ${xdir}/outfiles/check_env.out | awk '{print $3}' | head -1 | sed 's/ //g'`; fi	  
        done
      fi

      if [ -n "$mb_emagent_home" ]
      then
        em_h_link="<tr><td class=\"td_column\">EM Agent Home</td><td>$mb_emagent_home</td></tr>"
      else
        em_h_link="";
      fi 

      version_ofile="${OUTPUTDIR}/versions.html"
      if [[ -e $version_ofile ]]; then
        crs_version_wpatch=$(grep 'class="GIVERSION"' "$version_ofile"|head -1|sed "s/\s*//g"|sed "s/^.*>\(\([[:digit:]]\+\.*\)\+\)<.*$/\1/g")
      fi

      if [[ -n "$crs_version_wpatch" && `echo "$crs_version_wpatch"|grep -ic "\([0-9]\+\.\)\{4,\}"` -gt "0" ]]; then      
	print_crs_version=$crs_version_wpatch;
      else
	print_crs_version=${stack_crs_version[0]}
      fi

      #crs_hv_link="<tr><td class=\"td_column\">CRS Home - Version</td><td>$crs_home_path - ${stack_crs_version[0]}</td></tr>"
      crs_hv_link="<tr><td class=\"td_column\">CRS Home - Version</td><td>$crs_home_path - $print_crs_version</td></tr>"
      dbhv_link="<tr><td class=\"td_column\">DB Home - Version - Names</td><td>$db_versions</td></tr>"
      cname_link="<tr><td class=\"td_column\">Cluster Name</td><td>$cluster_name</td></tr>"
    fi
  fi
  if [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 0 ]]
  then
      if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]; then 
	#hosts_txt=`cat $HOSTLIST |grep "[a-zA-Z0-9]" `
	hosts_txt=`grep "[a-zA-Z0-9]" $HOSTLIST `
	node_dlink="<tr><td class=\"td_column\">${node_heading}</td><td>$hosts_txt</td></tr>"
      elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	node_slink="<tr><td class=\"td_column\">Number of nodes</td><td>$nodes_cnt</td></tr>"

	foxtrot_dom0_link="<a href=\"javascript:ShowHideRegion('foxtrot_dom0_summary');\">$foxtrot_dom0_cnt</a><div id=\"foxtrot_dom0_summary\" style=\"DISPLAY: none\">$foxtrot_dom0_link<a href=\"javascript:ShowHideRegion('foxtrot_dom0_summary');\"> ..Hide</a></div>"
	node_dlink_1="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;DOM0 Nodes</td><td>$foxtrot_dom0_link</td></tr>"


	foxtrot_cvm_link="<a href=\"javascript:ShowHideRegion('foxtrot_cvm_summary');\">$foxtrot_cvm_cnt</a><div id=\"foxtrot_cvm_summary\" style=\"DISPLAY: none\">$foxtrot_cvm_link<a href=\"javascript:ShowHideRegion('foxtrot_cvm_summary');\"> ..Hide</a></div>"
	node_dlink_2="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Control VM Nodes</td><td>$foxtrot_cvm_link</td></tr>"

	node_dlink=${node_dlink_1}${node_dlink_2}
      else
	node_slink="<tr><td class=\"td_column\">Number of nodes</td><td>$nodes_cnt</td></tr>"
	node_dlink="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;${node_heading}s</td><td>$dbservers_link</td></tr>"
      fi
  fi
  if [[ -e $OGGHOMESVERSIONFIL && `cat $OGGHOMESVERSIONFIL|wc -l` -gt 0 ]]
  then
    ogg_home_dlink="<tr><td class=\"td_column\">Oracle GoldenGate Homes</td><td>$ogg_homes_link</td></tr>"
  fi

  if [[ $single_instance_run -eq "1" ]] ; then
    if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]]; then
      printf "" 
    else
      node_slink=""
      hostname=`cat $HOSTLIST`;
      node_dlink="<tr><td class=\"td_column\">Database Server</td><td>$hostname</td></tr>"
    fi
  fi
  if [ $is_opc -eq 1 ] ; then
    node_slink=""
    node_dlink="<tr><td class=\"td_column\">${node_heading}</td><td>$localnode : $EXADATA_VERSION</td></tr>"
  fi

  if [[ $single_instance_run -eq "1" ]] ; then
    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
      asm_h_link="<tr><td class=\"td_column\">GRID Home</td><td>$CRS</td></tr>"
    fi
    if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]]; then
      printf "" 
    else
      summary_heading="Summary";
      if [ -n "$mb_emagent_home" ]
      then
        em_h_link="<tr><td class=\"td_column\">EM Agent Home</td><td>$mb_emagent_home</td></tr>"
      fi
    fi
    crs_hv_link=""
    cname_link=""
  fi;

  if [ -z "$upload_dbplatform" ]
  then
    upload_dbplatform=$(grep DB_PLATFORM $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g') 
  fi
  if [ -z "$upload_osdistro" ] 
  then
    upload_osdistro=$(grep OS_DISTRO $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g')
  fi
  if [ -z "$upload_oskernel" ]
  then
    upload_oskernel=$(grep OS_KERNEL $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g')
  fi
  if [ -z "$upload_osversion" ]
  then
    upload_osversion=$(grep OS_VERSION $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g')
  fi
  if [ -z "$collection_date" ]
  then
    collection_date=$(grep "COLLECTION DATE" $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g')
  fi

  tool_version=$(echo $show_version_envfile | awk -F"=" '{print $2}' | sed 's/ //g')

  collection_name=$(basename "${UPLOADFIL}.zip")

  if [ -n "$MERGEFILES" ];
  then
    current_exadata_version=$(grep CURRENT_EXADATA_VERSION $MASTERFIL1 |awk '{print $3}')
  fi

  if [ -n "$current_exadata_version" ]
  then
    l_version=$current_exadata_version
    format_l_version
    cev_link="<tr><td class=\"td_column\">Exadata Version</td><td>$l_version</td></tr>"
  else
    cev_link=""
  fi

  #if [ $upgrade_mode -gt 0 ]
  if [[ $upgrade_mode -gt 0 && $upgrade_mode -lt 3 ]] || [[ "$profiles2run" = "preinstall" && $crs_up -eq 0 ]]
  then
    if [ -z "$TARGET_VERSION" ]
    then
      targetversion=$(grep "TARGET_VERSION" $MASTERFIL1 | awk -F"=" '{print $2}')
    fi
    l_version=$targetversion
    format_l_version
    tv_link="<tr><td class=\"td_column\">Target Version</td><td>$l_version</td></tr>"
  else
    tv_link=""
  fi

  cat > $HTML_REPFILE <<EOF
<html lang="en"><head>
<style type="text/css">
body {font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
    font-size: 14px;
    background:white;
}
h1 {color:black;}
h2 {color:black; background:white}
h3 {color:black; background:white}
a {color: #000000;}
p {font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
    font-size: 14px;
}
.a_bgw {
  color: #000000;
  background:white;
}

.hiddendiv {display:none;}
.visiblediv {display:block;}

.scrollc{
        display:block;
        border: 0px;
        padding:5px;
        margin-top:5px;
        width:1500px;
        height:450px;
        overflow-y:hidden;
        }

.scrolle{
        display:block;
        border: 0px;
        padding:5px;
        margin-top:5px;
        width:1500px;
        height:100%;
        overflow-y:hidden;
        }
table {
    color: #000000;
    font-weight: bold;
    border-spacing: 0;
    outline: medium none;
font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
font-size: 14px;

}

th {
 background: #F2F5F7;
    border: 1px solid grey;
    font-size: 14px;
    font-weight: bold;
}
td {

 background: #F2F5F7;
    border: 1px solid grey;
    font-weight: normal;
    padding: 5;
}

.maatable {
  width:100%;
  height:100%;
  border-collapse: collapse;
  border-style: hidden;
}


.status_FAIL
{
    font-weight: bold;
    color: #c70303;
}
.status_WARNING
{
    font-weight: bold;
    color: #8B008B;
}
.status_INFO
{
    font-weight: bold;
    color: blue;
}
.status_PASS
{
    font-weight: bold;
    color: #006600;
}

.td_output {
  color: #000000;
 background: white;
    border: 0;
font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
font-size: 14px;
    font-weight: normal;
    padding: 0;
}

.td_column {
 background: #F2F5F7;
    border: 1px solid grey;
    font-size: 14px;
    font-weight: bold;
}

.td_title {

 background: #F2F5F7;
    border: 0px solid grey;
    font-weight: normal;
    padding: 5;
}

pre {
 overflow-x: auto; /* Use horizontal scroller if needed; for Firefox 2, not needed in Firefox 3 */
 white-space: pre-wrap; /* css-3 */
 white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */
 white-space: -pre-wrap; /* Opera 4-6 */
 white-space: -o-pre-wrap; /* Opera 7 */
 /* width: 99%; */
 word-wrap: break-word; /* Internet Explorer 5.5+ */
}

.shs_bar {
width: 500px ;
height: 20px ;
float: left ;
border: 1px solid #444444;
background-color: white ;
}

.shs_barfill {
height: 20px ;
float: left ;
background-color: $crh_bar_color ;
width: $crh_health% ;
}

.more_less_style {
  font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
  font-weight: bold;
  color: black;
}

</style>
<script language="JavaScript">
var report_format = "new";
function processForm()
{
    
    if (report_format == "old")
    {
        report_format = "new";
	var i;
	var bo = document.querySelectorAll("body");
        for (i = 0; i < bo.length; i++) 
        {
                bo[i].style.fontSize = "14px";
        }
	var hc1 = document.querySelectorAll("h1");
        for (i = 0; i < hc1.length; i++) 
        {
                hc1[i].style.color = "black";
        }
        var hc2 = document.querySelectorAll("h2");
	for (i = 0; i < hc2.length; i++) 
	{
		hc2[i].style.color = "black";
	}
	var hc3 = document.querySelectorAll("h3");
        for (i = 0; i < hc3.length; i++) 
        {
                hc3[i].style.color = "black";
        }
	var pf = document.querySelectorAll("p");
        for (i = 0; i < pf.length; i++) 
        {
                pf[i].style.fontSize = "14px";
        }
	var tf = document.querySelectorAll("table");
        for (i = 0; i < tf.length; i++) 
        {
                tf[i].style.fontSize = "14px";
        }
	var th = document.querySelectorAll("th");
        for (i = 0; i < th.length; i++) 
        {
                th[i].style.background = "#F2F5F7";
		th[i].style.border = "1px solid grey";
		th[i].style.fontSize = "14px";
        }
	var td = document.querySelectorAll("td");
        for (i = 0; i < td.length; i++) 
        {
                td[i].style.border = "1px solid grey";
        }
	var tdo = document.querySelectorAll(".td_output");
        for (i = 0; i < tdo.length; i++) 
        {
                tdo[i].style.background = "white";
                tdo[i].style.border = "1px solid grey";
                tdo[i].style.fontSize = "14px";
        }
	var tdc = document.querySelectorAll(".td_column");
        for (i = 0; i < tdc.length; i++) 
        {
                tdc[i].style.background = "#F2F5F7";
                tdc[i].style.border = "1px solid grey";
                tdc[i].style.fontSize = "14px";
        }
	var tdt = document.querySelectorAll(".td_title");
        for (i = 0; i < tdt.length; i++) 
        {
                tdt[i].style.border = "0px solid grey";
        }
	var shs = document.querySelectorAll(".shs_bar");
        for (i = 0; i < shs.length; i++) 
        {
                shs[i].style.background = "white";
        }
	var ml = document.querySelectorAll(".more_less_style");
        for (i = 0; i < ml.length; i++) 
        {
                ml[i].style.color = "black";
        }
	document.getElementById('results').innerHTML ="Switch to old format";

    }
    else
    {
        report_format = "old";
	var i;
	var bo = document.querySelectorAll("body");
        for (i = 0; i < bo.length; i++) 
        {
                bo[i].style.fontSize = "13px";
        }
	var hc1 = document.querySelectorAll("h1");
        for (i = 0; i < hc1.length; i++) 
        {
                hc1[i].style.color = "blue";
        }
        var hc2 = document.querySelectorAll("h2");
        for (i = 0; i < hc2.length; i++) 
        {
                hc2[i].style.color = "blue";
        }
	var hc3 = document.querySelectorAll("h3");
        for (i = 0; i < hc3.length; i++) 
        {
                hc3[i].style.color = "blue";
        }
        var pf = document.querySelectorAll("p");
        for (i = 0; i < pf.length; i++) 
        {
                pf[i].style.fontSize = "13px";
        }
	var tf = document.querySelectorAll("table");
        for (i = 0; i < tf.length; i++) 
        {
                tf[i].style.fontSize = "12px";
        }
	var th = document.querySelectorAll("th");
        for (i = 0; i < th.length; i++) 
        {
                th[i].style.background = "#D7EBF9";
                th[i].style.border = "1px solid #AED0EA";
                th[i].style.fontSize = "13px";
        }
	var td = document.querySelectorAll("td");
        for (i = 0; i < td.length; i++) 
        {
                td[i].style.border = "1px solid #AED0EA";
        }
	var tdo = document.querySelectorAll(".td_output");
        for (i = 0; i < tdo.length; i++) 
        {
                tdo[i].style.background = "#E0E0E0";
                tdo[i].style.border = "1px solid #AED0EA";
                tdo[i].style.fontSize = "13px";
        }
	var tdc = document.querySelectorAll(".td_column");
        for (i = 0; i < tdc.length; i++) 
        {
                tdc[i].style.background = "#D7EBF9";
                tdc[i].style.border = "1px solid #AED0EA";
                tdc[i].style.fontSize = "13px";
        }
	var tdt = document.querySelectorAll(".td_title");
        for (i = 0; i < tdt.length; i++) 
        {
                tdt[i].style.border = "0px solid #AED0EA";
        }
	var shs = document.querySelectorAll(".shs_bar");
        for (i = 0; i < shs.length; i++) 
        {
                shs[i].style.background = "#656565";
        }
	var ml = document.querySelectorAll(".more_less_style");
        for (i = 0; i < ml.length; i++) 
        {
                ml[i].style.color = "blue";
        }
	document.getElementById('results').innerHTML ="Switch to new format";
    }
}

function ExpandContract(divId)
{
  if(document.getElementById(divId).className == 'scrollc')
  {
    document.getElementById(divId).setAttribute('class','scrolle');
    document.getElementById(divId+'_mh').innerHTML = 'Click for less data';
  }
  else
  {
    document.getElementById(divId).setAttribute('class','scrollc')
    document.getElementById(divId + '_mh').innerHTML = 'Click for more data';
    window.location.hash = divId + '_a';
  }
}

function ShowHide(divId)
{
  if(document.getElementById(divId).style.display == 'none')
  {
    document.getElementById(divId).style.display='block';
    document.getElementById(divId+'_mh').innerHTML = 'Click for less data';
  }
   else
  {
    document.getElementById(divId).style.display = 'none';
    document.getElementById(divId + '_mh').innerHTML = 'Click for more data';
    window.location.hash = divId + '_a';
  }
}

function ShowHideRegion(divId)
{
  if(document.getElementById(divId).style.display == 'none')
  {
    document.getElementById(divId).style.display='block';
  }
   else
  {
    document.getElementById(divId).style.display = 'none';
  }
}

var showMode = 'table-cell';
if (document.all) showMode='block';
function toggleVis(btn , callid)
{
  cells = document.getElementsByName(btn);
  if(cells[0].style.display == 'none')
  {
        mode=showMode;
  }
  else
  {
        mode='none';
  }

  for(j = 0; j < cells.length; j++) cells[j].style.display = mode;

  if(callid == 'hide_check_link')
  {
        document.getElementById('hide_check_link').style.display='none';
        document.getElementById('show_check_link').style.display="";
  }
  else
  {
        document.getElementById('show_check_link').style.display='none';
        document.getElementById('hide_check_link').style.display="";
  }
}

function getParam(name)
{
  var start=location.search.indexOf("?"+name+"=");
  if (start<0) start=location.search.indexOf("&"+name+"=");
  if (start<0) return 0;
  return 1;
}

function deleteRow(t, r, s)
{
  var i=r.parentNode.parentNode.rowIndex;
  document.getElementById(t).deleteRow(i);
  if ( document.getElementById(s) != null )
    document.getElementById(s).innerHTML="";
}

function show_div_below(div)
  {
    var linkval = div;
    var link1 = linkval.replace("contents", "summary"); 
    var div2 = div + '_t';
    var v =  div + '_view';
    var h =  div + '_hide';
    var view_hide = document.getElementById(v);
    var hide_view = document.getElementById(h);
    var targets = document.getElementsByClassName(div);
    var i;
    var st = document.getElementById(div2).style.display;
    if ( st && st == "none" )
    {

      hide_view.style.display = "block";
      view_hide.style.display = "none";

      for (i = 0; i < targets.length; i++)
      {
	targets[i].style.display = "table-row";
      }
      document.getElementById(div2).style.display = "block";
      document.getElementById(div2).innerHTML = document.getElementById(div).innerHTML;
    }
     else if ( st )
    {
      for (i = 0; i < targets.length; i++)
      {
	targets[i].style.display = "none";
      }
      document.getElementById(div2).style.display = "none";
      hide_view.style.display = "none";
      view_hide.style.display = "block";

    }
     else
    {
      hide_view.style.display = "block";
      view_hide.style.display = "none";

      for (i = 0; i < targets.length; i++)
      {
	targets[i].style.display = "table-row";
      }
      document.getElementById(div2).style.display = "block";
      document.getElementById(div2).innerHTML = document.getElementById(div).innerHTML;
    }
    window.location.replace('#'+link1);
  }


function print_view()
{
	var divvals = ["p_dbservers_summary","v_dbservers_summary", "dbservers_summary", "ogg_homes_summary", "cells_summary","zfs_summary","ibs_summary","dbn_summary", "dbn_summary2_$mb_db_counter", "$bi_home", "el_pc_summary","foxtrot_dom0_summary","foxtrot_cvm_summary","shs_help"]

        document.getElementById("Expand").checked = true;
        document.getElementById("toc").style.display = "none";
        document.getElementById("print_view").style.display = "none";
        document.getElementById("normal_view").style.display = "block";
	for (var j = 0, length = divvals.length; j < length; j++)
        {
                if (document.getElementById(divvals[j]) != null )
		document.getElementById(divvals[j]).style.display = "block";
	}
        expand_collapse();

}
function normal_view()
{
	var divvals = ["p_dbservers_summary","v_dbservers_summary", "dbservers_summary", "ogg_homes_summary", "cells_summary","zfs_summary","ibs_summary","dbn_summary", "dbn_summary2_$mb_db_counter", "$bi_home", "el_pc_summary","foxtrot_dom0_summary","foxtrot_cvm_summary","shs_help"];

        document.getElementById("Collapse").checked = true;
        document.getElementById("toc").style.display = "block";
        document.getElementById("print_view").style.display = "block";
        document.getElementById("normal_view").style.display = "none";
	for (var j = 0, length = divvals.length; j < length; j++)
        {
                if (document.getElementById(divvals[j]) != null )
                document.getElementById(divvals[j]).style.display = "none";
        }
        expand_collapse();

}


function expand_collapse()
{
	var ec = document.getElementsByName('EC');
	var vh = document.getElementsByClassName("view");
	var hv = document.getElementsByClassName("hide");

	var alvl = ["PASS", "FAIL", "WARNING", "INFO"];

	for (var i = 0, length = ec.length; i < length; i++) 
	{
	    if (ec[i].checked) 
	    {
                if(ec[i].value == 'Expand')
		{
			var z;
			for (z = 0; z < vh.length; z++)
			{
				vh[z].style.display = "none";
			}
			for (z = 0; z < hv.length; z++)
                        {
                                hv[z].style.display = "block";
                        }
			for (var j = 0, length1 = alvl.length; j < length1; j++)
			{
				var cb = document.getElementById(alvl[j]);
				var targets = document.getElementsByClassName(alvl[j]);
				var k;	
				for (k = 0; k < targets.length; k++)
				{
					var innerstr = targets[k].innerHTML;
	          	                var res = innerstr.match(/<a name=\".*_summary\">/);
        	        	        if(res)
                	        	{
                        			var res1 = res.toString().substr(9,32);
			                        res1 = res1+"_contents";
						var res2 = res1 + '_t';
						var targets1 = document.getElementsByClassName(res1);
						if(cb.checked)
						{
      						  targets1[0].style.display = "table-row";
						  document.getElementById(res2).style.display = "block";
						  document.getElementById(res2).innerHTML = document.getElementById(res1).innerHTML;
						}
						else
						{
      						  targets1[0].style.display = "none";
						  document.getElementById(res2).style.display = "none";
						}
			                }
				}
			}
			
		}
		else
		{
			var z;
                        for (z = 0; z < vh.length; z++)
                        {
                                vh[z].style.display = "block";
                        }
                        for (z = 0; z < hv.length; z++)
                        {
                                hv[z].style.display = "none";
                        }
			for (var j = 0, length1 = alvl.length; j < length1; j++)
                        {
				var targets = document.getElementsByClassName(alvl[j]);
                                var k;
                                for (k = 0; k < targets.length; k++)
                                {
					var innerstr = targets[k].innerHTML;
                                        var res = innerstr.match(/<a name=\".*_summary\">/);
                                        if(res)
                                        {
						var res1 = res.toString().substr(9,32);
                                                res1 = res1+"_contents";
                                                var res2 = res1 + '_t';
                                                var targets1 = document.getElementsByClassName(res1);
						targets1[0].style.display = "none";
						document.getElementById(res2).style.display = "none";
					}
				}
                        }
		}
	    }
    
	}


}

function createDeleteButton(k)
{
  var rc=document.getElementById('checkscnt').innerHTML;

  if (k == 1)
  {
    for (i=0; i<=rc; i++)
    {
      var pn = 'deletebutton' +i;
      if (document.getElementById(pn) != null )
          document.getElementById(pn).style.display="";
    }
    document.getElementById("show_hide_link").style.display="";
    document.getElementById("message_on_hide").style.display="";
    document.getElementById("show_edit_link").style.display="none";
  }
   else
  {
    for (i=0; i<=rc; i++)
    {
      var pn = 'deletebutton' +i;
      if (document.getElementById(pn) != null )
          document.getElementById(pn).style.display="none";
    }
    document.getElementById("show_hide_link").style.display="none";
    document.getElementById("message_on_hide").style.display="none";
    document.getElementById("show_edit_link").style.display="";
  }
}

function toggleRegion(input, selectorText1, selectorText2, selectorText3)
{
	if (input.checked)
	{
		document.getElementById(selectorText1).className='visiblediv';
		document.getElementById(selectorText2).className='visiblediv';
		document.getElementById(selectorText3).className='visiblediv';
	}
	else
	{
		document.getElementById(selectorText1).className='hiddendiv';
		document.getElementById(selectorText2).className='hiddendiv';
		document.getElementById(selectorText3).className='hiddendiv';
	}
}

function toggleCheckboxes(input)
{

	if (input.checked)
        {
		document.getElementById("FAIL").checked = true;
		document.getElementById("PASS").checked = false;
		document.getElementById("INFO").checked = false;
		document.getElementById("WARNING").checked = false;

		if ( document.getElementById("maaval") != null )
	        document.getElementById("maaval").checked = true;

        	if ( document.getElementById("iscsval") != null )
	        document.getElementById("iscsval").checked = false;

        	if ( document.getElementById("pcval") != null )
	        document.getElementById("pcval").checked = true;

        	if ( document.getElementById("corval") != null )
	        document.getElementById("corval").checked = true;

        	if ( document.getElementById("emval") != null )
	        document.getElementById("emval").checked = true;

        	if ( document.getElementById("asrval") != null )
	        document.getElementById("asrval").checked = false;

        	if ( document.getElementById("patchval") != null )
	        document.getElementById("patchval").checked = false;

                if ( document.getElementById("filechval") != null )
                document.getElementById("filechaval").checked = false;

        	if ( document.getElementById("scval") != null )
	        document.getElementById("scval").checked = false;

        	if ( document.getElementById("tcval") != null )
	        document.getElementById("tcval").checked = false;
		
        	if ( document.getElementById("CETval") != null )
	        document.getElementById("CETval").checked = false;
	}
	else
	{
		document.getElementById("FAIL").checked = true;
                document.getElementById("PASS").checked = false;
                document.getElementById("INFO").checked = true;
                document.getElementById("WARNING").checked = true;

                if ( document.getElementById("maaval") != null )
                document.getElementById("maaval").checked = true;

                if ( document.getElementById("iscsval") != null )
                document.getElementById("iscsval").checked = true;

                if ( document.getElementById("pcval") != null )
                document.getElementById("pcval").checked = true;

                if ( document.getElementById("corval") != null )
                document.getElementById("corval").checked = true;

                if ( document.getElementById("emval") != null )
                document.getElementById("emval").checked = true;

                if ( document.getElementById("asrval") != null )
                document.getElementById("asrval").checked = true;

                if ( document.getElementById("patchval") != null )
                document.getElementById("patchval").checked = true;

               if ( document.getElementById("filechval") != null )
               document.getElementById("filechaval").checked = false;

                if ( document.getElementById("scval") != null )
                document.getElementById("scval").checked = true;

                if ( document.getElementById("tcval") != null )
                document.getElementById("tcval").checked = true;

                if ( document.getElementById("CETval") != null )
                document.getElementById("CETval").checked = true;
	}

	toggleChecks(document.getElementById('FAIL'), "FAIL");
	toggleChecks(document.getElementById('PASS'), "PASS");
	toggleChecks(document.getElementById('INFO'), "INFO");
	toggleChecks(document.getElementById('WARNING'), "WARNING");

	if ( document.getElementById("maaval") != null )
	toggleRegion(document.getElementById('maaval'), "msh","mstoc","msh");

	if ( document.getElementById("iscsval") != null )
	toggleRegion(document.getElementById('iscsval'), "t_iscs","istoc","ish");

	if ( document.getElementById("pcval") != null )
	toggleRegion(document.getElementById('pcval'), "pctoc","pcbody","pctoc");

	if ( document.getElementById("corval") != null )
	toggleRegion(document.getElementById('corval'), "corbody","corh","corh");

	if ( document.getElementById("emval") != null )
	toggleRegion(document.getElementById('emval'), "emtoc","emh","emtoc");

	if ( document.getElementById("asrval") != null )
	toggleRegion(document.getElementById('asrval'), "asrtoc","asrbody","asrtoc");

	if ( document.getElementById("patchval") != null )
	toggleRegion(document.getElementById('patchval'), "patchtoc","patchh","patchtoc");

        if ( document.getElementById("filechval") != null )
        toggleRegion(document.getElementById('filechval'), "filechtoc","filech","filechtoc");

	if ( document.getElementById("scval") != null )
	toggleRegion(document.getElementById('scval'), "sctoc","skipped_checks_section","sctoc");

	if ( document.getElementById("tcval") != null )
	toggleRegion(document.getElementById('tcval'), "tctoc","tcbody","tctoc");

	if ( document.getElementById("CETval") != null )
	toggleRegion(document.getElementById('CETval'), "CETtoc","CETbody","CETtoc");
}

function toggleChecks(input, selectorText)
{
	var pv = document.getElementById('PASS');
	var fv = document.getElementById('FAIL');
        var iv = document.getElementById('INFO');
	var wv = document.getElementById('WARNING');

    if (input.checked)
    {
		var targets = document.getElementsByClassName(selectorText);
		var i;
		for (i = 0; i < targets.length; i++) 
                {
			var innerstr = targets[i].innerHTML;
                        var res = innerstr.match(/<a href=\"#.*_details\">/);
			if(res)
			{
                        var res1 = res.toString().substr(10,32);
                        res1 = res1+"_contents";
			document.getElementById(res1).className='visiblediv';
			}
			targets[i].style.display = "table-row";
			
		}
    }
    else
    {
		var targets = document.getElementsByClassName(selectorText);
			var i;

			for (i = 0; i < targets.length; i++) 
                        {
			    var str = targets[i].innerHTML; 			    
			    var str1 = str.split(">"); 


			    if(((pv.checked && str1[0].indexOf('PASS')  >= 0) ||(fv.checked && str1[0].indexOf('FAIL')  >=0 )||(iv.checked && str1[0].indexOf('INFO')  >= 0)||(wv.checked && str1[0].indexOf('WARN') >= 0)) && (targets[i].innerHTML.indexOf('<b>Best Practices</b>') < 0)) 
			    {
			    }
			    else
			    {
				    var innerstr = targets[i].innerHTML;
				    var res = innerstr.match(/<a href=\"#.*_details\">/); 
				    if(res){
				    var res1 = res.toString().substr(10,32);
				    res1 = res1+"_contents";	
				    document.getElementById(res1).className='hiddendiv';
				   }
				    targets[i].style.display = "none"; 
			    }
			}
    }
	expand_collapse();
}
</script>
<title>Oracle $SYSTEM_NAME $report_type Report</title>
<meta name="FILE ID" content=$FILEID>
<meta name="FILE SIG" content=$FILESIG>
<meta name="FILE DATE" content=$FILEDATE>
</head><body onload="toggleChecks(document.getElementById('PASS'), &#39;PASS&#39;)">
<!-- Adding below gif will add a dependency to html report. So removed
<img border=0 src="rac_assurance_home.gif">
-->
<center><table border=0 width=100%><tr><td class="td_title" align="center">
 <h1>Oracle $SYSTEM_NAME $report_type Report<br><br>
EOF

if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
  skip_msg="<li>Skip will deduct 10 points</li>
            <li>Skipped component will deduct (No. of checks to be run on that component)*10 points</li>"
else
  skip_msg="<li>Skip will deduct 3 points</li>"
fi

if [[ -n "$run_acchk" && $run_acchk -eq "1" ]]
then
	G_TOTAL_CHECKS=$tot_acchk
	crh_passed_checks=$pass_acchk
	crh_failed_checks=$(perl -e "printf \"%.0f\", $fail_acchk+$warn_acchk;")
	less_pt=$(perl -e "printf \"%.0f\", $G_TOTAL_CHECKS-$crh_failed_checks;")
	if [ $G_TOTAL_CHECKS -gt "0" ]
	then
  	  crh_health=$(perl -e "printf \"%.0f\", int(($less_pt*100)/$G_TOTAL_CHECKS);")
	else
	  crh_health=0;
	fi
fi

if [[ $crh_total_points -gt "0" && `echo $components|grep -icw EXALOGIC_VM` -lt 1 && $print_score_in_report -ne 0 ]]
then 
  cat >> $HTML_REPFILE <<EOF
<span style="color:black;">System Health Score is $crh_health out of 100 <a style="color:black;" href="javascript:ShowHideRegion('shs_help');" title="What is this">(detail)</a> </span></h1>
<div id="shs_help" style="DISPLAY: none"><table border=0 summary="System Health Score formula"><tr><td align=left>System Health Score is derived using following formula.<ul>
<li>Every check has 10 points</li>
<li>Failure will deduct 10 points</li>
<li>Warning will deduct 5 points</li>
<li>Info will deduct 3 points</li>
$skip_msg</ul>
<table summary="PASS and FAIL statistics">
<tr><td>Total checks</td><td align=center>$G_TOTAL_CHECKS</td></tr>
<tr><td>Passed checks</td><td align=center>$crh_passed_checks</td></tr>
<tr><td>Failed(fail/warn/info/skip) checks</td><td align=center>$crh_failed_checks</td></tr>
</table>
<a href="javascript:ShowHideRegion('shs_help');"> ..Hide</a>
</td></tr></table>
</div>
EOF

fi

if [[ -n "$RAT_OS" ]] ; then
  os_version_print="$RAT_OS"
else
  if [[ -z $os_version_print ]];then
   os_version_print="$upload_dbplatform $upload_osdistro $upload_osversion $upload_oskernel"
  fi
fi

executed_hdr="<tr><td class=\"td_column\">Executed by</td><td>$usern</td></tr>"
if [ -n "$argsaved" ] ; then
  args_hdr="<tr><td class=\"td_column\">Arguments</td><td>$argsaved</td></tr>"
else
  args_hdr=""
fi
if [[ -z "$MERGEFILES" ]]
then
  ebsver=""
  if [[ -n "$EBS_VER" ]]
  then
    EBS_VER="R$EBS_VER"
    ebsver="<tr><td class=\"td_column\">EBS Version</td><td>$EBS_VER</td></tr>"
  fi
  duration_hdr="<tr><td class=\"td_column\">Duration</td><td>$checks_duration</td></tr>"
  collection_hdr="<tr><td class=\"td_column\">Collection Date</td><td>$collection_date</td></tr>"
else
  if [[ -n $SKIP_CRS_VAL && $SKIP_CRS_VAL -eq "1" ]]; then cname_link=""; fi
  profile_link=""
  ex_profile_link=""
  collection_hdr=""
  executed_hdr="<tr><td class=\"td_column\">Merge Executed by</td><td>$usern</td></tr>"
fi
if [ $is_zfssa_machine -eq 1 ]
then
   os_kernel_link=""
else
   os_kernel_link="<tr><td class="td_column">OS/Kernel Version</td><td>$os_version_print</td></tr>"
fi
if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
  cname_link=""
  crs_hv_link=""
  dbhv_link=""
  profile_link=""
  node_dlink=""
fi

if [[ -n "$run_acchk" && $run_acchk -eq "1" ]]
then
cat >> $HTML_REPFILE <<EOF
</td></tr></table></center>
<H2>$summary_heading</H2>
<table border=1 summary="Summary" role="presentation">
$os_kernel_link
$cev_link
$tv_link
$node_slink
$node_dlink
$phy_node_dlink
$vir_node_dlink
$el_cs_row
$cells_link
$zfs_link
$ext_zfs_link
$ibs_link
$tor_sw_link
$upg_link
<tr><td class="td_column">Collection</td><td>$collection_name</td></tr>
$duration_hdr
$executed_hdr
$args_hdr
$collection_hdr
</table>
EOF
else
cat >> $HTML_REPFILE <<EOF
</td></tr></table></center>
<H2>$summary_heading</H2>
<table border=1 summary="Cluster Summary" role="presentation">
$cname_link
$merge_collection_link
$os_kernel_link
$exalogic_version_link
$asm_h_link
$crs_hv_link
$dbhv_link
$oms_h_link
$em_h_link
$obiee_homes_link
$tt_homes_link
$ogg_home_dlink
$cev_link
$tv_link
$node_slink
$node_dlink
$phy_node_dlink
$vir_node_dlink
$el_cs_row
$cells_link
$zfs_link
$ext_zfs_link
$ibs_link
$tor_sw_link
$upg_link
$profile_link
$ex_profile_link
$ex_vm_files
<tr><td class="td_column">Collection</td><td>$collection_name</td></tr>
$ebsver
$duration_hdr
$executed_hdr
$args_hdr
$collection_hdr
</table>
EOF
fi

if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "1" ]] ; then
cat >$HTML_PASS_FILE <<EOF
<hr>
<a class="a_bgw" href="#">Top</a>
<a name="passed_checks"></a>
<H2>Findings Passed</h2>

EOF
fi

  #GoldenGate--
  gg_id=$(grep -i "^goldengate|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2) 
  #--
  #PEOPLESOFT--
  peoplesoft_id=$(grep -i "^peoplesoft|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #SIEBEL--
  siebel_id=$(grep -i "^siebel|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #CORROBORATE--
  corroborate_id=$(grep -i "^corroborate|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #OAM--
  oam_id=$(grep -i "^oam|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #OUD--
  oud_id=$(grep -i "^oud|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #OIM--
  oim_id=$(grep -i "^oim|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #UDC--
  udc_id="RANDOMID"
  #PLATINUM--
  platinum_id=$(grep -i "^platinum|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #EBS--
  ebs_id=$(grep -i "^ebs|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #EBS--
  em_id=$(grep -i "^em|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  

  crh_cnt=${#G_CHECKIDS[@]}
  maa_id=0
  gg_cnt=0
  peoplesoft_cnt=0
  siebel_cnt=0
  corroborate_cnt=0
  oam_cnt_fail=0
  oam_cnt_pass=0
  oud_cnt_fail=0
  oud_cnt_pass=0
  oim_cnt_pass=0
  oim_cnt_fail=0
  udc_cnt=0
  platinum_cnt=0
  ebs_cnt=0
  em_cnt=0
  #echo "Total=$crh_cnt"
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1
    chk_status=$(echo ${G_CHECKID_STATUS[$crh_cnt]} | awk -F":" '{print $1}')

    if [[ $chk_status = "FAIL" ]]
    then
	#chk_status1="<span class=\"status_FAIL\">FAIL</span>"
	chk_status1="<font color=\"#c70303\"><b>FAIL</b></font>"
    elif [[ $chk_status = "WARNING" ]] || [[ $chk_status = "WARN" ]]
    then
        #chk_status1="<span class=\"status_WARNING\">WARNING</span>"
	chk_status1="<font color=\"#8B008B\"><b>WARNING</b></font>"
	chk_status="WARNING"
    elif [[ $chk_status = "INFO" ]]
    then
        #chk_status1="<span class=\"status_INFO\">INFO</span>"
	chk_status1="<font color=\"blue\"><b>INFO</b></font>"
    else
	#chk_status1="<span class=\"status_PASS\">PASS</span>"
	chk_status1="<font color=\"#006600\"><b>PASS</b></font>"
    fi

    # Display only $G_HOST_CNT hosts and display more link
    # When all hosts, then display All
    crh_hosts=""
    # The prefix for seprating reports from storage servers, compute nodes etc
    # It will be compute, cell, switch, cluster or system
    crh_rep_prefix=""
    crh_rep_ptext=""
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" && -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]]
    then
      el_prefix=""
      nodearr=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | tr "," "\n")
      convserver=0
      cnode=0
       for crh_first_host in $nodearr
       do
         get_el_prefix "$crh_first_host"
         if [[ $el_prefix = "DB" ||  $el_prefix = "OVMM" || $el_prefix = "EC" || $el_prefix = "PC" ]] ; then
           let convserver=$convserver+1
           isconvserver=1
           iscnode=0 
        else
          let cnode=$cnode+1
          iscnode=1
          isconvserver=0
        fi

       if [[ $isconvserver -eq "1" &&  $convserver -eq "1" ]] || [[ $iscnode -eq "1" &&  $cnode -eq "1" ]] ; then
        get_host_string_html $crh_first_host $el_prefix
        get_tail_html
       fi
      done
    else
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] ; then
        el_prefix=""
        nodearr=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | tr "," "\n")
        for crh_first_host in $nodearr
        do
	  first_host=$(echo "$crh_first_host" | sed 's/ //g')
          get_host_string_html $first_host
        done
      else
        get_host_string_html
      fi
      get_tail_html
    fi
  done

  #GoldenGate Block....
  if [ $gg_cnt -gt 0 ]
  then
    goldengate_toc_entry="<li><a href=\"#goldengate\">GoldenGate</a></li>"
    
    HTML_GG_MAIN=${OUTPUTDIR}/goldengate.html
    cat > $HTML_GG_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="goldengate"></a>
       <h2>GoldenGate</h2>
       <table border=1 id="GoldenGate" summary="GoldenGate checks">
       <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
       <th scope="col">Status</th>
       <th scope="col">Type</th>
       <th scope="col">Message</th>
       <th scope="col">Status On</th>
       <th scope="col">Details</th></tr>
EOF
    for gg_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/GG_${gg_etype}.html" ]; 
      then 
        cat ${OUTPUTDIR}/GG_${gg_etype}.html >> $HTML_GG_MAIN 
        rm -f ${OUTPUTDIR}/GG_${gg_etype}.html
      fi
    done
    echo "</table>" >> $HTML_GG_MAIN
  fi

   #PEOPLESOFT Block....
  if [ $peoplesoft_cnt -gt 0 ]
  then
    peoplesoft_toc_entry="<li><a href=\"#peoplesoft\">Peoplesoft Checks</a></li>"

    HTML_PEOPLESOFT_MAIN=${OUTPUTDIR}/peoplesoft.html
    cat > $HTML_PEOPLESOFT_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="peoplesoft"></a>
       <h2>Peoplesoft Checks</h2>
EOF

    cat >> $HTML_PEOPLESOFT_MAIN <<EOF
         <table border=1 id="peoplesoft" summary="Peoplesoft Checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for peoplesoft_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_etype}.html" ];
      then
        cat ${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_etype}.html >> $HTML_PEOPLESOFT_MAIN
        rm -f ${OUTPUTDIR}/PEOPLESOFT_${peoplesoft_etype}.html
      fi
    done
    echo "</table>" >> $HTML_PEOPLESOFT_MAIN
  fi


  #SIEBEL Block....
  if [ $siebel_cnt -gt 0 ]
  then
    siebel_toc_entry="<li><a href=\"#siebel\">Siebel Checks</a></li>"

    HTML_SIEBEL_MAIN=${OUTPUTDIR}/siebel.html
    cat > $HTML_SIEBEL_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="siebel"></a>
       <h2>Siebel Checks</h2>
EOF

    cat >> $HTML_SIEBEL_MAIN <<EOF
         <table border=1 id="siebel" summary="Siebel Checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for siebel_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/SIEBEL_${siebel_etype}.html" ];
      then
        cat ${OUTPUTDIR}/SIEBEL_${siebel_etype}.html >> $HTML_SIEBEL_MAIN
        rm -f ${OUTPUTDIR}/SIEBEL_${siebel_etype}.html
      fi
    done
    echo "</table>" >> $HTML_SIEBEL_MAIN
  fi

  #CORROBORATE Block....
  if [ $corroborate_cnt -gt 0 ]
  then
    cor_checkbox=1
    corroborate_toc_entry="<div id=\"corh\"><li><a href=\"#corroborate\">Findings needing further review</a></li></div>"

    HTML_CORROBORATE_MAIN=${OUTPUTDIR}/corroborate.html
    cat > $HTML_CORROBORATE_MAIN <<EOF
       <div id="corbody">
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="corroborate"></a>
       <h2>Findings needing further review</h2>
EOF
    echo "<p>NOTE: This section contains best practices that ${program_name} can only do a partial check for because a complete check requires information it cannot gather (ex: data outside of ${program_name} run scope, requires customer knowledge, etc). Please investigate the partial finding that ${program_name} reports in this section, paying particular attention to the details, to determine if any action is required. </p>"  >> $HTML_CORROBORATE_MAIN;

    cat >> $HTML_CORROBORATE_MAIN <<EOF
         <table border=1 id="corroborate" summary="Findings needing further review">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for corroborate_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/CORROBORATE_${corroborate_etype}.html" ];
      then
        cat ${OUTPUTDIR}/CORROBORATE_${corroborate_etype}.html >> $HTML_CORROBORATE_MAIN
        rm -f ${OUTPUTDIR}/CORROBORATE_${corroborate_etype}.html
      fi
    done
    echo "</table></div>" >> $HTML_CORROBORATE_MAIN
  fi

  #OAM Block....
  if [ $oam_cnt_fail -gt 0 ] || [ $oam_cnt_pass -gt 0 ] 
  then
    oam_toc_entry="<li><a href=\"#oam\">Oracle Access Manager checks</a></li>"

    HTML_OAM_MAIN=${OUTPUTDIR}/oam.html
    cat > $HTML_OAM_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="oam"></a>
       <h2>OAM checks</h2>
EOF

    cat >> $HTML_OAM_MAIN <<EOF
         <table border=1 id="oam" summary="OAM checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for oam_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/OAM_${oam_etype}.html" ];
      then
        cat ${OUTPUTDIR}/OAM_${oam_etype}.html >> $HTML_OAM_MAIN
        rm -f ${OUTPUTDIR}/OAM_${oam_etype}.html
      fi
    done
    echo "</table>" >> $HTML_OAM_MAIN
  fi


  #OUD Block....
  if [ $oud_cnt_fail -gt 0 ] || [ $oud_cnt_pass -gt 0 ]
  then
    oud_toc_entry="<li><a href=\"#oud\">Oracle Unified Directory checks</a></li>"

    HTML_OUD_MAIN=${OUTPUTDIR}/oud.html
    cat > $HTML_OUD_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="oud"></a>
       <h2>OUD checks</h2>
EOF

    cat >> $HTML_OUD_MAIN <<EOF
         <table border=1 id="oud" summary="OUD checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for oud_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/OUD_${oud_etype}.html" ];
      then
        cat ${OUTPUTDIR}/OUD_${oud_etype}.html >> $HTML_OUD_MAIN
        rm -f ${OUTPUTDIR}/OUD_${oud_etype}.html
      fi
    done
    echo "</table>" >> $HTML_OUD_MAIN
  fi


  #OIM Block....
  if [ $oim_cnt_fail -gt 0 ] || [ $oim_cnt_pass -gt 0 ]
  then
    oim_toc_entry="<li><a href=\"#oim\">Oracle Identity Manager checks</a></li>"

    HTML_OIM_MAIN=${OUTPUTDIR}/oim.html
    cat > $HTML_OIM_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="oim"></a>
       <h2>OIM checks</h2>
EOF

    cat >> $HTML_OIM_MAIN <<EOF
         <table border=1 id="oim" summary="OIM checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for oim_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/OIM_${oim_etype}.html" ];
      then
        cat ${OUTPUTDIR}/OIM_${oim_etype}.html >> $HTML_OIM_MAIN
        rm -f ${OUTPUTDIR}/OIM_${oim_etype}.html
      fi
    done
    echo "</table>" >> $HTML_OIM_MAIN
  fi


  #UDC Block....
  if [ $udc_cnt -gt 0 ]
  then
    udc_toc_entry="<li><a href=\"#udc\">User Defined Checks</a></li>"

    HTML_UDC_MAIN=${OUTPUTDIR}/udc.html
    cat > $HTML_UDC_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="udc"></a>
       <h2>User Defined Checks</h2>
EOF

    cat >> $HTML_UDC_MAIN <<EOF
         <table border=1 id="udc" summary="User Defined Checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for udc_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/UDC_${udc_etype}.html" ];
      then
        cat ${OUTPUTDIR}/UDC_${udc_etype}.html >> $HTML_UDC_MAIN
        rm -f ${OUTPUTDIR}/UDC_${udc_etype}.html
      fi
    done
    echo "</table>" >> $HTML_UDC_MAIN
  fi

  #PLATINUM Block....
  if [ $platinum_cnt -gt 0 ]
  then
    pc_checkbox=1
    platinum_toc_entry="<div id=\"pctoc\"><li><a href=\"#platinum\">Platinum Certification</a></li></div>"

    HTML_PLATINUM_MAIN=${OUTPUTDIR}/platinum.html
    cat > $HTML_PLATINUM_MAIN <<EOF
       <div id="pcbody">
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="platinum"></a>
       <h2>Platinum Certification</h2>
EOF

    cat >> $HTML_PLATINUM_MAIN <<EOF
         <table border=1 id="platinum" summary="Platinum Certification checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for platinum_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/PLATINUM_${platinum_etype}.html" ];
      then
        cat ${OUTPUTDIR}/PLATINUM_${platinum_etype}.html >> $HTML_PLATINUM_MAIN
        rm -f ${OUTPUTDIR}/PLATINUM_${platinum_etype}.html
      fi
    done
    echo "</table></div>" >> $HTML_PLATINUM_MAIN
  fi

  #EBS Block....
  if [ $ebs_cnt -gt 0 ]
  then
    ebs_toc_entry="<li><a href=\"#e-business_suite\">E-Business Suite</a></li>"
    
    HTML_EBS_MAIN=${OUTPUTDIR}/ebs.html
    cat > $HTML_EBS_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="e-business_suite"></a>
       <h2>E-Business Suite</h2>
EOF
    #Message for skipped checks

    if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]]
    then
      custom_msg=0
      for chkid in `cat  $OUTPUTDIR/${program_name}_skipped_checks.log| cut -d'(' -f2 | cut -d')' -f1|sed 's/checkid:-//'`
      do
        if [[ `grep -iwc "$chkid" $SCRIPTPATH/.cgrep/profiles/E8DF76E07DD82E0DE04313C0E50AA55D.prf` -gt 0 ]]
        then
          custom_msg=1
        fi
      done

    fi

    echo "<b><p style=\"font-size:14px\"><span style=\"color:#c70303;font-size:14px\">NOTE!</span> Checks have been run for the following EBS areas: (the results you see will depend on the selection of check status visibility at the top of the report) $RAT_PLA_GRP.</p></b>"  >> $HTML_EBS_MAIN;

    echo "<b><p style=\"font-size:14px\"><span style=\"font-size:14px\">EBS Version:</span> $EBS_VER</p></b>"  >> $HTML_EBS_MAIN;

    cat >> $HTML_EBS_MAIN <<EOF
         <table border=1 id="E-Business_Suite" summary="E-Business Suite checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF

    old_ifs=$IFS
    IFS=","
    for pla_area in `echo "$RAT_PLA_AREA"`
    do
      iddval=""
      if [[ -r "${OUTPUTDIR}/EBS_${pla_area}_PASS.html"  ]]
      then
	iddval="$iddval PASS"
      fi
      if [[ -r "${OUTPUTDIR}/EBS_${pla_area}_ERROR.html"  ]]
      then
	 iddval="$iddval ERROR"
      fi
      if [[ -r "${OUTPUTDIR}/EBS_${pla_area}_INFO.html" ]]
      then
	iddval="$iddval INFO"
      fi
	if [[ -r "${OUTPUTDIR}/EBS_${pla_area}_FAIL.html" ]]
      then
	iddval="$iddval FAIL"
      fi
	if [[ -r "${OUTPUTDIR}/EBS_${pla_area}_WARNING.html" ]]
      then
	iddval="$iddval WARNING"
      fi
      if [[ -r "${OUTPUTDIR}/EBS_${pla_area}_OTHER.html" ]]
      then
	iddval="$iddval OTHER"
      fi

      if [[ -r "${OUTPUTDIR}/EBS_${pla_area}_ERROR.html" ||  -r "${OUTPUTDIR}/EBS_${pla_area}_FAIL.html" || -r "${OUTPUTDIR}/EBS_${pla_area}_WARNING.html" || -r "${OUTPUTDIR}/EBS_${pla_area}_INFO.html" || -r "${OUTPUTDIR}/EBS_${pla_area}_OTHER.html" || -r "${OUTPUTDIR}/EBS_${pla_area}_PASS.html" ]]
      then 
        set_grp_val $pla_area 
        echo "<tr class=\"$iddval\"$classattr><td id =\"$iddval\" colspan=\"5\" scope=\"row\" style=\"text-align: center;\"><b>$grpval</b></td></tr>" >> $HTML_EBS_MAIN
        for ebs_etype in ERROR FAIL WARNING INFO OTHER PASS
        do
          if [ -r "${OUTPUTDIR}/EBS_${pla_area}_${ebs_etype}.html" ]; 
          then 
            cat ${OUTPUTDIR}/EBS_${pla_area}_${ebs_etype}.html >> $HTML_EBS_MAIN 
            rm -f ${OUTPUTDIR}/EBS_${pla_area}_${ebs_etype}.html
          fi
        done
      fi
    done
    IFS=$old_ifs
    echo "</table>" >> $HTML_EBS_MAIN
  fi

  #EM Block....
  if [ $em_cnt -gt 0 ]
  then
    em_checkbox=1
    em_toc_entry="<div id=\"emtoc\"><li><a href=\"#enterprise_manager\">Enterprise Manager</a></li></div>"

    HTML_EM_MAIN=${OUTPUTDIR}/em.html
    cat > $HTML_EM_MAIN <<EOF
       <div id="emh"><hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="enterprise_manager"></a>
       <h2>Enterprise Manager</h2>
       <table border=1 id="Enterprise_Manager" summary="Enterprise Manager checks">
       <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
       <th scope="col">Status</th>
       <th scope="col">Type</th>
       <th scope="col">Message</th>
       <th scope="col">Status On</th>
       <th scope="col">Details</th></tr>
EOF
    for em_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/EM_${em_etype}.html" ];
      then
        cat ${OUTPUTDIR}/EM_${em_etype}.html >> $HTML_EM_MAIN
        rm -f ${OUTPUTDIR}/EM_${em_etype}.html
      fi
    done
    echo "</table></div>" >> $HTML_EM_MAIN
  fi
  
  if [[ $file_checker -eq 1 ]];then
    filech_toc_entry="<div id=\"filechtoc\"><li><a href=\"#filech_detailed\">File Attribute Changes</a></li></div>"
  fi
  # Append all MAA files
  maa_ids_cnt=$maa_id
  if [ $maa_id -gt 0 ]
  then
    maa_checkbox=1
    maa_toc_entry="<div id=\"mstoc\"><li><a href=\"#maa_scorecard\">Maximum Availability Architecture (MAA) Scorecard</a></li></div>"
    cat > $HTML_MAA_SC <<EOF
      <hr>
      <a href="#"  class="a_bgw">Top</a>
      <a name="maa_scorecard"></a>
      <div id="msh"><H2>Maximum Availability Architecture (MAA) Scorecard</h2>
           <table border=1 id="maasctbl_${crh_rep_prefix}" summary="Maximum Availability Architecture (MAA) scorecard">
           <tr><th>Outage Type</th>
	   <th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
           <th scope="col">Status</th>
           <th scope="col">Type</th>
           <th scope="col">Message</th>
           <th scope="col">Status On</th>
           <th scope="col">Details</th></tr>
EOF

    # Hack to sort the MAA Scorecard 
    # 1) computer failure 
    # 2) storage failure
    # 3) data corruptions
    # 4) logical corruptions
    # 5) database/cluster/site failure
    # 6) network failures
    # 7) client failover
    # 8) Oracle recovery manager(rman) best practices
    # 9) operational practices
    # 10) Software maintainance best practices
    # 11) consolidation practices
    # We read array from end to start. So add entries in reverse order

    for maa_sf2 in "CONSOLIDATION DATABASE PRACTICES" "OPERATIONAL BEST PRACTICES" "ORACLE GOLDENGATE FAILURE PREVENTION BEST PRACTICES" "ORACLE RECOVERY MANAGER (RMAN) BEST PRACTICES" "CLIENT FAILOVER OPERATIONAL BEST PRACTICES" "NETWORK FAILURE PREVENTION BEST PRACTICES" "DATABASE/CLUSTER/SITE FAILURE PREVENTION BEST PRACTICES" "LOGICAL CORRUPTION PREVENTION BEST PRACTICES" "DATA CORRUPTION PREVENTION BEST PRACTICES" "STORAGE FAILURES PREVENTION BEST PRACTICES" "COMPUTER FAILURE PREVENTION BEST PRACTICES" "DATABASE FAILURE PREVENTION BEST PRACTICES" "SOFTWARE MAINTENANCE BEST PRACTICES"
    do
      maa_sfname2=$(echo $maa_sf2 |  sed 's/[^a-zA-Z0-9]//g')
      MAA_IDS[$maa_id]=$maa_sfname2
      let maa_id=$maa_id+1
    done

    # echo "maa_id = $maa_id"
    while [ $maa_id -ge 0 ]
    do
      maa_otstatus="INFO"
      maa_otstatus_fo="INFO"
      if [ -e "${OUTPUTDIR}/${MAA_IDS[$maa_id]}_PASS_SF.html" ]
      then
        maa_otstatus="PASS"
        maa_otstatus_fo="PASS"
      fi

      chk_matrix=1
      for crh_etype in ERROR FAIL WARNING INFO OTHER
      do
        maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_${crh_etype}_SF.html"
        if [ -e "$maa_ofile" ]
        then
          maa_otstatus="FAIL"
	  maa_otstatus_fo="INFO"
        fi
	if [[ $crh_etype != "INFO" ]]; then chk_matrix=0; fi
      done

      if [ -e "${OUTPUTDIR}/${MAA_IDS[$maa_id]}_FAIL_SF.html" ]
      then
        maa_otstatus_fo="FAIL"
      fi

      if [ `echo ${MAA_IDS[$maa_id]} | grep 'SOFTWAREMAINTENANCEBESTPRACTICES'| wc -l` -eq 1 ] 
      then
        if [[ $chk_matrix -eq "1" ]]; then
          if [[ $OFFLINE -eq 1 ]];then
	    VDIR="${OUTPUTDIR}/versions.dat"
	  else
	    VDIR="${INPUTDIR}/versions.dat"
	  fi

      	  version_ofile="${OUTPUTDIR}/versions.html"
	  if [ -e "$version_ofile" ]; then
	    if [ -e "$VDIR" ] ; then
  	      OIFS=$IFS
	      IFS=$'\n'
	      for pattern in `awk -F';' '{print $8}' "$VDIR"|grep -v "^\s*$"|grep -v "^MESSAGE$"|sed 's/^\s*//g'|sed 's/\s*$//g'`
	      do
	        if [[ `grep -c "$pattern" $version_ofile` -eq "0" ]]; then maa_otstatus="PASS";maa_otstatus_fo="PASS"; else maa_otstatus="FAIL";maa_otstatus_fo="FAIL"; break; fi
	      done
    	      if [[ `grep -ic "Version is different from peers" "$version_ofile"` -gt "0" ]]; then maa_otstatus="FAIL"; maa_otstatus_fo="FAIL"; fi
	      IFS=$OIFS		
	    fi
	  fi
	fi
      fi

      maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_TOP.html"
      if [ -e "$maa_ofile" ] 
      then
        if [ $maa_otstatus = "INFO" ]
        then # No other *_SF files exists
          maa_otcnt=0
	  maa_otcnt_less=0
        else
          #maa_otcnt=$(wc -l ${OUTPUTDIR}/${MAA_IDS[$maa_id]}_*_SF.html| tail -1 | awk '{print $1}')
	  #maa_otcnt_less=$maa_otcnt/2
	   maa_otcnt=1
	   maa_otcnt_less=1
        fi
	let maa_otcnt_less=$maa_otcnt_less+1
        let maa_otcnt=$maa_otcnt+1
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE/${maa_otcnt_less}/'"
	replace_command1="sed 's/PLACEHOLDERTOREPLACE/${maa_otcnt}/'"
        replace_command_status="sed 's/PLACEHOLDER_STATUS/${maa_otstatus}/'"
        replace_command_status_class="sed 's/PLACEHOLDER_FO/${maa_otstatus_fo}/'"
        cat $maa_ofile | eval $replace_command | eval $replace_command_status | eval $replace_command1| eval $replace_command_status_class  >> $HTML_MAA_SC
        rm -f $maa_ofile
      fi
      for crh_etype in ERROR FAIL WARNING INFO OTHER PASS
      do
        maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_${crh_etype}_SF.html"
        # echo "-- $maa_ofile"
        if [ -e "$maa_ofile" ] 
        then
          if [ $table_printed -eq 0 ] ; then
	    table_printed=1
	    maaidx=`echo ${MAA_IDS[$maa_id]}|sed 's/A//g'|sed 's/E//g'`
	    echo "<tr><td colspan=6 scope=\"row\" style=\"padding:0;\"><table id=\"maasctbl_inner_${maaidx}\" width=100% summary=\"${MAA_IDS[$maa_id]}\">" >> $HTML_MAA_SC
          fi
          cat $maa_ofile >> $HTML_MAA_SC
          rm -f $maa_ofile
        fi
      done
      if [ $table_printed -eq 1 ] ; then
        table_printed=0
        echo "</table></td></tr>" >> $HTML_MAA_SC
      fi

      if [ `echo ${MAA_IDS[$maa_id]} | grep 'SOFTWAREMAINTENANCEBESTPRACTICES'| wc -l` -eq 1 ] 
      then
      	version_ofile="${OUTPUTDIR}/versions.html"
	if [ -e "$version_ofile" ]
	then
  	  cat $version_ofile >> $HTML_MAA_SC
	  echo "" > $version_ofile
	fi
      fi
      let maa_id=$maa_id-1
    done
    echo "</table></div>" >> $HTML_MAA_SC
  fi

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && -e ${OUTPUTDIR}/isc_summary.html ]] || [[ -n "$is_ssc_machine" && $is_ssc_machine -eq 1 && -e ${OUTPUTDIR}/isc_summary.html ]] || [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 && -e ${OUTPUTDIR}/isc_summary.html ]] || [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq 1 && -e ${OUTPUTDIR}/isc_summary.html ]]; then
    iscs_toc_entry="<div id=\"istoc\"><li><a class=\"a_bgw\" href=\"#iscs_versions\">Infrastructure Software and Configuration Summary</a></li></div>"
  fi 

  # Append the <errortype>.html to FAILED_<type>.html 
  for crh_ctype in compute cvserver cell zfscell extzfscell switch torswitch cluster system
  do
    case  $crh_ctype in
         compute)
            crh_ctext="$node_heading"
	    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	      crh_ctext="Node"
	    fi
            ;;
         cvserver)
            crh_ctext="Control vServer"
            ;;
         zfscell)
            crh_ctext="ZFS Storage Appliance"
            ;;
         cell)
            crh_ctext="Storage Server"
            ;;
         extzfscell)
            crh_ctext="External ZFS Storage Appliance"
            ;;
         switch)
            crh_ctext="InfiniBand Switch"
            ;;
         torswitch)
            crh_ctext="TOR Switch"
            ;;
         cluster)
            crh_ctext="$html_rack_type Wide"
            ;;
         system)
            crh_ctext="System Wide"
            ;;
         *)
            crh_ctext="$node_heading"
            ;;
    esac

    for crh_etype in ERROR FAIL WARNING INFO OTHER
    do
      crh_file_name="${OUTPUTDIR}/${crh_etype}_${crh_ctype}.html";
      if [ -e "${crh_file_name}" ]
      then
        if [ ! -r "${OUTPUTDIR}/FAILED_${crh_ctype}.html" ]
        then
          cat > ${OUTPUTDIR}/FAILED_${crh_ctype}.html <<EOF
             <a name="failed_checks_${crh_ctype}"></a>
             <H2>$crh_ctext</h2>
             <table border=1 id="failedtbl_${crh_ctype}" summary="Failed checks">
             <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
             <th scope="col">Status</th>
             <th scope="col">Type</th>
             <th scope="col">Message</th>
             <th scope="col">Status On</th>
             <th scope="col">Details</th></tr>
EOF
        fi
        cat ${crh_file_name} >> ${OUTPUTDIR}/FAILED_${crh_ctype}.html
        rm -f ${crh_file_name}
      fi
    done
    #if [ -r "${OUTPUTDIR}/FAILED_${crh_ctype}.html" ]
    #then
    #  echo "</table>" >> ${OUTPUTDIR}/FAILED_${crh_ctype}.html
    #fi
  done

  has_killed_procs=0
  has_skipped_checks=0
  has_skipped_nodes=0
  all_passed_text=" - All Checks Passed"
  #if [[ -e "$OUTPUTDIR/watchdog.log" && `grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -ivc "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' ` -gt 0 ]]
  if [[ -e "$OUTPUTDIR/watchdog.log" && `grep -ic "timed out" $OUTPUTDIR/watchdog.log ` -gt 0 ]]
  then
    has_killed_procs=1
    #has_killed_procs=0
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]]
  then
    has_skipped_checks=1
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]] 
  then
    has_skipped_nodes=1
  fi
  # Added this to print a warning if user ran older version of tool or print how many days this is version good
  if [[ -n "$cdfYes" && $cdfYes -eq 1 ]]
  then
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:red;font-size:14px\">WARNING!</span> $oldVersionWarningMessage.</p></b>" >> $HTML_REPFILE
  else
    if [[ -z "$RAT_ENABLE_STALENESS_VALIDATION" ]]
    then
      if [[ ! -e /opt/oracle/oak/install/inittab && ! -e /opt/oracle/bda ]]
      then
        echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:green;font-size:14px\">Note!</span> This version of ${program_name} is considered valid for ${validVersionDays} days from today or until a new version is available</p></b>" >> $HTML_REPFILE
      fi
    else
      echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:green;font-size:14px\">Note!</span> This version of ${program_name} is considered valid for ${validVersionDays} days from today or until a new version is available</p></b>" >> $HTML_REPFILE
    fi
  fi


  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1  && $is_avm_machine -eq 0 ]]
  then
    echo "<br/><br/><p><b>NOTE : </b>$program_name is only one part of the MAA Best Practices recommendation methodology. My Oracle Support \"Oracle Exadata Best Practices (Doc <a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=757552.1\" target=\"_blank\">ID757552.1</a>)\" should be reviewed thoroughly as it is the driver for exachk and contains additional operational and diagnostic guidance that is not programmed within $program_name.</p>" >> $HTML_REPFILE
  fi

  if [[ $has_killed_procs -eq "1" || $has_skipped_checks -eq "1" ]] ; then
    if [[ `uname -s` = "SunOS" || `uname -s` = "AIX" || `uname -s` = "HP-UX" ]] ; then
      tname=$(echo ${program_name} | sed -e 's/^./\E/g')
    else
      tname=$(echo ${program_name} | sed -e 's/^./\U&\E/g')
    fi
    
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:#c70303;font-size:14px\">WARNING!</span> The data collection activity appears to be incomplete for this ${program_name} run.  Please review the \"Killed Processes\" and / or \"Skipped Checks\" section and refer to \"Appendix A - Troubleshooting Scenarios\" of the \"${tname} User Guide\" for corrective actions.</p></b>" >> $HTML_REPFILE
    all_passed_text=" - No failed checks reported; review  \"Killed Processes\" and / or \"Skipped Checks\""
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]]
  then
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:#c70303;font-size:14px\">WARNING!</span> ${program_name} was unable to connect to few nodes. This condition will result in missing data and an incomplete ${program_name} report.  Click on \"<a href=\"#skipped_nodes\">Skipped Nodes</a>\" link in Table of contents to see list of nodes. Investigate why these nodes could not be pinged from the database server where ${program_name} was launched, and take corrective action, followed by another ${program_name} run.</p></b>" >> $HTML_REPFILE
  fi
  # append all failed html reports to HTML_FAILED_FILE
  crh_toc_failed_compute=""
  if [ -r "${OUTPUTDIR}/FAILED_compute.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_compute.html >> $HTML_FAILED_FILE
    crh_toc_failed_compute="<li><a class=\"a_bgw\" href=\"#failed_checks_compute\">$node_heading</a></li>"
  else
    if [ -r "${OUTPUTDIR}/PASS_compute.html" ]
    then
      cat ${OUTPUTDIR}/PASS_compute_header.html >> $HTML_FAILED_FILE
    fi
    if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
      crh_toc_failed_compute=""
    else  
      if [ $is_zfssa_machine -eq 0 ]
      then
        crh_toc_failed_compute="<li><a class=\"a_bgw\" href=\"#failed_checks_compute\">$node_heading$all_passed_text</a></li>"
      else
        crh_toc_failed_compute=""
      fi
    fi
  fi

  if [ -r "${OUTPUTDIR}/PASS_compute.html" ]
  then
    cat ${OUTPUTDIR}/PASS_compute.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_compute.html" || -r "${OUTPUTDIR}/PASS_compute.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_compute.html
    rm -f ${OUTPUTDIR}/FAILED_compute.html
  fi

  crh_toc_failed_cvserver=""
  if [ -r "${OUTPUTDIR}/FAILED_cvserver.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cvserver.html >> $HTML_FAILED_FILE
    crh_toc_failed_cvserver="<li><a class=\"a_bgw\" href=\"#failed_checks_cvserver\">Control vServer</a></li>"
  elif [[ $in_ec_exalogic -eq "1" ]] ; then
    if [ -r "${OUTPUTDIR}/PASS_cvserver.html" ]
    then
      cat ${OUTPUTDIR}/PASS_cvserver_header.html >> $HTML_FAILED_FILE
    fi
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]]; then
      crh_toc_failed_cvserver="<li><a class=\"a_bgw\" href=\"#failed_checks_cvserver\">Control vServer$all_passed_text</a></li>"
    fi
  fi

  if [ -r "${OUTPUTDIR}/PASS_cvserver.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cvserver.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_cvserver.html" || -r "${OUTPUTDIR}/PASS_cvserver.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_cvserver.html
    rm -f ${OUTPUTDIR}/FAILED_cvserver.html
  fi


  crh_toc_failed_cell=""
  if [ -r "${OUTPUTDIR}/FAILED_cell.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cell.html >> $HTML_FAILED_FILE
    crh_toc_failed_cell="<li><a class=\"a_bgw\" href=\"#failed_checks_cell\">Storage Server</a></li>"
  elif [[ -n "$cells_link" ]] ; then
    crh_toc_failed_cell="<li><a class=\"a_bgw\" href=\"#failed_checks_cell\">Storage Server$all_passed_text</a></li>"
    if [ -r "${OUTPUTDIR}/PASS_cell.html" ]
    then
      cat ${OUTPUTDIR}/PASS_cell_header.html >> $HTML_FAILED_FILE
    fi
    
  fi

  if [ -r "${OUTPUTDIR}/PASS_cell.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cell.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_cell.html" || -r "${OUTPUTDIR}/PASS_cell.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_cell.html
    rm -f ${OUTPUTDIR}/FAILED_cell.html
  fi


  crh_toc_failed_zfscell=""
  if [[ -r "${OUTPUTDIR}/FAILED_zfscell.html" && -n "$CELLDIR" && -e "$ZFSIP" ]] 
  then
    cat ${OUTPUTDIR}/FAILED_zfscell.html >> $HTML_FAILED_FILE
    crh_toc_failed_zfscell="<li><a class=\"a_bgw\" href=\"#failed_checks_zfscell\">ZFS Storage Appliance</a></li>"
  elif [[ -n "$zfs_link" ]] ; then
    crh_toc_failed_zfscell="<li><a class=\"a_bgw\" href=\"#failed_checks_zfscell\">ZFS Storage Appliance$all_passed_text</a></li>"
    if [ -r "${OUTPUTDIR}/PASS_zfscell.html" ]
    then
      cat ${OUTPUTDIR}/PASS_zfscell_header.html >> $HTML_FAILED_FILE
    fi
  fi

  if [ -r "${OUTPUTDIR}/PASS_zfscell.html" ]
  then
    cat ${OUTPUTDIR}/PASS_zfscell.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_zfscell.html" || -r "${OUTPUTDIR}/PASS_zfscell.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_zfscell.html
    rm -f ${OUTPUTDIR}/FAILED_zfscell.html
  fi

  crh_toc_failed_extzfscell=""
  if [[ -r "${OUTPUTDIR}/FAILED_extzfscell.html" && -n "$CELLDIR" && -e "$EXTZFSIP" ]]
  then
    cat ${OUTPUTDIR}/FAILED_extzfscell.html >> $HTML_FAILED_FILE
    crh_toc_failed_extzfscell="<li><a class=\"a_bgw\" href=\"#failed_checks_extzfscell\">External ZFS Storage Appliance</a></li>"
  elif [[ -n "$ext_zfs_link" ]] ; then
    crh_toc_failed_extzfscell="<li><a class=\"a_bgw\" href=\"#failed_checks_extzfscell\">External ZFS Storage Appliance$all_passed_text</a></li>"
    if [ -r "${OUTPUTDIR}/PASS_extzfscell.html" ]
    then
      cat ${OUTPUTDIR}/PASS_extzfscell_header.html >> $HTML_FAILED_FILE
    fi
  fi

  if [ -r "${OUTPUTDIR}/PASS_extzfscell.html" ]
  then
    cat ${OUTPUTDIR}/PASS_extzfscell.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_extzfscell.html" || -r "${OUTPUTDIR}/PASS_extzfscell.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_extzfscell.html
    rm -f ${OUTPUTDIR}/FAILED_extzfscell.html
  fi

  crh_toc_failed_switch=""
  if [ -r "${OUTPUTDIR}/FAILED_switch.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_switch.html >> $HTML_FAILED_FILE
    crh_toc_failed_switch="<li><a class=\"a_bgw\" href=\"#failed_checks_switch\">InfiniBand Switch</a></li>"
  elif [[ -n "$ibs_link" ]] ; then
    if [ -r "${OUTPUTDIR}/PASS_switch.html" ]
    then
      cat ${OUTPUTDIR}/PASS_switch_header.html >> $HTML_FAILED_FILE
    fi
    crh_toc_failed_switch="<li><a class=\"a_bgw\" href=\"#failed_checks_switch\">InfiniBand Switch$all_passed_text</a></li>"
  fi

  if [ -r "${OUTPUTDIR}/PASS_switch.html" ]
  then
    cat ${OUTPUTDIR}/PASS_switch.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_switch.html" || -r "${OUTPUTDIR}/PASS_switch.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_switch.html
    rm -f ${OUTPUTDIR}/FAILED_switch.html
  fi

  crh_toc_failed_torswitch=""
  if [ -r "${OUTPUTDIR}/FAILED_torswitch.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_torswitch.html >> $HTML_FAILED_FILE
    crh_toc_failed_torswitch="<li><a class=\"a_bgw\" href=\"#failed_checks_torswitch\">TOR Switch</a></li>"
  elif [[ -n "$tor_sw_link" ]] ; then
    if [ -r "${OUTPUTDIR}/PASS_torswitch.html" ]
    then
      cat ${OUTPUTDIR}/PASS_torswitch_header.html >> $HTML_FAILED_FILE
    fi
    crh_toc_failed_torswitch="<li><a class=\"a_bgw\" href=\"#failed_checks_torswitch\">TOR Switch$all_passed_text</a></li>"
  fi

  if [ -r "${OUTPUTDIR}/PASS_torswitch.html" ]
  then
    cat ${OUTPUTDIR}/PASS_torswitch.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_torswitch.html" || -r "${OUTPUTDIR}/PASS_torswitch.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_torswitch.html
    rm -f ${OUTPUTDIR}/FAILED_torswitch.html
  fi

  crh_toc_failed_cluster=""
  if [ -r "${OUTPUTDIR}/FAILED_cluster.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cluster.html >> $HTML_FAILED_FILE
    crh_toc_failed_cluster="<li><a class=\"a_bgw\" href=\"#failed_checks_cluster\">$html_rack_type Wide</a></li>"
  elif [[ -z "$is_exalogic_machine" ]] || [[ -z "$is_exalogic_foxtrot" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "0" ]]; then
    if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]] || [[ -z "$is_fmw_machine" ]]; then
      if [[ $is_opc -eq 0 ]] ; then
        if [ -r "${OUTPUTDIR}/PASS_cluster.html" ]
        then
    	  crh_toc_failed_cluster="<li><a class=\"a_bgw\" href=\"#failed_checks_cluster\">$html_rack_type Wide$all_passed_text</a></li>"
          cat ${OUTPUTDIR}/PASS_cluster_header.html >> $HTML_FAILED_FILE
        fi
      fi
    fi
  fi

  if [ -r "${OUTPUTDIR}/PASS_cluster.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cluster.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_cluster.html" || -r "${OUTPUTDIR}/PASS_cluster.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_cluster.html
    rm -f ${OUTPUTDIR}/FAILED_cluster.html
  fi

  crh_toc_failed_system=""
  if [ -r "${OUTPUTDIR}/FAILED_system.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_system.html >> $HTML_FAILED_FILE
    crh_toc_failed_system="<li><a class=\"a_bgw\" href=\"#failed_checks_system\">System Wide</a></li>"
    #crh_toc_failed_system="<li>System Wide$all_passed_text</li>"
  else
    if [ -r "${OUTPUTDIR}/PASS_system.html" ]
    then
	cat ${OUTPUTDIR}/PASS_system_header.html >> $HTML_FAILED_FILE
	crh_toc_failed_system="<li><a class=\"a_bgw\" href=\"#failed_checks_system\">System Wide$all_passed_text</a></li>"
    fi
  fi

  if [ -r "${OUTPUTDIR}/PASS_system.html" ]
  then
    cat ${OUTPUTDIR}/PASS_system.html >> $HTML_FAILED_FILE
  fi

  if [[ -r "${OUTPUTDIR}/FAILED_system.html" || -r "${OUTPUTDIR}/PASS_system.html" ]]
  then
    echo "</table>" >> $HTML_FAILED_FILE
    rm -f  ${OUTPUTDIR}/PASS_system.html
    rm -f ${OUTPUTDIR}/FAILED_system.html
  fi

  
  #pass_toc="<li><a href=\"#passed_checks\">Findings Passed</a></li>";
  #if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] 
  #then 
   # pass_toc=""
  #fi

  patch_heading_prefix="GRID and";
  if [[ $single_instance_run -eq "1" && $oracle_restart -ne "1" ]] ; then
    patch_heading_prefix="";
  fi

if [[ -n "$run_acchk" && $run_acchk -eq "1" ]]
then
cat >> $HTML_REPFILE <<EOF
<H2>Table of Contents</H2>
<ul>
$acchk_toc_entry
EOF
else
  cat >> $HTML_REPFILE <<EOF
<div id="normal_view" style='DISPLAY: none'><a href="#" onclick="normal_view()">Go back to Normal View</a></div>
<H2>Table of Contents</H2>
$crh_toc_failed_compute
EOF
#if [ -e "$OUTPUTDIR/patch_summary.html" ]
#then
#  echo "<ul><li><a href=\"#patch_summary\">$patch_heading_prefix RDBMS patch recommendation Summary report</a></li>" >> $HTML_REPFILE
#fi
if [[ -e "$OUTPUTDIR/patch_detailed.html" && $is_engineered_system -eq "0" ]]
then
  patch_rec=1
  #echo "<li><a href=\"#patch_detailed\">$patch_heading_prefix RDBMS patch recommendation Detailed report</a></li>" >> $HTML_REPFILE
  echo "<div id=\"patchtoc\"><li><a href=\"#patch_detailed\">Patch Recommendation</a></li></div>" >> $HTML_REPFILE
fi
cat >> $HTML_REPFILE <<EOF
$filech_toc_entry
$crh_toc_failed_cvserver
$crh_toc_failed_cell
$crh_toc_failed_zfscell
$crh_toc_failed_extzfscell
$crh_toc_failed_switch
$crh_toc_failed_cluster
$crh_toc_failed_system
$oam_toc_entry
$oud_toc_entry
$oim_toc_entry
$maa_toc_entry
$iscs_toc_entry
$goldengate_toc_entry
$peoplesoft_toc_entry
$siebel_toc_entry
$corroborate_toc_entry
$udc_toc_entry
$platinum_toc_entry
$ebs_toc_entry
$em_toc_entry
EOF
fi

  #if [[ -e "$OUTPUTDIR/${program_name}_versions.html" && $db_machine_compute -ne 1 ]]
  if [[ -e "$OUTPUTDIR/${program_name}_versions.html" && $db_machine_compute -ne 1 && $RUNNING_ONCELL -ne 1 ]]
  then
    echo "<div id=\"sfsvtoc\"><li><a href=\"#fs_versions\">Systemwide firmware and software versions</a></li></div>" >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]]
  then
    echo "<div id=\"asrtoc\"><li><a href=\"#fs_asrreport\">Systemwide Automatic Service Request (ASR) healthcheck</a></li></div>" >> $HTML_REPFILE
  fi
  #--removes killed processess section
  if [[ -e "$OUTPUTDIR/watchdog.log" ]]; then
   #if [[ `grep -ic "killing stuck command" $OUTPUTDIR/watchdog.log` -gt 0 || `grep -ic "timed out" $OUTPUTDIR/watchdog.log` -gt 0 ]]
   if [[ `grep -ic "timed out" $OUTPUTDIR/watchdog.log` -gt 0 ]]
   then
     echo "<li><a href=\"#killed_procs\">Killed Processes</a></li>" >> $HTML_REPFILE
   fi
  fi

  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]] 
  then
    echo "<div id=\"sctoc\"><li><a href=\"#skipped_checks\">Skipped Checks</a></li></div>" >> $HTML_REPFILE
  else
    if [[ -e "$WRKDIR/udc_skipped.log" ]]
    then
      echo "<div id=\"sctoc\"><li><a href=\"#skipped_checks\">Skipped Checks</a></li></div>" >> $HTML_REPFILE
    fi
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]]
  then
    echo "<li><a href=\"#skipped_nodes\">Skipped Nodes</a></li>" >> $HTML_REPFILE
  fi

  #if [[ -e $EXCLUDEFIL ]]; then 
  #  echo "" >> $LOGFIL; echo "Content of $EXCLUDEFIL:" >> $LOGFIL; cat $EXCLUDEFIL >> $LOGFIL; 
  #fi

  for chkid in `if [ -e $TMP_EXCLUDEFIL ]; then cat $TMP_EXCLUDEFIL; fi`
  do
    if [[ -e $EXCLUDEFIL ]]; then 
      sed "/$chkid/d" $EXCLUDEFIL > $EXCLUDEFIL.2
      mv -f $EXCLUDEFIL.2 $EXCLUDEFIL
    fi

    if [[ -e $EXCLUDELOG ]]; then
      sed "/$chkid/d" $EXCLUDELOG > $EXCLUDELOG.2
      mv -f $EXCLUDELOG.2 $EXCLUDELOG
    fi
  done

  if [[ -e $EXCLUDEFIL ]]; then 
    echo "" >> $LOGFIL; echo "Content of $EXCLUDEFIL:" >> $LOGFIL; cat $EXCLUDEFIL >> $LOGFIL; 
  fi
  if [ -e $TMP_EXCLUDEFIL ]; then 
    echo "Following checkids were excluded dynamically during execution by ${program_name}" >> $LOGFIL;
    cat $TMP_EXCLUDEFIL >> $LOGFIL; 
  fi

  if [ -e $EXCLUDELOG ] && [[ `cat $EXCLUDELOG|wc -l` -gt 0 ]]
  then
    echo "<li><a href=\"#excluded_checks\">Excluded Checks</a></li>" >> $HTML_REPFILE
  fi

  if [[ -z "$MERGEFILES" && -e $COLLECT_TIMING ]]; then
    echo "<div id=\"CETtoc\"><li><a href=\"#component_elapsed_time\">Component Elapsed Times</a></li></div>" >> $HTML_REPFILE
  fi

  echo "<div id=\"vmptoc\" style=\"DISPLAY: none\"><li><a href=\"#vmpscan\">Clusterwide Linux Operating system health check(VMPScan)</a></li></div>" >> $HTML_REPFILE

  
  if [[ -e  $OUTPUTDIR/${program_name}_consumers.html ]] && [[ -z "$MERGEFILES" ]]
  then
    echo "<div id=\"tctoc\"><li><a href=\"#top_consumers\">Top 10 Time Consuming Checks</a></li></div>" >> $HTML_REPFILE
  fi


if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
then
  cat >> $HTML_REPFILE <<EOF
</ul>
<br>
<div id="toc">
<H2>Report Feature</H2>
<li><input name="FO" id="FO" type="checkbox" onclick="toggleCheckboxes(this);" > <label for="FO">Show Failed checks only</label></li><br>

<li>Show checks with the following status:</li>
&nbsp; &nbsp; &nbsp; &nbsp;<input name="FAIL" id="FAIL" type="checkbox" onclick="toggleChecks(this, &#39;FAIL&#39;);" checked> <label for="FAIL">Fail</label>
<input name ="WARNING" id="WARNING" type="checkbox" onclick="toggleChecks(this, &#39;WARNING&#39;);" checked> <label for="WARNING">Warning</label>
<input name ="INFO" id="INFO" type="checkbox" onclick="toggleChecks(this, &#39;INFO&#39;);" checked> <label for="INFO">Info</label>
EOF

if [[ -n "$RAT_SHOWPASS" && $RAT_SHOWPASS -eq "1" ]]
then
	echo "<input name =\"PASS\" id=\"PASS\" type=\"checkbox\" onclick=\"toggleChecks(this, &#39;PASS&#39;);\" checked> <label for=\"PASS\">Pass</label><br>" >> $HTML_REPFILE
else
	echo "<input name =\"PASS\" id=\"PASS\" type=\"checkbox\" onclick=\"toggleChecks(this, &#39;PASS&#39;);\"> <label for=\"PASS\">Pass</label><br>" >> $HTML_REPFILE
fi

if [[ $maa_checkbox -eq "1" ||  $pc_checkbox -eq "1" || -e "$OUTPUTDIR/isc_summary.html" || -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ||  -e  $OUTPUTDIR/${program_name}_consumers.html ]]
then
cat >> $HTML_REPFILE <<EOF
<br><li>Show details of the following regions:</li>
EOF
fi
if [ $maa_checkbox -eq "1" ]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="maaval" id="maaval" type="checkbox" onclick="toggleRegion(this, &#39;msh&#39;,&#39;mstoc&#39;,&#39;msh&#39;);" checked> <label for="maaval">Maximum Availability Architecture (MAA) Scorecard</label><br>
EOF
fi
if [[ -e "$OUTPUTDIR/isc_summary.html" ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="iscsval" id="iscsval" type="checkbox" onclick="toggleRegion(this, &#39;t_iscs&#39;,&#39;istoc&#39;,&#39;ish&#39;);" checked> <label for="iscsval">Infrastructure Software and Configuration Summary</label><br>
EOF
fi

#if [[ -e "$OUTPUTDIR/${program_name}_versions.html" && $db_machine_compute -ne 1 ]]
if [[ -e "$OUTPUTDIR/${program_name}_versions.html" && $db_machine_compute -ne 1 && $RUNNING_ONCELL -ne 1 ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="sfsvval" id="sfsvval" type="checkbox" onclick="toggleRegion(this, &#39;sfsvtoc&#39;,&#39;sfsvtoc&#39;,&#39;sfsvbody&#39;);" checked> <label for="sfsvval">Systemwide firmware and software versions</label><br>
EOF
fi


if [[ $pc_checkbox -eq "1" ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="pcval" id="pcval" type="checkbox" onclick="toggleRegion(this, &#39;pctoc&#39;,&#39;pcbody&#39;,&#39;pctoc&#39;);" checked> <label for="pcval">Platinum Certification</label><br>
EOF
fi

if [[ $cor_checkbox -eq "1" ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="corval" id="corval" type="checkbox" onclick="toggleRegion(this, &#39;corbody&#39;,&#39;corh&#39;,&#39;corh&#39;);" checked> <label for="corval">Findings needing further review</label><br>
EOF
fi


if [[ $em_checkbox -eq "1" ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="emval" id="emval" type="checkbox" onclick="toggleRegion(this, &#39;emtoc&#39;,&#39;emh&#39;,&#39;emtoc&#39;);" checked> <label for="emval">Enterprise Manager</label><br>
EOF
fi


if [[ -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="asrval" id="asrval" type="checkbox" onclick="toggleRegion(this, &#39;asrtoc&#39;,&#39;asrbody&#39;,&#39;asrtoc&#39;);" checked> <label for="asrval">Systemwide Automatic Service Request (ASR) healthcheck</label><br>
EOF
fi

if [[ $patch_rec -eq "1" ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="patchval" id="patchval" type="checkbox" onclick="toggleRegion(this, &#39;patchtoc&#39;,&#39;patchh&#39;,&#39;patchtoc&#39;);" checked> <label for="emval">Patch Recommendation</label><br>
EOF
fi

if [[ $file_checker -eq "1" ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="filechval" id="filechval" type="checkbox" onclick="toggleRegion(this, &#39;filechtoc&#39;,&#39;filech&#39;,&#39;filechtoc&#39;);" checked> <label for="emval">File Attribute Changes</label><br>
EOF
fi


if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="scval" id="scval" type="checkbox" onclick="toggleRegion(this, &#39;sctoc&#39;,&#39;skipped_checks_section&#39;,&#39;sctoc&#39;);" checked> <label for="scval">Skipped Checks</label><br>
EOF
fi


if [[ -z "$MERGEFILES" && -e $COLLECT_TIMING ]]; then
  cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="CETval" id="CETval" type="checkbox" onclick="toggleRegion(this, &#39;CETtoc&#39;,&#39;CETbody&#39;,&#39;CETtoc&#39;);" checked> <label for="CETval">Component Elapsed Times</label><br>
EOF
fi


cat >> $HTML_REPFILE <<EOF
<div id="vmpcheck" style="DISPLAY: none">&nbsp; &nbsp; &nbsp; &nbsp;<input name ="vmpval" id="vmpval" type="checkbox" onclick="toggleRegion(this, &#39;vmptoc&#39;,&#39;vmpbody&#39;,&#39;vmptoc&#39;);" checked> <label for="vmpval">Clusterwide Linux Operating system health check(VMPScan)</label><br></div>
EOF


if [[ -e  $OUTPUTDIR/${program_name}_consumers.html ]]
then
cat >> $HTML_REPFILE <<EOF
&nbsp; &nbsp; &nbsp; &nbsp;<input name ="tcval" id="tcval" type="checkbox" onclick="toggleRegion(this, &#39;tctoc&#39;,&#39;tcbody&#39;,&#39;tctoc&#39;);" checked> <label for="tcval">Top 10 Time Consuming Checks</label><br>
EOF
fi


cat >> $HTML_REPFILE <<EOF
<br><li>Show details of the checks:</li>
&nbsp; &nbsp; &nbsp; &nbsp;<input type="radio" name="EC" id="Expand" value="Expand" onclick="expand_collapse();">Expand All
<input type="radio" name="EC" id="Collapse" value="Collapse" onclick="expand_collapse();" checked>Collapse All
EOF

cat >> $HTML_REPFILE <<EOF
<br><br><li id="show_check_link"><a href="javascript:toggleVis('checkid', 'show_check_link');" id="1show_check_link">Show Check Ids</a></li>
<li style="DISPLAY: none" id="hide_check_link"><a href="javascript:toggleVis('checkid', 'hide_check_link');" id="1hide_check_link">Hide Check Ids</a></li>
<br><li id="show_edit_link"><a href="javascript:createDeleteButton(1);" id="1show_edit_link">Remove finding from report</a></li>
<li id="show_hide_link" style="DISPLAY: none"><a href="javascript:createDeleteButton(0);" id="1show_hide_link">Hide Remove Buttons</a></li>
</p><p id="message_on_hide" style="DISPLAY: none"><br><b><span style="color:red">Removing findings in page does not change the original html file. Please use browsers save page button (or press Ctrl+S) to save the report.</span></b></p>
</div>
<div id="print_view"><li><a href="#"  onclick="print_view()">Printable View</a></li><hr></div>
<a name="failed_checks"></a>
EOF
fi
  # Append failed file to report
  if [ -e "$HTML_FAILED_FILE" ] 
  then
   if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
   then
    cat $HTML_FAILED_FILE >> $HTML_REPFILE
   fi 
    rm -f $HTML_FAILED_FILE
  fi

  if [ -e "$HTML_OAM_MAIN" ]
  then
    cat $HTML_OAM_MAIN >> $HTML_REPFILE
    rm -f $HTML_OAM_MAIN
  fi


  if [ -e "$HTML_OUD_MAIN" ]
  then
    cat $HTML_OUD_MAIN >> $HTML_REPFILE
    rm -f $HTML_OUD_MAIN
  fi

  if [ -e "$HTML_OIM_MAIN" ]
  then
    cat $HTML_OIM_MAIN >> $HTML_REPFILE
    rm -f $HTML_OIM_MAIN
  fi

  if [ -e "$HTML_MAA_SC" ]
  then
   if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
   then
    cat $HTML_MAA_SC >> $HTML_REPFILE
   fi
    rm -f $HTML_MAA_SC
  fi
  
 if [[ -n "$run_acchk" && $run_acchk -eq "1" ]]
 then
  if [ -e "$HTML_ACCHK_SC" ]
  then
    cat $HTML_ACCHK_SC >> $HTML_REPFILE
    rm -f $HTML_ACCHK_SC
  fi
 fi

  if [[ -e "$OUTPUTDIR/isc_summary.html" ]]
  then
    echo "<hr>" >> $HTML_REPFILE
    echo "<a href=\"#\"  class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<a name=\"iscs_versions\"></a>" >> $HTML_REPFILE
    echo "<div id="ish"><h2>Infrastructure Software and Configuration Summary</h2>" >> $HTML_REPFILE
    echo "<p>NOTE: This table displays the configuration summary of the system.  It is for informational purposes only. No action is required.</p></div>" >> $HTML_REPFILE
    cat $OUTPUTDIR/isc_summary.html >> $HTML_REPFILE
    rm -f $OUTPUTDIR/isc_summary.html
  fi

  if [ -e "$HTML_GG_MAIN" ]
  then
    cat $HTML_GG_MAIN >> $HTML_REPFILE
    rm -f $HTML_GG_MAIN
  fi

  if [ -e "$HTML_PEOPLESOFT_MAIN" ]
  then
    cat $HTML_PEOPLESOFT_MAIN >> $HTML_REPFILE
    rm -f $HTML_PEOPLESOFT_MAIN
  fi

  if [ -e "$HTML_SIEBEL_MAIN" ]
  then
    cat $HTML_SIEBEL_MAIN >> $HTML_REPFILE
    rm -f $HTML_SIEBEL_MAIN
  fi

  if [ -e "$HTML_CORROBORATE_MAIN" ]
  then
    cat $HTML_CORROBORATE_MAIN >> $HTML_REPFILE
    rm -f $HTML_CORROBORATE_MAIN
  fi

  if [ -e "$HTML_UDC_MAIN" ]
  then
    cat $HTML_UDC_MAIN >> $HTML_REPFILE
    rm -f $HTML_UDC_MAIN
  fi

  if [ -e "$HTML_PLATINUM_MAIN" ]
  then
    cat $HTML_PLATINUM_MAIN >> $HTML_REPFILE
    rm -f $HTML_PLATINUM_MAIN
  fi

  if [ -e "$HTML_EBS_MAIN" ]
  then
    cat $HTML_EBS_MAIN >> $HTML_REPFILE
    rm -f $HTML_EBS_MAIN
  fi

  if [ -e "$HTML_EM_MAIN" ]
  then
    cat $HTML_EM_MAIN >> $HTML_REPFILE
    rm -f $HTML_EM_MAIN
  fi

  #for crh_ctype in compute cell switch cluster system
  #do
  #  crh_file_name="${OUTPUTDIR}/FAILED_${crh_ctype}.html";
  #  if [ -e "${crh_file_name}" ]
  #  then
  #    cat ${crh_file_name} >> $HTML_REPFILE
  #    rm -f ${crh_file_name}
  #  fi
  #done

##############################################################################################
  #append patch summary
#  if [[ -e "$OUTPUTDIR/patch_summary.html" ]]
#  then
 #   echo "<hr><a name=\"patch_summary\"></a><a href=\"#\"  class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
 #   echo "<h2>$patch_heading_prefix RDBMS patch recommendation Summary report</h2>" >> $HTML_REPFILE
 #   cat $OUTPUTDIR/patch_summary.html >> $HTML_REPFILE
 #   rm -f $OUTPUTDIR/patch_summary.html
 # fi
##############################################################################################

  # append detailed patch report
  if [[ -e "$OUTPUTDIR/patch_detailed.html" && $is_engineered_system -eq "0" ]]
  then
    echo "<div id=\"patchh\"><hr><a name=\"patch_detailed\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    #echo "<h2>$patch_heading_prefix RDBMS patch recommendation Detailed report</h2>" >> $HTML_REPFILE
    echo "<h2>Patch Recommendation</h2>" >> $HTML_REPFILE
    cat $OUTPUTDIR/patch_detailed.html >> $HTML_REPFILE
    echo "</div>" >> $HTML_REPFILE
    rm -f $OUTPUTDIR/patch_detailed.html
  fi
  
  if [[ -n $file_checker && $file_checker -eq 1 ]];then
    file_changes=$(cat $filecheck_out_dir/Email_Warning)
    base_line_snapshot="Baseline Snapshot: ${filecheck_out_dir}/${file_snapshot} <br />"
    echo "<div id=\"filech\"><hr><a name=\"filech_detailed\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>File Attribute Changes</h2>" >> $HTML_REPFILE
    echo "<table border="1"><tr><td><pre>$base_line_snapshot $file_changes</pre></td></tr></table>" >> $HTML_REPFILE
    echo "</div>" >> $HTML_REPFILE
    if [[ -n $file_check_only && $file_check_only -eq 1 ]];then 
      cp $HTML_REPFILE $WRKDIR/${program_name}_${HOSTNAME}_${timestamp}.html
      echo -e "\n\nFile attribute check report (html) - $WRKDIR/${program_name}_${HOSTNAME}_${timestamp}.html\n\n"
      if [[ $daemon_running -eq "1" ]] ; then
        log_daemon "\nFile attribute check report (html) - $WRKDIR/${program_name}_${HOSTNAME}_${timestamp}.html\n"
      fi
    fi
  fi
 
  # append passed checks report
  echo "</table>" >> $HTML_PASS_FILE

  #if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
  #then
    #cat $HTML_PASS_FILE >> $HTML_REPFILE
  #fi
  rm -f $HTML_PASS_FILE

  # Now append the detailed description for each check

  #if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
  #then
  #  echo "<hr><a href=\"#\" class=\"a_bgw\">Top</a><h2>Best Practices and Other Recommendations</h2>" >> $HTML_REPFILE
  #  echo "<p>Best Practices and Other Recommendations are generally items documented in various sources which could be overlooked. ${program_name} assesses them and calls attention to any findings.</p>" >> $HTML_REPFILE
  #fi

  # replace the host names
  crh_cnt=${#G_CHECKIDS[@]}
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1
    #if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]] 
    if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" ]]
    then 
      crh_hosts=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | sed 's/\//\\\//g') # ORACLE_HOME will have / and below sed fails. So replace / with \/
      crh_hosts_passed=$(echo ${G_CHECKID_HOSTS_PASSED[$crh_cnt]} | sed 's/\//\\\//g') # ORACLE_HOME will have / and below sed fails. So replace / with \/
      if [[ `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]]
      then
 	if [ -n "$MERGEFILES" ] ; then	
	  if [ -z "$crh_hosts" ]; then 
	    crh_hosts=`grep "${G_CHECKIDS[$crh_cnt]}" $CURRDIR/.MERGED_COLLECTIONS/slave_results.out.merge| awk -F'|' '{print $10}'`;	  
	  fi
	fi
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE_FAIL/${crh_hosts}/'"
      else
        if [ -n "$crh_hosts_passed" ]
        then
          replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts_passed}/'"
        else
          replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts}/'"
        fi
      fi
      cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command > $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new
      mv -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      if [[ -n "$crh_hosts_passed" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]]
      then # Partially failed on cells
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts_passed}/'"
        cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command > $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new
        mv -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      fi
    fi
  done
  
  # Append each check-id.html to main report
  crh_cnt=${#G_CHECKIDS[@]}
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1

    if [ ! -z "${G_CHECKID_MAA_SF[$crh_cnt]}" ]
    then # MAA
      maa_msg=$(echo "${G_CHECKID_INFO[$crh_cnt]}" | tr "[a-z]" "[A-Z]")
      maa_sf_uc=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |tr "[a-z]" "[A-Z]")
      if [[ $maa_msg = $maa_sf_uc ]]
      then # The SF = MSG. dont display detailed as its a dummy check.
        echo ""
        #rm -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
        mv -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.out
      fi
    fi

    #if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]] 
  if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
  then
    if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" ]]
    then # No html details for passed checks
      echo "<div id=\"${G_CHECKIDS[$crh_cnt]}_contents\" style=\"display: none\">" >> $HTML_REPFILE
      replace_command="sed 's/PLACEHOLDER_TO_REPLACE_..../-/'"
      cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command >> $HTML_REPFILE
      # Add a top link at bottom also
      #echo "<a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\" class=\"a_bgw\">Top</a><br>" >>$HTML_REPFILE
      echo "<br><a href=\"#\" onclick='show_div_below(\"${G_CHECKIDS[$crh_cnt]}_contents\");return false;'>Hide</a>" >> $HTML_REPFILE
      echo "</div>" >> $HTML_REPFILE
      #rm -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      mv -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.out
    fi
  fi
  done
  
  # append exadata version report if available.
  #if [[ $OFFLINE -eq 0 &&  -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 ]]
  #if [[ -e "$OUTPUTDIR/${program_name}_versions.html" && $db_machine_compute -ne 1 ]]
  if [[ -e "$OUTPUTDIR/${program_name}_versions.html" && $db_machine_compute -ne 1 && $RUNNING_ONCELL -ne 1 ]]
  then
    echo "<div id=\"sfsvbody\"><hr><a name=\"fs_versions\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_versions.html | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $HTML_REPFILE
    echo "</div>" >> $HTML_REPFILE
  fi
  # append Exadata ASR healthcheck report if available.
  if [ -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]
  then
    echo "<div id=\"asrbody\"><hr><a name=\"fs_asrreport\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Systemwide Automatic Service Request (ASR) healthcheck</h2>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_${ASREXACHK}.html | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $HTML_REPFILE
    echo "</div>" >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/${program_name}_iscs.html" && -n $db_machine_compute && $db_machine_compute -eq 1 ]]
  then
    echo "<hr><a name=\"iscs_versions\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_iscs_versions.html | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $HTML_REPFILE
  fi
  #Append info about killed processes
  #if [[ -e "$OUTPUTDIR/watchdog.log" && `grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -ivc "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' ` -gt 0 ]]
  if [[ -e "$OUTPUTDIR/watchdog.log" ]] ; then
  #if [[ `grep -ic "timed out" $OUTPUTDIR/watchdog.log` -gt 0 ]]
  if [[ `grep -i "timed out" $OUTPUTDIR/watchdog.log|grep -vi 'expect:'|wc -l|sed 's/ //g'` -gt 0 ]]
  then
    echo "<div id=\"killed_procs_section\"><hr><a name=\"killed_procs\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Killed Processes</h2>" >> $HTML_REPFILE
    echo "<p>${program_name} found that below commands were killed during the run, so some checks might have failed to execute properly. Refer to the troubleshooting section of the user guide to resolve the issues.</p>" >> $HTML_REPFILE
    echo "<pre class=\"check-item\">" >> $HTML_REPFILE
    #grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -iv "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' |grep -v "LOG FROM" >> $HTML_REPFILE
    grep -i "timed out" $OUTPUTDIR/watchdog.log >> $HTML_REPFILE
    echo "</pre>" >> $HTML_REPFILE
    echo "</div>" >> $HTML_REPFILE
  fi
  fi

  # append skipped checks
  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]] 
  then
  #  custom_msg=0	
  #  for chkid in `cat  $OUTPUTDIR/${program_name}_skipped_checks.log| cut -d'(' -f2 | cut -d')' -f1|sed 's/checkid:-//'`
  #  do   
  #   	if [ `grep -iwc "$chkid" $SCRIPTPATH/.cgrep/profiles/E8DF76E07DD82E0DE04313C0E50AA55D.prf` -gt 0 ]
  #   	then
  #   		custom_msg=1
  #   	fi
  #  done
    echo "<div id=\"skipped_checks_section\"><hr><a name=\"skipped_checks\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Skipped Checks</h2>" >> $HTML_REPFILE
    echo "<pre class=\"check-item\">" >> $HTML_REPFILE

    if [[ -e "$WRKDIR/udc_skipped.log" ]]
    then
      echo "User defined checks will not be executed as the xml did not validate against the given xsd user_defined_checks.xsd" >> $HTML_REPFILE 2>/dev/null
    fi

    cat $OUTPUTDIR/${program_name}_skipped_checks.log >> $HTML_REPFILE
  #  if [ $custom_msg -eq "1" ]
  #  then
  #    echo "Note: Some EBS checks have been skipped, most likely because they were taking longer than the current query timeout value: $RAT_TIMEOUT seconds to run.  This can occur for EBS systems with very large  data sets.  The timeout value can be temporarily increased for checks by  setting the runtime environment variable RAT_TIMEOUT  to a higher value, eg.  export RAT_TIMEOUT=120.  It may be necessary to experiment with different  settings to find the right value for a given environment.  Please note that  changing the RAT_TIMEOUT changes the timeout for ALL checks and not just EBS  checks.  This may result in longer overall run times for the tool. If you  find a particular check is taking an extremely long time to execute, please report this via the <a href="https://community.oracle.com/community/support/_my_oracle_support/orachk"> ORAchk support community</a>."  >> $HTML_REPFILE;
  #  fi	
    echo "</pre>" >> $HTML_REPFILE
    echo "</div>" >> $HTML_REPFILE
  else
    if [[ -e "$WRKDIR/udc_skipped.log" ]]
    then
      echo "<div id=\"skipped_checks_section\"><hr><a name=\"skipped_checks\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
      echo "<h2>Skipped Checks</h2>" >> $HTML_REPFILE
      echo "<pre>" >> $HTML_REPFILE
      echo "User defined checks will not be executed as the xml did not validate against the given xsd user_defined_checks.xsd" >> $HTML_REPFILE 2>/dev/null
      echo "</pre>" >> $HTML_REPFILE
      echo "</div>" >> $HTML_REPFILE
    fi
  fi

  # append skipped nodes
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]]
  then
    echo "<div id=\"skipped_nodes_section\"><hr><a name=\"skipped_nodes\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Skipped Nodes</h2>" >> $HTML_REPFILE
    echo "<pre class=\"check-item\">" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_skipped_nodes.log >> $HTML_REPFILE
    echo "</table></pre>" >> $HTML_REPFILE
    echo "</div>" >> $HTML_REPFILE
  fi
  # append excluded checks 
  if [ -e $EXCLUDELOG  ] && [[ `cat $EXCLUDELOG|wc -l` -gt 0 ]]
  then
    echo "<hr><a name=\"excluded_checks\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Excluded Checks</h2>" >> $HTML_REPFILE
    echo "<pre>" >> $HTML_REPFILE
    cat $EXCLUDELOG >> $HTML_REPFILE
    echo "</table></pre>" >> $HTML_REPFILE
  fi

  #if [[ -e $OUTPUTDIR/${program_name}_consumers.html ]] && [[ -z "$MERGEFILES" ]]
  #then
   # echo "<hr>" >> $HTML_REPFILE
   # cat $OUTPUTDIR/${program_name}_consumers.html >> $HTML_REPFILE
  #fi 

  #Component Elapsed Times
  if [[ -z "$MERGEFILES" && -e $COLLECT_TIMING ]]; then
    elapsed_cntr=0
    OIFS=$IFS
    IFS=$'\n'
    for nodetimeentry in `grep 'ToTal Duration:' $COLLECT_TIMING|sed 's/.*ToTal Duration://g'|sed "s/^ //g"|sed "s/ $//g"`
    do
      ntentries[$elapsed_cntr]=$nodetimeentry
      elapsed_cntr=$(expr $elapsed_cntr + 1)    
    done 
    elapsed_cntr=0
    for nodenameentry in `grep ' STARTED ON ' $COLLECT_TIMING|sed 's/.*STARTED ON//g'|sed 's/ //g'`
    do
      nnentries[$elapsed_cntr]=$nodenameentry
      elapsed_cntr=$(expr $elapsed_cntr + 1)    
    done 
    IFS=$OIFS

    cat >> $HTML_REPFILE <<EOF
    <hr>
    <div id="CETbody"><a href="#" class="a_bgw">Top</a>
    <a name="component_elapsed_time"></a>
    <h2>Component Elapsed Times</h2>
    <table summary="Component Elapsed Times">
    <tr>
    <th scope="col">Component Name</th>
    <th scope="col">Component Type</th>
    <th scope="col">Elapsed Time</th>
    </tr>
EOF
    elapsed_cntr=0
    for printnname in "${nnentries[@]}"
    do
      ntype="Database Server"
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        ntype="Node"
      fi
      if [[ -e $CELLDIR/cells.out && `grep -iwc "$printnname" $CELLDIR/cells.out` -gt "0" ]]; 
        then ntype="Storage Server";
        cellip_cellname=$(cat "$CELLDIR/cells.out"|grep $printnname);
        if [[ -n $cellip_cellname ]];then
          cell_ip_only=$(echo "$cellip_cellname"|$AWK -F' ' '{print $1}');
          timeout_on_storage_cell=$(cat $OUTPUTDIR/watchdog.log|grep -c "Timed out while running collections on $cell_ip_only");
        fi 
      fi
      if [[ -e $ZFSIP && `grep -iwc "$printnname" $ZFSIP` -gt "0" ]]; then ntype="ZFS Storage Appliance"; fi
      if [[ -e $OUTPUTDIR/o_ibswitches.out && `grep -iwc "$printnname" $OUTPUTDIR/o_ibswitches.out` -gt "0" ]]; then ntype="IB Switch"; fi
 
      if [[ -n $timeout_on_storage_cell && $timeout_on_storage_cell -gt 0 ]];then
        let dh=$watchdog_wakeup_root/3600
        let dm=($watchdog_wakeup_root-3600*$dh)/60
        let ds=($watchdog_wakeup_root-3600*$dh)-60*$dm

        if [ $dh -gt 0 ]; then
          watchdog_timeout_duration="$dh Hours, $dm mins, $ds seconds";
        else
          if [ $dm -gt 0 ]; then
            watchdog_timeout_duration="$dm mins, $ds seconds";
          else
            watchdog_timeout_duration="$ds seconds";
          fi
        fi
        cat >> $HTML_REPFILE <<EOF
        <tr><td>${printnname}</td><td>${ntype}</td><td>$watchdog_timeout_duration</td></tr>
EOF

      else
        cat >> $HTML_REPFILE <<EOF
        <tr><td>${printnname}</td><td>${ntype}</td><td>${ntentries[$elapsed_cntr]}</td></tr>
EOF
      fi
      elapsed_cntr=$(expr $elapsed_cntr + 1)    
      
    done

    cat >> $HTML_REPFILE <<EOF
    </table>
    </div>
EOF
  fi

  echo "<div id=\"checkscnt\" style=\"display: none\">$g_tr_index</div>" >> $HTML_REPFILE
  cat >> $HTML_REPFILE <<EOF
    <script>
      var k=getParam('debug');
      createDeleteButton(k);
    </script>
EOF

#  echo "</body>
#<br><a href=\"#\" onclick=\"javascript:processForm();\"><div id=\"results\">Switch to old format</div></a>
#</html>" >> $HTML_REPFILE

}

# Prints the Clusterware patches summary report table.
print_cluster_patch_summary_html ()
{
  if [[ $single_instance_run -eq "1" && $oracle_restart -ne "1" ]] ; then return; fi;
#patch_summary_modified
  cat >> $OUTPUTDIR/patch_summary.html <<EOF
    <a name="${i}_crssummary"></a>
    <h3>Summary Report for "$i"</h3>
    <b>Clusterware patches</b>
    <table border=1 summary="Clusterware patches">
    <tr><th>Total patches</th>
    <th scope="col">Applied on CRS</th>
    <th scope="col">Applied on RDBMS</th>
    <th scope="col">Applied on ASM</th>
    <th scope="col">Details</th></tr>
    <tr><td align="right" scope="row">$pp_crs_tcount</td>
    <td align="right">$pp_crs_pcount</td>
    <td align="right">$pp_rdbms_pcount</td>
    <td align="right">$pp_asm_pcount</td>
    <td align="center"><a href="#${i}_crsdetailed">View</a></td>
    </tr></table>
EOF

}

# Print heading for each host. Can't use print_crs_patch_detail_html as its called
# only if there are patchs
print_crs_patch_detail_heading_html ()
{
  if [[ $single_instance_run -eq "1" && $oracle_restart -ne "1" ]] ; then return; fi;
  echo "<h3>Database server \"${fmt_hname}\"</h3><hr>" >> $OUTPUTDIR/patch_detailed.html
}

# Prints the Clusterware patches detailed table.
print_crs_patch_detail_html ()
{
  SUBJ=$SUBJ_PRINT
  PATCH=$PATCH_PRINT
  
  if [[ $single_instance_run -eq "1" && $oracle_restart -ne "1" ]] ; then return; fi;

  if [ $crs_patch_printed_html -eq "0" ] 
  then
    crs_patch_printed_html=1
    p_crs_patch=""
    pcp_hostname=$(echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g')
    cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <a name="${fmt_hname}_crsdetailed"></a>
      <br><br><b>$pp_crs_tcount Recommended CRS patches for $pcp_hostname from ${CRS}</b>
EOF
    if [[ -n "$PCW_NUM" && $PCW_NUM -gt 0 ]]
    then
      cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <table border=1 summary="Detailed CRS patches">
      <tr><th scope="col">Patch#</th>
      <th scope="col">CRS</th>
      <th scope="col">ASM</th>
      <th scope="col">RDBMS</th>
      <th scope="col">RDBMS_HOME</th>
      <th scope="col">Patch-Description</th></tr>
EOF
    else
      echo "<br>" >> $OUTPUTDIR/patch_detailed.html
    fi
  fi
  if [[ -n "$PCW_NUM" && $PCW_NUM -gt 0 ]]
  then
    if [[ -n "$fmt_crs_applied" && $fmt_crs_applied = "yes" ]] ; then
      fmt_crs_applied_p="applied"
    else
      fmt_crs_applied_p="not-applied"
    fi
    if [[ -n "$fmt_asm_applied" && $fmt_asm_applied = "yes" ]] ; then
      fmt_asm_applied_p="applied"
    else
      fmt_asm_applied_p="not-applied"
    fi
    if [[ -n "$fmt_rdbms_applied" && $fmt_rdbms_applied = "yes" ]] ; then
      fmt_rdbms_applied_p="applied"
    else
      fmt_rdbms_applied_p="not-applied"
    fi
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then # No seperate asm home in 11.2
      fmt_asm_applied_p="n/a"
    fi
    if [[ -z "$ASM_HOME" ]] ; then
      fmt_asm_applied_p="n/a"
    fi
    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
      fmt_asm_applied_p="n/a"
    fi

    if [ "$p_crs_patch" != "$PATCH" ] ; then
      echo "<tr><td scope=\"row\">$PATCH</td><td scope=\"row\">$fmt_crs_applied_p</td><td scope=\"row\">$fmt_asm_applied_p</td><td scope=\"row\">$fmt_rdbms_applied_p</td><td scope=\"row\">$fmt_patch_type</td><td scope=\"row\">$SUBJ</td></tr>" >> $OUTPUTDIR/patch_detailed.html
      p_crs_patch=$PATCH
    fi
    if [ $j -eq $PCW_NUM ]
    then
      echo "</table><a href=\"#${fmt_hname}_crssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
    fi
  else
    echo "<a href=\"#${fmt_hname}_crssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
  fi
}

# Print the rdbms patch summary report table.
# As we may have more oracle home's, print headings only when mb_db_counter=0
# else just print the row. At the end print </table>, 
# i.e when $mb_db_counter = ${#mb_oracle_homes_distinct[@]}
print_rdbms_patch_summary_html ()
{
  pr_print=$1
  if [ $mb_db_counter_printed -eq "0" ]
  then # Its first time 
    mb_db_counter_printed=1
    p_rdbms_patch=""
#patch_summary_modified
    cat >> $OUTPUTDIR/patch_summary.html <<EOF
      <br><b>RDBMS homes patches</b>
      <table border=1 summary="RDBMS homes patches">
      <tr><th scope="col">Total patches</th>
      <th scope="col">Applied on RDBMS</th>
      <th scope="col">Applied on ASM</th>
      <th scope="col">ORACLE_HOME</th>
      <th scope="col">Details</th></tr>
EOF
  fi
  
  if [[ -n "$pr_print" && "$pr_print" = "1" ]]
  then
    prp_ohome=$(echo "${i}_${mb_db_homes}" | sed 's/\///g')
#patch_summary_modified
    cat >> $OUTPUTDIR/patch_summary.html <<EOF
      <tr><td align="right" scope="row"><a name="${prp_ohome}_rdbmssummary"></a>${mb_non_pcw_num[$mb_db_counter]}</td>
      <td align="right">${mb_rp_rdbms_pcount[$mb_db_counter]}</td>
      <td align="right">${mb_rp_asm_pcount[$mb_db_counter]}</td>
      <td align="right">$mb_db_homes</td>
      <td align="center"><a href="#${prp_ohome}_rdbmsdetailed">View</a></td></tr>
EOF
  fi

  let prp_index=$mb_db_counter+1
  if [ $prp_index -eq ${#mb_oracle_homes_distinct[@]} ]
  then # No more rows
#patch_summary_modified
    echo "</table>" >> $OUTPUTDIR/patch_summary.html
  fi
}

# Print detailed patch report for every oracle_home
print_rdbms_patch_detailed_html ()
{
  if [ $printed_rdbms_patch_html -eq "0" ]
  then
    printed_rdbms_patch_html=1;
    prp_ohome=$(echo "${i}_${mb_oracle_homes_distinct[$mb_db_counter]}" | sed 's/\///g')
    cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <a name="${prp_ohome}_rdbmsdetailed"></a>
      <br><br><b>$rp_rdbms_tcount Recommended RDBMS patches for ${rdbms_home_version} from ${mb_oracle_homes_distinct[$mb_db_counter]}</b>
EOF
    if [ "$NON_PCW_NUM" -gt 0 ]
    then
      cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <table border=1 summary="Detailed rdbms home patches">
      <tr><th>Patch#</th>
      <th scope="col">RDBMS</th>
      <th scope="col">ASM</th>
      <th scope="col">Type</th>
      <th scope="col">Patch-Description</th></tr>
EOF
    else
      echo "<br>" >> $OUTPUTDIR/patch_detailed.html
    fi
  fi
  if [ "$NON_PCW_NUM" -gt 0 ]
  then
    if [[ -n "$2" && $2 = "yes" ]] ; then
      fmt_rdbms_applied_p="applied"
    else
      fmt_rdbms_applied_p="not-applied"
    fi
    if [[ -n "$3" && $3 = "yes" ]] ; then
      fmt_asm_applied_p="applied"
    else
      fmt_asm_applied_p="not-applied"
    fi
    if [[ -n "$crs112" && $crs112 -ge 1 ]] 
    then # No seperate asm home in 11.2
      fmt_asm_applied_p="n/a"
    fi
    if [[ -z "$ASM_HOME" ]] ; then
      fmt_asm_applied_p="n/a"
    fi
    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
      fmt_asm_applied_p="n/a"
    fi
    
    if [ "$p_rdbms_patch" != "$1" ] ; then
      echo "<tr><td scope=\"row\">$1</td><td scope=\"row\">$fmt_rdbms_applied_p</td><td scope=\"row\">$fmt_asm_applied_p</td><td scope=\"row\">$4</td><td scope=\"row\">$SUBJ</td></tr>" >> $OUTPUTDIR/patch_detailed.html
    p_rdbms_patch=$1
    fi
    if [[ $j -eq $NON_PCW_NUM  ]]
    then
      echo "</table>" >> $OUTPUTDIR/patch_detailed.html
      if [[ -f $napply_missing_list  ]]
      then
        echo "<pre>" >> $OUTPUTDIR/patch_detailed.html
        cat $napply_missing_list >> $OUTPUTDIR/patch_detailed.html
        echo "</pre>" >> $OUTPUTDIR/patch_detailed.html
      fi
      echo "<a href=\"#${prp_ohome}_rdbmssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
    fi
  else
    echo "<a href=\"#${prp_ohome}_rdbmssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
  fi
}
#-- End writing html reports

function assign_scr_switches ()
{
  crs_version_switch="crs activeversion"
  #if [ `uname -s` = "HP-UX" ] ; then
  #  crs_version_switch="has releaseversion"
  #fi
  bash_scr="/bin/env bash"
  bash_path=""
  if [[ ! -f "/bin/bash" || ! -f "/bin/env" ]] ; then
    bash_scr=$(which bash)
  fi
  if [[ ! -f "/bin/bash" ]] ; then
    bash_path=$(dirname $bash_scr)
  fi
  #$READ -p "bash_scr = $bash_scr and bash_path=$bash_path" somevar
  #bash_scr="/bin/bash -xv";
  bash_source="if [ -e \"/etc/profile\" ] ; then . /etc/profile >/dev/null 2>&1; fi; if [ -e \"\$HOME/.bash_profile\" ] ; then . \$HOME/.bash_profile >/dev/null 2>&1; elif [ -e \"\$HOME/.bash_login\" ] ; then . \$HOME/.bash_login >/dev/null 2>&1; elif [ -e \"\$HOME/.profile\" ] ; then . \$HOME/.profile >/dev/null 2>&1; fi"
  bash_source_check="if [ -e \"/etc/profile\" ] ; then (. /etc/profile >/dev/null 2>&1); fi; if [ -e \"\$HOME/.bash_profile\" ] ; then (. \$HOME/.bash_profile >/dev/null 2>&1); elif [ -e \"\$HOME/.bash_login\" ] ; then (. \$HOME/.bash_login >/dev/null 2>&1); elif [ -e \"\$HOME/.profile\" ] ; then (. \$HOME/.profile >/dev/null 2>&1); fi"
}

log_fail ()
{
  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch 
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:log_fail Start Time: $epoch_time" >> $CHK_TIMINGS
  fi

  #we should never end up in here when in SILENT mode
  #pass/fail is not a concept for SILENT mode
  if [ $SILENT -eq "1" ]
  then
    echo "DEBUG MESSAGE - log_fail() should not be called in SILENT mode".|tee -a $LOGFIL >/dev/null
  fi

  if [[ $ISBRANCH -eq 1 && $SILENT -eq 0 ]]
  then
    echo "BRANCH CONDITION FALSE" >>$LOGFIL
  elif [[ $ISBRANCH -ne 1 && $SILENT -eq 0 ]]
  then
    # gadiga for SHS
    if [[ $OFFLINE -eq 0 ]];
    then
      cell_ib_fail_count=$(grep 'FAIL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      cell_ib_warn_count=$(grep 'WARN' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      cell_ib_info_count=$(grep 'INFO' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      cell_ib_total_count=$(grep 'TOTAL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
    fi

    case "$ALVL" in
    "FAIL")
       if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
       then
         failedChecksOnCells=0
         for failType in "${a_cellCheckStatus[@]}";do if [ $failType != "PASS" ];then failedChecksOnCells=$(expr $failedChecksOnCells + 1 );fi;done
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+$failedChecksOnCells

      	  if [[ $OFFLINE -eq 0 ]]; then cell_ib_fail_count=$(expr $cell_ib_fail_count + $failedChecksOnCells); fi;
       else     
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
       fi
       ;;
    "WARNING")
      if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
      then
        warnChecksOnCells=0
        for failType in "${a_cellCheckStatus[@]}";do if [ $failType != "PASS" ];then warnChecksOnCells=$(expr $warnChecksOnCells + 1 );fi;done
        let G_FAIL_CHECKS=$G_FAIL_CHECKS+$warnChecksOnCells

        if [[ $OFFLINE -eq 0 ]]; then cell_ib_warn_count=$(expr $cell_ib_warn_count + $warnChecksOnCells); fi;
      else     
        let G_WARN_CHECKS=$G_WARN_CHECKS+1
      fi
      ;;
    "INFO")
      if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
      then
        infoChecksOnCells=0
        for failType in "${a_cellCheckStatus[@]}";do if [ $failType != "PASS" ];then infoChecksOnCells=$(expr $infoChecksOnCells + 1 );fi;done
        let G_FAIL_CHECKS=$G_FAIL_CHECKS+$infoChecksOnCells

        if [[ $OFFLINE -eq 0 ]]; then cell_ib_info_count=$(expr $cell_ib_info_count + $infoChecksOnCells); fi;
      else     
	let G_INFO_CHECKS=$G_INFO_CHECKS+1
	if [[ -n "$LOGIC" && "$LOGIC" = "Y" ]]
        then
	        let G_INFO_CHECKS_SCORE=$G_INFO_CHECKS_SCORE+1
	fi
      fi
      ;;
    *)
      if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
      then
        failedChecksOnCells=0
        for failType in "${a_cellCheckStatus[@]}";do if [ $failType != "PASS" ];then failedChecksOnCells=$(expr $failedChecksOnCells + 1 );fi;done
        let G_FAIL_CHECKS=$G_FAIL_CHECKS+$failedChecksOnCells

        if [[ $OFFLINE -eq 0 ]]; then cell_ib_fail_count=$(expr $cell_ib_fail_count + $failedChecksOnCells); fi;
      else     
        let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
      fi
      ;;
    esac

    if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
    then
      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$outcheck_cell_counter; 
      validate_needs_running;
      if [[ $OFFLINE -eq 0 ]]; then cell_ib_total_count=$(expr $cell_ib_total_count + $outcheck_cell_counter); fi;
    else
      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
      validate_needs_running
    fi 
    outcheck_cell_counter=0
    # end code for SHS

     echo "" >>$LOGFIL
     if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
     then
         echo "" >>$CELLREPFIL_FAIL
     elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
     then
          echo "" >>$IBREPFIL_FAIL
     else
         echo "" >>$REPFIL_FAIL
     fi

     if [[ $OFFLINE -eq 0 ]]; 
     then
       echo "FAIL = $cell_ib_fail_count" >> $CELLIBNTFILE.new
       echo "WARN = $cell_ib_warn_count" >> $CELLIBNTFILE.new
       echo "INFO = $cell_ib_info_count" >> $CELLIBNTFILE.new
       echo "TOTAL = $cell_ib_total_count" >> $CELLIBNTFILE.new
          
       rm -f $CELLIBNTFILE 2>/dev/null
       mv -f $CELLIBNTFILE.new $CELLIBNTFILE 2>/dev/null
     fi

     #ACREPCOUNT=`expr $ACREPCOUNT + 1`
     #echo "------------------------------" >>$LOGFIL
     #echo "------------------------------" >>$REPFIL
     #$READ -p "ACREPCOUNT1=$ACREPCOUNT1"
     echo  "Check:- $ALVL => $FMSG" >>$LOGFIL
      
     if [ $CREATE_HTML_REPORT -eq 1 ]
     then # gadiga
       init_arrays_html "FAIL"
     fi

     if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
     then 
       echo  "Check:- $ALVL => $FMSG" >>$CWCREPFIL_FAIL
       echo  "Check:- $ALVL => $FMSG" >>$SCWCREPFIL_FAIL
     else  
       if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
       then
         echo "" >>$CELLREPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$CELLREPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$CELLSREPFIL_FAIL
       elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
       then
         echo "" >>$IBREPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$IBREPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$IBSREPFIL_FAIL
       else
         echo "" >>$REPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$REPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$SREPFIL_FAIL
       fi 
     fi
     if [ $COMTYPE = "OS_PACKAGE" ]
     then
       echo  "Audit check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@$ALVL=>$FMSG@$rpm_status@$rpm_arch">>$OSCHECKRESULT
     else        
       if [ -z "$audit_check_name" ]
       then
         audit_check_name=$COM
       fi
       echo  "Audit check # $ACREPCOUNT@$audit_check_name@$VAL@$COMP@$ALVL=>$FMSG">>$OSCHECKRESULT
     fi
     #audit_check_name=""
     #echo "------------------------------" >>$LOGFIL
     #echo "------------------------------" >>$REPFIL
     echo "" >>$LOGFIL
     if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
     then
       echo "" >>$CELLREPFIL_FAIL
     elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
     then
       echo "" >>$IBREPFIL_FAIL
     else 
       echo "" >>$REPFIL_FAIL
     fi

     #echo "DEBUG - ALERT_LEVEL = $ALVL"
     #$READ -p "stop"

     if [ -z "$MERGEFILES" ];
     then
     if [[ $ALVL = "WARNING" && $ISBRANCH -eq 0 ]]
     then
       echo -e "$ORANGE $ALVL =>$NORM $FMSG"
     elif [[ $ALVL = "FAIL" && $ISBRANCH -eq 0 ]]
     then
       echo -e "$RED $ALVL =>$NORM    $FMSG"
     elif [[ $ALVL = "INFO" && $ISBRANCH -eq 0 ]]
     then 
       echo -e "$BLUE $ALVL =>$NORM    $FMSG"
     elif [[ $ALVL = "ERROR" && $ISBRANCH -eq 0 ]]
     then
       echo -e "$RED $ALVL =>$NORM    $FMSG"
     fi
     fi
     #follwoing if is not to print anything in report for for package from appendix
     if [ $COMTYPE != "OS_PACKAGE-DISABLED" ]
     then
       #grab the details from the appendix
       LINKNUM=0
       LINK=
       if [ $op_mode -eq 0 ]
       then
         LINKNUM=`grep -c _$ROW-LINK $REFFIL1`
         BEGPAT="_$ROW-BEGIN_COMMENTS"
         ENDPAT="_$ROW-END_COMMENTS"
       else
         if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
         then
           CHECK_ID=${crs_check_id[$crs_check_file_counter]} 
         fi 
         LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
         BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
         ENDPAT="_$CHECK_ID-END_COMMENTS"
       fi
       ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
       #Added this line to add pass/fail message as rational if its ORACLE_PATH and ratinoal is empty
       if [[ "$COMTYPE" = "ORACLE_PATCH" && `echo $ONFAIL|sed '/^$/d'|wc -l` -eq 0 ]];then ONFAIL=$FMSG;fi
  
       case  $OP in
       -eq)
          rep_op="="
         ;;
       -ne)
          rep_op="!="
        ;;
       -ge)
          rep_op=">="
        ;;
       -gt)
          rep_op=">"
        ;;
       -lt)
          rep_op="<"
        ;;
       -le)
          rep_op="<="
        ;;
        *)
         rep_op=$OP
        ;;
       esac 
       #echo "LINKNUM = $LINKNUM"
       #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
       #if [ -n "$LINK" ]
       #then
       #  echo "" >>$LOGFIL
       #  echo "" >>$REPFIL
       #fi
       #echo "COMMENTS - $ONFAIL" >>$LOGFIL
       #echo " Additional information to resolve above problem ">>$LOGFIL
       #echo "$ONFAIL" >>$LOGFIL
       if [[  $COMTYPE = "CLUSTERWIDE_CHECK" && -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
       then
         echo "Additional information to resolve above problem">>$CWCREPFIL_FAIL
         echo "-----------------------------------------------">>$CWCREPFIL_FAIL
         if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]; then echo -e "Success factor name = $SF \n">>$CWCREPFIL_FAIL;fi
         #echo -e "Recommended value is  \"$COMP\", Comparision operator is \"$rep_op\"  and Actual found on system is  \"$VAL\" \n">>$REPFIL
         echo "$ONFAIL" >>$CWCREPFIL_FAIL
         if [[ -e $SOURCEFIL_REPORT ]]
         then
           echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$CWCREPFIL_FAIL
         fi
         unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
       elif [[ -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
       then
         if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
         then
           echo "Additional information to resolve above problem">>$CELLREPFIL_FAIL
           echo "-----------------------------------------------">>$CELLREPFIL_FAIL
           if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$CELLREPFIL_FAIL;fi
           echo "$ONFAIL" >>$CELLREPFIL_FAIL
           if  [ -e $SOURCEFIL_REPORT ]
           then
             echo -e "TO REVIEW COLLECTED DATA FROM $(echo $cellname|tr "[a-z]" "[A-Z]") :- ${SOURCEFIL_REPORT_NEW}\n">>$CELLREPFIL_FAIL
           fi
         elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
         then 
           echo "Additional information to resolve above problem">>$IBREPFIL_FAIL
           echo "-----------------------------------------------">>$IBREPFIL_FAIL
           if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$IBREPFIL_FAIL;fi
           echo "$ONFAIL" >>$IBREPFIL_FAIL
           if [ -e $SOURCEFIL_REPORT ]
           then
             echo -e "TO REVIEW COLLECTED DATA FROM $(echo $switchname|tr "[a-z]" "[A-Z]") :- ${SOURCEFIL_REPORT_NEW}\n">>$IBREPFIL_FAIL
           fi 
         else
           echo "Additional information to resolve above problem">>$REPFIL_FAIL
           echo "-----------------------------------------------">>$REPFIL_FAIL
           if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$REPFIL_FAIL;fi
           echo "$ONFAIL" >>$REPFIL_FAIL
           if [[ -e $SOURCEFIL_REPORT ]]
           then
             echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$REPFIL_FAIL
           fi 
         fi
         unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
       fi
       if [ $LINKNUM -gt 0 ]
       then
         #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
         for ((j=1;j<=$LINKNUM;j+=1));
         do
           #echo "j=$j, ROW=$ROW" >>$REPFIL
           if [ $op_mode -eq 0 ]
           then
             LINK=`grep "_"$ROW"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
             PLA_LINE=`grep "_"$ROW"-PLA_LINE"" " $REFFIL1 | sed -n 's/.*-PLA_LINE//p' | sed 's/^\s*//g' | sed 's/\s*$//g'` 
           else
             LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
	     PLA_LINE=`grep "_"$CHECK_ID"-PLA_LINE"" " $REFFIL1 | sed -n 's/.*-PLA_LINE//p' | sed 's/^\s*//g' | sed 's/\s*$//g'`
           fi
           if [ $CREATE_HTML_REPORT -eq 1 ]
           then
             append_links_html "$ALVL"
           fi
           if [[  $COMTYPE = "CLUSTERWIDE_CHECK" && -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
           then 
             echo "  $LINK" >>$CWCREPFIL_FAIL;
           elif [[ -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
           then 
             if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
             then
               echo "  $LINK" >>$CELLREPFIL_FAIL; 
             elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
             then
               echo "  $LINK" >>$IBREPFIL_FAIL; 
             else
               echo "  $LINK" >>$REPFIL_FAIL; 
             fi
           fi
         done
       fi
       if [ $CREATE_HTML_REPORT -eq 1 ]
       then # gadiga - for html reports
         create_checkid_html $ALVL
         write_output_to_html $ALVL
       fi
     else
       if [[ -e $SOURCEFIL_REPORT ]]
       then
           echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$REPFIL_FAIL
       fi
       if [ $CREATE_HTML_REPORT -eq 1 ]
       then  # gadiga - for html reports
         write_output_to_html $ALVL
       fi
       unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
     fi # end if not to print in report file for OS_PACAKGE
     echo -e "CHECK ID = $CHECK_ID \nAUDIT CHECK NAME = $audit_check_name\n">>$LOGFIL
     echo "---------------------------------------------" >>$LOGFIL
     if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
     then
       echo "">>$CWCREPFIL_FAIL
       echo "">>$CWCREPFIL_FAIL
     else
       if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
       then
         echo "" >>$CELLREPFIL_FAIL
         echo "" >>$CELLREPFIL_FAIL
       elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]] 
       then
         echo "" >>$IBREPFIL_FAIL
         echo "" >>$IBREPFIL_FAIL
       else
         echo "">>$REPFIL_FAIL
         echo "">>$REPFIL_FAIL
       fi
     fi
   fi
   #echo "---------------------------------------------" >>$LOGFIL

   if [[ $ISBRANCH -ne 1 ]] ; then
     generate_result_xml "FAIL"     
   fi

   case $COMTYPE in
   SQL|SQL_PARAM)
     #echo ""
     ;;
   OS|OS_PARAM)
     SQL1=`echo "$SQL'$PARAM_PATH' ,'$OP $COMP','$VAL');"`
     #this loop is a hack to eliminate error for missing comma
     #in the sql statements that are output which contain strings
     #like 'print $1', these need double single quotes
     #this will handle up to |awk {'print $5'}, more than that
     #and we would need to increase the number of loops
     for ((s=1;s<=5;s+=1));
     do
       SQL1=${SQL1/\{print \$$s\}/\'\{print \$$s\}\'}
       #echo "SQL1 = $SQL1"
     done

     #set failure flag
     ;;
   *)
     echo "Unexpected argument log_result [1] = $TYPE" >>$UPDATEFIL
     ;;
   esac

   if [ $OFFLINE -eq "0" ]; then 
     get_current_epoch 
     echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:log_fail End Time: $epoch_time" >> $CHK_TIMINGS
   fi
}

get_log_result ()
{
  cmd_type=$1 # Populate m_opstat
  cmd_value=$2 # db name or ohome

  if [[ $OFFLINE -eq 0 ]]; then
    unset db_global_name
    db_global_name=$(grep -w "${db_name_to_check}.GLOBAL_NAME" $MASTERFIL|awk '{print $3}'|sed 's/ //g')
  fi

  if [[ $cmd_value = "-" ]]; then pval=$db_name_to_check; else pval=$cmd_value; fi
  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch
    if [[ "$NEEDS_RUNNING" = "ASM" && ${stack_asm_up[$stack_counter]} -eq 1 ]]; then pval=${stack_asm_sid[$stack_counter]}; fi;
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:get_log_result Start Time: $epoch_time" >> $CHK_TIMINGS
  fi

  #$1 = SQL or OS, what type of command is being processed
  #$2 = whether to print the SF (1 - for standalone SF or root branch) or branch step (0) info
  #$3 = the number of the current step within a branch
  #$4 = the total number of steps in the branch
  #echo "TYPE = $TYPE" >>$LOGFIL
  #added to remove space before and after from value returned by command 
  VAL=$(echo $VAL|tr -d ' ')
  #To add correct audit_check_name in log file and fix bug 14514471, added this one following line
  if [ -z "$audit_check_name" ]; then audit_check_name=$PARAM_PATH;fi
  echo "" >>$LOGFIL
  if [[ $ISBRANCH -eq 1 && $COMTYPE = OS ]]
  then
    echo "HOST $i BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS ]]
  then
    echo "HOST $i STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 1 && $COMTYPE = SQL ]]
  then
    echo "SQL BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL ]]
  then
    echo "SQL STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 1 && $COMTYPE = OS_PARAM ]]
  then
    echo "HOST $i BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_PARAM ]]
  then
    echo "HOST $i STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 1 && $COMTYPE = OS_PACKAGE ]]
  then
    echo "HOST $i BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_PACKAGE ]]
  then
    echo "HOST $i STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 1 && $COMTYPE = SQL_PARAM ]]
  then
    echo "SQL BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL_PARAM ]]
  then
    echo "SQL STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL_COLLECT ]]
  then
    echo "SQL DATA COLLECTION $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_COLLECT ]]
  then
    echo "OS DATA COLLECTION $ROW" >>$LOGFIL
  fi

  if [[ $LEVEL -eq "1" && $SILENT -eq "0" ]]
  then
    if [[ $COMTYPE != "OS_COLLECT" && $COMTYPE != "SQL_COLLECT" ]]
    then
      #only want the verbose output for root level checks
      #everything in the hierarchy below that is referring
      #to the original check
      echo "  SF = $SF" >>$LOGFIL
      echo "  CATEGORY = $CAT" >>$LOGFIL
      echo "  SUBCATEGORY = $SUBCAT" >>$LOGFIL
      echo "  IS_BRANCH = $ISBRANCH" >>$LOGFIL 
    fi
  fi
  echo "  PARAMETER OR PATH = $PARAM_PATH" >>$LOGFIL
  echo "  COMMAND = $COM" >>$LOGFIL
  echo "AUDIT_CHECK_COMPONENTS = $check_components" >>$LOGFIL
  echo "AUDIT_CHECK_ID = $CHECK_ID" >>$LOGFIL
  if [[ $COMTYPE != "OS_COLLECT" && $COMTYPE != "SQL_COLLECT" ]]
  then
    echo "  COMMAND RESULT = $VAL" >>$LOGFIL
  fi
  if [ $SILENT -eq "0" ]
  then
    echo "  OPERATOR = $OP" >>$LOGFIL
    echo "  COMPARISON VALUE = $COMP" >>$LOGFIL
  fi
  echo "" >>$LOGFIL
  #code to print audit check number in report file 
  sql_collect=$(grep -c  "SQL_COLLECT_COMMAND_START" $REFFIL)
  os_collect=$(grep -c  "OS_COLLECT_COMMAND_START" $REFFIL)
  sql_os_collect=$(expr $sql_collect + $os_collect)
  curr_row_number=$(echo $ROW|cut -d. -f1)
  ACREPCOUNT=$(expr $curr_row_number - $sql_os_collect 2>/dev/null)
  #echo "ROW number is $ROW">/dev/null

  case $OP in
  -z|-f|-d|-n|"! -f"|"! -d")
  #we should never come in here if in SILENT mode
  #we will have no comparison operator if that is the case
  #SO nothing to do here if in SILENT mode
  #
  #echo "DEBUG: This should be correct - $COMP"

  #this handles -n and -z type operators where there is no comparison value
  #$VAL is either empty or non-empty, non-empty = TRUE, EM{TY = FALSE
  #This should never be the case for OS_COLLECT or SQL_COLLECT
    case $COMTYPE in
    SQL_PARAM)
      #echo "VAL=$VAL  for $PARAM_PATH"
      if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_conter]} -ne 0 ]]
      then 
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
          if [[ $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $NEEDS_RUNNING != "OIM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
          then
            execute_once_sql_param=0
	  elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
          then
            execute_once_sql_param=0
          elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_sql_param=0
          else
            execute_once_sql_param=1
            OPSTAT=1
            log_pass
          fi
        else
           OPSTAT=0
           echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
           log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi
        #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
        if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

        if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
        then
          if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
          if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
          if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	  status_message=$(echo "$status_message" | sed "s/'//g")

	  if [[ $insert_stmt_printed -eq 0 ]]; then
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	  fi
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
        fi
      elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
      then 
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
          if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
          then
            execute_once_sql_param=0
	  elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
          then
            execute_once_sql_param=0
          elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_sql_param=0
          else
            execute_once_sql_param=1
            OPSTAT=1
            log_pass
          fi
        else
          OPSTAT=0
          echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
          log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL_ACTUAL">>$AACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL_ACTUAL">>$AACTUAL
        fi
        #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
        if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

        if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
        then
          if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
          if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
          if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	  status_message=$(echo "$status_message" | sed "s/'//g")

	  if [[ $insert_stmt_printed -eq 0 ]]; then
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','ASM on $target','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	  fi
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','ASM on $i','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
        fi 
      elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
      then
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
          if [[ $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $NEEDS_RUNNING != "OIM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]]
          then
            execute_once_sql_param=0
	  elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
          then
            execute_once_sql_param=0
          elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_sql_param=0
          else
            execute_once_sql_param=1
            OPSTAT=1
            log_pass
          fi
        else
          OPSTAT=0
          echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
          log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi
        #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
        if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

        if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]
        then
          if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
          if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
          if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	  status_message=$(echo "$status_message" | sed "s/'//g")

	  if [[ $insert_stmt_printed -eq 0 ]]; then
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	  fi
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
        fi
      fi  
      ;;
      SQL|SQL_OUT_CHECK)
      if [ $SILENT -eq "0"  ]
      then
        if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_dbinst_up[$stack_counter]} -eq 3 ]]
        then
          if [ "$OP" "$VAL" ] 
          then
            if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
            then
              execute_once_sql=0
	    elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
            then
              execute_once_sql=0
            else
              execute_once_sql=0
              OPSTAT=1
              log_pass
            fi
          else
            OPSTAT=0
            log_fail
          fi
          #if [ $ISBRANCH -eq 0 ]; then echo "$CHECK_ID|$VAL">>$DBACTUAL ; fi
          #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
          if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

          if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
          then
            #echo "$CHECK_ID|$VAL">>$DBACTUAL
            if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
            if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
            if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	    status_message=$(echo "$status_message" | sed "s/'//g")

	    if [[ $insert_stmt_printed -eq 0 ]]; then
              echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	    fi
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
          fi
        fi  
      elif [ $SILENT -eq "1" ]
      then
        OPSTAT=1
        log_pass
      fi 
      if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
      if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
      if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
      then
        if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]]
        then
          echo "$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi;
      elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
      then
        if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]]
        then
          echo "$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi
      fi    
      ;;
      *)
      if [[ "$OP" = "-f" || "$OP" = "-d" || "$OP" = "! -f" || "$OP" = "! -d" ]]; then VAL=$COMP; fi;
      if [[ "$OP" = "-f" && `echo $COMP|grep -ic OUTPUTDIR`  -ge 1 ]]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  VAL_DIR=$TMP_OUTPUT
	else
          VAL_DIR=$OUTPUTDIR
	fi
        VAL_FIL=$(echo $COMP|cut -d/ -f2)
        VAL=$(echo ${VAL_DIR}/${VAL_FIL})
        os_check_needs_collect_file=1  
      else
        os_check_needs_collect_file=0 
      fi
      if [ $RAT_DEBUG -eq 1 ]
      then
        if [ $OP "$VAL" ]
        then
          if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
          then
       	    execute_once_os=0
	  elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
          then
            execute_once_os=0
          elif [[ $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $NEEDS_RUNNING != "OIM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_os=0
          else
            execute_once_os=1
            OPSTAT=1
            log_pass
          fi
        else
          OPSTAT=0
          log_fail
        fi
      else
        if [ $OP "$VAL"  2>>$ERRFIL ]
        then
          if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
          then
            execute_once_os=0
	  elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
          then
            execute_once_os=0
          elif [[ $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $NEEDS_RUNNING != "OIM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_os=0
          else
            execute_once_os=1
            OPSTAT=1
            log_pass
          fi
        else
          OPSTAT=0
          log_fail
        fi
      fi
      if [[ "$OP" = "-f" || "$OP" = "-d" || "$OP" = "! -f" || "$OP" = "! -d" || "$OP" = "-z" || "$OP" = "-n" ]]; then VAL_ACTUAL=$OPSTAT; fi;
      if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
      if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
      then
        if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
        then
          echo "${db_name_to_check}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
        then
          echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        else
          echo "${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        fi
      elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0  ]] && [ $write_info_actual_files -eq 1 ]
      then
        if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
        then
          echo "${db_name_to_check}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
        then
          echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        else
          echo "${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        fi
      fi
      #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
      if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

      if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
      then 
        if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
        if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
        if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	status_message=$(echo "$status_message" | sed "s/'//g")

	if [[ $insert_stmt_printed -eq 0 ]]; then
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	else
	  cellname_counter=0
	  for cellname in ${a_cellname[@]}
	  do
	    target=$cellname
	    ACT_TARGET=$cellname
 	    ALVL_MB=${a_cellCheckStatus[$cellname_counter]}
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
 	    cellname_counter=$(expr $cellname_counter + 1 ) 
	  done
	fi
        echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
      fi
      ;;
      esac
    ;;
   *)
   #if we have a comaprison value then the operator must not be -n or -z

   #echo "DEBUG: What am I doing in here? - $COMP"  

   #$READ -p "it comes here execute_once=$execute_once node=$i and localnode=$localnode com type =$COMTYPE"
   #$READ -p "DEBUG OP=$OP VAL=$COMP $ROW $SOURCEFIL it came here for -f OPSTAT=$OPSTAT VAL_DIR=$VAL_DIR VAL_FIL=$VAL_FIL VAL=$VAL"
   case $COMTYPE in
   OS_COLLECT)
     #if in SILENT mode, just collect the data as usual
     #all this branch does is run the OS command
     #no pass fail decisions to be made at this point
     #
     #echo "DEBUG - PATH = $OUTPUTDIR/$PARAM_PATH.out"
     #VAL would have been intialized in OS_COLLECT section below
     #same for $OUTFIL
     if [ $OFFLINE -eq "0"  ]  
     then
       if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
       then
         execute_once_exce=0
       elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
       then
         execute_once_exce=0
       elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
       then
         execute_once_exce=0
       else
         execute_once_exce=1
         COMSUBSTR=`echo $COM |awk '{print substr($0,0,67)}' |sed 's/ //g'`
         #COMSUBSTR=`echo $COM |awk '{print substr($0,0,57)}' |sed 's/ //g'`
         if [ -z "$COLLECTION_NAME" ] 
         then
           echo "Collecting - $COMSUBSTR" 
           #echo "Collecting $COLLECTION_NAME - $COMSUBSTR" 
         else
           echo "Collecting - $COLLECTION_NAME" 
         fi
         echo "" >>$LOGFIL
         echo "Command executed on $i - $COM" >>$LOGFIL
         echo "" >>$LOGFIL
         #execute the command and redirect output to specified file
         #$READ -p "OUTFILE=$OUTFIL"
         if [[ -e $COLLECT_TIMING ]]; then echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME on $i">>$COLLECT_TIMING; fi

         if [ $RAT_DEBUG -eq 1 ]
         then
           #$READ -p "$VAL"
           if [[ $i = $localnode ]]
           then
             if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
             then
               for mb_db_homes in ${mb_oracle_homes_distinct[@]}
               do
                 skip_this_version=0
                 set_skip_this_version "$mb_db_homes"
                 if [ $skip_this_version -eq 1 ]
                 then #dont run
                   mb_db_counter=$(expr $mb_db_counter + 1)
                   echo "Skipping check($CHECK_ID) on version(9) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                   continue
                 fi
                 mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                 mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   OLD_OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
		 else
                   OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                   #localcmd=$TMPDIR/localcmd.sh
                   localcmd=$RTEMPDIR/localcmd.sh
		 fi
      	         nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   OLD_OH=$ORACLE_HOME
		   ORACLE_HOME=${mb_db_homes}
		   get_dbOwner
		   ORACLE_HOME=$OLD_OH
		   if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	           chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		 fi

		 security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		 security_fix "check_and_fix_script_existence" "$localcmd"

                 cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
      	         echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo $COM>>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi

      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   #OLD_OH=$ORACLE_HOME
		   #ORACLE_HOME=${mb_db_homes}
		   #get_dbOwner
		   #ORACLE_HOME=$OLD_OH

		   #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	           #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"

      		   security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "$dbOwner:$dbGroup" "540"
      		   security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$dbOwner:$dbGroup" "540"
 
		   su $dbOwner -c "$localcmd" >>$OUTFIL

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput
 
		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
      		   security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "" "540"
      		   security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
                   $localcmd >>$OUTFIL
		 fi

      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS

		 #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
		 if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
               done
             elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
             then
               for mb_ogg_home in `cat $OGGHOMESVERSIONFIL|grep -wi $i|cut -d'|' -f2`
               do
                 mb_ogg_home_version=$(cat  $OGGHOMESVERSIONFIL|grep -wi $mb_ogg_home|cut -d'|' -f3)
                 #Fix for bug 21443278
                 if [ -z "$mb_ogg_home_version" ]; then mb_ogg_home_version=121210;fi
                 ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                 if [ $ogg_version_found -gt 0 ]
                 then
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g') 
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     OLD_OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
      	             localcmd=$TMP_OUTPUT/localcmd.sh
		   else
                     OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
      	             #localcmd=$TMPDIR/localcmd.sh
      	             localcmd=$RTEMPDIR/localcmd.sh
		   fi
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");
      		   
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     OLD_OH=$ORACLE_HOME
		     ORACLE_HOME=${mb_db_homes}
		     get_dbOwner
		     ORACLE_HOME=$OLD_OH
		     if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	             chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		   fi

		   security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		   security_fix "check_and_fix_script_existence" "$localcmd"

      	           cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$TRGTORCLENV_PATCEHS   
      	           echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
      	           echo "$bash_source" >>$localcmd
      	           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
      	           echo $COM>>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

      	           get_current_epoch 
      	           echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     #OLD_OH=$ORACLE_HOME
                     #ORACLE_HOME=${mb_ogg_home}
                     #get_dbOwner
                     #ORACLE_HOME=$OLD_OH

		     #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	             #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
      		     security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "$dbOwner:$dbGroup" "540"
      		     security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$dbOwner:$dbGroup" "540"

                     su $dbOwner -c "$localcmd" >>$OUTFIL

		     move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		     move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		     write_del_rolbk_errlog
		     write_del_rolbk_tmpoutput

		     cd $OLD_DIR
	    	     unset OLD_DIR
                   else
      		     security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "" "540"
      		     security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
                     $localcmd >>$OUTFIL
                   fi

      	           get_current_epoch 
      	           echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS

		   #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
		   if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
                 else
                   echo "skipping $collection_name at $CHECK_ID for $mb_ogg_home because collection version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                 fi 
               done   
             else
	       if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	         printf ""
	       else
                 get_current_epoch 
	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && $PARAM = "CRS" ]]; then
                   OLD_OUTFIL=$OUTFIL
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_"$i".out"
                   OLD_OUTFIL_REPORT=$OUTFIL_REPORT
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

		   OLD_OH=$ORACLE_HOME
		   ORACLE_HOME=${mb_db_homes}
		   get_dbOwner
		   ORACLE_HOME=$OLD_OH
		   if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	           chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"

		   security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		   security_fix "check_and_fix_script_existence" "$localcmd"

                   cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_HOME=$CRS">>$TRGTORCLENV_PATCEHS
                   echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
                   echo "$bash_source" >>$localcmd
                   echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                   echo "$COM">>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi

		   #OLD_OH=$ORACLE_HOME
		   #ORACLE_HOME=$CRS
		   #get_dbOwner
		   #ORACLE_HOME=$OLD_OH

		   #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	           #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
      		   security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "$dbOwner:$dbGroup" "540"
      		   security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$dbOwner:$dbGroup" "540"
 
		   su $dbOwner -c "$localcmd" >>$OUTFIL

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput

		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
                   if [[ -z $TRGTORCLENV_PATCEHS ]]; then TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh; fi
      		   security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "" "540"
      		   security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
                   $localcmd >>$OUTFIL
                 fi

	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	       
	         #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
		 if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
	       fi
             fi
           else
             if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
             then
               for mb_db_homes in ${mb_oracle_homes_distinct[@]}
               do
                 skip_this_version=0
                 set_skip_this_version "$mb_db_homes"
                 if [ $skip_this_version -eq 1 ]
                 then #dont run
                   mb_db_counter=$(expr $mb_db_counter + 1)
                   echo "Skipping check($CHECK_ID) on version(10) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                   continue
                 fi
                 mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                 mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   OLD_OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
		 else
                   OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
		 fi
      	         nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");
      		 
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   OLD_OH=$ORACLE_HOME
		   ORACLE_HOME=${mb_db_homes}
		   get_dbOwner $i
		   ORACLE_HOME=$OLD_OH
		   if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	           chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		 fi

		 security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		 security_fix "check_and_fix_script_existence" "$localcmd"

                 cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
      	     	 echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo $COM>>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

		 #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
		 if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   #OLD_OH=$ORACLE_HOME
                   #ORACLE_HOME=${mb_db_homes}
                   #get_dbOwner
                   #ORACLE_HOME=$OLD_OH

		   #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	           #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
                   get_cygpath "localcmd"
                   get_cygpath "TRGTORCLENV_PATCEHS"
                   #$SCOPY $localcmd $i:${TMPDIR} >/dev/null 2>&1 
      	           #$SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                   $SCOPY $localcmd $i:${TMP_OUTPUT}/$dbOwner >/dev/null 2>&1 
      	           $SCOPY $TRGTORCLENV_PATCEHS $i:${TMP_OUTPUT}/$dbOwner >/dev/null 2>&1
                   restore_cygpath "localcmd"
                   restore_cygpath "TRGTORCLENV_PATCEHS"

		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $dbOwner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1; chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"

		   $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput

		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
                   get_cygpath "localcmd"
                   get_cygpath "TRGTORCLENV_PATCEHS"
                   #$SCOPY $localcmd $i:${TMPDIR} >/dev/null 2>&1 
                   $SCOPY $localcmd $i:${RTEMPDIR} >/dev/null 2>&1 
      	           $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                   restore_cygpath "localcmd"
                   restore_cygpath "TRGTORCLENV_PATCEHS"

		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
                   $SSHELL $i $localcmd >>$OUTFIL
		 fi

                 get_cygpath "OUTFIL_REPORT"
                 get_cygpath "OUTPUTDIR"
                 $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1
                 restore_cygpath "OUTFIL_REPORT"
                 restore_cygpath "OUTPUTDIR"

                 REM_RC=`$SSHELL $i rm -f $localcmd >/dev/null 2>&1;echo \$?;`
		 security_fix "verify_remcode" "$i:$localcmd" "$REM_RC"
      	         REM_RC=`$SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \$?;`
		 security_fix "verify_remcode" "$i:$TRGTORCLENV_PATCEHS" "$REM_RC"
		 
      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS
               done
             elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
             then
               for mb_ogg_home in `grep -wi $i $OGGHOMESVERSIONFIL|cut -d'|' -f2`
               do
                 mb_ogg_home_version=$(grep -wi $mb_ogg_home $OGGHOMESVERSIONFIL|cut -d'|' -f3)
                 #Fix for bug 21443278
                 if [ -z "$mb_ogg_home_version" ]; then mb_ogg_home_version=121210;fi
                 ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                 if [ $ogg_version_found -gt 0 ]
                 then
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g') 
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     OLD_OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
		     TRGTORCLENV_PATCEHS=$TMP_OUTPUT/set_orcl_env_patches.sh
		   else
                     OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
      	             #localcmd=$TMPDIR/localcmd.sh
      	             localcmd=$RTEMPDIR/localcmd.sh
		   fi
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");

		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     OLD_OH=$ORACLE_HOME
		     ORACLE_HOME=${mb_db_homes}
		     get_dbOwner $i
		     ORACLE_HOME=$OLD_OH
		     if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	             chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		   fi

		   security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		   security_fix "check_and_fix_script_existence" "$localcmd"

      	           cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$TRGTORCLENV_PATCEHS   
      	           echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
      	           echo "$bash_source" >>$localcmd
      	           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
      	           echo $COM>>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

		   #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
		   if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

      	           get_current_epoch 
      	           echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     #OLD_OH=$ORACLE_HOME
                     #ORACLE_HOME=${mb_ogg_home}
                     #get_dbOwner
                     #ORACLE_HOME=$OLD_OH

		     #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	             #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
                     get_cygpath "localcmd"
                     get_cygpath "TRGTORCLENV_PATCEHS"
                     #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1 
      	             #$SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                     $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1 
      	             $SCOPY $TRGTORCLENV_PATCEHS $i:${TMP_OUTPUT} >/dev/null 2>&1
                     restore_cygpath "localcmd"
                     restore_cygpath "TRGTORCLENV_PATCEHS"

		     ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $dbOwner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
		     security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		     ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1; chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		     security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
		     $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 
	
		     move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		     move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		     write_del_rolbk_errlog
		     write_del_rolbk_tmpoutput

		     cd $OLD_DIR
	    	     unset OLD_DIR
		   else
                     get_cygpath "localcmd"
                     get_cygpath "TRGTORCLENV_PATCEHS"
                     #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1 
                     $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1 
      	             $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                     restore_cygpath "localcmd"
                     restore_cygpath "TRGTORCLENV_PATCEHS"

		     ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		     security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		     ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		     security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
                     $SSHELL $i $localcmd >>$OUTFIL
		   fi

                   get_cygpath "OUTFIL_REPORT"
                   get_cygpath "OUTPUTDIR"
                   $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1 
                   restore_cygpath "OUTFIL_REPORT"
                   restore_cygpath "OUTPUTDIR"

                   REM_RC=`$SSHELL $i rm -f $localcmd >/dev/null 2>&1;echo \$?;`
		   security_fix "verify_remcode" "$localcmd" "$REM_RC"
      	           REM_RC=`$SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \$?;`
		   security_fix "verify_remcode" "$TRGTORCLENV_PATCEHS" "$REM_RC"

      	           get_current_epoch 
      	           echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS
                 else
                   echo "skipping $collection_name at $CHECK_ID for $mb_ogg_home because collection version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                 fi 
               done 
             else
    	       if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	   	 printf ""
	       else
	         #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
		 if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

      	         get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && $PARAM = "CRS" ]]; then
                   OLD_OUTFIL=$OUTFIL
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_"$i".out"
                   OLD_OUTFIL_REPORT=$OUTFIL_REPORT
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
                   nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

		   OLD_OH=$ORACLE_HOME
		   ORACLE_HOME=${mb_db_homes}
		   get_dbOwner $i
		   ORACLE_HOME=$OLD_OH
		   if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	           chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		   security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		   security_fix "check_and_fix_script_existence" "$localcmd"

                   cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_HOME=$CRS">>$TRGTORCLENV_PATCEHS
                   echo "#!$bash_scr" >$localcmd
                   echo "$RAT_DEBUG_FLG" >>$localcmd
                   echo "$bash_source" >>$localcmd
                   echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                   echo "$COM">>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi

                   #OLD_OH=$ORACLE_HOME
                   #ORACLE_HOME=$CRS
                   #get_dbOwner
                   #ORACLE_HOME=$OLD_OH

		   #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	           #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
                   get_cygpath "localcmd"
                   get_cygpath "OUTFIL_REPORT"
                   get_cygpath "OUTPUTDIR"
                   #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
		   #$SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                   $SCOPY $localcmd $i:$TMP_OUTPUT/$dbOwner >/dev/null 2>&1
		   $SCOPY $TRGTORCLENV_PATCEHS $i:${TMP_OUTPUT}/$dbOwner >/dev/null 2>&1

		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $dbOwner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1; chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
                   $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput

		   cd $OLD_DIR
		   unset OLD_DIR
		 else
                   if [[ -z $TRGTORCLENV_PATCEHS ]]; then TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh; fi
                   cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1

                   get_cygpath "localcmd"
                   get_cygpath "OUTFIL_REPORT"
                   get_cygpath "OUTPUTDIR"
                   #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
                   $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
		   $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/set_orcl_env_patches.sh >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$RTEMPDIR/set_orcl_env_patches.sh" "$ATTRMOD_RC"
                   $SSHELL $i $localcmd >>$OUTFIL
		 fi

                 $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1

                 REM_RC=`$SSHELL $i rm -f $localcmd >/dev/null 2>&1;echo \$?;`
		 security_fix "verify_remcode" "$localcmd" "$REM_RC"
		 REM_RC=`$SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \$?;`
		 security_fix "verify_remcode" "$TRGTORCLENV_PATCEHS" "$REM_RC"

                 restore_cygpath "localcmd"
                 restore_cygpath "OUTFIL_REPORT"
                 restore_cygpath "OUTPUTDIR"

      	         get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
               fi
             fi
           fi
           #cat $localcmd
           #$READ -p "see above"
           #ssh ratus-vm2 . /tmp/set_orcl_env.sh;/sbin/sysctl -a >>$OUTFIL
         else
           if [[ $i = $localnode ]]
           then
             if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
             then
               for mb_db_homes in ${mb_oracle_homes_distinct[@]}
               do
                 skip_this_version=0
                 set_skip_this_version "$mb_db_homes"
                 if [ $skip_this_version -eq 1 ]
                 then #dont run
                   mb_db_counter=$(expr $mb_db_counter + 1)
                   echo "Skipping check($CHECK_ID) on version(11) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                   continue
                 fi
                 mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                 mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   OLD_OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
		 else
                   OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                   #localcmd=$TMPDIR/localcmd.sh
                   localcmd=$RTEMPDIR/localcmd.sh
		 fi
      	         nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   OLD_OH=$ORACLE_HOME
		   ORACLE_HOME=${mb_db_homes}
		   get_dbOwner
		   ORACLE_HOME=$OLD_OH
		   if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	           chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		 fi

		 security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		 security_fix "check_and_fix_script_existence" "$localcmd"

                 cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
      	         echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo $COM>>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

      	         get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   #OLD_OH=$ORACLE_HOME
                   #ORACLE_HOME=${mb_db_homes}
                   #get_dbOwner
                   #ORACLE_HOME=$OLD_OH

		   #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	           #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
      		   security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "$dbOwner:$dbGroup" "540"
      		   security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$dbOwner:$dbGroup" "540"
                   su $dbOwner -c "$localcmd" >>$OUTFIL 2>>$ERRFIL

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput

		   cd $OLD_DIR
	    	   unset OLD_DIR
                 else
      		   security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "" "540"
      		   security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
                   $localcmd >>$OUTFIL 2>>$ERRFIL
                 fi

      	         get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS

		 #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
		 if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
               done
             elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
             then
               for mb_ogg_home in `grep -wi $i $OGGHOMESVERSIONFIL|cut -d'|' -f2`
               do
                 mb_ogg_home_version=$(grep -wi $mb_ogg_home $OGGHOMESVERSIONFIL|cut -d'|' -f3)
                 #Fix for bug 21443278
                 if [ -z "$mb_ogg_home_version" ]; then mb_ogg_home_version=121210;fi
                 ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                 if [ $ogg_version_found -gt 0 ]
                 then
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g') 
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     OLD_OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
      	             localcmd=$TMP_OUTPUT/localcmd.sh
  		   else
                     OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
      	             #localcmd=$TMPDIR/localcmd.sh
      	             localcmd=$RTEMPDIR/localcmd.sh
		   fi
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");
      		   
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     OLD_OH=$ORACLE_HOME
		     ORACLE_HOME=${mb_db_homes}
		     get_dbOwner
		     ORACLE_HOME=$OLD_OH
		     if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	             chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		   fi

		   security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		   security_fix "check_and_fix_script_existence" "$localcmd"

      	           cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$TRGTORCLENV_PATCEHS   
      	           echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
      	           echo "$bash_source" >>$localcmd
      	           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
      	           echo $COM>>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

      	           get_current_epoch 
                   echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     #OLD_OH=$ORACLE_HOME
                     #ORACLE_HOME=${mb_ogg_home}
                     #get_dbOwner
                     #ORACLE_HOME=$OLD_OH

		     #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	             #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
      		     security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "$dbOwner:$dbGroup" "540"
      		     security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$dbOwner:$dbGroup" "540"
                     su $dbOwner -c "$localcmd" >>$OUTFIL 2>>$ERRFIL

		     move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		     move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		     write_del_rolbk_errlog
		     write_del_rolbk_tmpoutput

		     cd $OLD_DIR
	    	     unset OLD_DIR
                   else
      		     security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "" "540"
      		     security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
                     $localcmd >>$OUTFIL 2>>$ERRFIL
                   fi

      	           get_current_epoch 
                   echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS

		   #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		   if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
                 else
                   echo "skipping $collection_name at $CHECK_ID for $mb_ogg_home because collection version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                 fi 
               done
             else
	       if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
		 printf ""	
	       else
      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && $PARAM = "CRS" ]]; then
                   OLD_OUTFIL=$OUTFIL
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_"$i".out"
                   OLD_OUTFIL_REPORT=$OUTFIL_REPORT
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
                   nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

                   OLD_OH=$ORACLE_HOME
                   ORACLE_HOME=$CRS
                   get_dbOwner
                   ORACLE_HOME=$OLD_OH
		   if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi

	           chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"

		   security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		   security_fix "check_and_fix_script_existence" "$localcmd"

                   cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_HOME=$CRS">>$TRGTORCLENV_PATCEHS
                   echo "#!$bash_scr" >$localcmd
                   echo "$RAT_DEBUG_FLG" >>$localcmd
                   echo "$bash_source" >>$localcmd
                   echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                   echo "$COM">>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi

                   #OLD_OH=$ORACLE_HOME
                   #ORACLE_HOME=$CRS
                   #get_dbOwner
                   #ORACLE_HOME=$OLD_OH

		   #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	           #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
      		   security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "$dbOwner:$dbGroup" "540"
      		   security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$dbOwner:$dbGroup" "540"

                   su $dbOwner -c "$localcmd" >>$OUTFIL 2>>$ERRFIL

                   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
                   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput

                   cd $OLD_DIR
                   unset OLD_DIR
                 else
                   if [[ -z $TRGTORCLENV_PATCEHS ]]; then TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh; fi
      		   security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "" "540"
      		   security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
      	           $localcmd >>$OUTFIL 2>>$ERRFIL
		 fi
      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	         #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
		 if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
               fi
             fi
           else
             if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
             then
               for mb_db_homes in ${mb_oracle_homes_distinct[@]}
               do
                 skip_this_version=0
                 set_skip_this_version "$mb_db_homes"
                 if [ $skip_this_version -eq 1 ]
                 then #dont run
                   mb_db_counter=$(expr $mb_db_counter + 1)
                   echo "Skipping check($CHECK_ID) on version(12) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                   continue
                 fi
                 mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                 mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   OLD_OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
		 else
                   OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                   #localcmd=$TMPDIR/localcmd.sh
                   localcmd=$RTEMPDIR/localcmd.sh
		 fi
      	         nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");
      		 
                 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OLD_OH=$ORACLE_HOME
                   ORACLE_HOME=${mb_db_homes}
                   get_dbOwner $i
                   ORACLE_HOME=$OLD_OH
		   if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi

	           chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		 fi

		 security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		 security_fix "check_and_fix_script_existence" "$localcmd"

                 cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
      	         echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo $COM>>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

		 #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi	
		 if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                 get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   #OLD_OH=$ORACLE_HOME
                   #ORACLE_HOME=${mb_db_homes}
                   #get_dbOwner
                   #ORACLE_HOME=$OLD_OH

		   #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	           #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
                   #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
                   #$SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                   $SCOPY $localcmd $i:$TMP_OUTPUT/$dbOwner >/dev/null 2>&1
                   $SCOPY $TRGTORCLENV_PATCEHS $i:${TMP_OUTPUT}/$dbOwner >/dev/null 2>&1

		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $dbOwner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1; chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
                   $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 2>>$ERRFIL

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput

		   cd $OLD_DIR
	    	   unset OLD_DIR
                 else
                   cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1

                   #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
                   $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                   $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1

		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		   ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		   security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
                   $SSHELL $i $localcmd >>$OUTFIL 2>>$ERRFIL
                 fi         

                 $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1

                 REM_RC=`$SSHELL $i rm -f $localcmd >/dev/null 2>&1;echo \$?;`	
		 security_fix "verify_remcode" "$localcmd" "$REM_RC"
                 REM_RC=`$SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \$?;`
		 security_fix "verify_remcode" "$TRGTORCLENV_PATCEHS" "$REM_RC"

                 get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS
               done
             elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
             then
               for mb_ogg_home in `grep -wi $i $OGGHOMESVERSIONFIL|cut -d'|' -f2`
               do
                 mb_ogg_home_version=$(grep -wi $mb_ogg_home $OGGHOMESVERSIONFIL|cut -d'|' -f3)
                 #Fix for bug 21443278
                 if [ -z "$mb_ogg_home_version" ]; then mb_ogg_home_version=121210;fi
                 ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                 if [ $ogg_version_found -gt 0 ]
                 then
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g') 
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     OLD_OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
      	             localcmd=$TMP_OUTPUT/localcmd.sh
		   else
                     OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
      	             #localcmd=$TMPDIR/localcmd.sh
      	             localcmd=$RTEMPDIR/localcmd.sh
		   fi
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");
      		   
                   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OLD_OH=$ORACLE_HOME
                     ORACLE_HOME=${mb_ogg_home}
                     get_dbOwner $i
                     ORACLE_HOME=$OLD_OH
		     if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi

	             chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
		   fi
		     
		   security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		   security_fix "check_and_fix_script_existence" "$localcmd"

      	           cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$TRGTORCLENV_PATCEHS   
      	           echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
      	           echo "$bash_source" >>$localcmd
      	           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
      	           echo $COM>>$localcmd 
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

                   get_current_epoch 
                   echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1 
      	             #$SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                     $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1 
      	             $SCOPY $TRGTORCLENV_PATCEHS $i:${TMP_OUTPUT} >/dev/null 2>&1

                     #OLD_OH=$ORACLE_HOME
                     #ORACLE_HOME=${mb_ogg_home}
                     #get_dbOwner
                     #ORACLE_HOME=$OLD_OH

		     #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	             #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
 
		     ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $dbOwner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
		     security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		     ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1; chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		     security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
                     $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 2>>$ERRFIL

		     move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		     move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		     write_del_rolbk_errlog
		     write_del_rolbk_tmpoutput

		     cd $OLD_DIR
	       	     unset OLD_DIR
                   else
		     ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		     security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		     ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		     security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
                     $SSHELL $i $localcmd >>$OUTFIL 2>>$ERRFIL
                   fi         

                   $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1

                   REM_RC=`$SSHELL $i rm -f $localcmd >/dev/null 2>&1;echo \$?;`
		   security_fix "verify_remcode" "$localcmd" "$REM_RC"
      	           REM_RC=`$SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \$?;`
		   security_fix "verify_remcode" "$TRGTORCLENV_PATCEHS" "$REM_RC"

                   get_current_epoch 
                   echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS
                 else
                   echo "skipping $collection_name at $CHECK_ID for $mb_ogg_home because collection version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                 fi 
               done
             else  
   	       if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	 	 printf "" 
  	       else
	       #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
	       if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

               get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

               if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && $PARAM = "CRS" ]]; then
                 OLD_OUTFIL=$OUTFIL
                 OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_"$i".out"
                 OLD_OUTFIL_REPORT=$OUTFIL_REPORT
                 OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_"$i"_report.out"
                 TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                 localcmd=$TMP_OUTPUT/localcmd.sh
                 nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

                 OLD_OH=$ORACLE_HOME
                 ORACLE_HOME=$CRS
                 get_dbOwner $i
                 ORACLE_HOME=$OLD_OH
		 if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi

	         chg_files_for_usr "localcmd,TRGTORCLENV_PATCEHS,OUTFIL,OUTFIL_REPORT,ERRFIL" "$localcmd,$TRGTORCLENV_PATCEHS,$OUTFIL,$OUTFIL_REPORT,$ERRFIL"

		 security_fix "check_and_fix_script_existence" "$TRGTORCLENV_PATCEHS"
		 security_fix "check_and_fix_script_existence" "$localcmd"

                 cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$CRS">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
                 echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo "$COM">>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi

                 get_cygpath "localcmd"
                 get_cygpath "OUTFIL_REPORT"
                 get_cygpath "OUTPUTDIR"
                 #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
                 #$SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                 $SCOPY $localcmd $i:$TMP_OUTPUT/$dbOwner >/dev/null 2>&1
                 $SCOPY $TRGTORCLENV_PATCEHS $i:${TMP_OUTPUT}/$dbOwner >/dev/null 2>&1

                 #OLD_OH=$ORACLE_HOME
                 #ORACLE_HOME=$CRS
                 #get_dbOwner
                 #ORACLE_HOME=$OLD_OH

		 #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
	         #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"

		 ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $dbOwner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
		 security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		 ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV_PATCEHS >/dev/null 2>&1; chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \\$?"`
		 security_fix "verify_attrmodcode" "$i:$TRGTORCLENV_PATCEHS" "$ATTRMOD_RC"
                 $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 2>>$ERRFIL

                 move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		 move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		 write_del_rolbk_errlog
		 write_del_rolbk_tmpoutput

                 cd $OLD_DIR
                 unset OLD_DIR
               else
                 if [[ -z $TRGTORCLENV_PATCEHS ]]; then TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh; fi
                 cp -f $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1

                 get_cygpath "localcmd"
                 get_cygpath "OUTFIL_REPORT"
                 get_cygpath "OUTPUTDIR"
                 #$SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
                 $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                 $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
		 ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		 security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		 ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/set_orcl_env_patches.sh >/dev/null 2>&1;echo \\$?"`
		 security_fix "verify_attrmodcode" "$i:$RTEMPDIR/set_orcl_env_patches.sh" "$ATTRMOD_RC"
                 $SSHELL $i $localcmd >>$OUTFIL 2>>$ERRFIL
               fi

               $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1

               REM_RC=`$SSHELL $i rm -f $localcmd >/dev/null 2>&1;echo \$?;`
	       security_fix "verify_remcode" "$localcmd" "$REM_RC"
	       REM_RC=`$SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1;echo \$?;`
	       security_fix "verify_remcode" "$TRGTORCLENV_PATCEHS" "$REM_RC"

               restore_cygpath "localcmd"
               restore_cygpath "OUTFIL_REPORT"
               restore_cygpath "OUTPUTDIR"

               get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	       fi
             fi
           fi
           #$localcmd >>$OUTFIL 2>>$ERRFIL
         fi
         if [ -e "$localcmd" ]; then rm -f $localcmd 2>/dev/null;fi
         if [ -e "$localcmd_report" ]; then rm -f $localcmd_report  2>/dev/null;fi
         if [ -e "$TRGTORCLENV_PATCEHS" ]; then rm -f $TRGTORCLENV_PATCEHS 2>/dev/null;fi
       fi
     fi
     ;;
   SQL_COLLECT)
     #if in SILENT mode then just collect the data as usual
     #
     #all this branch does is run the SQL command
     #no pass or fail decisions to be made at this point
     #
     #for each SQL_COLLECT we'll make a new script file
     #execute it in SQLPLUS and spool the result to the outpu directory
     #echo "DEBUG - PARAM_PATH = $PARAM_PATH, COM = $COM"
   
     #we only want to do these spool files once per database
     #not once per node so we check here if the file already exists
     #if it does we do not want to do the collection again
     #echo " $SF `echo $SF|grep -ic "DBMACHINE V1"` db_machine_compute=$db_machine_compute " 
     #$READ -p "see this"
      
     if [ ! -f $OUTFIL ] && [ $OFFLINE -eq "0" ] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] && [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
     then
       if  [[ $component_match_count  -lt 1 ]]
       then
         echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
       elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
       then
         call_get_log_result=0
	echo "Not running $COLLECTION_NAME (CHECK ID $CHECK_ID) on $i because no profile is in use">>$LOGFIL
       elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
       then
         call_get_log_result=0
         #echo "Skipping $COLLECTION_NAME (CHECK ID $CHECK_ID)  on $i because its excluded">>$EXCLUDELOG
         generate_exceptions_xml "Skipping $COLLECTION_NAME because its excluded"
	 generate_exceptions_json "Skipping $COLLECTION_NAME because its excluded"
       elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$COLLECTION_NAME" $EXCLUDEFIL` -ge 1 ]]
       then
         call_get_log_result=0
         echo "Skipping $COLLECTION_NAME (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
         generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"
  	 generate_exceptions_json "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"

         #commented this branch to execute all SQL_COLLECT to on all databases  
         #elif [[ "${mb_database_role[$mb_db_counter]}" != "$check_database_role" ]] 
         #then
         #    echo "$COM skipped for $db_name_to_check because database role does not match">>$LOGFIL
         #    call_get_log_result=0
         else
	   #create the script file that will be executed in SQL*Plus
	   #echo "DEBUG - INFIL = $INFIL"
	   #COMSUBSTR_NAME=`echo $COM |awk '{print substr($0,0,57)}' |sed 's/ //g'`
	   if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]] || [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 && "$NEEDS_RUNNING" = "ASM" ]]; then
	     COMSUBSTR=`echo $COM |awk '{print substr($0,0,67)}' |sed 's/ //g'`
    	     security_fix "check_and_fix_script_existence" "$INFIL"
             if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]; then echo "alter session set container=$db_name_to_check;">$INFIL;fi 
	     echo "$COM" >>$INFIL
	     pl_sql=`echo $COM|grep -ic "begin" `
	     if [ $pl_sql -gt 0 ]
	     then
	       echo "/" >>$INFIL
	       #$READ -p "see $INFIL for /"
	     fi
	     if [[ "$NEEDS_RUNNING" = "ASM" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
	     then
	       if [ -z "$COLLECTION_NAME" ] 
	       then
	         echo "Collecting - $COMSUBSTR" 
	       else
	         echo "Collecting - $COLLECTION_NAME " 
	       fi
	       #OLD_ORACLE_HOME=$ORACLE_HOME
	       #OLD_ORACLE_SID=$ORACLE_SID
               if [[ -n "$crs112" && $crs112 -ge 1 ]]
	       then
	         export ORACLE_SID=${stack_asm_sid[$stack_counter]}
	         export ORACLE_HOME=$CRS
	       else
	         export ORACLE_HOME=${stack_asm_home[$stack_counter]}
	         export ORACLE_SID=${stack_asm_sid[$stack_counter]}
	       fi
	       #$READ -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID infile is $INFIL and query is $COM"
               if [[ -e $COLLECT_TIMING ]]; then echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME">>$COLLECT_TIMING; fi
               #added 1=2 not to execute first part of this if not execute asm collection with username/password becuase we never ask asm sysdba password

	       if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	         get_dbOwner
	         chg_files_for_usr "NEW_INFIL,NEW_OUTFIL,ERRFIL" "$NEW_INFIL,$NEW_OUTFIL,$ERRFIL"
	       fi

	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ${stack_asm_sid[$stack_counter]}] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

    	       security_fix "check_and_fix_script_existence" "$NEW_INFIL"
	       if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 && 1 -eq 2 ]]
	       then
                 DBUSR=${mb_sysdba_user[$mb_db_counter]}
                 DBPWD=${mb_sysdba_pswd[$mb_db_counter]}

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   #get_dbOwner

	           #chg_files_for_usr "NEW_OUTFIL,ERRFIL" "$NEW_OUTFIL,$ERRFIL"

		   cp -f $INFIL $NEW_INFIL
		   chown $dbOwner:$dbGroup $NEW_INFIL

	           su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	           set head off
	           set lines 80
	           set feedback off
                   set timing off  
	           set serveroutput on
	           spool $NEW_OUTFIL
	           @@$NEW_INFIL
	           spool off
	           exit
EOF
"
		   move_files "$NEW_OUTFIL" "$OUTFIL"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput

		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
	           $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	           set head off
	           set lines 80
	           set feedback off
                   set timing off  
	           set serveroutput on
	           spool $OUTFIL
	           @@$INFIL
	           spool off
	           exit
EOF
	   	 fi
	       else
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   #get_dbOwner

	           #chg_files_for_usr "NEW_OUTFIL,ERRFIL" "$NEW_OUTFIL,$ERRFIL"

		   cp -f $INFIL $NEW_INFIL
		   chown $dbOwner:$dbGroup $NEW_INFIL

	           su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	           set head off
	           set lines 80
	           set feedback off
                   set timing off  
	           set serveroutput on
	           spool $NEW_OUTFIL
	           @@$NEW_INFIL
	           spool off
	           exit
EOF
"	
		   move_files "$NEW_OUTFIL" "$OUTFIL"
		   write_del_rolbk_errlog
		   write_del_rolbk_tmpoutput

		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
	           #$READ -p "before asm collection"
	           $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	           set head off
	           set lines 80
	           set feedback off
                   set timing off  
	           set serveroutput on
	           spool $OUTFIL
	           @@$INFIL
	           spool off
	           exit
EOF
		 fi
	          #$READ -p "check asm collection $ORACLE_SID and $ORACLE_HOME $OUTFIL and infile=$INFIL"
	       fi
    	       security_fix "check_and_fix_script_existence" "$NEW_INFIL"

	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ${stack_asm_sid[$stack_counter]}] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	       #ORACLE_SID=$OLD_ORACLE_SID
	       #ORACLE_HOME=$OLD_ORACLE_HOME   
	     elif [[ "$NEEDS_RUNNING" != "ASM" ]] && [ ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
	     then
               #echo "calling sql collect for $db_name_name_to_check oralce_Sid $ORACLE_SID and Oracle_home $ORACLE_HOME"
	       if [ -z "$COLLECTION_NAME" ] 
	       then
	         echo "Collecting - $COMSUBSTR for ${db_name_to_check} database" 
	       else
	         echo "Collecting - $COLLECTION_NAME for ${db_name_to_check} database " 
	       fi
	       #$READ -p "IS_SYSDBA=$IS_SYSDBA" 
               if [[ -e $COLLECT_TIMING ]]; then echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME on ${db_name_to_check}">>$COLLECT_TIMING; fi
	       if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]
	       then
	         #mb_checksysdba[$mb_db_counter]=0
	         dbConnectString="${RAT_PDB_USER}/${mb_db_sys_password[$mb_db_counter]}@"${mb_db_connect_string[$mb_db_counter]}" as sysdba"
	       else
                 DBUSR=${mb_sysdba_user[$mb_db_counter]}
                 DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
	         dbConnectString="$DBUSR/$DBPWD as sysdba"
	       fi      

	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $ORACLE_SID] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	       if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		 if [ ${mb_running_host[$mb_db_counter]} = $localnode ]; then
	           get_dbOwner
		 else
	           get_dbOwner ${mb_running_host[$mb_db_counter]}
		 fi
		 if [[ -z $dbOwner ]]; then call_get_log_result=0; mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
	         chg_files_for_usr "NEW_INFIL,NEW_OUTFIL,ERRFIL" "$NEW_INFIL,$NEW_OUTFIL,$ERRFIL"
	       fi

    	       security_fix "check_and_fix_script_existence" "$NEW_INFIL"
	       if [ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]
	       then
	         if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
	         then
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     #get_dbOwner

	             #chg_files_for_usr "NEW_OUTFIL,ERRFIL" "$NEW_OUTFIL,$ERRFIL"

                     cp -f $INFIL $NEW_INFIL
                     chown $dbOwner:$dbGroup $NEW_INFIL

	             su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" >/dev/null 2>&1 <<EOF
	             set head off
	             set lines 80
	             set feedback off
                     set timing off
	             set serveroutput on
	             spool $NEW_OUTFIL
	             @@$NEW_INFIL
	             spool off
	             exit
EOF
"
		     move_files "$NEW_OUTFIL" "$OUTFIL"
		     write_del_rolbk_errlog
		     write_del_rolbk_tmpoutput

		     cd $OLD_DIR
	             unset OLD_DIR
		   else
	             #$READ -p "came here for SQL_COLLECT RDBMS without issysdba"
	             $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
	             set head off
	             set lines 80
	             set feedback off
                     set timing off
	             set serveroutput on
	             spool $OUTFIL
	             @@$INFIL
	             spool off
	             exit
EOF
		   fi
		 else #remote_database_code
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
		     TMP_SQLTORUN=$TMP_OUTPUT/sqltorun.sql
		     #get_dbOwner

	             chg_files_for_usr "TMP_SPOOLFIL,TMP_SQLTORUN" "$TMP_SPOOLFIL,$TMP_SQLTORUN"
	             #chg_files_for_usr "TMP_SPOOLFIL" "$TMP_SPOOLFIL"

		     cp -f $INFIL $NEW_INFIL
		     $SCOPY $NEW_INFIL ${mb_running_host[$mb_db_counter]}:$TMP_SQLTORUN
		     $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_SQLTORUN"
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
		     export ORACLE_HOME=$ORACLE_HOME;
		     export ORACLE_SID=$ORACLE_SID;
		     su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
                     set timing off
		     set serveroutput on
		     spool $TMP_SPOOLFIL
		     @@$TMP_SQLTORUN
		     spool off
		     exit
EOF
"
EOF2
                     #REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $RTEMPDIR/sqltorun.sql>/dev/null 2>&1;echo \$?;"`
		     #security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql" "$REM_RC"
                     REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_SQLTORUN>/dev/null 2>&1;echo \\$?;"`
		     security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_SQLTORUN" "$REM_RC"
		     write_del_rolbk_tmpoutput

		     cd $OLD_DIR
		     unset OLD_DIR
		   else
		     TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
		     $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
		     export ORACLE_HOME=$ORACLE_HOME;
		     export ORACLE_SID=$ORACLE_SID;
		     $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
                     set timing off
		     set serveroutput on
		     spool $TMP_SPOOLFIL
		     @@$RTEMPDIR/sqltorun.sql
		     spool off
		     exit
EOF
EOF2
		   fi
		   $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SPOOLFIL $RTEMPDIR
		   cat $RTEMPDIR/sqltorun.out > $OUTFIL
                   REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $RTEMPDIR/sqltorun.sql>/dev/null 2>&1;echo \\$?;"`
		   security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql" "$REM_RC"
		 fi
	       else
		 #$ORACLE_HOME/bin/sqlplus -s / as sysdba
	         #$READ -p "came here for SQL_COLLECT RDBMS with issysdba see $OUTFIL"
	         if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
	         then
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     #get_dbOwner

	             #chg_files_for_usr "NEW_OUTFIL,ERRFIL" "$NEW_OUTFIL,$ERRFIL"

                     cp -f $INFIL $NEW_INFIL
                     chown $dbOwner:$dbGroup $NEW_INFIL

	             su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	             set head off
	             set lines 80
	             set feedback off
                     set timing off  
	             set serveroutput on
	             spool $NEW_OUTFIL
	             @@$NEW_INFIL
	             spool off
	             exit
EOF
"
		     move_files "$NEW_OUTFIL" "$OUTFIL"
		     write_del_rolbk_errlog
		     write_del_rolbk_tmpoutput

		     cd $OLD_DIR
	             unset OLD_DIR
		   else
	             $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	             set head off
	             set lines 80
	             set feedback off
                     set timing off  
	             set serveroutput on
	             spool $OUTFIL
	             @@$INFIL
	             spool off
	             exit
EOF
		   fi
		 else #remote_database_code
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
		     TMP_SQLTORUN=$TMP_OUTPUT/sqltorun.sql
		     #get_dbOwner

	             #chg_files_for_usr "TMP_SPOOLFIL" "$TMP_SPOOLFIL"
	             chg_files_for_usr "TMP_SPOOLFIL,TMP_SQLTORUN" "$TMP_SPOOLFIL,$TMP_SQLTORUN"

                     cp -f $INFIL $NEW_INFIL

		     $SCOPY $NEW_INFIL ${mb_running_host[$mb_db_counter]}:$TMP_SQLTORUN
		     $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_SQLTORUN"
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
	             export ORACLE_HOME=$ORACLE_HOME;
		     export ORACLE_SID=$ORACLE_SID;
		     su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
                     set timing off
		     set serveroutput on
		     spool $TMP_SPOOLFIL
		     @@$TMP_SQLTORUN
		     spool off
		     exit
EOF
"
EOF2
                     #REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_OUTPUT/sqltorun.sql>/dev/null 2>&1;echo \$?;"`
		     #security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql" "$REM_RC"
                     REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_SQLTORUN>/dev/null 2>&1;echo \\$?;"`
		     security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_SQLTORUN" "$REM_RC"
		     write_del_rolbk_tmpoutput

		     cd $OLD_DIR
	    	     unset OLD_DIR
		   else
		     TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
		     $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
	             export ORACLE_HOME=$ORACLE_HOME;
		     export ORACLE_SID=$ORACLE_SID;
		     $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
                     set timing off
		     set serveroutput on
		     spool $RTEMPDIR/sqltorun.out
		     @@$RTEMPDIR/sqltorun.sql
		     spool off
		     exit
EOF
EOF2
                     REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $RTEMPDIR/sqltorun.sql>/dev/null 2>&1;echo \\$?;"`
		     security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql" "$REM_RC"
		   fi
		   $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SPOOLFIL $RTEMPDIR
		   cat $RTEMPDIR/sqltorun.out > $OUTFIL
		   rm -f $RTEMPDIR/sqltorun.out >/dev/null 2>&1;
		 fi
	       fi
    	       security_fix "check_and_fix_script_existence" "$NEW_INFIL"

	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $ORACLE_SID] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	     fi
	     #if [ $OFFLINE -eq "0" ]; then 
  	     #  get_current_epoch 
	     #  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	     #fi
           fi
	 fi
	 #log_pass
     fi
     ;;
  OS_PACKAGE)
     #OS PAckages are a special case
     #what we want to know is if the package is installed
     #is the package that is installed a bad version of the package?
     #if the package is installed and it's not a bad version then => PASS
     #if the package that is installed is bad then => WARN/FAIL
     #$READ -p "RPM status $rpm_status"
  
     if [ $SILENT -eq 0 ]
     then
       echo "ROW=$ROW" >>$LOGFIL
       echo "RPM Checked.recommended rpm is $PARAM_PATH and actual found on system is $actual" and rpm status=$rpm_status>>$LOGFIL
       PARAM_PATH_PASS=""
       if [ -n "${rpm_arr1}" ]
       then
         for array_item in ${rpm_arr1[*]}
         do
           #if [ $element_count -ne 3 ] && [ -n "$array_item" ]
           if [ -n "$array_item" ]
           then
             if [ -z "$PARAM_PATH_PASS" ]
             then
               PARAM_PATH_PASS=$array_item
             else
               PARAM_PATH_PASS=$(echo $PARAM_PATH_PASS"-"$array_item)
             fi
           fi
           element_count=$(expr $element_count + 1)
         done 
       else
         PARAM_PATH_PASS=$(echo $PARAM_PATH|sed 's/|/-/g')
         PARAM_PATH_PASS=$(echo $PARAM_PATH_PASS|sed 's/--/-/g')
       fi
       element_count=0
       ACTUAL_PASS=""
       if [ -n "${rpm_arr2}" ]
       then
         for array_item in ${rpm_arr2[*]}
         do
           #if [ $element_count -ne 3 ] && [ -n "$array_item" ]
           if [ -n "$array_item" ]
           then
             if [ -z "$ACTUAL_PASS" ]
             then
               ACTUAL_PASS=$array_item
             else
               ACTUAL_PASS=$(echo $ACTUAL_PASS"-"$array_item)
             fi
           fi
           element_count=$(expr $element_count + 1)
         done 
       else
         ACTUAL_PASS=$(echo $actual|sed 's/|/-/g')
         ACTUAL_PASS=$(echo $ACTUAL_PASS|sed 's/--/-/g')
       fi
       element_count=0
       if [ $RAT_DEBUG -eq 1 ]
       then
         if [ $rpm_status -eq 0 ] 
         then
           OPSTAT=1
           if [ $rpm_arch -ne 99 ]
           then
             echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
           fi     
           if [ -z "$PMSG" ]; then  PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $rpm_status -eq 1 ]
         then
           OPSTAT=1
           if [ $rpm_arch -ne 99 ]
           then
             echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
           fi     
           if [ -z "$PMSG" ]; then  PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $rpm_status -eq 2 ]
         then
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="Package $ACTUAL_PASS does not meet recommendation for $PARAM_PATH_PASS ";fi
           echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
           log_fail
           if [ -z "$ALVL" ]; then ALVL="WARNING";fi
         elif [ $rpm_status -eq 3 ]
         then
           OPSTAT=0
           if [ -z "$ALVL" ]; then ALVL="FAIL";fi
           if [ -z "$FMSG" ]; then FMSG="Package $PARAM_PATH_PASS is recommended but NOT installed";fi
           echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
           log_fail
         fi
       else
         if [ $rpm_status -eq 0 ] 
         then
           OPSTAT=1
           if [ $rpm_arch -ne 99 ]
           then
              echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
           fi     
           if [ -z "$PMSG" ]; then  PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $rpm_status -eq 1 ]
         then
           OPSTAT=1
           if [ $rpm_arch -ne 99 ]
           then
              echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
           fi     
           if [ -z "$PMSG" ]; then  PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation";fi
           ALVL="PASS"
           log_pass
         elif [ $rpm_status -eq  2 ]
         then
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="Package $ACTUAL_PASS does not meet recommendation for $PARAM_PATH_PASS ";fi
           echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
           log_fail
           if [ -z "$ALVL" ]; then ALVL="WARNING";fi
         elif [ $rpm_status -eq 3 ]
         then
           OPSTAT=0
           if [ -z "$ALVL" ]; then ALVL="FAIL";fi
           if [ -z "$FMSG" ]; then FMSG="Package $PARAM_PATH_PASS is recommended but NOT installed";fi
           echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
           log_fail
         fi 
       fi 
       if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
       if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]] && [ $write_info_actual_files -eq 1 ]
       then
         echo "${CHECK_ID}|${rpm_status}@$PARAM_PATH_PASS" >>$OSACTUAL
       elif [ $OFFLINE -eq 0 ] && [ $write_info_actual_files -eq 1 ]
       then
         echo "${CHECK_ID}|${rpm_status}@$actual" >>$OSACTUAL
       fi
       #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
       if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

       if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
       then
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
         if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	 status_message=$(echo "$status_message" | sed "s/'//g")

	 if [[ $insert_stmt_printed -eq 0 ]]; then
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$PARAM_PATH_PASS','$PARAM_PATH_PASS','$ALVL_MB','$status_message','$PARAM_PATH_PASS','$ACTUAL_PASS','NA','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	 fi
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$PARAM_PATH_PASS','$PARAM_PATH_PASS','$ALVL_MB','$status_message','$PARAM_PATH_PASS','$ACTUAL_PASS','NA','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
       fi
     else
       #commented below code and above if condition not to generate silent files because i did not find these files being used anywhere else
       #code to generate os check result file in slent mode
       #ACREPCOUNT=`expr $ACREPCOUNT + 1`
       echo  "RPM check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@$ALVL=>$FMSG@$rpm_status@$rpm_arch">>$OSPKGSILENT
     fi
     ;;
   OS_PATCH)
     if [ $SILENT -eq 0 ] 
     then
       if [ $RAT_DEBUG -eq 1 ]
       then
         if [ $os_patch_status -eq 1 ]
         then
           #ALVL="PASS"
           OPSTAT=1
           if [ -z "$PMSG" ]; then PMSG="OS Patch $PARAM_PATH meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $os_patch_status -eq 2 ]
         then
           #ALVL="WARNING"
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="OS Patch $PARAM_PATH does not satisfy recommendation";fi
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           if [ -z "$ALVL" ]; then ALVL="WARNING";fi
           log_fail
         else
           #ALVL="FAIL"
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="OS Patch $PARAM_PATH is recommended but not installed";fi
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           if [ -z "$ALVL" ]; then ALVL="FAIL";fi
           log_fail
         fi 
       else   
         if [ $os_patch_status -eq 1 2>>$ERRFIL ]
         then
           #ALVL="PASS"
           OPSTAT=1
           if [ -z "$PMSG" ]; then PMSG="OS Patch $PARAM_PATH meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $os_patch_status -eq 2 2>>$ERRFIL ]
         then
           #ALVL="WARNING"
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="OS Patch $PARAM_PATH does not satisfy recommendation";fi
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           if [ -z "$ALVL" ]; then ALVL="WARNING";fi 
           log_fail
         else
           #ALVL="FAIL"
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="OS Patch $PARAM_PATH is recommended but not installed";fi
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           if [ -z "$ALVL" ]; then ALVL="FAIL";fi   
           log_fail
         fi 
       fi
       #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
       if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

       if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
       then
         #echo "${CHECK_ID}|${os_patch_status}@$os_patch_rls_actual" >>$OSACTUAL  
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
         if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	 status_message=$(echo "$status_message" | sed "s/'//g")

	 if [[ $insert_stmt_printed -eq 0 ]]; then
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'NA','$PARAM_PATH','$ALVL_MB','$status_message','$os_patch_rls_actual','$PARAM_PASS','NA','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	 fi
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'NA','$PARAM_PATH','$ALVL_MB','$status_message','$os_patch_rls_actual','$PARAM_PASS','NA','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
       fi
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       echo "$CHECK_ID|$os_patch_status">>$OSACTUAL
     elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       echo "$CHECK_ID|$os_patch_status">>$OSACTUAL
     fi
     ;;
  SQL|SQL_OUT_CHECK)
     if [ $SILENT -eq "0"  ]
     then
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP">>$LOGFIL
       #$READ -p  "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP alert level=$ALVL"
       #if [ $COMTYPE = "SQL_OUT_CHECK" ]
       #then
       #$READ -p "Press any key"    
       #$READ -p "rdbms status = ${stack_dbinst_up[$stack_counter]} and asm status =${stack_asm_up[$stack_counter]} and needs running=$NEEDS_RUNNING comtype=$COMTYPE" 
       #fi
       if [[ $i = $localnode &&  ${stack_dbinst_up[$stack_counter]} -ge ${database_mode} && $NEEDS_RUNNING = "RDBMS" && $RAT_RUNMODE_INTERNAL = "master" ]]
       #if [[ $i = $localnode &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS"  ]]
       #if [[ $i = ${mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS"  ]]
       then
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ] #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             #if [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -lt 1 ]]
             if [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -lt 1 ]] || [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -eq "1" && `cat $SOURCEFIL_REPORT|sed '/^$/d'|grep -ic 'TO REVIEW COLLECTED DATA'` -gt "0" ]];
             then
               echo -e "\nQuery returned no rows which is expected when the SQL check passes.\n">>$SOURCEFIL_REPORT
             fi
             log_pass
           else
             OPSTAT=0
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ] 2>>$ERRFIL
           then
             OPSTAT=1
             #if [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -lt 1 ]]
             if [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -lt 1 ]] || [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -eq "1" && `cat $SOURCEFIL_REPORT|sed '/^$/d'|grep -ic 'TO REVIEW COLLECTED DATA'` -gt "0" ]];
             then
               echo -e "\nQuery returned no rows which is expected when the SQL check passes.\n">>$SOURCEFIL_REPORT
               #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             fi 
             log_pass
           else
             OPSTAT=0
             log_fail
           fi
         fi 
         #$READ -p "ALVL=$ALVL and ALVL_MB=$ALVL_MB"
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
	 then
           #echo "$CHECK_ID|$VAL">>$DBACTUAL
	   if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
           #$READ -p "ALVL=$ALVL and ALVL_MB=$ALVL_MB"
	   #$READ -p "ALVL=$ALVL status_message=$status_message"

	   status_message=$(echo "$status_message" | sed "s/'//g")

	   if [[ $insert_stmt_printed -eq 0 ]]; then
  	     echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
	   echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
	 fi
       elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]]
       then
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ] #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ] 2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             log_fail
           fi
         fi
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
	 then
           #echo "$CHECK_ID|$VAL">>$AACTUAL
	   if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	   #$READ -p "ALVL=$ALVL status_message=$status_message"

	   status_message=$(echo "$status_message" | sed "s/'//g")

	   if [[ $insert_stmt_printed -eq 0 ]]; then
	     echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
	   echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
	 fi
       fi 
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to 
       #true so that we traverse the entire tree and so we do not miss 
       #collecting any data for any branch or step
       #
       # so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
       OPSTAT=1
       log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       #if [[ $i = $mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
       if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
       then 
         echo "$CHECK_ID|$VAL">>$DBACTUAL
       elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]] 
       then  
         echo "$CHECK_ID|$VAL">>$AACTUAL
       fi
     elif [[ $OFFLINE -eq 0 &&  $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       #if [[ $i = ${mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
       if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
       then 
         echo "$CHECK_ID|$VAL">>$DBACTUAL
       elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]] 
       then 
         echo "$CHECK_ID|$VAL">>$AACTUAL
       fi
     fi
     #if [ $COMTYPE = "SQL_OUT_CHECK" ]
     #then
     #  $READ -p "Press any key"    
     #  $READ -p " after execute rdbms status = ${stack_dbinst_up[$stack_counter]} and asm status =${stack_asm_up[$stack_counter]} and needs running=$NEEDS_RUNNING comtype=$COMTYPE" 
     #fi
     ;;
  SQL_PARAM)
     if [ $SILENT -eq "0"  ]
     then
       #echo "$VAL $OP $COMP at $ROW"
       #$READ -p "Press any key"
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP SOURCEFILENAME=$SOURCEFILENAME">>$LOGFIL
       #$READ -p "Insance status= ${stack_dbinst_up[$stack_counter]} and stack counter is $stack_counter"
       #$READ -p "${stack_dbinst_name[$stack_counter]}.${PARAM_PATH} compare=$COMP and $FMSG"
       if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       #if [[ ${stack_dbinst_up[$stack_counter]} -ne 0 || ${stack_asm_up[$stack_counter]} -eq 1 ]]
       then
         VAL=$(echo $VAL|tr "[a-z]" "[A-Z]") 
         COMP=$(echo $COMP|tr "[a-z]" "[A-Z]")
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ]  2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         fi
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
         then
           #echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
           if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	   status_message=$(echo "$status_message" | sed "s/'//g")

	   if [[ $insert_stmt_printed -eq 0 ]]; then
             echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
         fi
       elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
       then
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ]  2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         fi
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
         then
	   #echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
	   if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	   status_message=$(echo "$status_message" | sed "s/'//g")

	   if [[ $insert_stmt_printed -eq 0 ]]; then
	     echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','ASM on $i','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
	   echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','ASM on $i','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
         fi
       elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ]  2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         fi
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
         then 
           #echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
           if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	   status_message=$(echo "$status_message" | sed "s/'//g")

	   if [[ $insert_stmt_printed -eq 0 ]]; then
             echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
         fi
       fi
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to
       #true so that we traverse the entire tree and so we do not miss
       #collecting any data for any branch or step
       #
       #so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
       OPSTAT=1
       log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then 
         echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL;
       elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 && -e $SOURCEFIL ]]
       then 
         echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
       elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
         echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
       fi;
     elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
         echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL;
       elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 && -e $SOURCEFIL ]]
       then
         echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
       elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
         echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
       fi
     fi
     ;;
  CLUSTERWIDE_CHECK)
     #if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]]
     #then
     #    echo "$CHECK_ID|$CRS_VAL">>$CCACTUAL
     #elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]]
     #then
     #    echo "$CHECK_ID|$CRS_VAL">>$CCACTUAL
     #fi   
     if [[ -n "$cross_node_get_log_result_call" && $cross_node_get_log_result_call -eq 1 ]]
     then 
       if [ $RAT_DEBUG -eq 1 ]
       then
         if [ "$VAL" "$OP" "$COMP" ]; then CRS_VAL=1; else CRS_VAL=0;fi
       else
         if [ "${VAL}1" "$OP" "${COMP}1" ] 2>>$ERRFIL; then CRS_VAL=1; else CRS_VAL=0;fi
       fi 
     fi
     if [[ -n $CRS_VAL && $CRS_VAL -eq 1 ]]
     then
       #$READ -p  "cls_check_val1=$cls_check_val1 and cls_check_val2=$cls_check_val2 and CRS_VAL=$CRS_VAL $ROW $PMSG $FMSG $audit_check_name $COMTYPE"
       #$READ -p "COMTYPE=$COMTYPE"
       OPSTAT=1
       log_pass
       #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
       if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

       if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
       then
         #echo "$CHECK_ID|$VAL">>$CCACTUAL
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
         if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	
	 status_message=$(echo "$status_message" | sed "s/'//g")

	 if [[ $insert_stmt_printed -eq 0 ]]; then
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	 else
	   cellname_counter=0
	   for cellname in ${a_cellname[@]}
	   do
	     target=$cellname
	     ACT_TARGET=$cellname
 	     ALVL_MB=${a_cellCheckStatus[$cellname_counter]}
             echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
 	     cellname_counter=$(expr $cellname_counter + 1 ) 
	   done
	 fi
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
       fi
     elif [[ -n $CRS_VAL && $CRS_VAL -eq 0 ]]
     then
       OPSTAT=0
       log_fail
       #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
       if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

       if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
       then
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
         if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	 status_message=$(echo "$status_message" | sed "s/'//g")

	 if [[ $insert_stmt_printed -eq 0 ]]; then
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	 else
	   cellname_counter=0
	   for cellname in ${a_cellname[@]}
	   do
	     target=$cellname
	     ACT_TARGET=$cellname
 	     ALVL_MB=${a_cellCheckStatus[$cellname_counter]}
             echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
 	     cellname_counter=$(expr $cellname_counter + 1 ) 
	   done
	 fi
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
       fi
     fi   
     ;;
  *)
     #$READ -p "Press any key in get log result" 
     #We only want to do this comparison if we're NOT in SILENT mode
     #in SILENT mode we will not have a comparison operator or comparison value
     
     if [ $SILENT -eq "0"  ]
     then
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value =$COMP execute once=$execute_once ">>$LOGFIL
       #echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value =$COMP execute once=$execute_once "
       #$READ -p "Press any key"     
       #echo "VAL=%%%$VAL%%%%"
       if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
       then
         execute_once_exec=0
       elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
       then
         execute_once_exce=0
       elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
       then
         execute_once_exec=0
       else
	 #if [ `echo $COM|grep -ic copy_collect_file` -ge 1 ]
	 #then
	 #    copy_collect_file_name=$(echo $COM >/dev/null|cut -d= -f2|cut -d; -f1)
	 #    cp -f ${OUTPUTDIR}/${copy_collect_file_name} .
         #    $READ -p "see file $copy_collect_file_name"
	 #fi
         execute_once_exec=1
         if [ $RAT_DEBUG -eq 1 ] 
         then
           if [ "$VAL" "$OP" "$COMP" ] # 2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             log_fail
             if [ "$COMTYPE" = "OS_PARAM" ]; then echo "OS(kernel) parameter $PARAM_PATH failed for node $i">>$CWOSPARAM;fi;
           fi 
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ]  2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             log_fail
             if [ "$COMTYPE" = "OS_PARAM" ]; then echo "OS(kernel) parameter $PARAM_PATH failed for node $i">>$CWOSPARAM;fi;
           fi 
         fi
         #if [[ -n  "$os_check_needs_collect_file" && $os_check_needs_collect_file -eq 1 ]]; then rm -f $VAL_FIL;os_check_needs_collect_file=0; unset VAL_DIR VAL_FIL ;fi;
         #if [[ `echo $COM|grep -ic copy_collect_file` -ge 1 && -f $copy_collect_file_name ]]; then rm -f $copy_collect_file_name;fi;
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
	 then
           #if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
           #then
           #    echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
           #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
           #then
           #    echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
           #else
           #    echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
           #fi
	   if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
           if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	   status_message=$(echo "$status_message" | sed "s/'//g")

	   if [[ $insert_stmt_printed -eq 0 ]]; then
	     echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   else
	     cellname_counter=0
	     for cellname in ${a_cellname[@]}
	     do
	       target=$cellname
	       ACT_TARGET=$cellname	       
 	       ALVL_MB=${a_cellCheckStatus[$cellname_counter]}
               echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
 	       cellname_counter=$(expr $cellname_counter + 1 ) 
	     done
	   fi
	   echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','$db_global_name','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
	 fi
       fi
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to 
       #true so that we traverse the entire tree and so we do not miss 
       #collecting any data for any branch or step
       #
       #so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
       OPSTAT=1
       log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
     then
       echo "" >/dev/null 2>&1 
     elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
     then
       echo "" >/dev/null 2>&1 
     elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
     then
       echo "" >/dev/null 2>&1 
     elif [ $write_info_actual_files -eq 1 ]
     then
       if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]]  
       then
         if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
         then
           echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]   
         #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
         then
           echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
         then
           echo "${switchname}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         else
           echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
         fi
       elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]]
       then
         if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
         then
           echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]   
         #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
         then
           echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] || [[ $NEEDS_RUNNING = "TOR_SWITCH" && -n "$RAT_TORSWITCHES" ]]
         then
           echo "${switchname}|${CHECK_ID}|${VAL}" >>$OSACTUAL    
         else
           echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
         fi
       fi
     fi
     ;;
  esac
  ;;  
  esac
 
  if [[ -n "$cmd_type" && $cmd_type = "inloop" && $mb_db_counter_log -eq "0" ]]
  then
    m_opstat[$CUR_LEVEL]=""
  fi

  if [[ -n "$cmd_type" && $cmd_type = "inloop" && $OPSTAT -eq "1" ]]
  then # Load all succeeded target names into array
    #l_mb_db_homes is already set in set_skip_this_version
    if [ $cmd_value = "switch" ] ; then
      #echo "Pass on ${m_opstat[$CUR_LEVEL]},$switchname"
      m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},$switchname";
    else
      m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},$l_mb_db_homes-$l_mb_db_home_dname";
    fi
  elif [[  -n "$cmd_type" && $cmd_type = "inloop" && $OPSTAT -eq "0" ]]
  then
    m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},failedontarget"
  elif [[ -z "$cmd_type" && $OPSTAT -eq "1" ]] ; then
    m_opstat[$CUR_LEVEL]="passed_on_all_targets";
  elif [[ -z "$cmd_type" && $OPSTAT -eq "0" ]] ; then
    m_opstat[$CUR_LEVEL]="failedontarget"
  fi;

  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch 
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:get_log_result End Time: $epoch_time" >> $CHK_TIMINGS
  fi
}

check_patch ()
{
  #if [ `$CRS/bin/olsnodes |wc -l` -gt 4 ]
  if [ `cat $HOSTLIST|wc -l` -gt 999 ] 
  then
    if [ "$1" = "crs" ]
    then
      APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $CRS_INVENTORY`
    elif [ "$1" = "rdbms" ]
    then
      APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $RDBMS_INVENTORY`
    elif [ "$1" = "asm" ]
    then
      APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $ASM_INVENTORY`
    fi
  else
    if [ $OFFLINE -eq 0 ]
    then
      if [[ "$1" = "rdbms" ]]
      then 
        APPLIED=`grep -c $2 ${OUTPUTDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out`
        if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${OUTPUTDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out" "$2" "$1";fi
        #$READ -p " ${OUTPUTDIR}/o_${1}_inventory_${i}_${mb_db_homes_fil}.out"
      else 
        APPLIED=`grep -c $2 ${OUTPUTDIR}/o_${1}_inventory_${i}.out`
        if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${OUTPUTDIR}/o_${1}_inventory_${i}.out" "$2" "$1";fi
      fi
    else
      if [[ "$1" = "rdbms" ]]
      then
        APPLIED=`grep -c $2 ${DUMPDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out`
        if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${DUMPDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out" "$2" "$1";fi
        #$READ -p " ${OUTPUTDIR}/o_${1}_inventory_${i}_${mb_db_homes_fil}.out"
      else
        APPLIED=`grep -c $2 ${DUMPDIR}/o_${1}_inventory_${i}.out`
        if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${DUMPDIR}/o_${1}_inventory_${i}.out" "$2" "$1";fi
      fi
    fi
  fi
  #$READ -p "stop for higher_patch"
  return $APPLIED
}

check_higher_patch ()
{
  if [ "$3" = "rdbms" ]
  then 
    #applied_patches=$(cat $1|grep  ^"Patch description"|grep -i database|awk '{print $NF}'|sed 's/[^0-9]*//g')
    applied_patches=$(grep  ^"Patch description" $1|grep -i database|awk '{print $NF}'|sed 's/[^0-9]*//g')
  else
    #applied_patches=$(cat $1|grep  ^"Patch description"|grep -iv database|awk '{print $NF}'|sed 's/[^0-9]*//g')
    applied_patches=$(grep  ^"Patch description" $1|grep -iv database|awk '{print $NF}'|sed 's/[^0-9]*//g')
  fi
  #applied_patches="14727309 14727318 14727329 14727349"
  if [[ -e $1 && -n "$applied_patches" ]]
  then
    for applied_patch in $applied_patches
    do
      if [ "$applied_patch" -gt $2 ]
      then
        APPLIED=1
        PATCH=$applied_patch
        #SUBJ=$(cat $1|grep -iw $PATCH|grep -iw "description")
        SUBJ=$(grep -iw $PATCH $1|grep -iw "description")
        break
      else
        APPLIED=0
      fi
   done
  fi
}

checksysdba ()
{
  if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
  then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner

      chg_files_for_usr "ERRFIL" "$ERRFIL"

      IS_SYSDBA=$(su $dbOwner -c "echo \"select 1 from dual;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba 2>>$ERRFIL"|grep -v ^$) 
      write_del_rolbk_errlog
      write_del_rolbk_tmpoutput

      cd $OLD_DIR
      unset OLD_DIR
    else
      IS_SYSDBA=$(echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba 2>>$ERRFIL|grep -v ^$) 
    fi
  else #remote_database_code
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner "${mb_running_host[$mb_db_counter]}"

      IS_SYSDBA=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
      export ORACLE_HOME=$ORACLE_HOME ; \
      export ORACLE_SID=$ORACLE_SID; \
      cd "$dbhome_dir"; \
      su $dbOwner -c "$bash_scr -c \"echo \\\\\\"select 1 from dual;\\\\\\" | $ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$\""
EOF
)
      write_del_rolbk_tmpoutput
      cd $OLD_DIR
      unset OLD_DIR
    else
      IS_SYSDBA=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
      export ORACLE_HOME=$ORACLE_HOME ; \
      export ORACLE_SID=$ORACLE_SID; \
      echo "select 1 from dual;" | $ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^$
EOF
)
    fi
  fi
  echo "Value back from Database is  $IS_SYSDBA">>$LOGFIL
  if [ `echo $IS_SYSDBA|grep -c "ORA-"` -ge 1 ]
  then
    IS_SYSDBA=0
  else
    IS_SYSDBA=1
  fi
  echo -e "\nValue set to IS_SYSDBA for $db_name_to_check = ${IS_SYSDBA}\n\n">>$LOGFIL
}

checkpassword ()
{
  if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
  then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      is_password_correct=$(su $dbOwner -c "echo \"select 1 from dual;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba" | grep -v ^$)
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      write_del_rolbk_tmpoutput
      cd $OLD_DIR
      unset OLD_DIR
    else
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      is_password_correct=$(echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^$)
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    fi
  else #remote_database_code
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      is_password_correct=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
      cd "$dbhome_dir"; 
      export ORACLE_HOME=$ORACLE_HOME
      export ORACLE_SID=$ORACLE_SID; \
      su $dbOwner -c "echo \"select 1 from dual;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba"
EOF
)
      is_password_correct=$(echo "$is_password_correct"|grep -v ^$)
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      write_del_rolbk_tmpoutput
      cd $OLD_DIR
      unset OLD_DIR
    else
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      is_password_correct=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
      export ORACLE_HOME=$ORACLE_HOME
      export ORACLE_SID=$ORACLE_SID; \
      echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^$
EOF
)
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    fi
  fi
  if [[ -n "$is_password_correct" && `echo $is_password_correct|grep -c "ORA-"` -ge 1 ]]
  then
    echo -e "\n${is_password_correct}\n"
    WRNDBPWD=`expr $WRNDBPWD + 1`
    if [ $WRNDBPWD -lt 3 ]; 
    then
      nosysdba
    else    
      unset mb_db_names[$mb_db_counter] 
      echo -e "${RED}\n\n$DBUSR is not able to login as sysdba to ${db_name_to_check}.Make sure password file is available on ${mb_running_host[$mb_db_counter]} and you are using password file password to login as sysdba.\nYou can cancel (ctrl+c) this run,configure password file and run it again. Otherwise best practice checks for $db_name_to_check database will be skipped.\n\n"${NORM}|tee -a $LOGFIL
      echo -e "$is_password_correct">>$LOGFIL 
      #removing database from list becauase password did not work
    fi
  fi
}

checkdictionary ()
{
  if [ $IS_SYSDBA -eq 0 ]
  then
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner
        IS_DICTIONARY=$(su $dbOwner -c "echo \"select name from v\\\$database;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba" |grep -v ^$)     
	write_del_rolbk_tmpoutput
	cd $OLD_DIR
	unset OLD_DIR
      else
        IS_DICTIONARY=$(echo "select name from v\$database;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba |grep -v ^$)     
      fi
    else #remote_database_code
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner
        IS_DICTIONARY=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
	cd "$dbhome_dir";
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
        su $dbOwner -c "echo \"select name from v\\\\\\$database;\" | $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba"
EOF
)
	IS_DICTIONARY=$(echo "$IS_DICTIONARY"|grep -v ^$)
	write_del_rolbk_tmpoutput
	cd $OLD_DIR
	unset OLD_DIR
      else
        IS_DICTIONARY=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
        echo "select name from v\\\$database;" | $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba|grep -v ^$
EOF
)
      fi
    fi
  fi
  #echo "checkdictionary IS_DICTIONARY=$IS_DICTIONARY";

  if [ `echo $IS_DICTIONARY|grep -c "ORA-00942"` -ge 1 ]
  then
    IS_DICTIONARY=0
  else
    IS_DICTIONARY=1
  fi
}

nosysdba ()
{
  if [ $WRNDBPWD -gt 0 ]
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]; then return; fi

    exec 3<&2; exec 2<&0 
    $READ -p "Enter user name again for $db_name_to_check:- " DBUSR
    exec 2<&3
    printf  "Enter password for $DBUSR@$db_name_to_check:- " 
    tty -s && stty -echo
    $READ DBPWD
    read_code=`echo $?`;
    tty -s && stty echo
    if [[ $read_code -eq 1 ]]; then return; fi

    if [ `echo $DBUSR|wc -w` -gt 1 ]; then DBUSR=`echo $DBUSR|awk '{print $1}'`; fi
    checkpassword
  else
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="MULTIPART_QUESTION" defaultId="" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n5_nlsid">
      OS authentication is not enabled. Enter sysdba privileged user's credential for {1} 
    </text>
    <tokens>
      <token index="1">$db_name_to_check</token>
    </tokens>
    </tokenizedtext>
    <multipart-question>
      <question id="q${PROBE_QUES_CNT}q1" questionType="TEXT" defaultId="" outcome="No"> 
	<text nls_id="orhc_exadata_n6_nlsid">User Name</text>
      </question>
      <question id="q${PROBE_QUES_CNT}q2" questionType="SECRET" defaultId="" outcome="No"> 
	<text nls_id="orhc_exadata_n80_nlsid">Password</text>
      </question>
    </multipart-question>
  </question>
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

      echo -e "\n"
      echo -e "OS authentication is not enabled so please enter sysdba privileged user name for $db_name_to_check:- "
      printf  "Enter password for $DBUSR@$db_name_to_check:- " 
    elif [[ $EM_XMLD_MODE -eq 1 ]]
    then
      echo "OS authentication is not enabled so please enter sysdba privileged user name for $db_name_to_check:- "
      read_probe_xml "<token index=\"1\">$db_name_to_check</token>" 
      DBUSR=$xml_rvalue

      printf  "Enter password for $DBUSR@$db_name_to_check:- "
      read_probe_xml "<token index=\"2\">$db_name_to_check</token>" 
      DBPWD=$xml_rvalue
    else
      #$READ -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID"
      echo -e "\n"
      exec 3<&2; exec 2<&0
      $READ -p "OS authentication is not enabled so please enter sysdba privileged user name for $db_name_to_check:- " DBUSR
      exec 2<&3
      printf  "Enter password for $DBUSR@$db_name_to_check:- " 
      tty -s && stty -echo
      $READ DBPWD
      read_code=`echo $?`;
      tty -s && stty echo
      if [[ $read_code -eq 1 ]]; then return; fi

      if [ `echo $DBUSR|wc -w` -gt 1 ]; then DBUSR=`echo $DBUSR|awk '{print $1}'`; fi
      checkpassword
    fi
  fi
  #If user enter sys as sysdba, take only sys because script appends "as sysdba".
}

singleSqlValue ()
{
  colname=`echo $1 |tr 'a-z' 'A-Z'` 
  if [[ ${#mb_checksysdba[@]} -gt 0 && ${mb_checksysdba[$mb_db_counter]} -eq 1 ]]
  then
    if [ $# -eq 3  ]
    then 
      if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

          sqlValue=$(su $dbOwner -c "echo \"set heading off feedback off timing off;
                    select '$colname = ' ||$colname from $3\$\"$2\";\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba" | grep -v ^\$ | tail -1)
	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
	  unset OLD_DIR
	else
          sqlValue=$( echo "set heading off feedback off timing off;
                    select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$|tail -1)
	fi
      else #remote_database_code
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner "${mb_running_host[$mb_db_counter]}"

          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
	  cd "$dbhome_dir"; \
          su $dbOwner -c "echo \"set heading off feedback off timing off;
                    select '$colname = ' ||$colname from $3\$\"$2\";\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba"
EOF
)
	  sqlValue=$(echo "$sqlValue"|grep -v ^$|tail -1)
	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
	  unset OLD_DIR
	else
          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
          echo "set heading off feedback off timing off;
                    select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$|tail -1
EOF
)
	fi
      fi
    else
      if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

          sqlValue=$(su $dbOwner -c "echo \"set heading off feedback off timing off;
               select '$colname = '||$colname from $2;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba" | grep -v ^\$ | tail -1)
	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
	  unset OLD_DIR
	else
          sqlValue=$( echo "set heading off feedback off timing off;
               select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^\$|tail -1)
	fi
      else #remote_database_code
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner "${mb_running_host[$mb_db_counter]}"

          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
	  cd "$dbhome_dir"; \
          su $dbOwner -c "echo \"set heading off feedback off timing off;
              select '$colname = '||$colname from $2;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba"
EOF
)
	  sqlValue=$(echo "$sqlValue"|grep -v ^$|tail -1)
	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
	  unset OLD_DIR
	else
          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
          echo "set heading off feedback off timing off;
              select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^\$|tail -1
EOF
)
	fi
      fi
    fi
  else
    mb_sysdba_user[$mb_db_counter]=$DBUSR
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    mb_sysdba_pswd[$mb_db_counter]=$DBPWD 
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    if [ $# -eq 3  ]
    then
      if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
      then
 	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        sqlValue=$( echo "set heading off feedback off timing off;
                     select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1)
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      else #remote_database_code
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
          echo "set heading off feedback off timing off;
               select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1
EOF
)
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
      #echo $sqlValue
      #$READ -p "press any key f"
    else
      if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
      then
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        sqlValue=$( echo "set heading off feedback off timing off;
              select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^\$|tail -1)
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      else #remote_database_code
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
          echo "set heading off feedback off timing off;
               select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1
EOF
)
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
    fi
  fi
}

multipleSqlValue ()
{
  if [[ ${#mb_checksysdba[@]} -gt 0 && ${mb_checksysdba[$mb_db_counter]} -eq 1 ]]
  then
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner

        sql_stmt=$(echo $1 | sed 's/\$/\\\$/g')

        sqlValue=$(su $dbOwner -c "echo \"set heading off feedback off timing off;
		  $sql_stmt;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba" | grep -v ^\$)
	write_del_rolbk_tmpoutput
        cd $OLD_DIR
	unset OLD_DIR
      else
        sqlValue=$( echo "set heading off feedback off timing off;
		  $1;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$)
      fi
    else #remote_database_code
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner "${mb_running_host[$mb_db_counter]}"

        sql_stmt=$(echo $1 | sed 's/\$/\\\\\\$/g')
        sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
	cd "$dbhome_dir"; \
        su $dbOwner -c "echo \"set heading off feedback off timing off;
		  $sql_stmt;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba"
EOF
 )
	sqlValue=$(echo "$sqlValue"|grep -v ^$)
	write_del_rolbk_tmpoutput
        cd $OLD_DIR
	unset OLD_DIR
      else
        sql_stmt=$(echo "$1" | sed 's/\$/\\\$/g')
        sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
        echo "set heading off feedback off timing off;
		  $sql_stmt;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$
EOF
 )
      fi
    fi
  else
    mb_sysdba_user[$mb_db_counter]=$DBUSR
    mb_sysdba_pswd[$mb_db_counter]=$DBPWD
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      sqlValue=$( echo "set heading off feedback off timing off;
      	  $1;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$)
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    else #remote_database_code
      sql_stmt=$(echo $1 | sed 's/\$/\\\\\\$/g')
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
        echo "set heading off feedback off timing off;
	    $sql_stmt;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$
EOF
)
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    fi
  fi
}

is_crs_up ()
{
  if [ $is_windows -eq "1" ] ; then
    crs_up=0
    if [ `grep -c OracleOHService $win_services` -gt "0" ] ; then
      crs_up=1
      v_crs_home_val=$(grep CRS_HOME= $windiscover | sed 's/CRS_HOME=//')
      #if [ `grep cluster_name= $v_crs_home_val/install/cluster.ini | sed 's/cluster_name=//'|wc -c` -lt 3 ] ; then
      if [[ -n "$RAT_ORACLE_RESTART" && $RAT_ORACLE_RESTART -eq "1" ]] ; then
        oracle_restart=1
        crs_version_switch="has softwareversion"
	export RAT_LEGACY_DISCOVERY=1
      fi
    fi
    return;
  fi
  check_crsd=$(ps -ef |grep -ic "crsd\.bin")
  check_crs=`ps -ef|grep -ic "d\.bin"`
  if [[ ${check_crs} -ge 4 && $check_crsd -gt 0 ]]
  then
    crs_up=1
  else
    crs_up=0
  fi
  if [[ ${check_crs} -ge 4 && -n "$check_crsd" && $check_crsd -lt 1 ]]
  then
    crs_up=1
    oracle_restart=1
    export RAT_LEGACY_DISCOVERY=1
    crs_version_switch="has softwareversion"
  else 
    oracle_restart=0
  fi
  echo "CRS_UP = $crs_up" >>$MASTERFIL
  echo "ORACLE_RESTART = $oracle_restart" >>$MASTERFIL
}

is_db_up ()
{
  somebgproc=`echo $bgproc|cut -d_ -f2`
  somebgsid=`echo $bgproc|cut -d_ -f3|cut -d' ' -f1`
  #$READ -p "$bgproc and $somebgsid somebgproc=$somebgproc"
  if [ `echo $bgproc|grep -c "ora_pmon_$ORACLE_SID"` -ge 1 ]
  then
    db_up=1
    somedb_up=1  
    somedb_up=1  
  elif [ "$somebgproc" = "pmon" ]
  then
    somedb_up=1
    db_up=0
  else
    db_up=0
    somedb_up=0
  fi
  #$READ -p "db_up=$db_up"
}

#This function is to discover environment with OMS(Oracle Management Server)
discover_OMS ()
{
  oms_discovery_scope=$1
  if [[ -n $oms_discovery_scope && $oms_discovery_scope = "localonly" ]]; then
    stack_counter=0
  else
    stack_counter=1
  fi

  for stack in `cat $HOSTLIST`
  do
    is_oms_installed=0
    is_oms_up=0
    #if [ $is_windows -eq "1" ] ; then
    #  OMS_PATTERN="LOC=.*\oms\""
    #else
    #  OMS_PATTERN="LOC=.*/oms\""
    #fi

    OMS_PATTERN="NAME=\"oms"
 
    if [ $stack = $localnode ]; then
      if [[ -e "${invntr_location[$stack_counter]}/ContentsXML/inventory.xml" && `grep '<HOME NAME=' "${invntr_location[$stack_counter]}/ContentsXML/inventory.xml"|grep -c "$OMS_PATTERN"` -gt 0 || -n $RAT_OMS_HOME ]]; then
        is_oms_installed=1
        echo $stack.OMS_INSTALLED = $is_oms_installed >>$MASTERFIL

        if [ -z $RAT_OMS_HOME ]; then
          if [ $is_windows -eq "1" ] ; then
            #OMS_HOMES=`grep '<HOME NAME=' "${invntr_location[$stack_counter]}/ContentsXML/inventory.xml"|grep "LOC=.*\oms\""|sed "s/^.*LOC=\"\(.*\oms\)\".*/\1/g"` 
	     OMS_HOMES=`grep '<HOME NAME=' "${invntr_location[$stack_counter]}/ContentsXML/inventory.xml"|grep "$OMS_PATTERN"|$AWK -F" " '{print $3}'|sed 's/\"//g'|sed 's/LOC=//'`
          else
            #OMS_HOMES=`grep '<HOME NAME=' "${invntr_location[$stack_counter]}/ContentsXML/inventory.xml"|grep "LOC=.*/oms\""|sed "s/^.*LOC=\"\(.*\/oms\)\".*/\1/g"` 
	     OMS_HOMES=`grep '<HOME NAME=' "${invntr_location[$stack_counter]}/ContentsXML/inventory.xml"|grep "$OMS_PATTERN"|$AWK -F" " '{print $3}' |sed 's/\"//g'|sed 's/LOC=//'`
          fi
        else
	  OMS_HOMES=$(echo "$RAT_OMS_HOME"|sed 's/,/ /g')
        fi
        
	ask_sys_pass=0
        for mb_oms_home in `echo "$OMS_HOMES"`
        do
	  is_oms_up=0
	  get_cygpath "mb_oms_home"
          if [[ -e $mb_oms_home ]]; then 
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
   	      get_omsOwner
	      OMS_STATUS=`su $omsOwner -c "${mb_oms_home}/bin/emctl$BAT status oms 2>/dev/null"`
	       OMS_VERSION=`su $omsOwner -c "${mb_oms_home}/bin/emctl$BAT getversion oms"`
	      write_del_rolbk_tmpoutput
	      cd $OLD_DIR
	      unset OLD_DIR	      
            else
              OMS_STATUS=`${mb_oms_home}/bin/emctl$BAT status oms 2>/dev/null`
  	      OMS_VERSION=`${mb_oms_home}/bin/emctl$BAT getversion oms`
	    fi

	    omsv=`echo $OMS_VERSION|grep "OMS Version"|$AWK -F" " '{print$NF}'|sed 's/ //g'`

	    if [[ -n "$omsv" ]]
            then
              OMS_VERSION=$omsv
            else
	      if [ `echo $OMS_VERSION|grep -ic "13c Release 1"` -gt "0"  ]
	      then
                OMS_VERSION="13.1.0.0.0"
	      fi
            fi

            if [[ `echo "$OMS_STATUS"|grep -ic "WebTier is Up"` -gt "0" && `echo "$OMS_STATUS"|grep -ic "Oracle Management Server is Up"` -gt "0" ]]; then
              is_oms_up=1
	      ask_sys_pass=1
            fi
    	    echo ${stack}:${mb_oms_home}:OMS_UP = $is_oms_up >>$MASTERFIL
	    echo ${stack}:${mb_oms_home}:OMS_VERSION = $OMS_VERSION >>$MASTERFIL
          fi
	  restore_cygpath "mb_oms_home"
        done
    
	if [[ -n "$run_profile" && $run_profile -eq "1" ]]; then
	  if [[ `echo "$profiles2run" | grep -icw emoms` -eq "0" ]]; then
	    ask_sys_pass=0
	  fi
	fi

       if [[ $ask_sys_pass -eq "1" ]]; then	
        sysman_pwd_cnt=3
        while [ $sysman_pwd_cnt -gt 0 ]
        do
          sysman_pwd_cnt=$(expr $sysman_pwd_cnt - 1)
          echo""
          printf  "Enter password for OMS sysman user:- "
          tty -s && stty -echo
          $READ OMS_SYSMAN_PASSWORD
          read_code=`echo $?`;
          tty -s && stty echo
          
	  printf "\n\nVerifying OMS sysman password.\n\n. .\n ";
          OMS_HOME=`grep -i "$stack:.*:OMS_UP = 1" $MASTERFIL|awk -F":" '{print $2}'|sed 's/ //g'|head -1`	
	  
  	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_omsOwner	
            sysman_pwd_status=`su $omsOwner -c "$OMS_HOME/bin/emctl$BAT list properties -sysman_pwd $OMS_SYSMAN_PASSWORD 2>/dev/null"`
	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            sysman_pwd_status=`$OMS_HOME/bin/emctl$BAT list properties -sysman_pwd $OMS_SYSMAN_PASSWORD 2>/dev/null`
	  fi
          if [[ `echo "$sysman_pwd_status"|grep -ic "Property Details"` -eq "0" ]]; then
            unset OMS_SYSMAN_PASSWORD
	    echo ""
  	    if [[ $sysman_pwd_cnt -eq "0" ]]; then
              echo -e "\n\n${RED}OMS sysman password was incorrect. Checks requiring OMS sysman password will be skipped.${NORM}\n" 
	    else
              echo -e "\n\n${RED}OMS sysman password was incorrect. $sysman_pwd_cnt retries remaining.${NORM}\n" 
	    fi
            echo ""
          else
            break	
          fi
        done      
       fi

        if [[ -n $OMS_SYSMAN_PASSWORD ]]; then
	  get_cygpath "mb_oms_home"
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
  	    get_omsOwner
	    OMS_PROPERTIES=`su $omsOwner -c "${mb_oms_home}/bin/emctl$BAT list properties<<EOF
		$OMS_SYSMAN_PASSWORD
EOF
"`
	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    OMS_PROPERTIES=`${mb_oms_home}/bin/emctl$BAT list properties<<EOF
		$OMS_SYSMAN_PASSWORD
EOF
`
	  fi
	  restore_cygpath "mb_oms_home"
	  OMS_NODES=`echo "$OMS_PROPERTIES"|grep -i "Management Server :"|awk -F":" '{print $2}'|sed 's/ //g'` 

          for OMSNODE in `echo "$OMS_NODES"`
	  do
	    SHORT_OMSNODE=`echo "$OMSNODE"|cut -d. -f1`
   	    if [[ `grep -icw "$SHORT_OMSNODE" $HOSTLIST.$$` -eq "0" ]];then
              echo "$SHORT_OMSNODE" >> $HOSTLIST.$$ 
	    fi	    
	  done
	fi
      fi 
    else
      stack_check_oms=0
      stack_check_oms=`$SSHELL $stack "$bash_scr -c \"if [ -e \\\\\\"${invntr_location[$stack_counter]}/ContentsXML/inventory.xml\\\\\\" ]; then grep '<HOME NAME=' \\\\\\"${invntr_location[$stack_counter]}/ContentsXML/inventory.xml\\\\\\"; fi\"" 2>/dev/null`

      if [ $is_windows -eq "1" ] ; then
        OMS_PATTERN="LOC=.*\oms\""
      else
        OMS_PATTERN="LOC=.*/oms\""
      fi
      if [[ `echo "$stack_check_oms"|grep -c "$OMS_PATTERN"` -gt 0 || -n $RAT_OMS_HOME ]]; then 
        is_oms_installed=1
        echo $stack.OMS_INSTALLED = $is_oms_installed >>$MASTERFIL

        if [ -z $RAT_OMS_HOME ]; then
          if [ $is_windows -eq "1" ] ; then
            OMS_HOMES=`echo "$stack_check_oms"|grep '<HOME NAME='|grep "LOC=.*\oms\""|sed "s/^.*LOC=\"\(.*\oms\)\".*/\1/g"` 
          else
            OMS_HOMES=`echo "$stack_check_oms"|grep '<HOME NAME='|grep "LOC=.*/oms\""|sed "s/^.*LOC=\"\(.*\/oms\)\".*/\1/g"` 
          fi
        else
          OMS_HOMES=$(echo "$RAT_OMS_HOME"|sed 's/,/ /g')
        fi

        for mb_oms_home in `echo "$OMS_HOMES"`
        do
	  get_cygpath "mb_oms_home"
          if [[ -e $mb_oms_home ]]; then 
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              get_omsOwner "$stack" "1"
              OMS_STATUS=`$SSHELL $stack "cd $omshome_dir 2>/dev/null; su $omsOwner -c \"${mb_oms_home}/bin/emctl$BAT status oms 2>/dev/null\""`
		OMS_VERSION=`$SSHELL $stack "su $omsOwner -c \"${mb_oms_home}/bin/emctl$BAT getversion oms\""`
		
    	      write_del_rolbk_tmpoutput
	    else
              OMS_STATUS=`$SSHELL $stack "${mb_oms_home}/bin/emctl$BAT status oms 2>/dev/null"`
		OMS_VERSION=`$SSHELL $stack "${mb_oms_home}/bin/emctl$BAT getversion oms "`
	    fi
	    omsv=`echo $OMS_VERSION|grep "OMS Version"|$AWK -F" " '{print$NF}'|sed 's/ //g'`

            if [[ -n "$omsv" ]]
            then
                    OMS_VERSION=$omsv
            else
		   if [ `echo $OMS_VERSION|grep -ic "13c Release 1"` -gt "0"  ]
		   then
                    OMS_VERSION="13.1.0.0.0"
		   fi
            fi

            if [[ `echo "$OMS_STATUS"|grep -ic "WebTier is Up"` -gt "0" && `echo "$OMS_STATUS"|grep -ic "Oracle Management Server is Up"` -gt "0" ]]; then
              is_oms_up=1
	    fi
    	    echo ${stack}:${mb_oms_home}:OMS_UP = $is_oms_up >>$MASTERFIL
	    echo ${stack}:${mb_oms_home}:OMS_VERSION = $OMS_VERSION >>$MASTERFIL
          fi
	  restore_cygpath "mb_oms_home"
        done
      fi
    fi
  done
  stack_counter=0
  unset stack
  unset mb_oms_home
}

#this function is to find out the inventory location dependet on platform
#if no inventory is found , means no CRS and RDBMS is installed
search_invntr_platform ()
{
  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then ask_inv_loc="No"; return; fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then return; fi; 
  if [[ -n "$is_exadata_dom0_machine" && $is_exadata_dom0_machine -eq "1" ]]; then return; fi;
  if [[ -n "$is_opc" && $is_opc -eq "1" ]]; then return; fi;
  if [[ -n "$is_ssc_globalzone_machine" && $is_ssc_globalzone_machine -eq "1" ]]; then return; fi;
  if [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq "1" ]]; then return; fi;
  if [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] ; then return; fi;

  search_scope=$1
  if [[ -n $search_scope && $search_scope = "localonly" ]]; then
    invntr_counter=0
    cp -f $HOSTLIST $HOSTLIST.$$
    echo "$localnode" > $HOSTLIST
  else
    invntr_counter=1
    sed /^$localnode$/d $HOSTLIST > $HOSTLIST.new
    cp -f $HOSTLIST $HOSTLIST.$$
    mv -f $HOSTLIST.new $HOSTLIST
  fi

  for invntr in `cat $HOSTLIST`
  do
    case `/bin/uname` in
    Linux)
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        v_oratab=$RAT_ORATAB_LOC;
      else
        v_oratab="/etc/oratab"
      fi
      #Bug fix 23702178 for Exadata Sparc
      if [ `uname -p` = "sparc64" ]
      then 
           v_oraInstLoc=/var/opt/oracle/oraInst.loc
      else
            
           v_oraInstLoc=/etc/oraInst.loc
      fi
      if [ $invntr = $localnode ]
      then
        if [[ -e $v_oraInstLoc && -z "$RAT_INV_LOC" ]]
        then
          #invntr_location[$invntr_counter]=`cat /etc/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          invntr_location[$invntr_counter]=`grep -v "^#" $v_oraInstLoc|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ ! -e $v_oraInstLoc && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
              exec 2<&3
	      write_in_env "ORACLE_SW_INSTALL_OPTION" "$ask_inv_loc"
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              #$READ -p "invntr_location= ${invntr_location[$invntr_counter]}"
              ;;
            *)     
              ;;    
          esac
        else 
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      else
        $SSHELL $invntr ls -l $v_oraInstLoc >/dev/null 2>&1
        inv_ptr_exist=$(echo $?) 
        if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
        then
          invntr_location[$invntr_counter]=`$SSHELL $invntr cat $v_oraInstLoc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it.\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    else
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
	    fi
          fi
        elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]] && [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]];
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
              exec 2<&3
	      write_in_env "ORACLE_SW_INSTALL_OPTION" "$ask_inv_loc"
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              ;;
            *)     
              ;;    
          esac
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      fi
    ;;
    SunOS)
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        v_oratab=$RAT_ORATAB_LOC;
      else
      	v_oratab="/var/opt/oracle/oratab"
      fi
      if [ $invntr = $localnode ]
      then
        if [[ -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then
          invntr_location[$invntr_counter]=`cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ ! -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
       	      exec 3<&2; exec 2<&0
       	      $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
       	      exec 2<&3
	      write_in_env "ORACLE_SW_INSTALL_OPTION" "$ask_inv_loc"
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              ;;
            *)     
              ;;    
          esac
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      else
        $SSHELL $invntr ls -l /var/opt/oracle/oraInst.loc >/dev/null 2>&1
        inv_ptr_exist=$(echo $?) 
        if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
        then
          invntr_location[$invntr_counter]=` $SSHELL $invntr cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
              exec 2<&3
	      write_in_env "ORACLE_SW_INSTALL_OPTION" "$ask_inv_loc"
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              ;;
            *)     
             ;;    
          esac
          #$READ -p "inventory found at ${invntr_location[$invntr_counter]}"
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      fi
    ;;
    HP-UX) 
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        v_oratab=$RAT_ORATAB_LOC;
      else
        v_oratab="/etc/oratab"
      fi
      if [ $invntr = $localnode ]
      then
        if [[ -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then
          #invntr_location[$invntr_counter]=`cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          invntr_location[$invntr_counter]=`grep -v "^#" /var/opt/oracle/oraInst.loc|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ ! -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
              exec 2<&3
	      write_in_env "ORACLE_SW_INSTALL_OPTION" "$ask_inv_loc"
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              ;;
            *)     
              ;;    
          esac
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      else
        $SSHELL $invntr ls -l /var/opt/oracle/oraInst.loc  >/dev/null 2>&1
        inv_ptr_exist=$(echo $?) 
        if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
        then
          invntr_location[$invntr_counter]=`$SSHELL $invntr cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
       	      exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
       	      exec 2<&3
	      write_in_env "ORACLE_SW_INSTALL_OPTION" "$ask_inv_loc"
	      process_prompt "$read_code" "ask_inv_loc" "n"
  	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
       	      exit 1; 
              ;;
            n|N|No|NO)   
       	      ;;
            *)     
              ;;    
          esac
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      fi
    ;;
    AIX)
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        v_oratab=$RAT_ORATAB_LOC;
      else
        v_oratab="/etc/oratab"
      fi
      if [ $invntr = $localnode ]
      then
        if [[ -f /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then
          #invntr_location[$invntr_counter]=`cat /etc/oraInst.loc|grep -v "#"|grep inventory_loc|cut -d= -f2`
          invntr_location[$invntr_counter]=`grep -v "#" /etc/oraInst.loc|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ ! -e /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
       	      exec 3<&2; exec 2<&0
       	      $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
       	      exec 2<&3
	      write_in_env "ORACLE_SW_INSTALL_OPTION" "$ask_inv_loc"
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              #$READ -p "invntr_location= ${invntr_location[$invntr_counter]}"
              ;;
            *)     
              ;;    
          esac 
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      else
        $SSHELL $invntr ls -l /etc/oraInst.loc >/dev/null 2>&1
        inv_ptr_exist=$(echo $?) 
        if [[ $inv_ptr_exist -eq 0 && -z $RAT_INV_LOC ]]
        then
          invntr_location[$invntr_counter]=`$SSHELL $invntr cat /etc/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
        then 
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              #$READ -p "invntr_location= ${invntr_location[$invntr_counter]}"
              ;;
            *)     
             ;;    
          esac 
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      fi
    ;;
    CYGWIN_NT-[0-9].[0-9])
      invntr_location[$invntr_counter]=$(grep INV_LOC= $windiscover |sed 's/INV_LOC=//' | sed 's/ *$//');
    ;;
    *)  /bin/echo "ERROR: Unknown Operating System"
        exit -1
    ;;
    esac
    invntr_counter=`expr $invntr_counter + 1 `
  done
  invntr_counter=0

  if [[ -n $search_scope && $search_scope = "localonly" ]]; then
    discover_OMS "localonly"
  else
    discover_OMS
  fi
  mv -f $HOSTLIST.$$ $HOSTLIST >/dev/null 2>&1
}

#this function is to check that CRS is installed or not on all nodes in cluster
is_crs_installed()
{
  search_invntr_platform
  crs_counter=0
  for crs_install in `cat $HOSTLIST`
  do
    unset invntr_CH
    if [ $crs_install = $localnode ]
    then
      if [ -n "${invntr_location[$crs_counter]}" ]
      then
        #invntr_CH=`cat ${invntr_location[$crs_counter]}/ContentsXML/inventory.xml |grep "CRS=\"true\""|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'`
        invntr_CH=`grep "CRS=\"true\"" "${invntr_location[$crs_counter]}/ContentsXML/inventory.xml" 2>/dev/null |grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g' | sed 's|\\\\|\/|g'|head -1`
        local_invntr_CH=$invntr_CH
        if [[ -z "$invntr_CH" ||! -d $invntr_CH ||! -f $invntr_CH/bin/crsd ]] && [[ -z "$RAT_CRS_HOME" ]] && [[ -z $is_oms_installed || -n $is_oms_installed && $is_oms_installed -eq "0" ]] && [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]
 	then 
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="${program_name} did not find the CRS binaries on $crs_install from environment.\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
 	  echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
 	  exit 1; 
 	fi
      fi

      if [[  -d $invntr_CH || -n "$RAT_CRS_HOME" ]] 
      then
        if [[ -f $invntr_CH/bin/crsd || -n "$RAT_CRS_HOME" ]]
        then
          crs_installed[$crs_counter]=1
          echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
          if [ -n "$RAT_CRS_HOME" ]
          then 
            if [[ `grep -ic "CRS_HOME =" $MASTERFIL` -eq "0" ]]; then echo "CRS_HOME = $RAT_CRS_HOME" >>$MASTERFIL; fi
            crsSoftwareOwner=$(ls -l $RAT_CRS_HOME/bin/ocssd 2>/dev/null|awk '{print $3}')
          else  
            if [[ `grep -ic "CRS_HOME =" $MASTERFIL` -eq "0" ]]; then echo "CRS_HOME = $invntr_CH" >>$MASTERFIL; fi
            #$READ -p "$nvntr_CH ls -l $invntr_CH/bin/crsd"
            crsSoftwareOwner=$(ls -l $invntr_CH/bin/ocssd 2>/dev/null|awk '{print $3}')
          fi
          #$READ -p "userid=$userid"
          root_user_allowed=0
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
	    root_user_allowed=1; 
	  fi

          if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
            root_user_allowed=1
          fi
 
          if [[ $root_user_allowed -eq "0" ]] && [[ "$usern" = "${root_user}" || $userid -eq 0 ]] && [[ -n "$daemon_init_mode" && $daemon_init_mode -eq 0 ]]
          then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} found that oracle software owner exists and its being run by ${root_user}.Please change ownership and permission for ${program_name} and all accompanied files being ${root_user} to rdbms software owner,login as rdbms software owner and run it again."
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} found that oracle software owner exists and its being run by ${root_user}."
            echo -e "\nPlease change ownership and permission for ${program_name} and all accompanied files being ${root_user} to rdbms software owner,login as rdbms software owner and run it again\n${NORM}"
            exit 1
          fi
        else
          crs_installed[$crs_counter]=0
          echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
        fi
      else
        crs_installed[$crs_counter]=0  
        echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
      fi
    else
      if [ -n "${invntr_location[$crs_counter]}" ]
      then
        invntr_CH=`$SSHELL $crs_install cat \"${invntr_location[$crs_counter]}/ContentsXML/inventory.xml\" 2>/dev/null |grep "CRS=\"true\""|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'| sed 's|\\\\|\/|g'|head -1`

        #$READ -p "inventory laction ${invntr_location[$crs_counter]} and CRS_HOME $invntr_CH"
 	$SSHELL $crs_install ls -l $invntr_CH >/dev/null 2>&1
 	remote_crs_home_status=$(echo $?) 
 	if [[ -n "$remote_crs_home_status" && $remote_crs_home_status -ne 0 ]] && [[ -z "$RAT_CRS_HOME" ]] && [[ -z $is_oms_installed || -n $is_oms_installed && $is_oms_installed -eq "0" ]] && [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]
 	then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="${program_name} did not find the CRS binaries on $crs_install from environment.\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
 	  echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
 	  exit 1;
 	fi
      fi

      if [[ -n "$remote_crs_home_status" && $remote_crs_home_status -eq 0 ]] || [[ -n "$RAT_CRS_HOME" ]] 
      then
        $SSHELL $crs_install ls -l $invntr_CH/bin/crsd >/dev/null 2>&1
        remote_crsd_file_status=$(echo $?)
  
        if [[ -n "$remote_crsd_file_status" && $remote_crsd_file_status -ne 0 ]] && [[ -z "$RAT_CRS_HOME" ]] && [[ -z $is_oms_installed || -n $is_oms_installed && $is_oms_installed -eq "0" ]] && [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]
        then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="${program_name} did not find the CRS binaries on $crs_install from environment.\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.eg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
          echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
 	  exit 1;
        fi
 	
        if [[ -n "$remote_crsd_file_status" && $remote_crsd_file_status -eq 0 ]] || [[ -n "$RAT_CRS_HOME" ]]
 	then
 	  crs_installed[$crs_counter]=1
 	  echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
 	else
 	  crs_installed[$crs_counter]=0
 	  echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
 	fi
      else
        crs_installed[$crs_counter]=0  
        echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
      fi
    fi
    #$READ -p "crs installed at on $crs_install ${crs_installed[$crs_counter]}"
    crs_counter=`expr $crs_counter + 1`
  done
  crs_counter=0
}

function is_valid_ohome
{
  export ORACLE_SID=$1
  export ORACLE_HOME=$2
  if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
    RAT_DBNAMES="$RAT_DBNAMES $ORACLE_SID";
    RAT_ORACLE_HOME="$ORACLE_HOME";
  fi 
  export LD_LIBRARY_PATH=$ORACLE_HOME/lib
  if [ ! -e "$ORACLE_HOME/bin/sqlplus" ] ; then
    valid_ohome=0
    return;
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    get_dbOwner

    iname=`su $dbOwner -c "echo \"set feedback  off heading off lines 120 
        select INSTANCE_NAME from gv\\\\\\\$instance;\" | $ORACLE_HOME/bin/sqlplus -s \"/ as sysdba\"" |  grep -v ^$ | grep $ORACLE_SID 2>&1`
    write_del_rolbk_tmpoutput
    cd $OLD_DIR
    unset OLD_DIR
  else
    iname=`echo 'set feedback  off heading off lines 120 
        select INSTANCE_NAME from gv\$instance;' | $ORACLE_HOME/bin/sqlplus -s "/ as sysdba" |  grep -v ^$ | grep $ORACLE_SID 2>&1`
  fi

  if [[ $iname = $ORACLE_SID || `echo "$iname" | grep -ic "insufficient privileges"` -gt 0 ]] ; then
    valid_ohome=1
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      #what_db=$(su $dbOwner -c \"$ORACLE_HOME/bin/sqlplus -v|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'\")
      what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s -version" | awk '{print $3}' | sed 's/\.//g' | sed '/^$/d')   
    else 
      what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    fi
    if [[ -n "$what_db" && $what_db -gt "$latest_si_version" ]] ; then
      latest_si_version=$what_db
    fi
  else
    valid_ohome=0
  fi
}

function search_oh_si()
{
  #Search config file ${program_name}_homes.conf
  #oconf_file="${program_name}_homes.conf"
  oconf_file="$WRKDIR/${program_name}_homes.conf"
  if [ -e "$oconf_file" ] ; then
    #if [[ `cat $oconf_file | grep -ic "$sid|"` -gt 0 ]] ; then
    if [[ `grep -ic "$sid|" $oconf_file` -gt 0 ]] ; then
      oh=$(grep "$sid|" $oconf_file | head -1 | cut -d'|' -f2)
      valid_ohome=0
      in_conf=1
      is_valid_ohome $sid $oh
      if [ $valid_ohome -eq 1 ] ; then found_in="c"; return; fi;
    fi
  fi

  # oratab
  #oh=$(cat $ORATAB |grep ":/" |grep -v "+"|grep -v "^#"|grep -w "$sid:" |cut -d: -f2)
  if [ $is_windows -eq "1" ] ; then
    oh=$(grep ":" $ORATAB |grep -v "+"|grep -v "^#"|grep -i "$sid|" |cut -d\| -f2)
  else
    oh=$(grep ":/" $ORATAB |grep -v "+"|grep -v "^#"|grep -w "$sid:" |cut -d: -f2)
  fi
  if [[ -n "$oh" && "$oh" ]]
  then
    valid_ohome=0
    is_valid_ohome $sid $oh
    if [ $valid_ohome -eq 1 ] ; then
      found_in="oratab";
      return;
    fi;
  fi

  # If pmap exists, try parsing pmap output

  pmap_found=$(which pmap >/dev/null 2>&1;echo $?)
  if [[ -n "$pmap_found" && $pmap_found -eq "0"  ]] ; then
    ppid=$(ps -ef |grep "ora_pmon_$sid"|grep -v grep |awk '{print $2}')
    oh=$(pmap $ppid  | grep bin/oracle | awk '{print $NF}' | sort -u | sed 's/\/bin\/oracle//');
    if [[ -z $oh ]];then
      oh=$(pmap -p $ppid 2>/dev/null  | grep bin/oracle | awk '{print $NF}' | sort -u | sed 's/\/bin\/oracle//');
    fi
    is_valid_ohome $sid $oh
    if [ $valid_ohome -eq 1 ] ; then found_in="pmap"; return; fi;
  fi
 
  # Ask user if we are not in silent mode.
  attempt_cnt=3
  while [[ $attempt_cnt -ge "0" ]] ; do

    printf "Enter ORACLE_HOME for $sid : "

    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
    cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n78_nlsid">
      Enter ORACLE_HOME for {1} 
    </text>
    <tokens>
      <token index="1">$sid</token>
    </tokens>
    </tokenizedtext>
  </question>
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
      oh="" 
      break
    elif [[ $EM_XMLD_MODE -eq 1 ]]
    then
      read_probe_xml "<token index="1">$sid</token>"
      oh=$xml_rvalue  
      break
    else
      $READ oh
      valid_ohome=0
      if [ -n "$oh" ] ; then
        is_valid_ohome $sid $oh
        if [ $valid_ohome -eq 1 ] ; then found_in="input"; return; fi;
      fi
      if [[ $attempt_cnt -gt "0" ]] ; then
        echo "Could not login to $sid using $oh. Try again ($attempt_cnt attempts remaining)"
      else
        echo "Skipping database $sid"
      fi
      attempt_cnt=$(expr $attempt_cnt - 1)
    fi
  done
  oh=""
}

function save_to_conf ()
{
  if [[ $in_conf -eq "1" && $found_in = "c" ]] ; then
    return; # Valid one in conf file
  fi
  if [[ $in_conf -eq "0" ]] ; then
    echo "$sid|$oh" >> $oconf_file
  else
    grep -v "$sid|" $oconf_file > $oconf_file.bak
    echo "$sid|$oh" >> $oconf_file.bak
    mv -f $oconf_file.bak $oconf_file
  fi
}

function search_si ()
{
  cnt=0
  latest_si_version=0
  TMP_RAT_DBNAMES=$RAT_DBNAMES
  if [ $is_windows -eq "1" ] ; then
    sids=`grep "SERVICE_NAME: OracleService" $win_services  | sed 's/SERVICE_NAME: OracleService//' | tr -d '\r' |sort -u|tr '[:upper:]' '[:lower:]'`;
  else
    sids=`ps -ef |grep ora_pmon|grep -v grep |awk '{print $NF}'`
  fi
  for sid in $sids
  do
    sid=$(echo $sid | sed 's/ora_pmon_//')

    if [[ -n "$TMP_RAT_DBNAMES" ]]
    then
      if [[ `echo "$TMP_RAT_DBNAMES"|grep -wc "$sid"` -eq 0 ]]
      then
        continue;
      else
	RAT_DBNAMES=$(echo "$RAT_DBNAMES"|$perl_exe -pe "s/\b$sid\b//g")
	RAT_DBNAMES=$(echo "$RAT_DBNAMES"|sed "s/^,|,$//g")
      fi
    fi

    oh=""
    in_conf=0
    search_oh_si
    if [ -n "$oh" ] ; then
      save_to_conf 
      sids_si[$cnt]=$sid
      homes_si[$cnt]=$oh
      if [[ -z "$RAT_DBNAMES" || `echo $RAT_DBNAMES | grep -ic $sid` -eq "0" ]]
      then # Add to RAT_DBNAMES If not exists
        RAT_DBNAMES="$RAT_DBNAMES $sid";
        RAT_DBHOMES="$RAT_DBHOMES $oh";
      fi
      cnt=$(expr $cnt + 1)
    fi
  done
}

function get_ohome_si_oh ()
{
  i_sid=$1
  l_cnt=0
  for l_sid in "${sids_si[@]}"
  do
    if [ "$l_sid" = "$i_sid" ] ; then
      l_oh=${homes_si[$l_cnt]}
      return;
    fi
    l_cnt=$(expr $l_cnt + 1);
  done
}

# Check for rdbms installation location for single instance db
function is_rdbms_installed_si()
{
  search_si
  if [[ -z "$RAT_DBNAMES" ]] ; then
    if [[ $latest_si_version -gt 0 && -z "$RAT_DB" ]] ; then
      RAT_DB=$latest_si_version
    fi
  fi
  #if [ "$TYP" != "-r" ]; then TYP="-b";fi
  rdbms_counter=0
  #RAT_DB=112030
  crs_up=0
  crs_installed=0
  crs_installed[0]=0
  asm_installed[0]=0
  stack_crs_up[0]=0
  echo $localnode.CRS_INSTALLED = 0 >> $MASTERFIL
  echo SINGLE_INSTANCE_RUN = 1 >> $MASTERFIL

  stack_counter=0
  mb_running_host[0]=$localnode
}

#this function is to check that RDBMS is installed or not on all nodes in cluster
is_rdbms_installed()
{
  #search_invntr_platform
  rdbms_counter=0
  for rdbms_install in `cat $HOSTLIST`
  do
    unset invntr_OH
    if [ $rdbms_install = $localnode ] 
    then
      if [ -n "${invntr_location[$rdbms_counter]}" ]
      then
        for invntr_OH in `grep LOC "${invntr_location[$rdbms_counter]}/ContentsXML/inventory.xml" 2>/dev/null |grep -v "CRS=\"true\""|grep -iv ASM|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'`
        do
          if [[  -d $invntr_OH || -n "$RAT_ORACLE_HOME" ]] 
          then
            if [[ -f $invntr_OH/bin/oracle || -n "$RAT_ORACLE_HOME" ]]
            then
              #oratab_OH=$(cat $v_oratab|grep ":/" |grep -v "+"|grep -v "^#"|head -1 |cut -d: -f2)
              oratab_OH=$(grep ":/" $v_oratab|grep -v "+"|grep -v "^#"|head -1 |cut -d: -f2)
              if [[ -n "$oratab_OH" && $invntr_OH = $oratab_OH ]]
              then
                rdbms_installed[$rdbms_counter]=1
                local_invntr_OH=$invntr_OH
                break
              else
                rdbms_installed[$rdbms_counter]=0
              fi
            else
              rdbms_installed[$rdbms_counter]=0
            fi
          else
            rdbms_installed[$rdbms_counter]=0  
          fi
        done
        if [[ -n "${rdbms_installed[$rdbms_counter]}" && ${rdbms_installed[$rdbms_counter]} -eq 1 ]]
        then
          echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
        else
          echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
        fi
      else
        rdbms_installed[$rdbms_counter]=0
        echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
      fi
    else
      if [ -n "${invntr_location[$rdbms_counter]}" ]
      then
        for invntr_OH in `$SSHELL $rdbms_install cat \"${invntr_location[$rdbms_counter]}/ContentsXML/inventory.xml\" 2>/dev/null|grep LOC|grep -v "CRS=\"true\""|grep -iv ASM|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'` 
        do
          $SSHELL $rdbms_install ls -l $invntr_OH >/dev/null 2>&1
          if [[ $? -eq 0  || -n "$RAT_ORACLE_HOME" ]] 
          then
            $SSHELL $rdbms_install ls -l $invntr_OH/bin/oracle >/dev/null 2>&1
            if [[ $? -eq 0 || -n "$RAT_ORACLE_HOME" ]]
            then
              oratab_OH=$($SSHELL $rdbms_install cat $v_oratab|grep ":/" |grep -v "+"|grep -v "^#"|head -1 |cut -d: -f2)
              if [[ -n "$oratab_OH" && $invntr_OH = $oratab_OH ]]
              then
                rdbms_installed[$rdbms_counter]=1
                #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
                break
              else
                rdbms_installed[$rdbms_counter]=0
              fi
            else
              rdbms_installed[$rdbms_counter]=0
              #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
            fi
          else
            rdbms_installed[$rdbms_counter]=0  
            #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
          fi
        done
        if [[ -n "${rdbms_installed[$rdbms_counter]}" && ${rdbms_installed[$rdbms_counter]} -eq 1 ]]
        then
          echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
        else
          echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
        fi
      else
        rdbms_installed[$rdbms_counter]=0
        echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
      fi
    fi
    #$READ -p "crs installed on $rdbms_install=${crs_installed[$rdbms_counter]}"
    rdbms_counter=`expr $rdbms_counter + 1`
  done
  if [ -n "$oratab_OH" ]
  then
    export ORACLE_HOME=$oratab_OH
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null" | awk '{print $3}' | sed 's/\.//g' | sed '/^$/d')
      write_del_rolbk_tmpoutput
      cd $OLD_DIR
      unset OLD_DIR
    else
      what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    fi
    echo "$oratab_OH|$what_db" >>$OUTPUTDIR/mb_db_homes_distinct.out
  fi
  mb_set_oracle_home_version_distinct 
  rdbms_counter=0
}

is_asm_installed()
{
  #search_invntr_platform
  asm_counter=0
  for asm_install in `cat $HOSTLIST`
  do
    unset invntr_AH
    if [ $asm_install = $localnode ] 
    then
      if [ -n "${invntr_location[$asm_counter]}" ]
      then
        #invntr_AH=`cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep LOC|grep -v "CRS=\"true\""|grep -v db|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'|head -1`
        invntr_AH=`grep LOC "${invntr_location[$asm_counter]}/ContentsXML/inventory.xml" 2>/dev/null |grep -v "CRS=\"true\""|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'|head -1`
        #if [[ -z "$invntr_AH" || ! -d $invntr_AH || ! -e $invntr_AH/bin/oracle ]] && [ -z "$RAT_ASM_HOME" ]
        #then
        #  echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
        #  exit 1;
        #fi
      fi
      if [[  -d $invntr_AH || -n "$RAT_ASM_HOME" ]] 
      then
        if [[ -f $invntr_AH/bin/oracle || -n "$RAT_ASM_HOME" ]]
        then
          asm_installed[$asm_counter]=1
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
        else
          asm_installed[$asm_counter]=0
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
        fi
      else
        asm_installed[$asm_counter]=0  
        echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
      fi
    else
      if [ -n "${invntr_location[$asm_counter]}" ]
      then
        invntr_AH=`$SSHELL $asm_install cat \"${invntr_location[$asm_counter]}/ContentsXML/inventory.xml\" 2>/dev/null|grep LOC|grep -v "CRS=\"true\""|grep -vi db|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'|head -1` 
        $SSHELL $asm_install ls -l $invntr_AH >/dev/null 2>&1
        remote_asm_home_status=$(echo $?)
        #if [[ $remote_asm_home_status -ne 0 &&  -z "$RAT_ASM_HOME" ]]
        #then
        #  echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
        #  exit 1;
        #fi
      fi
      if [[ $remote_asm_home_status -eq 0  || -n "$RAT_ASM_HOME" ]] 
      then
        $SSHELL $asm_install ls -l $invntr_AH/bin/oracle >/dev/null 2>&1
        remote_asmd_file_status=$(echo $?)
        #if [[ $remote_asmd_file_status -ne 0 &&  -z "$RAT_ASM_HOME" ]]
        #then
        #  echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
        #  exit 1;
        #fi
        if [[ $remote_asmd_file_status -eq 0 || -n "$RAT_ASM_HOME" ]]
        then
          asm_installed[$asm_counter]=1
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
        else
          asm_installed[$asm_counter]=0
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
        fi
      else
        asm_installed[$asm_counter]=0  
        echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
      fi
    fi
    #$READ -p "crs installed on $rdbms_install=${crs_installed[$rdbms_counter]}"
    asm_counter=`expr $asm_counter + 1`
  done
  asm_counter=0
}

function create_running_db_list ()
{
  if [[ -z $CRS ]]; then
    crd_status=0;
    return;
  fi

  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then return; fi

  db_list=$(echo "$db_list"|sed "s/ //g")

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
    OLD_OH=$ORACLE_HOME
    if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
    get_dbOwner
    if [[ -n "$dbOwner" ]]; then
      crs_db_hosts=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i 'is running' | awk '{print \$NF}'")
    fi
    ORACLE_HOME=$OLD_OH
    write_del_rolbk_tmpoutput
    cd $OLD_DIR
    unset OLD_DIR
  else
    OLD_OH=$ORACLE_HOME	
    if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
    export ORACLE_HOME=$ORACLE_HOME 
    crs_db_hosts=$($ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i "is running" | awk '{print $NF}')
    ORACLE_HOME=$OLD_OH
  fi

  if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
    if [[ -z $crs_db_hosts ]]; then
      ora_sid=$(ps -ef |grep pmon_${db_list}|grep -v grep|awk '{print $8}'|cut -d_ -f3);
    fi
    if [[ -n $ora_sid ]]; then
      crs_db_hosts="running.";
    fi
  fi

  remote_crs_db_hosts=0
  if [[ -z $crs_db_hosts ]]; then
    for hosts in `cat $HOSTLIST`
    do
      t_flag="-T";
      if [ $hosts != $localnode ]; then
        if [ -e $db_list_fil_verbose ] ;then crs_db_home=$(grep -w $db_list $db_list_fil_verbose|awk '{print $2}');fi
        if [ -z "$crs_db_home" ];then 
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
	    OLD_OH=$ORACLE_HOME
	    if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	    get_dbOwner "$hosts" "1"
	    if [[ -n "$dbOwner" ]]; then
	      crs_db_home=$($SSHELL $hosts "su $dbOwner -c \"cd $dbhome_dir;export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRKR-1078|awk '{ print \\\$NF }'\"");
	    fi
	    ORACLE_HOME=$OLD_OH
    	    write_del_rolbk_tmpoutput
	  else
    	    OLD_OH=$ORACLE_HOME	
	    if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	    crs_db_home=$($SSHELL $hosts "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRKR-1078|awk '{ print $NF }'");
	    ORACLE_HOME=$OLD_OH
	  fi
	fi
        if [ -z "$crs_db_home" ]; then 
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	    get_dbOwner "$hosts" "1"
	    if [[ -n "$dbOwner" ]]; then
	      crs_db_home=$($SSHELL $hosts \"su $dbOwner -c "cd $dbhome_dir;export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRCD-1229|awk '{ printf \\\"%s\\\",substr(\\\$NF,1,length(\\\$NF)-1) }'\"");
	    fi
	    ORACLE_HOME=$OLD_OH
    	    write_del_rolbk_tmpoutput
	  else
    	    OLD_OH=$ORACLE_HOME	
	    if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	    crs_db_home=$($SSHELL $hosts "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRCD-1229|awk '{ printf \"%s\",substr($NF,1,length($NF)-1) }'");
	    ORACLE_HOME=$OLD_OH
          fi
	fi
	if [[ -n "$crs_db_home" ]]; then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$crs_db_home
	    get_dbOwner "$hosts" "1"
	    if [[ -n "$dbOwner" ]]; then
	      crs_db_hosts=`$SSHELL $t_flag $hosts<<EOF
	      cd $dbhome_dir 2>/dev/null;
              export ORACLE_HOME=$crs_db_home
              su $dbOwner -c "$crs_db_home/bin/srvctl$BAT status database -d $db_list 2>/dev/null"
EOF`
	    fi
	    ORACLE_HOME=$OLD_OH
    	    write_del_rolbk_tmpoutput
          else
	    crs_db_hosts=`$SSHELL $t_flag $hosts<<EOF
            export ORACLE_HOME=$crs_db_home
            $crs_db_home/bin/srvctl$BAT status database -d $db_list 2>/dev/null
EOF`
	  fi
	fi
	unset crs_db_home
	crs_db_hosts=$(echo "$crs_db_hosts"|grep -i "is running" | awk '{print $NF}')
      fi
      if [[ -n "$crs_db_hosts" ]]
      then
	remote_crs_db_hosts=1
        crs_db_hosts=$hosts
      fi
      if [[ -n $crs_db_hosts ]]; then break; fi
    done
  fi

  if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
    for mapping in ${hostmap[@]}
    do
      management_host=${mapping%%:*}
      client_host=${mapping#*:}
  
      if [[ `echo "$client_host" | grep -ic "$crs_db_hosts"` -ge 1 ]]; then
        crs_db_hosts=$management_host;
      fi
    done
  fi
  
  if [[ -n "$crs_db_hosts" && $crs_db_hosts = "running." ]] && [[ $remote_crs_db_hosts -eq 0 ]]
  then
    crs_db_hosts=$localnode
  fi

  if [[ -n "$remote_crs_db_hosts" && $remote_crs_db_hosts -eq 1 ]]; then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      remote_host_to_chk=$(echo "$crs_db_hosts"|head -1)
      OLD_OH=$ORACLE_HOME
      if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
      get_dbOwner $remote_host_to_chk "1"
      if [[ -n "$dbOwner" ]]; then
        crs_db_status=$($SSHELL $remote_host_to_chk "su $dbOwner -c \"export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list|grep -ic 'is running'\"")
      fi
      ORACLE_HOME=$OLD_OH
      write_del_rolbk_tmpoutput
    else
      OLD_OH=$ORACLE_HOME	
      if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
      crs_db_status=$($SSHELL $remote_host_to_chk "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list|grep -ic \"is running\"")
      ORACLE_HOME=$OLD_OH
    fi
  else
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      OLD_OH=$ORACLE_HOME
      if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
      get_dbOwner
      export ORACLE_HOME=$ORACLE_HOME
      if [[ -n "$dbOwner" ]]; then
        crs_db_status=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list|grep -ic 'is running'")
      fi
      ORACLE_HOME=$OLD_OH
      write_del_rolbk_tmpoutput
      cd $OLD_DIR
      unset OLD_DIR
    else
      OLD_OH=$ORACLE_HOME	
      if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
      export ORACLE_HOME=$ORACLE_HOME 
      crs_db_status=$($ORACLE_HOME/bin/srvctl$BAT status database -d $db_list|grep -ic "is running")
      ORACLE_HOME=$OLD_OH
    fi
  fi

  if [[ -n "$crs_db_status" && $crs_db_status -ge 1  ]]
  then
    crs_db_status=$(echo $crs_db_hosts| grep -ic $localnode)
    if [ $crs_db_status -eq 1 ]
    then
      echo $db_list >>$running_db_list;
      echo ":$db_list:$localnode" >>$running_db_host_list;
    else
      if [[ -n $localonly && $localonly -eq "0" ]] ; then
        for crs_db_running_host in $(echo $crs_db_hosts)
  	do
  	  if [[ -n "$crs_db_running_host" && `grep -ic "$crs_db_running_host" $HOSTLIST` -gt "0" ]]
  	  then
  	    echo $db_list >>$running_db_list;
  	    echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
  	    break;
  	  else
  	    if [[ $olsnodes_ssh_disabled -eq 1 ]]
  	    then
  	      for mapping in ${hostmap[@]}
  	      do
  	 	management_host=${mapping%%:*};
  		client_host=${mapping#*:};
  		if [[ -n "$crs_db_running_host" && `echo "$client_host" | grep -ic "$crs_db_running_host"` -gt "0" ]]
  		then
  		  echo $db_list >>$running_db_list;
  		  echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
  		  break;
  		fi
  	      done	
  	    fi
  	  fi;
  	done
      fi
    fi;
  else
    #below if condition to find $ORACLE_HOME using config database -v option 
    if [ -e $db_list_fil_verbose ] ;then crs_db_home=$(grep -w $db_list $db_list_fil_verbose|awk '{print $2}');fi
    if [ -z "$crs_db_home" ];then 
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
    	get_dbOwner
	if [[ -n "$dbOwner" ]]; then 
          crs_db_home=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRKR-1078|awk '{ print \$NF }'");
	fi
	ORACLE_HOME=$OLD_OH
    	write_del_rolbk_tmpoutput
    	cd $OLD_DIR
    	unset OLD_DIR
      else
        OLD_OH=$ORACLE_HOME	
	if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	export ORACLE_HOME=$ORACLE_HOME;
        crs_db_home=$($CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRKR-1078|awk '{ print $NF }');
	ORACLE_HOME=$OLD_OH
      fi
    fi
    if [ -z "$crs_db_home" ];then 
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi 
    	get_dbOwner
	if [[ -n "$dbOwner" ]]; then
          crs_db_home=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRCD-1229|awk '{ printf \"%s\",substr(\$NF,1,length(\$NF)-1) }'");
	fi
	ORACLE_HOME=$OLD_OH
    	write_del_rolbk_tmpoutput
    	cd $OLD_DIR
    	unset OLD_DIR
      else
        OLD_OH=$ORACLE_HOME	
        if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi 
	export ORACLE_HOME=$ORACLE_HOME;
        crs_db_home=$($CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRCD-1229|awk '{ printf "%s",substr($NF,1,length($NF)-1) }');
	ORACLE_HOME=$OLD_OH
      fi
    fi 
    if [ -n "$crs_db_home" ]; then 
      export ORACLE_HOME=$crs_db_home;
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    	get_dbOwner
	if [[ -n "$dbOwner" ]]; then 
          crs_db_status=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i $localnode |grep -ic 'is running'");
	fi
    	write_del_rolbk_tmpoutput
    	cd $OLD_DIR
    	unset OLD_DIR
      else
	ORACLE_HOME=$crs_db_home
	export ORACLE_HOME=$ORACLE_HOME
        crs_db_status=$($ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i $localnode |grep -ic "is running");
      fi
    fi;

    if [ $crs_db_status -ge 1 ]
    then
      echo $db_list | tr -d '\r' >>$running_db_list;
      echo ":$db_list:$localnode" >>$running_db_host_list;
    elif [ -n "$ORACLE_HOME" ]
    then
      if [[ -n $localonly && $localonly -eq "0" ]] ; then
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          get_dbOwner
	  if [[ -n "$dbOwner" ]]; then
            crs_db_hosts=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i 'is running' | awk '{print \$NF}'")
	  fi
    	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
          unset OLD_DIR
        else
	  export ORACLE_HOME=$ORACLE_HOME
          crs_db_hosts=$($ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i "is running" | awk '{print $NF}')
        fi
	database_found=0
  	for crs_db_running_host in $(echo $crs_db_hosts)
  	do
     	  if [[ -n "$crs_db_running_host" && `grep -ic "$crs_db_running_host" $HOSTLIST` -gt "0" ]]
  	  then
  	    echo $db_list | tr -d '\r' >>$running_db_list;
  	    echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
	    database_found=1
  	    break;
  	  else
  	    if [[ $olsnodes_ssh_disabled -eq 1 ]]
  	    then
  	      break_inside_loop=0
  	      for mapping in ${hostmap[@]}
  	      do
  		management_host=${mapping%%:*};
  		client_host=${mapping#*:};
  		if [[ -n "$crs_db_running_host" && `echo "$client_host" | grep -ic "$crs_db_running_host"` -gt "0" ]]
  		then
  		  echo $db_list | tr -d '\r' >>$running_db_list;
  		  echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
  		  break_inside_loop=1
	          database_found=1
  		  break;
  		fi
  	      done
  	      if [ $break_inside_loop -eq 1 ]; then break; fi; 
  	    else
  	      echo "$db_list: $crs_db_running_host is not selected" >> $LOGFIL
  	    fi
  	  fi
  	done

	if [ $database_found -eq 0 ]; then
          for hosts in `cat $HOSTLIST`
          do
	    t_flag="-T";
            if [ $hosts != $localnode ]; then
              if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                OLD_OH=$ORACLE_HOME
                ORACLE_HOME=$crs_db_home
                get_dbOwner "$hosts" "1"
		if [[ -n "$dbOwner" ]]; then
                  crs_db_status=`$SSHELL $t_flag $hosts<<EOF
	  	  cd $dbhome_dir 2>/dev/null;
                  export ORACLE_HOME=$crs_db_home
                  su $dbOwner -c "$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null"
EOF`      
		fi
                ORACLE_HOME=$OLD_OH
    		write_del_rolbk_tmpoutput
              else
                crs_db_status=`$SSHELL $t_flag $hosts<<EOF
                export ORACLE_HOME=$crs_db_home
                $ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null
EOF`      
              fi
	      crs_db_status=$(echo "$crs_db_status"|grep -i $hosts | grep -ic "is running")
              if [ $crs_db_status -ge 1 ]; then 
      		echo $db_list >>$running_db_list;
                echo ":$db_list:$hosts" >>$running_db_host_list;
		break;
              fi
            fi
          done
	fi	
      fi
    fi
  fi;
  crd_status=1
  return;
}

getdbnodename ()
{
  unset dbnode	
  hlist=$(grep "RDBMS_ORACLE_HOME = $1|" $MASTERFIL|head -1|awk -F'|' '{print $4}')
  for inode in `cat $HOSTLIST`
  do
    if [[ `echo "$hlist"|grep -icw $inode` -gt "0" && `grep -ic "$inode.$idbname.INSTANCE_NAME = [a-zA-Z0-9].*$" $MASTERFIL` -gt "0" ]]; then
      dbnode=$inode
      break;
    fi
  done
  if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
    for inode in `cat $HOSTLIST`
    do
      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*}
        client_host=${mapping#*:}
        client_host=`echo "$client_host"|cut -d. -f1|tr -d '\r'`
        if [[ "$inode" = "$management_host" ]]; then t_inode=$client_host; break; fi
      done
      if [[ `echo "$hlist"|grep -icw $t_inode` -gt "0" && `grep -ic "$t_inode.$idbname.INSTANCE_NAME = [a-zA-Z0-9].*$" $MASTERFIL` -gt "0" ]]; then
        dbnode=$inode
        break;
      fi
    done
  fi
}

remove_unselected_dbs_envfil ()
{
  cp -f $MASTERFIL $MASTERFIL.raw.log
  all_dbs_in_envfil=$(grep "\.RUNNING =" $MASTERFIL|awk -F. '{print $1}')
  for all_db in `echo "$all_dbs_in_envfil"`
  do
    is_db_selected=0
    for db_name_to_check in "${mb_db_names[@]}"
    do
      if [[ "$db_name_to_check" = "$all_db" ]]; then is_db_selected=1; break; fi
    done  
    if [[ $is_db_selected -eq "0" ]]; then 
      for rhost in `cat $HOSTLIST`
      do
	sed -e "/^$rhost\.$all_db\.INSTANCE_NAME /d;/^$rhost\.$all_db\.INSTANCE_MODE /d;/^$rhost\.$all_db\.INSTANCE_VERSION /d" $MASTERFIL > $MASTERFIL.t
	mv -f $MASTERFIL.t $MASTERFIL
      done
      sed -e "/^$all_db\.CHECKED_NODE /d;/^$all_db\.DATABASE_ROLE /d;/^$all_db\.DATABASE_TYPE /d;/^$all_db\.DATABASE_APP_USER /d;/^$all_db\.GLOBAL_NAME /d;/^$all_db\.PHYSICAL_STANDBY /d;/^$all_db\.LOGICAL_STANDBY /d;/^DB_NAME = $all_db|/d" $MASTERFIL > $MASTERFIL.t
      mv -f $MASTERFIL.t $MASTERFIL

      uc_all_db=$(echo "$all_db"|tr "[a-z]" "[A-Z]")
      sed -e "/^$uc_all_db\.PHYSICAL_STANDBY /d;/^$uc_all_db\.LOGICAL_STANDBY /d" $MASTERFIL > $MASTERFIL.t
      mv -f $MASTERFIL.t $MASTERFIL
    fi
  done
}

is_rdbms_installed_crs ()
{
  crd_status=0
  rdbms_counter=0
  db_list_from_env=0
  db_list_fil=$INPUTDIR/db_list.out 
  db_list_fil_verbose=$INPUTDIR/db_list_verbose.out 
  db_config_fil=$INPUTDIR/db_config.out
  running_db_list=$INPUTDIR/running_db_list.out
  running_db_host_list=$INPUTDIR/running_db_host_list.out
  touch $running_db_list
  touch $running_db_host_list
  running_group=$(id|awk '{print $2}'|cut -d'(' -f2|cut -d')' -f1)
  db_counter=1

  if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]] || [[ $single_instance_run -eq "1" ]]
  then
    if [[ -z "$RAT_DBNAMES" &&  -z "$RAT_DBHOMES" && $single_instance_run -eq "0" ]]
    then
      if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" && $aprofile_id != "RANDOMID" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
        touch $db_list_fil
        db_list_from_env=1
      else
	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	  touch $db_list_fil $db_list_fil_verbose
	  for idbdata in `grep -i 'DB_NAME =' $MASTERFIL|awk '{print $3}'`
	  do
	    idbname=$(echo $idbdata|cut -d'|' -f1)
	    idbversion=$(echo $idbdata|cut -d'|' -f2)
	    idbhome=$(echo $idbdata|cut -d'|' -f3)

	    echo -e "$idbname" >> $db_list_fil
	    echo -e "${idbname}\t${idbhome}\t${idbversion}" >> $db_list_fil_verbose
          done
	else
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    unset dbconfig_write
            OLD_OH=$ORACLE_HOME
            ORACLE_HOME=$CRS
            get_dbOwner
	    if [[ -n "$dbOwner" ]]; then
              dbconfig_write=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config database | tr -d '\r'");
	      echo -e "$dbconfig_write" > $db_list_fil
              if [ $crs112 -gt 0 ]; then 
	        unset dbconfig_write
	        dbconfig_write=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config database -v | tr -d '\r' 2>/dev/null");
                echo -e "$dbconfig_write" > $db_list_fil_verbose;
	      fi
	    fi
            ORACLE_HOME=$OLD_OH
    	    write_del_rolbk_tmpoutput
            cd $OLD_DIR
            unset OLD_DIR
          else
            $CRS/bin/srvctl$BAT config database | tr -d '\r' > $db_list_fil
            if [ $crs112 -gt 0 ]; then $CRS/bin/srvctl$BAT config database -v | tr -d '\r' 2>/dev/null> $db_list_fil_verbose;fi
          fi
	fi
        db_list_from_env=1
      fi
    else 
      db_list_from_env=0
      if [[ -z "$RAT_DBHOMES" &&  -n "$RAT_DBNAMES" ]]
      then
        for db_list in $RAT_DBNAMES
        do
	  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	    for idbdata in `grep -i 'DB_NAME =' $MASTERFIL|grep -iw $db_list|awk '{print $3}'`
	    do
	      idbname=$(echo $idbdata|cut -d'|' -f1)
	      if [[ `grep -ic "$idbname\.RUNNING = 1" $MASTERFIL` -gt "0" ]]; then
	        idbhome=$(echo $idbdata|cut -d'|' -f3)
	        getdbnodename "$idbhome"

		if [[ -n "$dbnode" ]]; then
	          echo -e "$idbname" >> $running_db_list
	          echo -e ":$idbname:$dbnode" >> $running_db_host_list
		fi
	      fi
            done
	  else
            create_running_db_list;
            if [[ $crd_status = 0 ]];
            then
              echo $db_list >> $running_db_list
  	      echo ":$db_list:$localnode" >> $running_db_host_list	
  	    fi
	  fi
  	  echo $db_list >> $db_list_fil
  	  db_counter=$(expr ${db_counter} + 1)
  	done
      elif [[ -n "$RAT_DBHOMES" &&  -n "$RAT_DBNAMES" ]]
      then
        for db_list in $RAT_DBNAMES
        do
	  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	    for idbdata in `grep -i 'DB_NAME =' $MASTERFIL|grep -iw $db_list|awk '{print $3}'`
	    do
	      idbname=$(echo $idbdata|cut -d'|' -f1)
	      if [[ `grep -ic "$idbname\.RUNNING = 1" $MASTERFIL` -gt "0" ]]; then
	        idbhome=$(echo $idbdata|cut -d'|' -f3)
	        getdbnodename "$idbhome"

		if [[ -n "$dbnode" ]]; then
	          echo -e "$idbname" >> $running_db_list
	          echo -e ":$idbname:$dbnode" >> $running_db_host_list
		fi
	      fi
            done
	  else
            create_running_db_list;
            if [[ $crd_status = 0 ]];
            then
              echo $db_list >> $running_db_list
  	      echo ":$db_list:$localnode" >> $running_db_host_list
  	    fi
	  fi
          echo $db_list >> $db_list_fil
          db_counter=$(expr ${db_counter} + 1)
        done
      elif [[ -z "$RAT_DBNAMES" && -n "$RAT_DBHOMES" ]]
      then
        for db_list in $RAT_DBNAMES
        do
          echo $db_list >> $db_list_fil
          db_counter=$(expr ${db_counter} + 1)
        done
      fi
    fi

    if [ $db_list_from_env -eq 1 ]
    then
      echo -e "\nSearching for running databases . . . . .\n"
      for db_list in `cat $db_list_fil`
      do 
	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	 #for idbdata in `grep -i 'DB_NAME =' $MASTERFIL|grep -iw "$db_list|"|awk '{print $3}'`
	  for idbdata in `grep -i 'DB_NAME =' $MASTERFIL|grep -i " $db_list|"|awk '{print $3}'`
	  do
	    idbname=$(echo $idbdata|cut -d'|' -f1)
	    if [[ `grep -ic "$idbname\.RUNNING = 1" $MASTERFIL` -gt "0" ]]; then
	      idbhome=$(echo $idbdata|cut -d'|' -f3)
	      getdbnodename "$idbhome"

	      if [[ -n "$dbnode" ]]; then
	        echo -e "$idbname" >> $running_db_list
	        echo -e ":$idbname:$dbnode" >> $running_db_host_list
	      fi
	    fi
          done
	else
          create_running_db_list
	fi
        printf ". "
        printf ". "
      done

      no_of_databases=$(cat $running_db_list|wc -l)
  
      if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
      for mapping in ${hostmap[@]}
      do
       	management_host=${mapping%%:*}
       	client_host=${mapping#*:}
  
        tmp_client_host=""
       	if [[ `grep -ic "$client_host" $running_db_host_list` -ge 1 ]]; then
          sed 's/'$client_host'/'$management_host'/p' $running_db_host_list>> $running_db_host_list.new
      	  mv -f $running_db_host_list.new $running_db_host_list
        else
      	  tmp_client_host=$(echo $client_host|awk -F"." '{print $1}');
      	  if [[ `grep -ic "$tmp_client_host" $running_db_host_list` -ge 1 ]]; then
      	    sed 's/'$tmp_client_host'/'$management_host'/p' $running_db_host_list>> $running_db_host_list.new
      	    mv -f $running_db_host_list.new $running_db_host_list
      	  fi
       	fi
      done
      fi
  
      #remove duplicate entries....
      if [ -e "$running_db_host_list" ]
      then
      	cat $running_db_host_list|sort|uniq > $running_db_host_list.new
        mv -f $running_db_host_list.new $running_db_host_list
      fi
  
      if [[ `cat $db_list_fil|sed '/^$/d'|wc -l` -ge 1 && $no_of_databases -lt 1 && `ps -ef |grep ora_pmon|grep -v grep|wc -l` -gt 0 ]]
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  EMSG="$program_name could not determine status of databases registered in clusterware to check best practices. \nSet environment variable RAT_DBNAMES to name of the database and re-run.\neg. like export RAT_DBNAMES=\"TESTDB,PRODDB\""
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
	fi
        echo -e "\n\n${RED}$program_name could not determine status of databases registered in clusterware to check best practices. Set environment variable RAT_DBNAMES to name of the database and re-run.${NORM}\n\nlike export RAT_DBNAMES=\"TESTDB,PRODDB\"\n" 
        exit 0
      elif [[ `cat $db_list_fil|sed '/^$/d'|wc -l` -lt 1 && `ps -ef |grep ora_pmon|grep -v grep|wc -l` -gt 0 ]]
      then
        if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
          echo
        else
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="Databases are not registered in Clusteware to check best practices.Set environment variable RAT_DBNAMES to name of the database and re-run.\neg. like export RAT_DBNAMES=\"TESTDB,PRODDB\""
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
          echo -e "\n\n${RED}Databases are not registered in Clusteware to check best practices.Set environment variable RAT_DBNAMES to name of the database and re-run.${NORM}\n\nlike export RAT_DBNAMES=\"TESTDB,PRODDB\"\n" 
          exit 0
        fi
      fi
  
    #else
    #  if [ -z "$RAT_DBHOMES" ];then cat $db_list_fil >$running_db_list;fi
    fi
  
    #cat $db_list_fil
    #cat $running_db_list
    #$READ -p "running db list"
    #if [[ -f $running_db_list && `cat $running_db_list|wc -l` -ge 1 ]]; then cp -f $running_db_list $db_list_fil;fi;
    no_of_databases=$(cat $running_db_list|wc -l)
    #$READ -p "stop"
    if [[ $single_instance_run -eq "1" ]] ; then
      db_list_from_env=1
      db_counter=1
    fi

    if [[ $no_of_databases -ge 1 && `cat $running_db_list|wc -l` -ge 1 && $db_list_from_env -eq 1 ]]
    then

     if [[ $dbnames -ne "1" ]] ; then
       if [[ $single_instance_run -eq "0" ]] ; then
         echo -e "\nList of running databases registered in OCR"
         db_print_msg="List of running databases registered in OCR"
         nlsid='n7'
       else
         echo -e "\nList of running databases"
    	 db_print_msg="List of running databases"
	 nlsid='n35'
       fi
       if [[ $EM_PROBE_MODE -eq 1 ]]
       then
         cat >> ${PROBE_XML}.tmp << EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="MULTI_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_${nlsid}_nlsid">
        $db_print_msg
      </text>
    </context>
    <text nls_id="orhc_exadata_n8_nlsid"> 
      Select databases from list for checking best practices
    </text>
    <options>
EOF
       fi

     if [[ -e $running_db_list && $single_instance_run -eq "1" && $oracle_restart -eq "1" && -n $RAT_DBNAMES ]] ; then
	if [[ -f "$running_db_list" ]] ; then
	  rm -f $running_db_list;
	fi
	touch $running_db_list;
	dbarr=$(echo $RAT_DBNAMES | tr " " "\n")
	counter_db=0;
	for dbval in $dbarr
	do
	  echo "$dbval" >> $running_db_list
	  counter_db=$(expr ${counter_db} + 1)
	done
	no_of_databases=$counter_db
     fi

       for db_list in `cat $running_db_list`
       do 
         if [[ $EM_PROBE_MODE -eq 1 ]]
         then
           cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${db_counter}">
        <text>$db_list</text>
      </option>
EOF
         fi
         echo "${db_counter}. $db_list"
         db_counter=$(expr ${db_counter} + 1)
       done

       if [ $no_of_databases -gt 1 ]; 
       then 
         if [[ $EM_PROBE_MODE -eq 1 ]]
         then
           cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${db_counter}">
        <text nls_id="orhc_exadata_n4_nlsid">All</text>
      </option>
EOF
         fi

         echo -e "${db_counter}. All of above";
         db_counter_none=$(expr $db_counter + 1 );
       else 
         db_counter_none=$db_counter;
         db_counter=$(expr ${db_counter} - 1);
       fi
  
       if [[ -n "$dboption" ]] ; then
         if [[ "$dboption" = "all" ]]; then 
           db_to_check=$db_counter; 
         elif [[ "$dboption" = "none" ]]; then
           db_to_check=$db_counter_none;
         fi
       fi
  
       #db_counter_none=$(expr $db_counter + 1 )
       echo -e "$db_counter_none. None of above\n"  

       if [[ $EM_PROBE_MODE -eq 1 ]]
       then
         cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o$db_counter_none">
        <text nls_id="orhc_exadata_n3_nlsid">None</text>
      </option>
    </options>
  </question>
</group>
EOF
	 PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

         if [[ -z "$dboption" ]] ; then db_to_check=$db_counter; fi;
       elif [[ $EM_XMLD_MODE -eq 1 ]]
       then
         echo "Select databases from list for checking best practices. For multiple databases, select ${db_counter} for All or comma separated number like 1,2 etc [1-${db_counter_none}][${db_counter}]."

         read_probe_xml "Select databases from list for checking best practices" 
	 db_to_check=$xml_rvalue
       else
         if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]
         then
           ask_question2user=1
           if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" && $aprofile_id != "RANDOMID" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
             ask_question2user=0; #No need toask user for db if no db checks
             db_to_check=${db_counter_none}
           fi
           if [ $daemon_init_mode -eq 1 ]; then ask_question2user=0;fi
           if [[ $ask_question2user -eq "1" ]] && [[ -z "$dboption" ]] ; then
             exec 3<&2; exec 2<&0 
             $READ -p "Select databases from list for checking best practices. For multiple databases, select ${db_counter} for All or comma separated number like 1,2 etc [1-${db_counter_none}][${db_counter}]." db_to_check
	     read_code=`echo $?`;
             exec 2<&3
	     process_prompt "$read_code" "db_to_check" "$db_counter"
           fi
         else
           if [[ -z "$dboption" ]] ; then db_to_check=$db_counter; fi;
         fi
       fi
  
       db_to_check=$(echo $db_to_check|sed 's/[a-zA-Z]//g')

       comma_ent=`echo $db_to_check |grep "," | wc -l`

       if [  $comma_ent -lt 1 ];then
         if [ -n "$db_to_check" ] && [[  $db_to_check -lt 1 || $db_to_check -gt $db_counter_none ]];then
           echo -e "${RED}\n\nInvalid choice for the selection of the database.\n\n${program_name} is exiting.${NORM}\n\n";
           exit 1;
         fi
       fi

       if [  $comma_ent -ge 1 ];then
         case_check=comma_or_single_db
       else
         if [ -z $db_to_check ];then
           case_check=all
         else
           if [ $db_to_check -eq ${db_counter_none} ];then
             case_check=none
           elif [ $db_to_check -eq ${db_counter} ];then
             case_check=all
           elif [ $db_to_check -lt ${db_counter} ];then
             case_check=comma_or_single_db
           else
             case_check=other
           fi
         fi
       fi
     else
	case_check=all
     fi
       case  $case_check in
         none)
	   write_in_env "DATABASE_CHECK_OPTION" "none"
           multiple_db=1
           db_name_to_check_none=1
           rdbms_counter=0
           mb_set_oracle_homes
           rm -f $running_db_host_list; touch $running_db_host_list
           rm -f $running_db_list; touch $running_db_list
           no_of_databases=$(cat $running_db_list|wc -l)
	   ;;
         all)
	   write_in_env "DATABASE_CHECK_OPTION" "all"
           for db_list in `cat $running_db_list`
           do
             mb_db_names[$rdbms_counter]=$db_list
             rdbms_counter=$(expr ${rdbms_counter} + 1 )
           done
           db_name_to_check=${mb_db_names[0]}
           if [ $rdbms_counter -gt 1 ]
           then
             multiple_db=1
           else
             multiple_db=0
           fi
           rdbms_counter=0
           mb_set_oracle_homes  
           db_name_to_check_all=1
           ;;
         comma_or_single_db)
	   unset print_db_name_list
           if [ `echo $db_to_check|wc -c` -gt 2 ]
           then
             if [ -n "$IFS" ]; then old_ifs=$IFS;IFS=$',';fi;
             for db_to_check_ifs in $db_to_check 
             do
	       if [[  $db_to_check_ifs -lt 1 || $db_to_check_ifs -gt $db_counter_none ]];then
	         echo -e "${RED}\n\nInvalid choice for the selection of the database.\n\n${program_name} is exiting.${NORM}\n\n";
                 exit 1;
               fi
               db_to_check_ifs=$(echo $db_to_check_ifs|sed 's/[a-zA-Z,\*\.;|?/]//g')
               if [[ -n "$db_to_check_ifs" && $db_to_check_ifs -lt $db_counter ]]
               then
      	         db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check_ifs}'p')  
      	         mb_db_names[$rdbms_counter]=$db_name_to_check
      	         #$READ -p "db_name_to_check=$db_name_to_check"
      	         rdbms_counter=$(expr ${rdbms_counter} + 1 )
               fi

	       print_db_name_list="$db_name_to_check $print_db_name_list"
             done
             if [ -n "$old_ifs" ]; then IFS=$old_ifs;else IFS=$'\n';fi;
             db_name_to_check=${mb_db_names[0]}
             multiple_db=1
             rdbms_counter=0
             mb_set_oracle_homes 
             #echo "${mb_db_names[@]}"
           else
      	     db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check}'p')  
      	     mb_db_names[$rdbms_counter]=$db_name_to_check
      	     mb_set_oracle_homes 
      	     multiple_db=0
	     print_db_name_list="$db_name_to_check $print_db_name_list"
           fi
	   write_in_env "DATABASE_CHECK_OPTION" "$print_db_name_list"
           ;;
         *)
	   unset print_db_name_list
           for db_list in `cat $running_db_list`
           do
             mb_db_names[$rdbms_counter]=$db_list
             #echo "${mb_db_names[$rdbms_counter]}"
             rdbms_counter=$(expr ${rdbms_counter} + 1 )
	     print_db_name_list="$db_list $print_db_name_list"	     
           done
           db_name_to_check=${mb_db_names[0]}
           multiple_db=1
           rdbms_counter=0
           db_name_to_check_all=1
           mb_set_oracle_homes 

	   write_in_env "DATABASE_CHECK_OPTION" "$print_db_name_list"
           ;;      
       esac
     elif [[ $no_of_databases -gt 1 && `cat $running_db_list|wc -l` -ge 1 && $db_list_from_env -eq 0 ]]
     then
       for db_list in `cat $running_db_list`
       do
         mb_db_names[$rdbms_counter]=$db_list
         #echo "${mb_db_names[$rdbms_counter]}"
         rdbms_counter=$(expr ${rdbms_counter} + 1 )
       done
       db_name_to_check=${mb_db_names[0]}
       multiple_db=1
       rdbms_counter=0
       mb_set_oracle_homes 
     else
       rdbms_counter=0
       if [[ -n "$no_of_databases" && $no_of_databases -gt 0 ]]
       then
         db_name_to_check=$(cat $running_db_list|sed -n '1p')
         mb_db_names[$rdbms_counter]=$db_name_to_check
       fi
       mb_set_oracle_homes 
       multiple_db=0
     fi

     if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]] && [[ -z $db_name_to_check_all ]]; then remove_unselected_dbs_envfil; fi
  
     #commented for time being because have plan to support multiple version in upgrade
  
     #$READ -p "DB Name selected =$db_name_to_check"  
     #if [[ $upgrade_mode -gt 1 && -e $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out && `cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out|wc -l ` -gt 1 ]]
     #then
     #    echo -e "${RED}you selected multiple version of database which is not supported for upgrade best practice checking. Please select same version databases from list${NORM}\n\n"
     #    echo -e "you selected:-\n\n"
     #    cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
     #    echo -e "\n\n"
     #    #exit 1
     #fi
  
     if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
       printf ". "  	     
     else 
       if [ -n "$db_name_to_check" ]
       then
         #db_name_to_check=$(echo $db_name_to_check|tr '[:upper:]' '[:lower:]')
         if [[ -n "$crs112" && $crs112 -ge 1 ]] 
         then
           db_name_to_check_lower=$(echo $db_name_to_check|tr "[A-Z]" "[a-z]")
           if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
             OLD_OH=$ORACLE_HOME
             ORACLE_HOME=$CRS
             get_dbOwner
             ORACLE_HOME=$OLD_OH
	     if [[ -n "$dbOwner" ]]; then
               db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p")
	     fi
             echo -e "$db_config_fil_write" > $db_config_fil
    	     write_del_rolbk_tmpoutput
             cd $OLD_DIR
             unset OLD_DIR
             if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  
               unset db_config_fil_write
               db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p")
               echo -e "$db_config_fil_write" > $db_config_fil;
             fi;
             unset db_config_fil_write
           else
             $CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p > $db_config_fil
             if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p > $db_config_fil;fi;
           fi
         else
           if [[ $single_instance_run -eq "0" ]] ; then
             if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
               OLD_OH=$ORACLE_HOME
               if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
               get_dbOwner
	       if [[ -n "$dbOwner" ]]; then
                 db_config_fil_write=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT config database -d $db_name_to_check -a")
	       fi
               echo -e "$db_config_fil_write" > $db_config_fil 
               ORACLE_HOME=$OLD_OH
    	       write_del_rolbk_tmpoutput
               cd $OLD_DIR
               unset OLD_DIR
             else
	       OLD_OH=$ORACLE_HOME
	       if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	       export ORACLE_HOME=$ORACLE_HOME;
               $ORACLE_HOME/bin/srvctl$BAT config database -d $db_name_to_check -a > $db_config_fil 
	       ORACLE_HOME=$OLD_OH
             fi
           else
             l_oh="";
             get_ohome_si_oh $db_name_to_check
             echo "ORACLE_HOME=$l_oh" > $db_config_fil
           fi
         fi
       fi
     fi

     for rdbms_install in `cat $HOSTLIST`
     do
       unset invntr_OH
       if [ $rdbms_install = $localnode ]
       then
         if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
           if [[ -n $db_name_to_check ]]; then crs_OH=$(grep -w "DB_NAME = $db_name_to_check" $MASTERFIL|awk '{print $3}'|cut -d '|' -f3); fi
         else 
           if [ $is_windows -eq "0" ] ; then
             if [ -e $db_config_fil ]; then  crs_OH=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME |cut -d: -f2|sed 's/ //g');fi
           else
             if [ -e $db_config_fil ]; then  
               crs_OH=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME |sed 's/ //g'| sed 's|\\|\/|g');
               if [ ! -n "$crs_OH" ] ; then 
                 crs_OH=$(grep -w "Oracle home:" $db_config_fil|grep ^Oracle|sed 's/Oracle home: //g' | sed 's/ //g'  | sed 's|\\|\/|g')
               fi
             fi
           fi
	 fi
         crs_OH=$(echo $crs_OH|cut -d= -f2|sed 's/ //g')
         if [ -z "$crs_OH" ]; then crs_OH=$ORACLE_HOME; fi;
         if [ -n "${invntr_location[$rdbms_counter]}" ]
         then
           if [[ -z "$crs_OH" || ! -d $crs_OH ||  ! -e $crs_OH/bin/oracle ]] && [[ -z "$RAT_ORACLE_HOME" ]]
           then
	     get_set_crs_OH  "$rdbms_install"
	     if [[ -z "$crs_OH" || ! -d $crs_OH ||  ! -e $crs_OH/bin/oracle ]]; then
               if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n $is_oms_installed && $is_oms_installed -eq "1" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]]; then
                 echo
               else
	         if [[ $EM_PROBE_MODE -eq 1 ]]
      	         then
	           EMSG="${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
	           update_probe_xml "ERROR" "GENERIC" "$EMSG"
      	         fi
  	         echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
                 exit 1;
               fi
	     fi
           fi

           if [[ -d $crs_OH || -n "$RAT_ORACLE_HOME" ]]
           then
             if [[ -f $crs_OH/bin/oracle || -n "$RAT_ORACLE_HOME" ]]
             then
               rdbms_installed[$rdbms_counter]=1
               local_invntr_OH=$crs_OH
             else
               rdbms_installed[$rdbms_counter]=0
             fi
           else
             rdbms_installed[$rdbms_counter]=0
           fi

           if [ ${rdbms_installed[$rdbms_counter]} -eq 1 ]
           then
 	     echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
             rbdmsSoftwareOwner=$(ls -l ${local_invntr_OH}/bin/oracle 2>/dev/null|awk '{print $3}')
             #$READ -p "rbdmsSoftwareOwner=$rbdmsSoftwareOwner usern=$usern crsSoftwareOwner=$crsSoftwareOwner" 
             gridUserAllowed=0
             if [[ "$profiles2run" = "clusterware" || "$profiles2run" = "asm" || "$profiles2run" = "clusterware,asm" || "$profiles2run" = "asm,clusterware" ]]
             then
               gridUserAllowed=1  
             fi
             if [[ -n "$crsSoftwareOwner" && -n "$rbdmsSoftwareOwner" && "$crsSoftwareOwner" != "$rbdmsSoftwareOwner" && "$usern" = "$crsSoftwareOwner" && "$usern" != "$root_user" ]] && [[ "$gridUserAllowed" -eq 0 ]]
             then
	       if [[ $EM_PROBE_MODE -eq 1 ]]
      	       then
		 EMSG="You have run ${program_name} as the clusterware software owner. ${program_name} is intended to be run as an RDBMS software owner (eg. oracle with ownership and group eg.,oracle:oinstall).\nPlease run ${program_name} as an RDBMS software owner and with ownership as described above."
		 update_probe_xml "ERROR" "GENERIC" "$EMSG"
      	       fi
               echo -e "${RED}You have run ${program_name} as the clusterware software owner. ${program_name} is intended to be run as an RDBMS software owner (eg., oracle with ownership and group eg., oracle:oinstall)."
               echo -e "\nPlease run ${program_name} as an RDBMS software owner and with ownership as described above.\n${NORM}"
               exit 1
             fi
           else
	     echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
           fi
         else
           rdbms_installed[$rdbms_counter]=0
	   echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
         fi
       else
         if [ -n "${invntr_location[$rdbms_counter]}" ]
         then
           if [ -z "$crs_OH" ]; then crs_OH=$ORACLE_HOME; fi

           $SSHELL $rdbms_install ls -l $crs_OH >/dev/null 2>&1
           remote_rdbms_home_status=$(echo $?)
           if [[ $remote_rdbms_home_status -ne 0 && -z "$RAT_ORACLE_HOME" ]] 
           then
	     get_set_crs_OH  "$rdbms_install"
             $SSHELL $rdbms_install ls -l $crs_OH >/dev/null 2>&1
             remote_rdbms_home_status=$(echo $?)
             if [[ $remote_rdbms_home_status -ne 0 ]]; then
               if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n $is_oms_installed && $is_oms_installed -eq "1" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
                 echo
               else
	         if [[ $EM_PROBE_MODE -eq 1 ]]
      	         then
	           EMSG="${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
	           update_probe_xml "ERROR" "GENERIC" "$EMSG"
      	         fi
                 echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
                 exit 1;
               fi
	     fi
           fi
           if [[ $remote_rdbms_home_status -eq 0 || -n "$RAT_ORACLE_HOME" ]]
           then 
             $SSHELL $rdbms_install ls -l $crs_OH/bin/oracle >/dev/null 2>&1
             remote_oracle_file_status=$(echo $?)
             if [[ $remote_oracle_file_status -ne 0  && -z "$RAT_ORACLE_HOME" ]] 
             then
	       get_set_crs_OH  "$rdbms_install"
               $SSHELL $rdbms_install ls -l $crs_OH/bin/oracle >/dev/null 2>&1
               remote_oracle_file_status=$(echo $?)
	       if [[ $remote_oracle_file_status -ne 0 ]]; then
                 if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n $is_oms_installed && $is_oms_installed -eq "1" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
                   echo
                 else
	           if [[ $EM_PROBE_MODE -eq 1 ]]
      	           then
	             EMSG="${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
	             update_probe_xml "ERROR" "GENERIC" "$EMSG"
      	           fi
                   echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
                   exit 1;
                 fi
	       fi
             fi
             if [[ $remote_oracle_file_status -eq 0  || -n "$RAT_ORACLE_HOME" ]]
             then
               rdbms_installed[$rdbms_counter]=1
             else
               rdbms_installed[$rdbms_counter]=0
             fi
           else
             rdbms_installed[$rdbms_counter]=0
           fi

           if [ ${rdbms_installed[$rdbms_counter]} -eq 1 ]
           then
	     echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
           else
	     echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
           fi
         else
           rdbms_installed[$rdbms_counter]=0
	   echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
         fi
       fi # localnode if ends here
       rdbms_counter=`expr $rdbms_counter + 1`
     done 
     rdbms_counter=0  
  else
     is_rdbms_installed
     echo "is_rdbms_installed was called because CRS was down on local node">>$LOGFIL
     multiple_db=0
  fi
  #$READ -p "stop did not find the RDBMS binaries on"
}

# Added to capture the host name where database is running
#remote_database_code
mb_set_running_hosts ()
{
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do 
    mb_host_name=$(grep ":$db_name_to_check:" $running_db_host_list | awk -F":" '{print $3}');
    if [ -z "$mb_host_name" ]
    then 
      mb_host_name=$localnode
    fi
    mb_running_host[$mb_db_counter]="$mb_host_name"
    if [[ -n $RAT_DEBUG_V ]]
    then
      echo "Running host for $db_name_to_check:*** $mb_host_name";
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
}

check_pdb_password()
{
  pdb_check_password_status=1
  return
  pdb_check_password_count=3
  pdb_check_password_status=0
 
  while [[ $pdb_check_password_count -gt 0  && $pdb_check_password_status -eq 0 ]]
  do
    echo ""
    printf "Enter ${RAT_PDB_USER} user password for $pdb_name pluggable database.${pdb_check_password_count} tries remaining:-"
    tty -s && stty -echo
    $READ -r pdb_sys_password
    tty -s && stty echo
    echo ""
    
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      pdb_check_password_message=$(su $dbOwner -c "echo \"select 'LoginSuccessFull' from dual;\"|$ORACLE_HOME/bin/sqlplus ${RAT_PDB_USER}/$pdb_sys_password@\"${mb_pdb_connect_string[$mb_pdb_counter]}\" as sysdba") 
      write_del_rolbk_tmpoutput
      cd $OLD_DIR
      unset OLD_DIR
    else
      pdb_check_password_message=$(echo "select 'LoginSuccessFull' from dual;"|$ORACLE_HOME/bin/sqlplus ${RAT_PDB_USER}/$pdb_sys_password@"${mb_pdb_connect_string[$mb_pdb_counter]}" as sysdba) 
    fi

    if [ $(echo "$pdb_check_password_message"|grep -wc "LoginSuccessFull") -ge 1 ]
    then
      pdb_check_password_status=1
    else 
      pdb_check_password_status=0
      if [ $pdb_check_password_count -gt 1 ]
      then   
        echo ""
        echo ""
        echo -e "${RED}${RAT_PDB_USER} password is wrong for $pdb_name pluggable database${NORM}" 
      fi
    fi
    pdb_check_password_count=$( expr $pdb_check_password_count - 1)
  done
  if [ $pdb_check_password_status -eq 0 ]
  then
    echo ""
    echo -e "${RED}sys password validation failed for $pdb_name pluggable database. removing from list of databases to check best practices${NORM}"   
  fi
}

mb_set_oracle_homes ()
{
  if [ $no_of_databases -gt 1 ]; then  echo -e "\nSearching out ORACLE_HOME for selected databases.\n";fi
  mb_set_running_hosts; #remote_database_code
  mb_db_counter=0
  mb_db_counter_upgraded=0
  mb_db_counter_need_upgrade=0
  validate_oracle_home_tries=0
  mb_pdb_counter=0

  for db_name_to_check in "${mb_db_names[@]}"
  do 
    printf ". "
    if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
      printf ". "
    else 
      if [[ -n "$crs112" && $crs112 -ge 1 ]]
      then
        db_name_to_check_lower=$(echo $db_name_to_check|tr "[A-Z]" "[a-z]")
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
	  if [[ -n "$dbOwner" ]]; then
            db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p")
	  fi
          echo -e "$db_config_fil_write" > $db_config_fil
    	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
          unset OLD_DIR	
          if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  
            unset db_config_fil_write
            db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p")
            echo -e "$db_config_fil_write" > $db_config_fil;
          fi;
	  unset db_config_fil_write
        else
          $CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p > $db_config_fil
          if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p > $db_config_fil;fi;
        fi
      else
        if [[ $single_instance_run -eq "0" ]] ; then
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            OLD_OH=$ORACLE_HOME
            if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
            get_dbOwner
	    if [[ -n "$dbOwner" ]]; then
              db_config_fil_write=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT config database -d $db_name_to_check -a")
	    fi
            echo -e "$db_config_fil_write" > $db_config_fil 
            ORACLE_HOME=$OLD_OH
    	    write_del_rolbk_tmpoutput
            cd $OLD_DIR
            unset OLD_DIR
	    unset db_config_fil_write
          else
	    OLD_OH=$ORACLE_HOME
	    if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	    export ORACLE_HOME=$ORACLE_HOME
            $ORACLE_HOME/bin/srvctl$BAT config database -d $db_name_to_check -a > $db_config_fil 
	    ORACLE_HOME=$OLD_OH
          fi
        else 
          l_oh="";
          get_ohome_si_oh $db_name_to_check
          echo "ORACLE_HOME=$l_oh" > $db_config_fil
        fi
      fi

      if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
        for mapping in ${hostmap[@]}
        do
          management_host=${mapping%%:*}
          client_host=${mapping#*:}
        
          if [[ `grep -ic "$client_host" $db_config_fil` -ge 1 ]]; then
            sed 's/'$client_host'/'$management_host'/p' $db_config_fil>> $db_config_fil.new
            mv -f $db_config_fil.new $db_config_fil
          else
            tmp_client_host=$(echo $client_host|awk -F"." '{print $1}');
            if [[ `grep -ic "$tmp_client_host" $db_config_fil` -ge 1 ]]; then
              sed 's/'$tmp_client_host'/'$management_host'/p' $db_config_fil>> $db_config_fil.new
              mv -f $db_config_fil.new $db_config_fil
            fi
          fi
        done
      fi
    fi

    #following code to fix the issue raised by DHS
    if [[ -n "$RAT_ORACLE_HOME" && $no_of_databases -eq 1 ]]
    then
      mb_oracle_homes[$mb_db_counter]=$RAT_ORACLE_HOME
    else
      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	mb_oracle_homes[$mb_db_counter]=$(grep -w "DB_NAME = $db_name_to_check" $MASTERFIL|awk '{print $3}'|cut -d '|' -f3)
      else 
        if [ $is_windows -eq "0" ] ; then
          mb_oracle_homes[$mb_db_counter]=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME|cut -d: -f2|cut -d= -f2|sed 's/ //g')
        else
          mb_oracle_homes[$mb_db_counter]=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME|cut -d= -f2|sed 's/ //g' | sed 's|\\|\/|g')
          if [ ! -n "${mb_oracle_homes[$mb_db_counter]}" ] ; then 
             mb_oracle_homes[$mb_db_counter]=$(grep -w "Oracle home:" $db_config_fil|grep ^Oracle|sed 's/Oracle home: //g' | sed 's/ //g'  | sed 's|\\|\/|g')
          fi
        fi
      fi
    fi
    ####

    #below if condition to find $ORACLE_HOME using config database -v option
    if [[ -z "${mb_oracle_homes[$mb_db_counter]}" && -e $db_list_fil_verbose ]]
    then
      mb_oracle_homes[$mb_db_counter]=$(grep -w ${db_name_to_check} $db_list_fil_verbose|awk '{print $2}')
    fi

    if [ -z "${mb_oracle_homes[$mb_db_counter]}" ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
        get_dbOwner
	if [[ -n "$dbOwner" ]]; then
          mb_oracle_homes[$mb_db_counter]=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d ${db_name_to_check}|grep PRKR-1078|awk '{ print \$NF }'")   
	fi
        ORACLE_HOME=$OLD_OH
        write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR
      else
	OLD_OH=$ORACLE_HOME	
	if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	export ORACLE_HOME=$ORACLE_HOME;
        mb_oracle_homes[$mb_db_counter]=$($ORACLE_HOME/bin/srvctl$BAT status database -d ${db_name_to_check}|grep PRKR-1078|awk '{ print $NF }')   
	ORACLE_HOME=$OLD_OH
      fi
    fi

    mb_read_oracle_home "${mb_oracle_homes[$mb_db_counter]}" "$db_name_to_check"

    if [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 0 ]] 
    then
      mb_oracle_homes[$mb_db_counter]=${mb_oracle_homes[$mb_db_counter]}
    else
      mb_validate_oracle_home "$mb_ask_oracle_home"
      mb_oracle_homes[$mb_db_counter]=$mb_ask_oracle_home
    fi

    #echo " ${mb_oracle_homes[$mb_db_counter]}  and mb_db_counter=$mb_db_counter"
    while [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 1 ]] && [ $validate_oracle_home_tries -lt 3 ] && [ $validate_oracle_home_status -eq 0 ]
    do
      validate_oracle_home_tries=$(expr $validate_oracle_home_tries + 1 )
      mb_oracle_homes[$mb_db_counter]=""
      mb_read_oracle_home "${mb_oracle_homes[$mb_db_counter]}" "$db_name_to_check"
      mb_validate_oracle_home "$mb_ask_oracle_home"
      mb_oracle_homes[$mb_db_counter]=$mb_ask_oracle_home
      printf ". "
      #$READ -p "validate_oracle_home_tries=$validate_oracle_home_tries"
    done

    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}

    unset what_db
    if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
      what_db=$(grep "RDBMS_ORACLE_HOME = ${mb_oracle_homes[$mb_db_counter]}|" $MASTERFIL|awk '{print $3}'|cut -d '|' -f2)
    else
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner
	if [[ -n "$dbOwner" ]]; then
          what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
	fi
    	write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR
      else
        what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
      fi
      if [ -z $what_db ]; then
        t_flag="-T";
        for hosts in `cat $HOSTLIST`
        do
          if [[ "$hosts" = "$localnode" ]]; then continue; fi

          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            get_dbOwner "$hosts" "1"
	    if [[ -n "$dbOwner" ]]; then
              what_db=`$SSHELL $t_flag $hosts<<EOF
              cd $dbhome_dir 2>/dev/null;
              export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
              su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF`  		
	    fi
    	    write_del_rolbk_tmpoutput
          else	
            what_db=`$SSHELL $t_flag $hosts<<EOF
            export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
            $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF`  		
          fi
          what_db=$(echo "$what_db"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
          if [[ -n $what_db ]]; then break; fi
        done
      fi
    fi

    if [[ `echo "$what_db"|grep -ic "^1220"` -gt "0" ]]; then what_db="122010"; fi

    export PATH=$ORACLE_HOME/bin:$PATH
    #if [ -n "$RAT_DB" ]; then what_db=$RAT_DB;fi
    check_oh_last_character=$ORACLE_HOME
    if [ -n "$check_oh_last_character" ]
    then 
      if [ `uname -s` = "Linux" ]
      then
        oh_last_character=$(expr substr $check_oh_last_character ${#check_oh_last_character} 1) 
      else
        oh_last_character=""
      fi
      if [[ -n "$oh_last_character" && "$oh_last_character" = "/" && $what_db -lt 111070 ]]; then  mb_oracle_homes[$mb_db_counter]=$(echo ${mb_oracle_homes[$mb_db_counter]}|sed 's/.$//');fi;
    fi
    #ports_find_sid
    #$READ -p "ORACLE_HOME=$ORACLE_HOME"
    mb_database_type[$mb_db_counter]="NORMAL"
    if [ $single_instance_run -eq "1" ] ; then
      mb_oracle_sids[$mb_db_counter]=${mb_db_names[$mb_db_counter]}
    else
      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	mb_oracle_sids[$mb_db_counter]=$(grep -i "${mb_running_host[$mb_db_counter]}.$db_name_to_check.INSTANCE_NAME =" $MASTERFIL|awk '{print $3}')
	if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
	  if [[ -z ${mb_oracle_sids[$mb_db_counter]} ]]; then
	    unset mapped_host
            for mapping in ${hostmap[@]}
            do
              management_host=${mapping%%:*}
              client_host=${mapping#*:}
  
	      short_hostname=`echo "${mb_running_host[$mb_db_counter]}"| tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
              if [[ `echo "$management_host" | grep -ic "${mb_running_host[$mb_db_counter]}"` -ge 1 ]] || [[ `echo "$management_host" | grep -ic "$short_hostname"` -ge 1 ]]; then
                mapped_host=$client_host;
              fi
            done
	  fi
	  mb_oracle_sids[$mb_db_counter]=$(grep -i "$mapped_host.$db_name_to_check.INSTANCE_NAME =" $MASTERFIL|awk '{print $3}')
	  if [[ -z ${mb_oracle_sids[$mb_db_counter]} ]]; then
	    short_mapped_host=`echo "$mapped_host"| tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
	    mb_oracle_sids[$mb_db_counter]=$(grep -i "$short_mapped_host.$db_name_to_check.INSTANCE_NAME =" $MASTERFIL|awk '{print $3}')
	  fi
	fi
	if [[ -z ${mb_oracle_sids[$mb_db_counter]} ]]; then continue; fi
      else
        local_mb_running_host="${mb_running_host[$mb_db_counter]}";
        if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
          for mapping in ${hostmap[@]}
          do
       	    tmp_client_host=""
            management_host=${mapping%%:*}
            client_host=${mapping#*:}
           
            if [[ `echo "$management_host" |grep -ic "$local_mb_running_host"` -ge 1 ]]; then
              tmp_client_host=$(echo $client_host|awk -F"." '{print $1}');
              local_mb_running_host=$tmp_client_host;
            fi 
          done
        fi
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
          get_dbOwner
	  if [[ -n "$dbOwner" ]]; then
            mb_oracle_sids[$mb_db_counter]=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;${ORACLE_HOME}/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null|grep -i "$local_mb_running_host"|head -1|awk '{print \$2}'") 
	  fi
          ORACLE_HOME=$OLD_OH
    	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
          unset OLD_DIR
        else
	  OLD_OH=$ORACLE_HOME
	  if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	  export ORACLE_HOME=$ORACLE_HOME;
          mb_oracle_sids[$mb_db_counter]=$(${ORACLE_HOME}/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null|grep -i "$local_mb_running_host"|head -1|awk '{print $2}') 
          ORACLE_HOME=$OLD_OH
        fi
        #remote_database_code
        if [ -z ${mb_oracle_sids[$mb_db_counter]} ]; then
          t_flag="-T";
          for hosts in `grep -v "$localnode" $HOSTLIST`
          do
            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              OLD_OH=$ORACLE_HOME
              if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
              get_dbOwner $hosts "1"
	      if [[ -n "$dbOwner" ]]; then 
                mb_oracle_sids[$mb_db_counter]=`$SSHELL $t_flag $hosts<<EOF
                cd $dbhome_dir 2>/dev/null;
                export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
                su $dbOwner -c "${ORACLE_HOME}/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null"
EOF`        	
	      fi
              ORACLE_HOME=$OLD_OH
    	      write_del_rolbk_tmpoutput
              cd $OLD_DIR
              unset OLD_DIR
            else
              mb_oracle_sids[$mb_db_counter]=`$SSHELL $t_flag $hosts<<EOF
              export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
              ${ORACLE_HOME}/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null
EOF`        	
            fi
            mb_oracle_sids[$mb_db_counter]=$(echo "${mb_oracle_sids[$mb_db_counter]}"|grep -i "$local_mb_running_host"|head -1|awk '{print $2}')
            if [[ -n ${mb_oracle_sids[$mb_db_counter]} ]]; then break; fi
          done
        fi
      fi
    fi

    export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}

    if [[ $what_db -gt 121000 ]]
    then
      checksysdba     
      mb_checksysdba[$mb_db_counter]=$IS_SYSDBA
      if [[ ${mb_checksysdba[$mb_db_counter]} -eq 1 ]]
      then  
        multipleSqlValue "select value from v\$parameter where name='local_listener'"
        local_listener=$(echo $sqlValue|awk 'BEGIN { FS = "=" }{ print $NF }'|sed 's/[^0-9]*//g'|tr "\013" " ")
        #local_listener=$(echo $sqlValue|awk -F "PORT=" '{print $2}'|sed 's/)//g'|tr "\013" " ")
        #To remove new line and blank space charactor  
        local_listener=$(echo $local_listener|sed 's/ //g')
        multipleSqlValue "select upper(cdb) from v\$database"  
      	
        if [ "$sqlValue" = "YES" ]
        then
      	  mb_database_type[$mb_db_counter]="CDB"
      	  multipleSqlValue "select name from v\$pdbs where open_mode='READ WRITE'"  
      	  sqlValue=$(echo $sqlValue|tr "\013" " ")

          if [[ -n "$RAT_PDBNAMES" && "$RAT_PDBNAMES" = "none" ]]
          then
            sqlValue="" 
          elif  [ -n "$RAT_PDBNAMES" ]
          then 
            sqlValue=$RAT_PDBNAMES
          fi

      	  if [ -z "$RAT_PDB_USER" ]; then RAT_PDB_USER=sys;fi     

      	  for pdb_name in $sqlValue
      	  do  
      	    #if [ "$NOQUESTION" -eq 0 ]
      	    #then    
      	    if [ -z "$db_name_to_check_none" ]
      	    then 
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		get_dbOwner
		if [[ -n "$dbOwner" ]]; then 
		  l_service_name=$(su $dbOwner -c "$ORACLE_HOME/bin/lsnrctl services |grep -iw ${pdb_name}|cut -d'\"' -f2")
		fi
    		write_del_rolbk_tmpoutput
		cd $OLD_DIR
		unset OLD_DIR
	      else
      	        l_service_name=$($ORACLE_HOME/bin/lsnrctl services |grep -iw ${pdb_name}|cut -d'"' -f2)
	      fi
      	      if [ -z "$l_service_name" ] ; then l_service_name=${pdb_name}; fi
      	      mb_pdb_connect_string[$mb_pdb_counter]="(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = ${mb_running_host[$mb_db_counter]})(PORT = ${local_listener})) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ${l_service_name})))"
      	      check_pdb_password
      	    
	      if [ $pdb_check_password_status -eq 1 ]
      	      then 
      	        mb_pdb_names[$mb_pdb_counter]=$pdb_name 
      	        mb_pdb_homes[$mb_pdb_counter]=${mb_oracle_homes[$mb_db_counter]}
      	        mb_pdb_running_host[$mb_pdb_counter]=${mb_running_host[$mb_db_counter]}
      	        mb_pdb_running_sid[$mb_pdb_counter]=$ORACLE_SID
                          
                #commenting this because not asking password for pdbs
      	        #mb_pdb_sys_password[$mb_pdb_counter]=$pdb_sys_password 
      	        mb_pdb_counter=$(expr $mb_pdb_counter + 1)
      	      fi
      	    fi
      	    #else 
      	    #  echo -e "\n${RED}Pluggable database $pdb_name can not checked in silent mode because user needs to key in database password${NORM}\n\n"|tee -a $LOGFIL
      	    #fi
      	  done 
      	  #If there are PDBS for a CDB then set multiple_db=1  
      	  if [[ $multiple_db -eq 0 && $mb_pdb_counter -gt 0 ]]; then multiple_db=1;fi 
      	  #echo "$db_name_to_check.pluggable_databases = $sqlValue" >>$MASTERFIL
        fi
      else
        echo -e "\n${RED} OS authentication to login as sysdba is not enabled so skipping $db_name_to_check for pdb discovery${NORM}\n\n"|tee -a $LOGFIL 
      fi    
    fi  

    #func_what_db
    if [[ $upgrade_mode -eq 2 ]]
    then
      if [[ -n "$what_db" &&  $what_db -eq $targetversion ]]
      then 
        mb_db_names_upgraded[$mb_db_counter_upgraded]=$db_name_to_check
        mb_db_counter_upgraded=$(expr $mb_db_counter_upgraded + 1)
      else
        mb_db_names_need_upgrade[$mb_db_counter_need_upgrade]=$db_name_to_check
        mb_db_counter_need_upgrade=$(expr $mb_db_counter_need_upgrade + 1)
      fi
    elif [ $upgrade_mode -eq 3 ]
    then
      if [[ -n "$what_db" &&  `echo $supportedTargetVersion|grep -icw $what_db` -ge 1 ]]
      then 
        mb_db_names_upgraded[$mb_db_counter_upgraded]=$db_name_to_check
        mb_db_counter_upgraded=$(expr $mb_db_counter_upgraded + 1)
      else
        mb_db_names_need_upgrade[$mb_db_counter_need_upgrade]=$db_name_to_check
        mb_db_counter_need_upgrade=$(expr $mb_db_counter_need_upgrade + 1)
      fi
    fi

    if [  -e $OUTPUTDIR/mb_db_homes_versions_distinct.out ]
    then 
      if [ `grep -c "$what_db" $OUTPUTDIR/mb_db_homes_versions_distinct.out` -lt 1 ]
      then  
        echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_versions_distinct.out
      fi
    else
      echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_versions_distinct.out
    fi

    if [ -z "$db_name_to_check_none"  ]
    then
      if [  -e $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out ]
      then 
        if [ `grep -c "$what_db" $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out` -lt 1 ]
        then  
          echo "$ORACLE_HOME|$what_db|$db_name_to_check">>$OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
        fi
      else
        echo "$ORACLE_HOME|$what_db|$db_name_to_check">>$OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
      fi
    fi
    #$READ -p " ${mb_oracle_homes[$mb_db_counter]} ${mb_oracle_sids[$mb_db_counter]}"
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  #$READ -p  "${mb_oracle_sids[@]} ${mb_oracle_homes[@]} ${mb_db_names[@]}"
  #code to add PDBs to to the end of the list of databases

  mb_pdb_counter=0
  for pdb_name in "${mb_pdb_names[@]}" 
  do
    mb_db_names[$mb_db_counter]=$pdb_name
    mb_oracle_homes[$mb_db_counter]=${mb_pdb_homes[$mb_pdb_counter]}
    mb_database_type[$mb_db_counter]="PDB"
    mb_running_host[$mb_db_counter]=${mb_pdb_running_host[$mb_pdb_counter]}
    #commenting this because not asking password for pdbs
    #mb_db_sys_password[$mb_db_counter]=${mb_pdb_sys_password[$mb_pdb_counter]}
    mb_db_connect_string[$mb_db_counter]=${mb_pdb_connect_string[$mb_pdb_counter]}
    mb_database_role[$mb_db_counter]="PRIMARY"
    mb_oracle_sids[$mb_db_counter]=${mb_pdb_running_sid[$mb_pdb_counter]}
    mb_checksysdba[$mb_db_counter]=1
    mb_db_counter=$(expr $mb_db_counter + 1)
    mb_pdb_counter=$(expr $mb_pdb_counter + 1)
  done

  mb_db_counter=0
  mb_db_counter_upgraded=0
  mb_db_counter_need_upgrade=0
  mb_pdb_counter=0
  #$READ -p "${mb_db_names[@]} ${mb_oracle_homes[@]} ${mb_database_type[@]} ${mb_running_host[$mb_db_counter]} ${mb_database_role[@]}"
  #$READ -p "${mb_database_type[@]}"

  for db_name_to_check_oh in `if [ -r $db_list_fil ]; then cat $db_list_fil;fi`
  do
    if [[ $upgrade_mode -gt 0 && ` echo ${mb_db_names[@]}|grep -icw $db_name_to_check_oh` -lt 1 ]]
    then
      echo "skipping $db_name_to_check_oh database for checking patches because not selected from list">>$LOGFIL
    else
      printf ". "
      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	printf ". "
      else
        if [[ -n "$crs112" && $crs112 -ge 1 ]]
        then
          db_name_to_check_lower=$(echo $db_name_to_check_oh|tr "[A-Z]" "[a-z]")
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            OLD_OH=$ORACLE_HOME
            ORACLE_HOME=$CRS
            get_dbOwner
            ORACLE_HOME=$OLD_OH
	    if [[ -n "$dbOwner" ]]; then
              db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p")
	    fi
            echo -e "$db_config_fil_write" > $db_config_fil
    	    write_del_rolbk_tmpoutput
            cd $OLD_DIR
            unset OLD_DIR
            if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  
              unset db_config_fil_write
              db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check_oh}.db -p")
              echo -e "$db_config_fil_write" > $db_config_fil;
            fi;
          else
            $CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p > $db_config_fil
            if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then $CRS/bin/crsctl status resource ora.${db_name_to_check_oh}.db -p > $db_config_fil;fi;
          fi
        else
          if [[ $single_instance_run -eq "0" ]] ; then
            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              OLD_OH=$ORACLE_HOME
              if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
              get_dbOwner
	      if [[ -n "$dbOwner" ]]; then 
                db_config_fil_write=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT config database -d $db_name_to_check_oh -a")
	      fi
              echo -e "$db_config_fil_write" > $db_config_fil 
              ORACLE_HOME=$OLD_OH
    	      write_del_rolbk_tmpoutput
              cd $OLD_DIR
              unset OLD_DIR
            else
	      OLD_OH=$ORACLE_HOME
	      if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	      export ORACLE_HOME=$ORACLE_HOME
              $ORACLE_HOME/bin/srvctl$BAT config database -d $db_name_to_check_oh -a > $db_config_fil 
	      ORACLE_HOME=$OLD_OH
            fi
          else 
            l_oh="";
            get_ohome_si_oh $db_name_to_check_oh
            echo "ORACLE_HOME=$l_oh" > $db_config_fil
          fi
        fi
      fi

      #following code to fix the issue raised by DHS
      if [[ -n "$RAT_ORACLE_HOME" && `cat $db_list_fil|wc -l` -eq 1 ]]
      then
        export ORACLE_HOME=$RAT_ORACLE_HOME
      else
	if [[ $oracle_restart -eq "0" ]] ; then
          if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
            export ORACLE_HOME=$(grep -w "DB_NAME = $db_name_to_check_oh" $MASTERFIL|awk '{print $3}'|cut -d '|' -f3)
          else 
            if [ $is_windows -eq "0" ] ; then
              export ORACLE_HOME=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME|cut -d: -f2|cut -d= -f2|sed 's/ //g')
            else
              export ORACLE_HOME=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME|cut -d= -f2|sed 's/ //g' | sed 's|\\|\/|g')
              if [ ! -n "$ORACLE_HOME" ] ; then 
                ORACLE_HOME=$(grep -w "Oracle home:" $db_config_fil|grep ^Oracle|sed 's/Oracle home: //g' | sed 's/ //g'  | sed 's|\\|\/|g')
              fi
            fi
	  fi
        fi
      fi
      #####
      #below if condition to find $ORACLE_HOME using config database -v option
      if [[ -z "${ORACLE_HOME}" && -e $db_list_fil_verbose ]]
      then
        export ORACLE_HOME=$(grep -w ${db_name_to_check_oh} $db_list_fil_verbose|awk '{print $2}')
      fi

      if [ -z "${ORACLE_HOME}" ]
      then
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
          get_dbOwner
	  if [[ -n "$dbOwner" ]]; then
            export ORACLE_HOME=$(su $dbOwner -c "export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl$BAT status database -d ${db_name_to_check_oh}|grep PRKR-1078|awk '{ print \$NF }'")   
	  fi
	  if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$OLD_OH; fi
    	  write_del_rolbk_tmpoutput
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  OLD_OH=$ORACLE_HOME
          if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	  export ORACLE_HOME=$ORACLE_HOME 
          export ORACLE_HOME=$($ORACLE_HOME/bin/srvctl$BAT status database -d ${db_name_to_check_oh}|grep PRKR-1078|awk '{ print $NF }')   
	  if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$OLD_OH; fi
	fi
      fi

      mb_read_oracle_home "$ORACLE_HOME" "$db_name_to_check_oh"

      if [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 0 ]] 
      then
        echo "Do nothing" >/dev/null 2>&1
      else
        mb_validate_oracle_home "$mb_ask_oracle_home"
        export ORACLE_HOME=$mb_ask_oracle_home
      fi
      while [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 1 ]] && [ $validate_oracle_home_tries -lt 3 ] && [ $validate_oracle_home_status -eq 0 ]
      do
        validate_oracle_home_tries=$(expr $validate_oracle_home_tries + 1 )
        ORACLE_HOME=""
        mb_read_oracle_home "$ORACLE_HOME" "$db_name_to_check_oh"
        mb_validate_oracle_home "$mb_ask_oracle_home"
        export ORACLE_HOME=$mb_ask_oracle_home
        printf ". "
      done

      validate_oracle_home_tries=0
      unset what_db
      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
        what_db=$(grep "RDBMS_ORACLE_HOME = $ORACLE_HOME|" $MASTERFIL|awk '{print $3}'|cut -d '|' -f2)
      else
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          get_dbOwner
	  if [[ -n "$dbOwner" ]]; then 
            what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
	  fi
    	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
          unset OLD_DIR
        else
          what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
        fi
        if [ -z $what_db ]; then
          t_flag="-T";
          for hosts in `cat $HOSTLIST`
          do
            if [[ "$hosts" = "$localnode" ]]; then continue; fi

            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              get_dbOwner "$hosts" "1"
	      if [[ -n "$dbOwner" ]]; then
                what_db=`$SSHELL $t_flag $hosts<<EOF
                cd $dbhome_dir 2>/dev/null;
                export ORACLE_HOME=$ORACLE_HOME
                su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF`    		
	      fi
    	      write_del_rolbk_tmpoutput
            else
              what_db=`$SSHELL $t_flag $hosts<<EOF
              export ORACLE_HOME=$ORACLE_HOME
              $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF`    		
            fi
            what_db=$(echo "$what_db"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
            if [[ -n $what_db ]]; then break; fi
          done
        fi
      fi

      if [ -n "$what_db" ]; then echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_distinct.out;fi
      echo "$what_db">>$OUTPUTDIR/mb_db_versions_distinct.out
      mb_db_counter=$(expr $mb_db_counter + 1)
    fi
  done
  mb_db_counter=0
  echo -e "\n"
  mb_set_oracle_home_version_distinct 
  #$READ -p  "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} ${mb_oracle_homes_version_distinct[@]}"
}

mb_set_oracle_home_version_distinct ()
{
  mb_db_counter=0
  for mb_db_version in `if [ -e $OUTPUTDIR/mb_db_versions_distinct.out ]; then cat $OUTPUTDIR/mb_db_versions_distinct.out|sort -u;fi;`
  do
    mb_oracle_versions_distinct[$mb_db_counter]=$mb_db_version
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  mb_db_counter=0

  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "1" ]]; then
    sed -e "s/RDBMS_ORACLE_HOME = .*//g" $MASTERFIL > $MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
  fi

  for mb_db_home in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f1|sort -u;fi;`
  do
    unset dbOwner 
    unset oh_available_on_host
    unset what_db
    mb_oracle_homes_distinct[$mb_db_counter]=$mb_db_home
    if [ $OFFLINE -eq 0 ]
    then
      if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 ]]; then
	what_db=$(grep "RDBMS_ORACLE_HOME = ${mb_db_home}|" $MASTERFIL|head -1|awk -F'|' '{print $2}')
      else
	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
	  what_db=$(grep "RDBMS_ORACLE_HOME = ${mb_db_home}|" $MASTERFIL|head -1|awk -F'|' '{print $2}')
	else
          export ORACLE_HOME=$mb_db_home
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            get_dbOwner
	    if [[ -n "$dbOwner" ]]; then 
              what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
	    fi
    	    write_del_rolbk_tmpoutput
            cd $OLD_DIR
            unset OLD_DIR
          else
            what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
          fi
          if [[ -n $what_db ]]; then
            oh_available_on_host=$localnode;
          fi

          t_flag="-T";
          for hosts in `cat $HOSTLIST`
          do
	    unset t_what_db
            if [[ $localnode != $hosts ]]; then
              if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                get_dbOwner "$hosts" "1"
		if [[ -n "$dbOwner" ]]; then
                  t_what_db=$($SSHELL $t_flag $hosts $bash_scr <<EOF
                  cd $dbhome_dir 2>/dev/null; \
                  export ORACLE_HOME=$ORACLE_HOME; \
                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF
)
		fi
		write_del_rolbk_tmpoutput
              else 
                t_what_db=$($SSHELL $t_flag $hosts $bash_scr <<EOF
                export ORACLE_HOME=$ORACLE_HOME;\
                $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF
)
              fi
              t_what_db=$(echo "$t_what_db"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
              if [[ -n $t_what_db ]]; then
                what_db=$t_what_db
                get_dbOwner "$hosts" "1";
                oh_available_on_host=${oh_available_on_host},${hosts};
		write_del_rolbk_tmpoutput
              fi
            fi
          done

          oh_available_on_host=$(echo "$oh_available_on_host"|sed 's/^,//g'|sed 's/,$//g')

          if [[ -z $dbOwner && -z $oh_available_on_host ]]; then get_dbOwner "" "1"; oh_available_on_host=$localnode; write_del_rolbk_tmpoutput; fi;  oracle_home_owner[$mb_db_counter]=$dbOwner;
          echo "RDBMS_ORACLE_HOME = $mb_db_home|${what_db}|${oracle_home_owner[$mb_db_counter]}|${oh_available_on_host}">>$MASTERFIL
	fi
      fi
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done

  multiple_oracle_homes=$mb_db_counter
  mb_db_counter=0
  for mb_db_version in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f2;fi`
  do
    mb_db_versions_all[$mb_db_counter]=$mb_db_version
    mb_db_counter=$(expr $mb_db_counter + 1)
  done

  mb_db_counter=0 
  for mb_db_home_version in `if [ -e $OUTPUTDIR/mb_db_homes_versions_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f1|sort -u;fi;`
  do
    mb_oracle_homes_version_distinct[$mb_db_counter]=$(grep $mb_db_home_version "$OUTPUTDIR/mb_db_homes_versions_distinct.out"|cut -d'|' -f2)
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  mb_db_counter=0
}

mb_rdbms_stack_status ()
{
  mb_db_counter=0

  for db_name_to_check in "${mb_db_names[@]}"
  do
    printf ". "
    #reinitializing database password check counter for each database
    WRNDBPWD=0
    mb_skip[$mb_db_counter]=0;

    stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then new_stack_status=$TMP_OUTPUT/stack_status_${db_name_to_check}.out; fi
    if [ $upgrade_mode -eq 2 ]
    then
      if [[ -n "${mb_db_names_upgraded[@]}" && ` echo ${mb_db_names_upgraded[@]}|grep -icw $db_name_to_check` -ge 1 ]]
      then
        its_upgraded=0
        mb_skip[$mb_db_counter]=1;
      else
        its_upgraded=0
      fi
    elif [ $upgrade_mode -eq 3 ]
    then 
      if [[ -n "${mb_db_names_upgraded[@]}" && ` echo ${mb_db_names_upgraded[@]}|grep -icw $db_name_to_check` -ge 1 ]]
      then
        its_upgraded=0
      else
        its_upgraded=0
        mb_skip[$mb_db_counter]=1;
      fi
    else
      its_upgraded=0
    fi

    if [[ -z "$db_name_to_check_none" && $its_upgraded -eq 0 ]]
    then
      if [[ $oracle_restart -eq "0" ]]
      then	
        if [ -z "$RAT_ORACLE_HOME" ]
        then  
          export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
        else
          export ORACLE_HOME=$RAT_ORACLE_HOME
        fi
      fi
      #Following if block is to set ORACLE_SID even database is not registered in OCR.
      if [ -n "${mb_oracle_sids[$mb_db_counter]}" ]
      then
        export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
      else
        mb_oracle_sids[$mb_db_counter]=$ORACLE_SID
        export ORACLE_SID
      fi
      export PATH=$PATH:$ORACLE_HOME/bin
      checksysdba
      mb_checksysdba[$mb_db_counter]=$IS_SYSDBA 
      #$READ -p "IS_SYSDBA=${mb_checksysdba[$mb_db_counter]}"
      
      if [[ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
      then 
        if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] && [[ -n "$daemon_init_mode" && $daemon_init_mode -eq 0 ]] 
        then
          nosysdba
          mb_sysdba_user[$mb_db_counter]=$DBUSR
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          mb_sysdba_pswd[$mb_db_counter]=$DBPWD
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi

 	  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
	    printf ". "
	  else 
            if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
            then
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	        get_dbOwner
	        chg_files_for_usr "new_stack_status" "$new_stack_status"

	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	        su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
    	        set head off
    	        set lines 80
    	        set feedback off
                set timing off    
	        set serveroutput on
	        spool $new_stack_status
	        select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	        spool off
	        exit
EOF
"
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	        move_files "$new_stack_status" "$stack_status"

    		write_del_rolbk_tmpoutput
	        cd $OLD_DIR
	        unset OLD_DIR
	      else 
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	        $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
    	        set head off
    	        set lines 80
    	        set feedback off
                set timing off    
	        set serveroutput on
	        spool $stack_status
	        select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	        spool off
	        exit
EOF
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	      fi
            else #remote_database_code
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	        TMP_SSFIL=$TMP_OUTPUT/stack_status_${db_name_to_check}.log
	        get_dbOwner "${mb_running_host[$mb_db_counter]}" "1"
	        chg_files_for_usr "TMP_SSFIL" "$TMP_SSFIL"

	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
	        cd "$dbhome_dir"; \
                export ORACLE_HOME=$ORACLE_HOME
                export ORACLE_SID=$ORACLE_SID; \
	        su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	        set head off
	        set lines 80
	        set feedback off
                set timing off 
	        set serveroutput on
	        spool $TMP_SSFIL
	        select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\\\\\$instance;
	        spool off
	        exit
EOF
"
EOF2
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	        write_del_rolbk_tmpoutput
	      else 
	        TMP_SSFIL=$RTEMPDIR/stack_status_${db_name_to_check}.log
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
                export ORACLE_HOME=$ORACLE_HOME
                export ORACLE_SID=$ORACLE_SID; \
	        $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	        set head off
	        set lines 80
	        set feedback off
                set timing off 
	        set serveroutput on
	        spool $TMP_SSFIL
	        select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	        spool off
	        exit
EOF
EOF2
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	      fi
              $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SSFIL $stack_status >/dev/null 2>&1
            fi #end of localnode if
	  fi
          printf ". . . . "
        else
          unset mb_db_names[$mb_db_counter]
          echo -e "\nOS authentication not enabled and asking database password not possible in silent mode so dropping $db_name_to_check from list to check best practices\n">>$LOGFIL  
        fi #end of NOQUESTION if
      else
        mb_sysdba_user[$mb_db_counter]=1
        mb_sysdba_pswd[$mb_db_counter]=1

 	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
	  printf ". "
	else 
          if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
          then
  	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      get_dbOwner
	      chg_files_for_usr "new_stack_status" "$new_stack_status"

	      su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off 
	      set serveroutput on
	      spool $new_stack_status
	      select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	      spool off
	      exit
EOF
"
	      move_files "$new_stack_status" "$stack_status"
    	      write_del_rolbk_tmpoutput
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off 
	      set serveroutput on
	      spool $stack_status
	      select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	      spool off
	      exit
EOF
	    fi
          else #remote_database_code
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      TMP_SSFIL=$TMP_OUTPUT/stack_status_${db_name_to_check}.log
	      get_dbOwner "${mb_running_host[$mb_db_counter]}"
	      chg_files_for_usr "TMP_SSFIL" "$TMP_SSFIL"

              $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
              export ORACLE_HOME=$ORACLE_HOME
              export ORACLE_SID=$ORACLE_SID; \
	      cd "$dbhome_dir"; \
	      su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off
	      set serveroutput on
	      spool $TMP_SSFIL
	      select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\\\\\$instance;
	      spool off
	      exit
EOF
"
EOF2
    	      write_del_rolbk_tmpoutput
	      cd $OLD_DIR
  	      unset OLD_DIR
	    else
	      TMP_SSFIL=$RTEMPDIR/stack_status_${db_name_to_check}.log
              $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
              export ORACLE_HOME=$ORACLE_HOME
              export ORACLE_SID=$ORACLE_SID; \
	      $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off
	      set serveroutput on
	      spool $TMP_SSFIL
	      select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	      spool off
	      exit
EOF
EOF2
	    fi
            $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SSFIL $stack_status >/dev/null 2>&1
	  fi
	fi
	printf ". . . . "
      fi
    elif [[ -n "$db_name_to_check_none" && $db_name_to_check_none -eq 1 ]] || [ $its_upgraded -eq 1 ]
    then
      if [ -z "$RAT_ORACLE_HOME" ]
      then  
        export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
      else
        export ORACLE_HOME=$RAT_ORACLE_HOME
      fi
      export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
      checksysdba
      mb_checksysdba[$mb_db_counter]=$IS_SYSDBA 
      if [[ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
      then 
        if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] && [[ -n "$daemon_init_mode" && $daemon_init_mode -eq 0 ]] 
        then     
          nosysdba
          mb_sysdba_user[$mb_db_counter]=$DBUSR
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          mb_sysdba_pswd[$mb_db_counter]=$DBPWD
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi

	  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
	    printf ". "
	  else
            if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
            then
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	        get_dbOwner
	        chg_files_for_usr "new_stack_status" "$new_stack_status"

	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	        su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	        set head off
	        set lines 80
	        set feedback off
                set timing off
	        set serveroutput on
	        spool $new_stack_status
	        select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	        spool off
	        exit
EOF
"
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	        move_files "$new_stack_status" "$stack_status"
    	        write_del_rolbk_tmpoutput
	        cd $OLD_DIR
	        unset OLD_DIR
	      else
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	        $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	        set head off
	        set lines 80
	        set feedback off
                set timing off
	        set serveroutput on
	        spool $stack_status
	        select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	        spool off
	        exit
EOF
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	      fi
            else #remote_database_code
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	        TMP_SSFIL=$TMP_OUTPUT/stack_status_${db_name_to_check}.log
	        get_dbOwner "${mb_running_host[$mb_db_counter]}"
	        chg_files_for_usr "TMP_SSFIL" "$TMP_SSFIL"

	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
	        cd "$dbhome_dir";
                export ORACLE_HOME=$ORACLE_HOME
                export ORACLE_SID=$ORACLE_SID; \
	        su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	        set head off
	        set lines 80
	        set feedback off
                set timing off
	        set serveroutput on
	        spool $TMP_SSFIL
	        select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\\\\\$instance;
	        spool off
	        exit
EOF
"
EOF2
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	        write_del_rolbk_tmpoutput
	        cd $OLD_DIR
	        unset OLD_DIR
	      else
	        TMP_SSFIL=$RTEMPDIR/stack_status_${db_name_to_check}.log
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
                export ORACLE_HOME=$ORACLE_HOME
                export ORACLE_SID=$ORACLE_SID; \
	        $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	        set head off
	        set lines 80
	        set feedback off
                set timing off
	        set serveroutput on
	        spool $TMP_SSFIL
	        select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	        spool off
	        exit
EOF
EOF2
	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	      fi
              #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
              $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SSFIL $stack_status >/dev/null 2>&1
            fi #end of localnode if
	  fi
          printf ". . . . "
        else
          unset mb_db_names[$mb_db_counter]
          echo -e "\nOS authentication not enabled and asking database password not possible in silent mode so dropping $db_name_to_check from list to check best practices\n">>$LOGFIL  
        fi  #end of NOQUESTION if 
      else
	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
	  printf ". "
	else
          mb_sysdba_user[$mb_db_counter]=1
          mb_sysdba_pswd[$mb_db_counter]=1
          if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
          then
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      get_dbOwner
	      chg_files_for_usr "new_stack_status" "$new_stack_status"

	      su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off 
	      set serveroutput on
	      spool $new_stack_status
	      select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	      spool off
	      exit
EOF
"
	      move_files "$new_stack_status" "$stack_status"
    	      write_del_rolbk_tmpoutput
	      cd $OLD_DIR
	      unset OLD_DIR
	    else 
	      $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off 
	      set serveroutput on
	      spool $stack_status
	      select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	      spool off
	      exit
EOF
	    fi
          else #remote_database_code
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      TMP_SSFIL=$TMP_OUTPUT/stack_status_${db_name_to_check}.log
	      get_dbOwner ${mb_running_host[$mb_db_counter]}
	      chg_files_for_usr "TMP_SSFIL" "$TMP_SSFIL"

              $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
              export ORACLE_HOME=$ORACLE_HOME
              export ORACLE_SID=$ORACLE_SID; \
	      cd "$dbhome_dir"; \
	      su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off
	      set serveroutput on
	      spool $TMP_SSFIL
	      select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\\\\\$instance;
	      spool off
	      exit
EOF
"
EOF2
    	      write_del_rolbk_tmpoutput
	      cd $OLD_DIR
	      unset OLD_DIR
	    else 
	      TMP_SSFIL=$RTEMPDIR/stack_status_${db_name_to_check}.log
              $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
              export ORACLE_HOME=$ORACLE_HOME
              export ORACLE_SID=$ORACLE_SID; \
	      $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off
	      set serveroutput on
	      spool $TMP_SSFIL
	      select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	      spool off
	      exit
EOF
EOF2
	    fi
            $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SSFIL $stack_status >/dev/null 2>&1
          fi
	fi
	printf ". . . . "
      fi #end os IS_SYSDBA if
    fi #end of first if in this for loop
    #fi
    #echo "stack_status: ${mb_running_host[$mb_db_counter]}"
    #cat $stack_status
    mb_db_counter=$(expr $mb_db_counter + 1)
    #$READ -p "stop here"

    if [[ $olsnodes_ssh_disabled -eq 1 ]];
    then
      TMP_STKFILE=$(dirname $stack_status)/.$(basename $stack_status);
      replacement=0
      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*};
        client_host=${mapping#*:};
	if [[ -e $stack_status ]]; then
          tag=`grep -ic "$client_host" $stack_status`;
          if [[ $tag -eq 1 ]]; then
            str=`grep "$client_host" $stack_status`;
            echo $str | sed 's/'$client_host'/'$management_host'/g' >> $TMP_STKFILE
            replacement=1
          fi
	fi
      done
      if [[ $replacement -eq 1 ]]
      then
        rm -rf $stack_status;
        mv -f $TMP_STKFILE $stack_status;
        rm -rf $TMP_STKFILE;
      fi
    fi
  done
  mb_db_counter=0
  printf ""
}

#db_name_to_check=$(echo $db_name_to_check|tr '[:upper:]' '[:lower:]')
is_asm_installed_crs ()
{
  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then return; fi

  #search_invntr_platform
  asm_counter=0
  asm_config_fil=$INPUTDIR/asm_config.out
  if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]]
  then
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$CRS
	get_dbOwner
	ORACLE_HOME=$OLD_OH
	crs_AH=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config asm |grep -i home |awk '{print \$3}'")
    	write_del_rolbk_tmpoutput
	cd $OLD_DIR
	unset OLD_DIR
      else
        crs_AH=$($CRS/bin/srvctl$BAT config asm |grep -i home |awk '{print $3}')
      fi
      #in 12102,above command output format chagned so making CRS_HOME to ASM_HOME 
      if [[ -n "$crs_AH" && "$crs_AH" = "<CRS" ]]; then crs_AH=$CRS;fi  
    fi
    for asm_install in `cat $HOSTLIST`
    do
      unset invntr_AH
      if [ $asm_install = $localnode ]
      then
	if [[ -n "$crs112" && $crs112 -eq 0 ]]; then 
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS	 
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    crs_AH=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $asm_install|awk '{print \$2}'")
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    crs_AH=$($CRS/bin/srvctl$BAT config asm -n $asm_install|awk '{print $2}')
	  fi
	  #if [[ -n "${invntr_location[$asm_counter]}" && -n "$crs_AH" ]]
	  #then
	  #  invntr_AH=$(cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep $crs_AH|awk '{print $3}'|cut -d= -f2|sed 's/\"//g' )
	  #  if [[ $invntr_AH = $crs_AH  && $crs112 -eq 0 ]] 
	  #  then
        fi
	if [[ -d $crs_AH || -n "$RAT_ASM_HOME" ]]
	then
	  if [[ -f $crs_AH/bin/oracle || -n "$RAT_ASM_HOME" ]]
	  then
	    asm_installed[$asm_counter]=1
	    local_invntr_AH=$crs_AH
	  else
	    asm_installed[$asm_counter]=0
	  fi
	else
	  asm_installed[$asm_counter]=0
	fi
	# else
	#   asm_installed[$asm_counter]=0
	# fi
	if [ ${asm_installed[$asm_counter]} -eq 1 ]
	then
	  echo "$asm_install.ASM_INSTALLED = 1" >>$MASTERFIL
	else
	  echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	fi
	#else
	#    asm_installed[$asm_counter]=0
	#    echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	#fi
      else
	if [[ -n "$crs112" &&  $crs112 -eq 0 ]]; then 
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS	 
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    crs_AH=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $asm_install|awk '{print \$2}'");
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    crs_AH=$($CRS/bin/srvctl$BAT config asm -n $asm_install|awk '{print $2}');
	  fi
        fi
	#if [[ -n "${invntr_location[$asm_counter]}" && -n "$crs_AH" ]]
	#then
	#  invntr_AH=$(ssh $asm_install cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep $crs_AH|awk '{print $3}'|cut -d= -f2|sed 's/\"//g' )
	#  if [[ $invntr_AH = $crs_AH && $crs112 -eq  0 ]]
	#  then
        $SSHELL $asm_install ls -l $crs_AH >/dev/null 2>&1
        if [[ $? -eq 0  || -n "$RAT_ASM_HOME" ]]
        then 
          $SSHELL $asm_install ls -l $crs_AH/bin/oracle >/dev/null 2>&1
          if [[ $? -eq 0 || -n "$RAT_ASM_HOME" ]]
          then
       	    asm_installed[$asm_counter]=1
          else
       	    asm_installed[$asm_counter]=0
          fi
        else
          asm_installed[$asm_counter]=0
        fi
	#else
	#  asm_installed[$asm_counter]=0
	#fi
	if [ ${asm_installed[$asm_counter]} -eq 1 ]
	then
	  echo "$asm_install.ASM_INSTALLED = 1" >>$MASTERFIL
	else
	  echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	fi
	#else
	#  asm_installed[$asm_counter]=0
	#  echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL   
	#fi
      fi #localnode if ends here
      asm_counter=`expr $asm_counter + 1`
    done 
    asm_counter=0  
  else
    is_asm_installed
    echo "is_asm_installed was called because CRS was down on local node">>$LOGFIL
  fi
}

#is_exalogic_machine
#In exalogic we dont check statck status. This function initializes all varia bles
func_init_arrays ()
{
  if [ $OFFLINE -eq "0" ] ; then touch $ORCLENVFIL; fi;
  crs_installed=0
  stack_counter=0 
  for stack in `cat $HOSTLIST`
  do
    stack_crs_up[$stack_counter]=0
    stack_dbinst_up[$stack_counter]=0
    stack_asm_up[$stack_counter]=0
    if [[ -n "$is_exalytics_machine" &&  "$is_exalytics_machine" -eq 0 ]];then rdbms_installed[$stack_counter]=0;fi
    crs_installed[$stack_counter]=0
    stack_counter=$(expr $stack_counter + 1)
  done
  stack_counter=0
}


#this function is to check the CRS and RDBMS instance status in entire cluster.
#CRS check swill executed if CRS is and Database checks will be executed if 
#rDBMS instance is up and that too on individual node
func_stack_status ()
{
  if [[ ! -n "$is_fmw_machine" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
    if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
      echo ""
    else
      echo -e "\nChecking Status of Oracle Software Stack - Clusterware, ASM, RDBMS\n"
      printf ". "
    fi
  fi

  mb_rdbms_stack_status

  #$READ -p "IS_SYSDBA=$IS_SYSDBA"
  echo "MULTIPLE_DATABASE = $multiple_db" >>$MASTERFIL
  stack_counter=0
  for stack in `cat $HOSTLIST`
  do
    qstack=$stack
    if [[ $olsnodes_ssh_disabled -eq 1 ]];
    then
      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*};
        client_host=${mapping#*:};
        if [ $stack = $management_host ]; then qstack=$client_host; qstack=${qstack%%.*}; fi
      done	
    fi

    printf ". "

    if [ $stack = $localnode ]
    then
      if [ $is_windows -eq "1" ] ; then
        if [ -n "${invntr_location[$stack_counter]}" ]
        then
          oraInventoryFile="${invntr_location[$stack_counter]}/ContentsXML/inventory.xml";
          oraInventoryFile=`echo "$oraInventoryFile"|sed 's/ /\ /'`;
          if [[ -e $oraInventoryFile ]]
          then
            if [ -n "$RAT_EMAGENT_HOME" ]
            then
              emhome=$RAT_EMAGENT_HOME
            else
              emhome=`grep "HOME NAME=" "$oraInventoryFile"|grep agent| grep core|head -1|sed 's/.*LOC="//'|sed 's/" TYPE.*//'`;
            fi
            if [ -n "$RAT_EMAGENT_INST" ]
            then
              EMAGENT_INST=$RAT_EMAGENT_INST
            else
              EMAGENT_INST=`grep "HOME NAME=" "$oraInventoryFile"|grep agent|grep core|head -1|sed 's/.*LOC="//'|sed 's/" TYPE.*//'|sed 's/core.*//'`;
              EMAGENT_INST="$EMAGENT_INST\agent_inst"
            fi
            if [ -n "$emhome" ]
            then
              is_emagent_installed=1;
              echo "${stack}.EMAGENT_INSTALLED = 1" >>$MASTERFIL
              echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
              echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
            else
              is_emagent_installed=0;
              echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
              emhome="";
              EMAGENT_INST="";
              echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
              echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
            fi
          else
            is_emagent_installed=0;
            echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
            emhome="";
            EMAGENT_INST="";
            echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
            echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
          fi
        else
          is_emagent_installed=0;
          echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
          emhome="";
          EMAGENT_INST="";
          echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
          echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
        fi
      else # not windows
	if [[ -e $EMHOMEVERSIONFIL && `grep -wc "agent_inst" $EMHOMEVERSIONFIL` -gt 0 ]];then
	  printf ". "
	else
	  if [[ `/bin/uname` = "Linux" ]]; then EMHOMEVERSIONFIL="$EMHOMEVERSIONFIL2"; fi
	fi
        if [[ -e $EMHOMEVERSIONFIL && `grep -wc "agent_inst" $EMHOMEVERSIONFIL` -gt 0 ]];then
          is_emagent_installed=1;
          #emhome=`cat  $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d':' -f2`

	  selectedemhome=""
	  selectedEMAGENT_INST=""

          for emline in `cat $EMHOMEVERSIONFIL|grep -w "agent_inst"`
          do
	    emhome=`echo $emline|cut -d ':' -f1|head -1`
	    EMAGENT_INST=`echo $emline|cut -d ':' -f2|head -1`
	    if [[ -d "$emhome" && -e "$emhome/bin/emctl" ]]
	    then
	      selectedemhome=$emhome
              selectedEMAGENT_INST=$EMAGENT_INST
              valid_installation=1
              if [[ -e "$OMS_HOME/install/eminstall.info" ]]; then
	        oms_em=`grep AGENT_HOME= $OMS_HOME/install/eminstall.info|awk -F"=" '{print $2}'|tr -d '\n'`;
                if [[ "$oms_em" = "$emhome" ]]
                then
                  break
                fi
              fi
	    fi
          done
	
	  emhome=$selectedemhome
	  EMAGENT_INST=$selectedEMAGENT_INST

          if [ -n "$RAT_EMAGENT_HOME" ]
          then
            emhome=$RAT_EMAGENT_HOME
          fi

          if [ -n "$RAT_EMAGENT_INST" ]
          then
            EMAGENT_INST=$RAT_EMAGENT_INST
          fi

          EMAGENT_UP=0

          if [[ -e $emhome/bin/emctl$BAT ]]; then
	    get_agentOwner

	    if [[ $usern != $agentOwner &&  -z "$RAT_ROOT_RUN" ]]
	    then
	      if [[ -n $run_profile && $run_profile -eq "0" ]]; then
	      	if [[ -n $exclude_profile && $exclude_profile -eq "0" ]]; then
	      	  exclude_profile=1
	      	  internal_profile_set=1
	      	  profiles2exclude="emagent"
	          set_profile_run
	      	else
	          if [ `echo $profiles2exclude|grep -ic "emagent"` -eq 0 ]
	          then
	       	    profiles2exclude="$profiles2exclude,emagent"
                    set_profile_run
	          fi
	      	fi
	      else
	      	if [ `echo $profiles2run|grep -ic "emagent"` -gt 0 ]
	      	then
	      	  echo -e "${RED}\n\nWARNING! emagent profile needs to be run only as emagent owner or root.${NORM}\n\n"; 
	      	fi
	      fi
	    fi

	    if [ $usern = $agentOwner ]
            then
	      all_os_users=$(ps -ef |grep ora_pmon|grep -v grep|$AWK '{print $2}')
	      for os_user in $(echo -e "$all_os_users")
	      do
	        os_user=$(ps -o user= -p $os_user)
	        is_same_user=$(echo -e "${all_os_usernames}"|grep -ic $os_user)
	        if [ $is_same_user -eq 0 ];then  all_os_usernames=$(echo $all_os_usernames $os_user);fi
	      done

	      if [ `echo -e "${all_os_usernames}"|grep -ic $usern` -eq 0 ]
	      then
	        if [[ -n $run_profile && $run_profile -eq "0" ]]; then
	          run_profile=1
	          internal_profile_set=1
	          profiles2run="emagent"
                  set_profile_run
	        fi
	      fi
            fi

	    if [ $usern = $agentOwner ]
            then
	      EMAGENT_STATUS=`$emhome/bin/emctl$BAT status agent 2>>$ERRFIL`
              if [[ `echo "$EMAGENT_STATUS"|tail -1|grep -ic "Agent is Running and Ready"` -gt 0 ]]; then
                EMAGENT_UP=1	
	      fi
	      mb_em_home_version=`echo "$EMAGENT_STATUS"|grep  "Agent Version"|$AWK -F":" '{print $2}'|sed 's/ //g'`
	      mb_em_home_version=`echo $mb_em_home_version |sed 's/\.//g'`
	      echo "${stack}.EMAGENT_VERSION = $mb_em_home_version" >>$MASTERFIL
            fi

	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              EMAGENT_STATUS=`su $agentOwner -c "$emhome/bin/emctl$BAT status agent" 2>>$ERRFIL`
              if [[ `echo "$EMAGENT_STATUS"|tail -1|grep -ic "Agent is Running and Ready"` -gt 0 ]]; then
                EMAGENT_UP=1    
              fi
              mb_em_home_version=`echo "$EMAGENT_STATUS"|grep  "Agent Version"|$AWK -F":" '{print $2}'|sed 's/ //g'`
              mb_em_home_version=`echo $mb_em_home_version |sed 's/\.//g'`
	      echo "${stack}.EMAGENT_VERSION = $mb_em_home_version" >>$MASTERFIL
            fi

    	    write_del_rolbk_tmpoutput
          fi

          if [[ $valid_installation -ne "1" ]] && [[ -z "$RAT_EMAGENT_INST" || -z "$RAT_EMAGENT_HOME" ]]; then
	    is_emagent_installed=0;
            echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
	    emhome="";
            EMAGENT_INST="";
	    echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
            echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
	    echo "${stack}.EMAGENT_UP = 0" >> $MASTERFIL
	  else
	    echo "${stack}.EMAGENT_INSTALLED = 1" >>$MASTERFIL
	    echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
            echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
	    echo "${stack}.EMAGENT_UP = $EMAGENT_UP" >> $MASTERFIL
          fi
        else
          is_emagent_installed=0;
	  echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
	  emhome="";
	  EMAGENT_INST="";
	  echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
	  echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
  	  echo "${stack}.EMAGENT_UP = 0" >> $MASTERFIL
        fi
      fi # is windows?

      if [ $is_windows -eq "1" ] ; then
        stack_check_crs=`grep -c OracleOHService $win_services`;
        stack_check_crsd=`grep -c OracleOHService $win_services`;
        if [[ $stack_check_crs -gt "0" ]] ; then stack_check_crs=3; fi
  	if [[ $stack_check_crsd -gt "0" ]] ; then stack_check_crsd=1; fi
      else
        stack_check_crs=`ps -ef|grep -ic "d.bin"`
	stack_check_crsd=`ps -ef |grep -ic "crsd\.bin"`
      fi

      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
        if [[ `grep -ic "$qstack\.ASM_INSTANCE = \+" $MASTERFIL` -gt "0" || `grep -ic "$qstack\..*\.INSTANCE_NAME = [0-9a-zA-Z][0-9a-zA-Z]*" $MASTERFIL` -gt "0" ]]; then
	  stack_check_crs_run=0
	else
	  stack_check_crs_run=1
	fi
      else
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_check_crs_run=`su $dbOwner -c "$CRS/bin/crsctl status resource -t >/dev/null 2>&1";echo $?`
          else
            stack_check_crs_run=`su $dbOwner -c "$CRS/bin/crs_stat -t >/dev/null 2>&1";echo $?`
          fi
    	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
          unset OLD_DIR
        else
          if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_check_crs_run=`$CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
          else
            #stack_check_crs_run=`$CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?`
            stack_check_crs_run=`$CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
          fi
        fi
      fi

      #$READ -p "$stack_check_crs $stack_check_crs_run $CRS"
      printf ". "
      if [[ ${stack_check_crs} -ge 3 && $stack_check_crs_run -eq 0 ]]
      then
	if [[ -n "$crs112" && $crs112 -ge 1 ]]
	then
	  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	    stack_asm_sid[$stack_counter]=$(grep -i "$qstack\.ASM_INSTANCE =" $MASTERFIL|awk '{print $3}')
	  else
	    if [[ `uname -s` = "AIX"  || `uname -s` = "SunOS" ||  `uname -s` = "HP-UX" ]] 
	    then
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	        OLD_OH=$ORACLE_HOME
	        ORACLE_HOME=$CRS
	        get_dbOwner
	        ORACLE_HOME=$OLD_OH
	        asm_inst_name_single=$(su $dbOwner -c "$CRS/bin/crs_stat|grep -iw asm|grep $qstack|cut -d. -f3")
    		write_del_rolbk_tmpoutput
	        cd $OLD_DIR
	        unset OLD_DIR
	      else
	        asm_inst_name_single=$($CRS/bin/crs_stat|grep -iw asm|grep $qstack|cut -d. -f3)
	      fi
	      stack_asm_sid[$stack_counter]=$(echo "+${asm_inst_name_single}")
	    else
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	        OLD_OH=$ORACLE_HOME
	        ORACLE_HOME=$CRS
	        get_dbOwner
	        ORACLE_HOME=$OLD_OH
	        stack_asm_sid[$stack_counter]="+"`su $dbOwner -c "$CRS/bin/crs_stat|grep -wi -A 2 asm|grep $qstack|cut -d. -f3|grep -v $qstack"`
    		write_del_rolbk_tmpoutput
	        cd $OLD_DIR
	        unset OLD_DIR
	      else
	        stack_asm_sid[$stack_counter]="+"`$CRS/bin/crs_stat|grep -wi -A 2 asm|grep $qstack|cut -d. -f3|grep -v $qstack`
	      fi
	      if [ $is_windows -eq "0" ] ; then
	        stack_acfs_modules=$(/sbin/lsmod|grep -i -E 'oracleacfs|oracleoks|oracleadvm'|wc -l)
	      fi
	    fi
            if [[ $is_windows -eq "0" && "${stack_asm_sid[$stack_counter]}" != "$(ps -ef |grep asm_pmon|grep -v grep|$AWK 'BEGIN { FS = "_" } {print $NF}')" ]]
            then 
              stack_asm_sid[$stack_counter]=$(ps -ef |grep asm_pmon|grep -v grep|$AWK 'BEGIN { FS = "_" } {print $NF}')
            fi      
	  fi
	  printf ". . . . "
	else
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
	      stack_asm_home[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm |grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g'"`
	      asm_home_path="${stack_asm_home[$stack_counter]}";
	      ASM_HOME="${stack_asm_home[$stack_counter]}";
	      stack_asm_sid[$stack_counter]="+ASM";
            else  
	      stack_asm_sid[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print \$1}'"`
	      stack_asm_home[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print \$2}'"`
            fi
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
	      stack_asm_home[$stack_counter]=`$CRS/bin/srvctl$BAT config asm |grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g'`
	      asm_home_path="${stack_asm_home[$stack_counter]}";
	      ASM_HOME="${stack_asm_home[$stack_counter]}";
	      stack_asm_sid[$stack_counter]="+ASM";
            else  
	      stack_asm_sid[$stack_counter]=`$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print $1}'`
	      stack_asm_home[$stack_counter]=`$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print $2}'`
            fi
	  fi
	  printf ". . . . "
	fi
	save_crs

 	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
	  stack_crs_version[$stack_counter]=`grep "$qstack.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
	else
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    stack_crs_version[$stack_counter]=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch|grep active|sed -n 's/.*\[//p'|sed 's/\]//g'"`
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_crs_version[$stack_counter]=`su $dbOwner -c "$CRS/bin/crsctl query has softwareversion|sed -n 's/.*\[//p'|sed 's/\]//g'"`
            fi 
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    stack_crs_version[$stack_counter]=`$CRS/bin/crsctl query $crs_version_switch|grep active|sed -n 's/.*\[//p'|sed 's/\]//g'`
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_crs_version[$stack_counter]=`$CRS/bin/crsctl query has softwareversion|sed -n 's/.*\[//p'|sed 's/\]//g'`
            fi 
	  fi
	fi
	ret_crs
	
	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
          stack_asm_up[$stack_counter]=`grep -i "$qstack.ASM_STATUS =" $MASTERFIL |awk '{print $3}'`
	  stack_acfs_up[$stack_counter]=`grep -i "$qstack.ACFS_STATUS =" $MASTERFIL |awk '{print $3}'`
	else
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_asm=`su $dbOwner -c "$CRS/bin/srvctl$BAT status asm |grep -ic \"is running on $qstack\""`
            else
              stack_asm=`su $dbOwner -c "$CRS/bin/srvctl$BAT status asm -n $qstack|grep -ic 'is running'"`
            fi
	    if [ $stack_asm -ge 1 ]
	    then
	      stack_asm_up[$stack_counter]=1
	      printf ". "
	      stack_acfs_drivers=$(su $dbOwner -c "$CRS/bin/crsctl stat res ora.registry.acfs -t|grep $qstack")
	      if [ $? -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	      printf ". "
	      stack_acfs_registry=$(su $dbOwner -c "$CRS/bin/crsctl stat res ora.drivers.acfs -init -t|grep $qstack")
	      if [  $? -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	      if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	      then 
	        stack_acfs_up[$stack_counter]=1
	      else 
	        stack_acfs_up[$stack_counter]=0
	      fi
	      printf ". "
	    else
	      stack_asm_up[$stack_counter]=0
	      printf ". "
	    fi
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_asm=`$CRS/bin/srvctl$BAT status asm |grep -ic "is running on $qstack"`
            else
              stack_asm=`$CRS/bin/srvctl$BAT status asm -n $qstack|grep -ic "is running"`
            fi
     	    #stack_asm=0
	    if [ $stack_asm -ge 1 ]
	    then
	      stack_asm_up[$stack_counter]=1
	      printf ". "
	      stack_acfs_drivers=$($CRS/bin/crsctl  stat res ora.registry.acfs -t|grep $qstack)
	      if [ $? -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	      printf ". "
	      stack_acfs_registry=$($CRS/bin/crsctl  stat res ora.drivers.acfs -init -t|grep $qstack)
	      if [  $? -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	      if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	      then 
	        stack_acfs_up[$stack_counter]=1
	      else 
	        stack_acfs_up[$stack_counter]=0
	      fi
	      printf ". "
	    else
	      stack_asm_up[$stack_counter]=0
	      printf ". "
	    fi
	  fi
	fi

        #if [ ${stack_check_crsd} -eq 1 ] ; then 
	if [ ${stack_check_crsd} -gt 0 ] ; then
 	  stack_crs_up[$stack_counter]=1
          crs_up=1
	else
	  stack_crs_up[$stack_counter]=0
	  crs_up=0
        fi 
	#if [ ${crs_installed[$stack_counter]} -eq 0 ]; then crs_installed[$stack_counter]=1;fi;
	printf ". "
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
	  cluster_name=`su $dbOwner -c "$CRS/bin/cemutlo -n"`
    	  write_del_rolbk_tmpoutput
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  cluster_name=`$CRS/bin/cemutlo -n`
	fi
      else
	stack_crs_up[$stack_counter]=0
	stack_asm_up[$stack_counter]=0
	printf ". "
	crs_up=0
      fi

      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
  	printf "."	
        echo "${qstack}.CRS_STATUS = ${stack_crs_up[$stack_counter]}" >>$MASTERFIL

 	if [[ $CRS12 -eq "1" ]]; then
	  sed -e "s/${qstack}.CRS_ACTIVE_VERSION =.*/${qstack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$stack_counter]}/g" $MASTERFIL > $MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
          for db_name_to_check in "${mb_db_names[@]}"
          do
            stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
            if [ -f $stack_status ]
            then  
              idbinst_v=`grep -w $qstack $stack_status|cut -d'|' -f3`
	      sed -e "s/$qstack\.$db_name_to_check\.INSTANCE_VERSION =/$qstack\.$db_name_to_check\.INSTANCE_VERSION = $idbinst_v/g" $MASTERFIL > $MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
            fi
	  done
	fi

	db_name_cntr=0
        for db_name_to_check in "${mb_db_names[@]}"
        do
	  if [[ "${mb_database_type[$db_name_cntr]}" = "PDB" && -f $stack_status ]]; then
	    set_pdb_data 
	  else
            stack_dbinst_up[$stack_counter]=`grep -i "$qstack\.$db_name_to_check\.INSTANCE_MODE" $MASTERFIL | awk '{print $3}'`
            stack_dbinst_name[$stack_counter]=`grep -i "$qstack\.$db_name_to_check\.INSTANCE_NAME" $MASTERFIL | awk '{print $3}'`
            stack_dbinst_version[$stack_counter]=`grep -i "$qstack\.$db_name_to_check\.INSTANCE_VERSION" $MASTERFIL | awk '{print $3}'`
            db_version=${stack_dbinst_version[$stack_counter]}
            printf ". "

            if [ -z ${stack_dbinst_up[$stack_counter]} ]
            then
              stack_dbinst_up[$stack_counter]=0
              db_up=0 
              printf ". "
            else
              db_up=1
              printf ". "
            fi
            stack_host[$stack_counter]=$qstack
            printf ". "
            printf ". "
	  fi
	  db_name_cntr=$(expr $db_name_cntr + 1)
        done
	unset db_name_cntr
      else
        echo "${stack}.CRS_STATUS = ${stack_crs_up[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.ASM_STATUS = ${stack_asm_up[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.ASM_INSTANCE = ${stack_asm_sid[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.ASM_HOME = ${stack_asm_home[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.ACFS_STATUS = ${stack_acfs_up[$stack_counter]}" >>$MASTERFIL

        if [[ -n "$multiple_db" &&  $multiple_db -eq 1 ]]
        then
          for db_name_to_check in "${mb_db_names[@]}"
          do
            stack_dbinst_up[$stack_counter]=""
            stack_dbinst_name[$stack_counter]=""
            stack_dbinst_version[$stack_counter]="" 
            stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
            if [ -f $stack_status ]
            then  
              stack_dbinst_up[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f2`
              stack_dbinst_name[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f1`
              stack_dbinst_version[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f3`
              db_version=${stack_dbinst_version[$stack_counter]}
              printf ". "
            fi
            if [ -z ${stack_dbinst_up[$stack_counter]} ]
            then
              stack_dbinst_up[$stack_counter]=0
              db_up=0 
              printf ". "
            else
              db_up=1
              printf ". "
            fi
            stack_host[stack_counter]=$stack
            printf ". "
            echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
            echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
            echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
            printf ". "
          done
        else
          for db_name_to_check in "${mb_db_names[@]}"
          do
            stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
            if [ -f $stack_status ]
            then
              stack_dbinst_up[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f2`
              stack_dbinst_name[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f1`
              stack_dbinst_version[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f3`
              db_version=stack_dbinst_version[$stack_counter]
              printf ". "
            fi  
          done 

          if [ -z ${stack_dbinst_up[$stack_counter]} ]
          then
            stack_dbinst_up[$stack_counter]=0
            db_up=0
            printf ". "
          else
            db_up=1
            printf ". "
          fi 

          stack_host[$stack_counter]=$stack
          printf ". "
          echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
          echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
          echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
          printf ". "
        fi
      fi
    else
      if [ $is_windows -eq "0" ] ; then
        stack_check_crs=`$SSHELL $stack ps -ef|grep -ic "d.bin"`
        stack_check_crsd=`$SSHELL $stack ps -ef |grep -ic "crsd\.bin"`
      else
        stack_check_crs=`$SSHELL $stack "grep -c OracleOHService $RTEMPDIR/win_services.out"`;
        stack_check_crsd=`$SSHELL $stack "grep -c OracleOHService $RTEMPDIR/win_services.out"`;
        if [ $stack_check_crs -gt "0" ] ; then stack_check_crs=3; fi
  	if [ $stack_check_crsd -gt "0" ] ; then stack_check_crsd=1; fi
      fi

      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
        if [[ `grep -ic "$qstack\.ASM_INSTANCE = \+" $MASTERFIL` -gt "0" || `grep -ic "$qstack\..*\.INSTANCE_NAME = [0-9a-zA-Z][0-9a-zA-Z]*" $MASTERFIL` -gt "0" ]]; then
	  stack_check_crs_run=0
	else
	  stack_check_crs_run=1
	fi
      else
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner $stack "1"
          ORACLE_HOME=$OLD_OH
          if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_check_crs_run=`$SSHELL $stack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crsctl status resource -t >/dev/null 2>&1\"";echo $?`
          else
            stack_check_crs_run=`$SSHELL $stack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crs_stat -t >/dev/null 2>&1\"";echo $?`
          fi
    	  write_del_rolbk_tmpoutput
        else
          if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_check_crs_run=`$SSHELL $stack $CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
          else
            #stack_check_crs_run=`$SSHELL $stack $CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?`
            stack_check_crs_run=`$SSHELL $stack $CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
          fi
        fi
      fi
      #$READ -p "stack_check_crs_run=$stack_check_crs_run and stack_check_crs=$stack_check_crs"
      printf ". "

      if [ $is_windows -eq "1" ] ; then
        if [ -n "${invntr_location[$stack_counter]}" ]
        then
          oraInventoryFile="${invntr_location[$stack_counter]}/ContentsXML/inventory.xml";
          stack_check_emagent=0;
          stack_check_emagent=`$SSHELL $stack "$bash_scr -c \"if [ -e \\\\\\"$oraInventoryFile\\\\\\" ]; then grep -wic '<HOME NAME=' \\\\\\"$oraInventoryFile\\\\\\"; fi\"" 2>/dev/null`;
          oraInventoryFile=`echo "$oraInventoryFile"|sed 's/ /\\\ /'`;

          if [[ $stack_check_emagent -gt 0 ]];then
            if [ -n "$RAT_EMAGENT_HOME" ]
            then
              emhome=$RAT_EMAGENT_HOME
            else
              emhome=`$SSHELL $stack "cat $oraInventoryFile|grep -wi \"HOME NAME=\"|grep agent|grep core|head -1" 2>/dev/null`;
              emhome=`echo $emhome|sed 's/.*LOC="//'|sed 's/" TYPE.*//'`;
            fi
            if [ -n "$RAT_EMAGENT_INST" ]
            then
              EMAGENT_INST=$RAT_EMAGENT_INST
            else
              EMAGENT_INST=`echo $emhome|sed 's/core.*/agent_inst/'`;
            fi

            if [ -n "$emhome" ]
            then
              is_emagent_installed=1;
              echo "${stack}.EMAGENT_INSTALLED = 1" >>$MASTERFIL
              echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
              echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
            else
              is_emagent_installed=0;
              echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
              emhome="";
              EMAGENT_INST="";
              echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
              echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
            fi
          else
            is_emagent_installed=0;
            echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
            emhome="";
            EMAGENT_INST="";
            echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
            echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
          fi
        else
          is_emagent_installed=0;
          echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
	  emhome="";
          EMAGENT_INST="";
	  echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
          echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
	fi
      else
        stack_check_emagent=0;
        stack_check_emagent=`$SSHELL $stack " $bash_scr -c \"if [ -e $EMHOMEVERSIONFIL ]; then grep -wc \"agent_inst\" $EMHOMEVERSIONFIL ;fi\""`;
	if [[ $stack_check_emagent -gt 0 ]];then
	  printf ". "
	else
	  if [[ `/bin/uname` = "Linux" ]]; then
	    stack_check_emagent=`$SSHELL $stack " $bash_scr -c \"if [ -e $EMHOMEVERSIONFIL2 ]; then grep -wc \"agent_inst\" $EMHOMEVERSIONFIL2 ;fi\""`;
	    EMHOMEVERSIONFIL=$EMHOMEVERSIONFIL2;
	  fi
	fi
        if [[ $stack_check_emagent -gt 0 ]];then
          is_emagent_installed=1;
	  selectedemhome=""
	  selectedEMAGENT_INST=""

  	  for emline in `$SSHELL $stack "cat $EMHOMEVERSIONFIL|grep -w agent_inst"`
          do
            emhome=`echo $emline|cut -d ':' -f1|head -1`
            EMAGENT_INST=`echo $emline|cut -d ':' -f2|head -1`
            if [[ -d "$emhome" && -e "$emhome/bin/emctl" ]]
            then
	      selectedemhome=$emhome
	      selectedEMAGENT_INST=$EMAGENT_INST
	      valid_installation=1
	      if [[ -e "$OMS_HOME/install/eminstall.info" ]]; then
                oms_em=`grep AGENT_HOME= $OMS_HOME/install/eminstall.info|awk -F"=" '{print $2}'|tr -d '\n'`;
                if [[ "$oms_em" = "$emhome" ]]
                then
                  break
                fi
              fi
            fi
          done

	  emhome=$selectedemhome
	  EMAGENT_INST=$selectedEMAGENT_INST

          if [ -n "$RAT_EMAGENT_HOME" ]
          then
            emhome=$RAT_EMAGENT_HOME
          fi

          if [ -n "$RAT_EMAGENT_INST" ]
          then
            EMAGENT_INST=$RAT_EMAGENT_INST
          fi

          EMAGENT_UP=0
          if [[ -n $emhome ]]; then
	    get_agentOwner $stack
	    if [[ $usern = $agentOwner ]]
	    then
              EMAGENT_STATUS=`$SSHELL $stack "$emhome/bin/emctl$BAT status agent" 2>/dev/null`
	      if [[ `echo "$EMAGENT_STATUS"|tail -1|grep -ic "Agent is Running and Ready"` -gt 0 ]]; then
                EMAGENT_UP=1
	      fi
		mb_em_home_version=`echo "$EMAGENT_STATUS"|grep  "Agent Version"|$AWK -F":" '{print $2}'|sed 's/ //g'`
		mb_em_home_version=`echo $mb_em_home_version |sed 's/\.//g'`
		echo "${stack}.EMAGENT_VERSION = $mb_em_home_version" >>$MASTERFIL
	    fi

	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              EMAGENT_STATUS=`$SSHELL $stack "su $agentOwner -c \"$emhome/bin/emctl$BAT status agent\"" 2>>$ERRFIL`
              if [[ `echo "$EMAGENT_STATUS"|tail -1|grep -ic "Agent is Running and Ready"` -gt 0 ]]; then
                EMAGENT_UP=1
              fi
              mb_em_home_version=`echo "$EMAGENT_STATUS"|grep  "Agent Version"|$AWK -F":" '{print $2}'|sed 's/ //g'`
              mb_em_home_version=`echo $mb_em_home_version |sed 's/\.//g'`
	      echo "${stack}.EMAGENT_VERSION = $mb_em_home_version" >>$MASTERFIL
            fi

    	    write_del_rolbk_tmpoutput
          fi

	  if [[ $valid_installation -ne "1" ]] && [[ -z "$RAT_EMAGENT_INST" || -z "$RAT_EMAGENT_HOME" ]]; then
	    is_emagent_installed=0;
            echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
	    emhome="";
            EMAGENT_INST="";
	    echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
            echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
	    echo "${stack}.EMAGENT_UP = 0" >> $MASTERFIL
	  else
	    echo "${stack}.EMAGENT_INSTALLED = 1" >>$MASTERFIL
	    echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
            echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
	    echo "${stack}.EMAGENT_UP = $EMAGENT_UP" >> $MASTERFIL
	  fi
        else
          is_emagent_installed=0;
	  echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
          emhome="";
          EMAGENT_INST="";
          echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
          echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
          echo "${stack}.EMAGENT_UP = 0" >> $MASTERFIL
        fi
      fi # is windows?

      if [[ ${stack_check_crs} -ge 3 && $stack_check_crs_run -eq 0 ]]
      then
	if [[ -n "$crs112" && $crs112 -ge 1 ]]
	then
	  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	    stack_asm_sid[$stack_counter]=$(grep -i "$qstack\.ASM_INSTANCE =" $MASTERFIL|awk '{print $3}')
	    if [[ -z $ORACLE_HOME ]]; then ORACLE_HOME=$CRS; fi
	  else
	    if [[ `uname -s` = "AIX"  || `uname -s` = "SunOS" || `uname -s` = "HP-UX" ]] 
	    then
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	        OLD_OH=$ORACLE_HOME
	        ORACLE_HOME=$CRS
	        get_dbOwner
	        ORACLE_HOME=$OLD_OH
	        asm_inst_name_single=$(su $dbOwner -c "$CRS/bin/crs_stat|grep -wi asm|grep $qstack|cut -d. -f3")		
    		write_del_rolbk_tmpoutput
	        cd $OLD_DIR
	        unset OLD_DIR	
	      else
	        asm_inst_name_single=$($CRS/bin/crs_stat|grep -wi asm|grep $qstack|cut -d. -f3)		
	        stack_asm_sid[$stack_counter]=$(echo "+${asm_inst_name_single}")
	      fi
	    else
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	        OLD_OH=$ORACLE_HOME
	        ORACLE_HOME=$CRS
	        get_dbOwner
	        ORACLE_HOME=$OLD_OH
	        stack_asm_sid[$stack_counter]="+"`su $dbOwner -c "$CRS/bin/crs_stat|grep -wi -A 2 asm|grep $qstack|cut -d. -f3|tail -1"`
    		write_del_rolbk_tmpoutput
	        cd $OLD_DIR
	        unset OLD_DIR	
	      else
	        stack_asm_sid[$stack_counter]="+"`$CRS/bin/crs_stat|grep -wi -A 2 asm|grep $qstack|cut -d. -f3|tail -1`
	      fi
	      if [ $is_windows -eq "0" ] ; then
	        stack_acfs_modules=$($SSHELL $stack /sbin/lsmod|grep -i -E 'oracleacfs|oracleoks|oracleadvm'|wc -l)
	      fi
	    fi
            if [ $is_windows -eq "0" ] ; then
              ps_asm_sid=$($SSHELL $stack ps -ef |grep asm_pmon|grep -v grep|$AWK 'BEGIN { FS = "_" } {print $NF}')    
              if [ "${stack_asm_sid[$stack_counter]}" != "$ps_asm_sid" ]
              then 
                stack_asm_sid[$stack_counter]=$($SSHELL $qstack ps -ef |grep asm_pmon|grep -v grep|$AWK 'BEGIN { FS = "_" } {print $NF}')
              fi              
            fi              
	  fi
	  printf ". . . "
	else
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_asm_home[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm |grep 'ASM home:'|sed 's/ //g'|sed 's/ASMhome://g'"`
	      ASM_HOME=${stack_asm_home[$stack_counter]};
              stack_asm_sid[$stack_counter]="+ASM";
            else
              stack_asm_sid[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print \$1}'"`
              stack_asm_home[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print \$2}'"`
            fi
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR	
	  else
	    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_asm_home[$stack_counter]=`$CRS/bin/srvctl$BAT config asm |grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g'`
	      ASM_HOME=${stack_asm_home[$stack_counter]};
              stack_asm_sid[$stack_counter]="+ASM";
            else
              stack_asm_sid[$stack_counter]=`$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print $1}'`
              stack_asm_home[$stack_counter]=`$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print $2}'`
            fi
	  fi

	  printf ". . . . "
	fi
	save_crs
 	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
	  stack_crs_version[$stack_counter]=`grep "$qstack.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
	else
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    stack_crs_version[$stack_counter]=`$SSHELL $stack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crsctl query $crs_version_switch 2>/dev/null|grep active|sed -n 's/.*\[//p'|sed 's/\]//g'\""`
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    stack_crs_version[$stack_counter]=`$SSHELL $stack $CRS/bin/crsctl query $crs_version_switch|grep active|sed -n 's/.*\[//p'|sed 's/\]//g'`
	  fi
	fi
	ret_crs

	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
          stack_asm_up[$stack_counter]=`grep -i "$qstack.ASM_STATUS =" $MASTERFIL |awk '{print $3}'`
	  stack_acfs_up[$stack_counter]=`grep -i "$qstack.ACFS_STATUS =" $MASTERFIL |awk '{print $3}'`
	else
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_asm=`su $dbOwner -c "$CRS/bin/srvctl$BAT status asm |grep -ic \"is running on $qstack\""`
	    else
	      stack_asm=`su $dbOwner -c "$CRS/bin/srvctl$BAT status asm -n $qstack|grep -ic 'is running'"`
	    fi
	     
	    printf ". "
	    if [ $stack_asm -ge 1 ]
	    then
	      stack_asm_up[$stack_counter]=1
	      printf ". "
	      stack_acfs_drivers=$($SSHELL $stack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crsctl stat res ora.registry.acfs -t 2>/dev/null|grep $qstack\"")
	      if [ `echo $?` -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	      printf ". "
	      stack_acfs_registry=$(su $dbOwner -c "$CRS/bin/crsctl stat res ora.drivers.acfs -init -t|grep $qstack")
	      if [ `echo $?` -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	      if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	      then 
	        stack_acfs_up[$stack_counter]=1
	      else 
	        stack_acfs_up[$stack_counter]=0
	      fi
	      printf ". "
	    else
	      stack_asm_up[$stack_counter]=0
	      printf ". "
	    fi
	    
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_asm=`$CRS/bin/srvctl$BAT status asm |grep -ic "is running on $qstack"`
	    else
	      stack_asm=`$CRS/bin/srvctl$BAT status asm -n $qstack|grep -ic "is running"`
	    fi
	     
	    printf ". "
	    if [ $stack_asm -ge 1 ]
	    then
	      stack_asm_up[$stack_counter]=1
	      printf ". "
	      stack_acfs_drivers=$($SSHELL $stack $CRS/bin/crsctl  stat res ora.registry.acfs -t|grep $qstack)
	      if [ `echo $?` -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	      printf ". "
	      stack_acfs_registry=$($CRS/bin/crsctl  stat res ora.drivers.acfs -init -t|grep $qstack)
	      if [ `echo $?` -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	      if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	      then 
	        stack_acfs_up[$stack_counter]=1
	      else 
	        stack_acfs_up[$stack_counter]=0
	      fi
	      printf ". "
	    else
	      stack_asm_up[$stack_counter]=0
	      printf ". "
	    fi
	  fi
	fi

	#if [ ${stack_check_crsd} -eq 1 ] ; then
	if [ ${stack_check_crsd} -gt 0 ] ; then
	  stack_crs_up[$stack_counter]=1
	else
	  stack_crs_up[$stack_counter]=0
	fi
	#if [ ${crs_installed[$stack_counter]} -eq 0 ]; then crs_installed[$stack_counter]=1;fi;
	printf ". "
      else
	stack_crs_up[$stack_counter]=0
	stack_asm_up[$stack_counter]=0
	printf ". "
      fi

      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
  	printf "."	
        echo "${qstack}.CRS_STATUS = ${stack_crs_up[$stack_counter]}" >>$MASTERFIL

 	if [[ $CRS12 -eq "1" ]]; then
	  sed -e "s/${qstack}.CRS_ACTIVE_VERSION =.*/${qstack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$stack_counter]}/g" $MASTERFIL > $MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
          echo "${qstack}.ASM_HOME = ${stack_asm_home[$stack_counter]}" >>$MASTERFIL
          for db_name_to_check in "${mb_db_names[@]}"
          do
            stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
            if [ -f $stack_status ]
            then  
              idbinst_v=`grep -w $stack $stack_status|cut -d'|' -f3`
	      sed -e "s/$qstack\.$db_name_to_check\.INSTANCE_VERSION =/$qstack\.$db_name_to_check\.INSTANCE_VERSION = $idbinst_v/g" $MASTERFIL >$MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
            fi
	  done
	fi

 	db_name_cntr=0
        for db_name_to_check in "${mb_db_names[@]}"
        do
	  if [[ "${mb_database_type[$db_name_cntr]}" = "PDB" && -f $stack_status ]]; then
	    set_pdb_data 
	  else
            stack_dbinst_up[$stack_counter]=`grep -i "$qstack\.$db_name_to_check\.INSTANCE_MODE" $MASTERFIL | awk '{print $3}'`
            stack_dbinst_name[$stack_counter]=`grep -i "$qstack\.$db_name_to_check\.INSTANCE_NAME" $MASTERFIL | awk '{print $3}'`
            stack_dbinst_version[$stack_counter]=`grep -i "$qstack\.$db_name_to_check\.INSTANCE_VERSION" $MASTERFIL | awk '{print $3}'`
            db_version=${stack_dbinst_version[$stack_counter]}
            printf ". "

            if [ -z ${stack_dbinst_up[$stack_counter]} ]
            then
              stack_dbinst_up[$stack_counter]=0
              db_up=0 
              printf ". "
            else
              db_up=1
              printf ". "
            fi
            stack_host[$stack_counter]=$qstack
            printf ". "
            printf ". "
	  fi
	  db_name_cntr=$(expr $db_name_cntr + 1)
        done
	unset db_name_cntr
      else
        echo "${stack}.CRS_STATUS = ${stack_crs_up[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.ASM_STATUS = ${stack_asm_up[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.ASM_INSTANCE = ${stack_asm_sid[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.ASM_HOME = ${stack_asm_home[$stack_counter]}" >>$MASTERFIL
        echo "${stack}.ACFS_STATUS = ${stack_acfs_up[$stack_counter]}" >>$MASTERFIL

        if [[ -n "$multiple_db" && $multiple_db -eq 1 ]]
        then
          for db_name_to_check in "${mb_db_names[@]}"
          do
            stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
            stack_dbinst_up[$stack_counter]=""
            stack_dbinst_name[$stack_counter]=""
            stack_dbinst_version[$stack_counter]="" 
            if [  -f $stack_status ]
            then
              stack_dbinst_up[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f2`
              local_db_inst=`grep -w $stack $stack_status|cut -d. -f2`
              stack_dbinst_name[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f1`
              stack_dbinst_version[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f3`
              db_version=stack_dbinst_version[$stack_counter]
              printf ". "
            fi
            if [ -z ${stack_dbinst_up[$stack_counter]} ]
            then
              stack_dbinst_up[$stack_counter]=0
              printf ". "
              db_up=0
            else
              db_up=1
            fi
            printf ". "
            stack_host[stack_counter]=$stack
            echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
            echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
            echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
            printf ". "
          done
        else
          for db_name_to_check in "${mb_db_names[@]}"
          do
            stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
            if [ -f $stack_status ]
            then
              stack_dbinst_up[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f2`
              stack_dbinst_name[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f1`
              stack_dbinst_version[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f3`
              db_version=stack_dbinst_version[$stack_counter]
              printf ". "
            fi
          done

          if [ -z ${stack_dbinst_up[$stack_counter]} ]
          then
            stack_dbinst_up[$stack_counter]=0
            db_up=0
            printf ". "
          else
            db_up=1
            printf ". "
          fi
          printf ". "
          stack_host[stack_counter]=$stack
          echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
          echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
          echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
          printf ". "
        fi
      fi
    fi 
    stack_counter=`expr $stack_counter + 1 `
    printf ". "
  done
 
  mb_db_counter_local=0
  for db_name_to_check in "${mb_db_names[@]}"
  do 
    echo "$db_name_to_check.CHECKED_NODE = ${mb_running_host[$mb_db_counter_local]}" >>$MASTERFIL
    mb_db_counter_local=$(expr $mb_db_counter_local + 1)
  done

  printf ". \n"
  #when this fuction is over, reinitialize stack_counter to use in Main for loop to trace each host.
  stack_counter=0
  #following function will add asm version to master file

  GetMachineRole
  is_this_db_machine "$localnode" "0"
  #if [ $db_machine_compute -eq 1 ];then func_cells_stack_status;fi;
  is_this_oda
  check_maa_scorecard
  check_hacheck
  is_this_minicluster
  #Following code is to override components found from environment and use passed from command line option"
  if [ -n "$options_components" ]
  then
    components=$options_components
  fi
  #this condition not to execute old code
  if [ 1 -eq 2 ]
  then
  #To execute only hacheck depending upon type of the database either RAC or SI
    if [[ "$components" = "HACHECK" || "$components" = "MAA" || "$components" = "MAA:HACHECK" || "$components" = "HACHECK:MAA" ]]; then only_hacheck_run=1;else only_hacheck_run=0;fi
    echo "ONLY_HACHECK_RUN = $only_hacheck_run" >>$MASTERFIL
    if [ `echo $options_components|grep -icw hacheck` -ge 1 ] 
    then
      if [ $single_instance_run -eq 0 ]
      then
        components=$(echo ${components}|sed 's/HACHECK//')
        components=$(echo ${components}:HACHECK)
      else
        components=$(echo ${components}|sed 's/HACHECK//')
        components=$(echo ${components}|sed 's/SIDBHACHECK//')
        components=$(echo ${components}:SIDBHACHECK)    
      fi
    fi
    if [ `echo $options_components|grep -icw hacheck` -ge 0 ]
    then
      if [[ "$TYP" = "-r" && $db_machine_compute -eq 0 ]]
      then 
        if [ $single_instance_run -eq 0 ]
        then
    	  components=$(echo ${components}:HACHECK)
	elif [[ $single_instance_run -eq 1 ]]
	then
	  components=$(echo ${components}:SIDBHACHECK)
	else
	  components=$(echo ${components}|sed 's/:HACHECK//')
	  components=$(echo ${components}|sed 's/:SIDBHACHECK//')
	fi
      fi
      if [ $upgrade_mode -eq 0 ]; then TYP=-a;fi
    fi

    if [ $only_hacheck_run -eq 1 ]; then TYP=-b;fi

    if [[ -n "$include_hacheck" && $include_hacheck -eq 0 ]]
    then
      components=$(echo ${components}|sed 's/:HACHECK//')
      components=$(echo ${components}|sed 's/:SIDBHACHECK//')
    fi
  fi

  #this is to change HACHECK to SIDBHACHECK for single instance run
  if [[ `echo $options_components|grep -icw hacheck` -ge 1 && $single_instance_run -eq 1 ]]
  then
    components=$(echo ${components}|sed 's/HACHECK//')
    components=$(echo ${components}|sed 's/SIDBHACHECK//')
    components=$(echo ${components}:SIDBHACHECK)
  fi             
  if [ -z "$components" ]
  then
    echo -e "\n\n${RED}Component is empty.\n\n${program_name} is exiting...${NORM}"
    exit 1
  fi
  final_components=$components
  #$READ -p "final_components=$final_components"
  #if [ -n "$options_components" ]; then echo "${localnode}.COMPONENTS = $components" >>$MASTERFIL;fi
  #commented following function here and will call after asking root password because is_this_db_machine will be called once again
  #write_db_machine_info_to_envfile $localnode
  if [ $upgrade_mode -gt 0 ]; then echo "UPGRADE_MODE = $upgrade_mode" >>$MASTERFIL;fi
  #$READ -p "COMPONENTS = $components TYPE=$TYP"
}

# Format value in $l_version from 112030 to 11.2.0.3.0
format_l_version()
{
  if [ -z "$1" ]
  then
    l_version=$(echo $l_version | sed 's/[0-9]/&./g' | sed 's/\.//' | sed 's/.$//')
  else # For exalogic version is like 1.0.0.2
    l_version=$(echo $l_version | sed 's/[0-9]/&./g' | sed 's/.$//')
  fi
}

func_print_homes()
{
  stk_line_header_h="${stk_line_header}--------------------------"
  echo -e "\n\n${stk_line_header_h}" | tee -a $OUTPUTDIR/installed_components.out
  echo -e "                                       Installed components summary   $NORM                          "| tee -a $OUTPUTDIR/installed_components.out
  echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
  #printf "%-11s " "$stk_host_header" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-40s " "GI_HOME" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-60s " "ORACLE_HOME" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-30s\n" "Database Names" | tee -a $OUTPUTDIR/installed_components.out
  echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
  #for node in `cat $HOSTLIST`
  #do
  node=$localnode
  crs_active_version=`grep "$node.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
  rm -f $OUTPUTDIR/mb_db_tmp.out
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    #l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f2)
    l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f2 |sort -u | head -1)
    format_l_version
    oh_version=$l_version
    running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL |awk '{print $3}'`
    echo "${mb_oracle_homes[$mb_db_counter]}|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
    mb_db_counter=$(expr $mb_db_counter + 1)
  done

  first_time_print=0
  mb_db_counter=0
  if  [ -e $OUTPUTDIR/mb_db_tmp.out ]
  then
    for mb_oh_name in `cut -d'|' -f1  $OUTPUTDIR/mb_db_tmp.out |sort -u`
    do
      oh_version=$(grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f2|sort -u)
      if [ $first_time_print -eq 0 ]
      then
        printf "%-40s " "$CRS - $crs_active_version" | tee -a $OUTPUTDIR/installed_components.out
      else
        first_time_print=0
      fi
      printf "%-60s " "${mb_oh_name} - ${oh_version}" | tee -a $OUTPUTDIR/installed_components.out
      running_db_line=""
      for running_db in `grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u`
      do
        running_db_line="$running_db $running_db_line"
      done # Finished printing db info for a OH
      mb_db_counter=$(expr $mb_db_counter + 1)
      printf "%-30s\n" "$running_db_line" | tee -a $OUTPUTDIR/installed_components.out
    done # Finished printing all homes
    echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
  fi
  mb_db_counter=0
}

func_print_homes_tree()
{
  echo -e "\n\n${stk_line_header}"
  echo -e "                                       Installed components summary   $NORM                          "
  echo $stk_line_header
  for node in `cat $HOSTLIST`
  do
    crs_active_version=`grep "$node.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
    echo -e "Host : $node\n" | tee -a $OUTPUTDIR/installed_components.out
    echo -e "  |-- GI_HOME - Version : $CRS - $crs_active_version\n" | tee -a $OUTPUTDIR/installed_components.out
    rm -f $OUTPUTDIR/mb_db_tmp.out
    mb_db_counter=0
    for db_name_to_check in "${mb_db_names[@]}"
    do
      l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f2)
      format_l_version
      oh_version=$l_version
      running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL |awk '{print $3}'`
      echo "${mb_oracle_homes[$mb_db_counter]}|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
      mb_db_counter=$(expr $mb_db_counter + 1)
    done

    mb_db_counter=0
    if  [ -e $OUTPUTDIR/mb_db_tmp.out ]
    then
      for mb_oh_name in `cut -d'|' -f1  $OUTPUTDIR/mb_db_tmp.out |sort -u`
      do
        oh_version=$(grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f2|sort -u)
        echo -e "    |-- ORACLE_HOME - Version : ${mb_oh_name} - ${oh_version}\n" | tee -a $OUTPUTDIR/installed_components.out 
        for running_db in `grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u`
        do
          echo -e "      |-- Database Name : $running_db" | tee -a $OUTPUTDIR/installed_components.out
          running_instance=$(grep "$mb_oh_name|$oh_version|$running_db|" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f4)
          if [ -n "$running_instance" ]
          then
            echo "        |-- Instance Name: $running_instance" | tee -a $OUTPUTDIR/installed_components.out
          fi
          echo -e ""| tee -a $OUTPUTDIR/installed_components.out
        done # Finished printing db info for a OH
        mb_db_counter=$(expr $mb_db_counter + 1)
      done # Finished printing all homes
    fi
    echo -e "\n"| tee -a $OUTPUTDIR/installed_components.out
  done # Finished all nodes
  echo $stk_line_header
  mb_db_counter=0
}

func_stack_print ()
{
  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then return; fi

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  offline_counter=0

  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $olsnodes_ssh_disabled -eq 1 ]]; then
    unset mapped_host
    for mapping in ${hostmap[@]}
    do
      management_host=${mapping%%:*}
      short_management_host=$(echo $management_host|awk -F"." '{print $1}');

      client_host=${mapping#*:}
      short_client_host=$(echo $client_host|awk -F"." '{print $1}');
  
      for stackhost in "${stack_host[@]}" 
      do
        if [[ "$short_client_host" = "$stackhost" ]]; then 
	  sed -e "s/$stackhost/$short_management_host/g" $MASTERFIL > $MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
	  sed -e "s/MAP:$management_host.*/MAP:$management_host = $client_host/g" $MASTERFIL > $MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
	fi
      done
    done
  fi

  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`
    if [[ -n "$multiple_db" && $multiple_db -eq 1 ]] 
    then
      db_status_counter=0
      mb_db_counter_local=0
      #added uniq not to display same instance names of container instance in case of pdbs are found 
      stack_db_instances[$offline_counter]=`grep -i "$node" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}'|sort|uniq`

      for db_name_to_check in "${mb_db_names[@]}"
      do
        if [[ $node = ${mb_running_host[$mb_db_counter_local]} ]] # && ! -z "`grep -i $node.${db_name_to_check}.INSTANCE_MODE  $MASTERFIL |awk '{print $3}'`" ]] 
        then #remote_database_code
    	  stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    	  stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'` 
	  db_status_counter=$(expr $db_status_counter + 1)
	fi 
        mb_db_counter_local=$(expr $mb_db_counter_local + 1)
      done
      db_status_counter=0
      mb_db_counter_local=0
    else
      stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
      if [[ -n "${mb_running_host[0]}" && $node = ${mb_running_host[0]} ]]
      then 
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
      else
        #added this else part to avoid below error when no database is running on local node and asm is up
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
      fi;
      stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    fi
    offline_counter=`expr $offline_counter + 1`  
  done
  else
    echo
  fi

  if [[ ! -n "$is_fmw_machine" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
    offline_counter=0
    stk_line_header="-------------------------------------------------------------------------------------------------------"
    r="-----------------------------------------------------------------------------------"
    stk_host_header="Host Name"
    stk_crs_installed_header="CRS Installed"
    stk_asm_installed_header="ASM HOME"
    stk_rdbms_installed_header="RDBMS Installed"
    stk_crs_header="CRS UP"
    stk_asm_header="ASM UP"
    stk_rdbms_header="RDBMS UP"
    stck_dbinst_name="DB Instance Name"
    stk_status_no="No"
    stk_status_yes="Yes"
    stk_status_na="N/A"

    echo $stk_line_header
    #echo -e "                                   $BLINK $BOLD Oracle Stack Status  $NORM                          "
    echo -e "                                                 Oracle Stack Status  $NORM                          "
    echo $stk_line_header
    echo $stk_host_header|awk '{printf "%-11s",$stk_host_header}'
    echo $stk_crs_installed_header|awk '{printf "%-15s",$stk_crs_installed_header}'

    if [ $gi112 -eq 0 ] ; then echo $stk_asm_installed_header|awk '{printf "%-15s",$stk_asm_installed_header}'; fi

    echo $stk_rdbms_installed_header|awk '{printf "%-17s",$stk_rdbms_installed_header}'
    echo $stk_crs_header|awk '{printf "%-10s",$stk_crs_header}'
    echo $stk_asm_header|awk '{printf "%-10s",$stk_asm_header}'
    echo $stk_rdbms_header|awk '{printf "%-10s",$stk_rdbms_header}'
    echo $stck_dbinst_name|awk '{printf "%-15s\n",$stk_rdbms_header}'
    echo $stk_line_header

    for stk in `cat $HOSTLIST`
    do
      echo $stk|awk '{printf "%-11s",$stk}'
      if [[ -n "${crs_installed[$offline_counter]}" && ${crs_installed[$offline_counter]} -eq 1 ]]
      then
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
      else
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
      fi
      if [ $gi112 -eq 0 ]
      then
        if [[ -n "${asm_installed[$offline_counter]}" && ${asm_installed[$offline_counter]} -eq 1 ]]
        then
          echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
        else
          echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
        fi
      #else
      #  echo -e $BLUE "N/A" $NORM|awk '{printf "%-30s",$stk_status_no}'
      fi

      if [[ ${rdbms_installed[$offline_counter]} -eq 0 ]]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
      fi
      if [[ ${stack_crs_up[$offline_counter]} -eq 0 ]]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-25s",$stk_status_no}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-25s",$stk_status_yes}'
      fi
      if [[ ${stack_asm_up[$offline_counter]} -eq 0 ]]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-23s",$stk_status_no}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-23s",$stk_status_yes}'
      fi
      if [[ ${stack_dbinst_up[$offline_counter]} -eq 0 && $multiple_db -eq 0 ]]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-23s",$stk_status_no}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-23s",$stk_status_yes}'
      fi
      if [[ -n "$multiple_db" && $multiple_db -eq 0 ]]
      then
        if [[ ${stack_dbinst_up[$offline_counter]} -eq 1 ]]
        then
          stk_inst_name=${stack_dbinst_name[$offline_counter]}
          echo -e $GREEN ${stack_dbinst_name[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
        else
          stk_inst_name=${stack_dbinst_name[$offline_counter]}
     	  echo -e $GREEN ${stack_dbinst_name[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
        fi
      else
        #if [ ${stack_db_status[$offline_counter]} -ne 0 ]
        if [[ -n "${stack_db_status[$offline_counter]}" && ${stack_db_status[$offline_counter]} -ne -1 ]]
        then
          stk_inst_name=${stack_db_instances[$offline_counter]}
     	  echo -e $GREEN ${stack_db_instances[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
        else
          stk_inst_name=${stack_db_instances[$offline_counter]}
     	  echo -e $GREEN ${stack_db_instances[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
        fi
        #echo -e "\n"
      fi
      offline_counter=`expr $offline_counter + 1`
    done
    offline_counter=0
    echo $stk_line_header
  fi
}

func_stack_print_aix ()
{
  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then return; fi

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  offline_counter=0
  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`

    if [ $multiple_db -eq 1 ]
    then
      db_status_counter=0
      mb_db_counter_local=0
      #added uniq not to display same instance names of container instance in case of pdbs are found 
      stack_db_instances[$offline_counter]=`grep -i "$node" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}'|sort|uniq`
      
      for db_name_to_check in "${mb_db_names[@]}"
      do
        if [ $node = ${mb_running_host[$mb_db_counter_local]} ]
        then
          stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
          stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
          db_status_counter=$(expr $db_status_counter + 1)
        fi
        mb_db_counter_local=$(expr $mb_db_counter_local + 1)
      done
      db_status_counter=0
      mb_db_counter_local=0
    else
      stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
      if [ "$node" = "${mb_running_host[0]}" ]
      then
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
      fi;
      stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    fi
    offline_counter=`expr $offline_counter + 1`
  done
  else
    echo
  fi

  if [[ ! -n "$is_fmw_machine" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
    offline_counter=0
    stk_line_header="-------------------------------------------------------------------------------------------------------"
    r="-----------------------------------------------------------------------------------"
    stk_host_header="Host Name"
    stk_crs_installed_header="CRS Installed"
    stk_asm_installed_header="ASM HOME"
    stk_rdbms_installed_header="RDBMS Installed"
    stk_crs_header="CRS UP"
    stk_asm_header="ASM UP"
    stk_rdbms_header="RDBMS UP"
    stck_dbinst_name="DB Instance Name"
    stk_status_no="No"
    stk_status_yes="Yes"
    stk_status_na="N/A"

    echo $stk_line_header
    #echo -e "                                   $BLINK $BOLD Oracle Stack Status  $NORM                          "
    echo -e "                                                 Oracle Stack Status  $NORM                          "
    echo $stk_line_header
    echo $stk_host_header|awk 'BEGIN { FS = "," } ;{printf "%-11s",$1}'
    echo $stk_crs_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-15s",$1}'

    if [ $gi112 -eq 0 ]; then echo $stk_asm_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-15s",$1}'; fi

    echo $stk_rdbms_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-17s",$1}'
    echo $stk_crs_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
    echo $stk_asm_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
    echo $stk_rdbms_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
    echo $stck_dbinst_name|awk 'BEGIN { FS = "," } ;{printf "%-15s\n",$1}'
    echo $stk_line_header

    for stk in `cat $HOSTLIST`
    do
      echo $stk|awk 'BEGIN { FS = "," } ;{printf "%-11s",$1}'
      if [ ${crs_installed[$offline_counter]} -eq 0 ]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-15s",$2}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-15s",$2}'
      fi
      if [ $gi112 -eq 0 ]
      then
        if [[ -n "${asm_installed[$offline_counter]}" && ${asm_installed[$offline_counter]} -eq 1 ]]
        then
          echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-15s",$2}'
        else
          echo -e $RED $stk_status_no $NORM|awk '{printf "%-15s",$2}'
        fi
      #else
      #  echo -e $BLUE "N/A" $NORM|awk '{printf "%-15s",$2}'
      fi

      if [ ${rdbms_installed[$offline_counter]} -eq 0 ]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-17s",$2}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-17s",$2}'
      fi
      if [ ${stack_crs_up[$offline_counter]} -eq 0 ]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
      fi
      if [ ${stack_asm_up[$offline_counter]} -eq 0 ]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
      fi
      if [[ ${stack_dbinst_up[$offline_counter]} -eq 0 && $multiple_db -eq 0 ]]
      then
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
      else
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
      fi
      if [ $multiple_db -eq 0 ]
      then
        if [[ ${stack_dbinst_up[$offline_counter]} -eq 1 ]]
        then
          stk_inst_name=${stack_dbinst_name[$offline_counter]}
          echo -e  ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
        else
          stk_inst_name=${stack_dbinst_name[$offline_counter]}
          echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
        fi
      else
        if [[ -n "$${stack_db_status[$offline_counter]}" && ${stack_db_status[$offline_counter]} -ne 0 ]]
        then
          stk_inst_name=${stack_db_instances[$offline_counter]}
          echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
        else
          stk_inst_name=${stack_db_instances[$offline_counter]}
          echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
        fi
      fi
      offline_counter=`expr $offline_counter + 1`
    done
    offline_counter=0
    echo $stk_line_header
  fi
}

func_cells_stack_status ()
{
  cell_counter=0
  for cell_ip in `cat /etc/oracle/cell/network-config/cellip.ora |cut -d\" -f2`
  do
    cell_host[$cell_counter]=$(ssh $cell_ip hostname -s)
    cell_cellsrv[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes cellsrvStatus\"|grep -wc \"running\"")
    cell_msstatus[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes msStatus\"|grep -wc \"running\"")
    cell_rsstatus[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes rsStatus\"|grep -wc \"running\"")
    echo $cell_host $cell_cellsrv $cell_msstatus $cell_rsstatus
  done  
}

func_minor_check_space ()
{
  min_tmp_space=20480
  space_status=0
  space_pass_msg=""
  space_fail_msg=""
  tmp_out_space_status=0    
  tmp_out_location=$1

  if [[ `echo "$tmp_out_location"|grep -cw "USR_HOMEDIR"` -gt "0" ]]; then return; fi

  if [ `uname -s` = "HP-UX" ] ; then
    space_tmp_out_location=`df -k $tmp_out_location| grep free |awk '{print $1}'`
  else
    awk_col_tmp_out=`df -k  $tmp_out_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`;
    if [ $awk_col_tmp_out  -gt 0 ]
    then
      space_tmp_out_location=`df -k $tmp_out_location |grep -iv "avail" | awk '{ print $3}'|tail -1 `  
    else
      space_tmp_out_location=`df -k $tmp_out_location |grep -iv "avail" | awk '{ print $4}'`
    fi 
  fi

  if [ $min_tmp_space -lt $space_tmp_out_location ]
  then
    space_pass_msg="$space_pass_msg \nSpace available at $tmp_out_location is $space_tmp_out_location KB"
  else
    space_fail_msg="$space_fail_msg $RED \nSpace available at $tmp_out_location is $space_tmp_out_location KB and required space is $min_tmp_space KB $NORM "
    space_status=1
  fi
}

#this function will check space for two locations
#1.Current location from where tool will run
#2. $TMPDIR because this tool uses tmp to for temporary files movement among cluster nodes
func_check_space ()
{
  if [[ -n $RAT_SKIP_SPACE_VALIDATION && $RAT_SKIP_SPACE_VALIDATION -eq "1" ]]; then 
    space_status=0; 
    if [[ -e $LOGFIL ]]; then echo "Skipping space check on $1 as RAT_SKIP_SPACE_VALIDATION is set" >> $LOGFIL; fi

    return;
  fi

  if [[ -n "$1" && $1 = "RUNTIME_DIR" ]]; then func_minor_check_space $2; return; fi

  SKIP_LOCALNODE=0
  if [[ -n "$1" ]]; then 
    if [[ "$1" = "NOLOCALNODE" ]]; then
      SKIP_LOCALNODE=1
    else
      if [[ -e $HOSTLIST ]]; then mv -f $HOSTLIST $HOSTLIST.bak; fi
      echo "$1" > $HOSTLIST; 
    fi
  fi

  min_curr_space=102400
  #min_curr_space=137758049
  min_tmp_space=20480
  #min_tmp_space=1377678890000
  curr_location=$CHECKHOME
  tmp_location=$TMPDIR
  space_status=0
  space_pass_msg=""
  space_fail_msg=""

  local_tmp_out_space_status=0    
  remote_tmp_out_space_status=0    
  remote_tmp_space_status=0
  no_chk_tmpoutput=0
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then tmp_out_location=$RAT_TMP_OUTPUT; fi
  if [[ `echo "$tmp_out_location"|grep -cw "USR_HOMEDIR"` -gt "0" ]]; then no_chk_tmpoutput=1; fi

  for space in `cat $HOSTLIST`
  do
    node_ssh_user=$usern
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
    then
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$space"` -le 0 ]]; then
        node_ssh_user="${root_user}"
      else
	node_ssh_user="${foxtrot_dom0_user}"
      fi
    fi

    if [ $space = $localnode ]
    then
      if [[ -n "$SKIP_LOCALNODE" && $SKIP_LOCALNODE -eq 1 ]]; then continue; fi

      TMPDIRMAP=("${TMPDIRMAP[@]}" $space:$tmp_location);
      TMPOUTMAP=("${TMPOUTMAP[@]}" $space:$tmp_out_location);

      if [ `uname -s` = "HP-UX" ] ; then
        space_curr_location=`df -k $curr_location| grep free |awk '{print $1}'`
        space_tmp_location=`df -k $tmp_location| grep free |awk '{print $1}'`
        if [[ -n "$tmp_out_location" && $no_chk_tmpoutput -eq "0" ]]; then space_tmp_out_location=`df -k $tmp_out_location| grep free |awk '{print $1}'`; fi
      else
        awk_col=`df -k  $curr_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
        awk_col_tmp=`df -k  $tmp_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
        if [[ -n "$tmp_out_location" && $no_chk_tmpoutput -eq "0" ]]; then awk_col_tmp_out=`df -k  $tmp_out_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`; fi
        if [ $awk_col  -gt 0 ]
        then
 	  space_curr_location=`df -k $curr_location| grep -iv "avail" | awk '{ print $3}'|tail -1`  
        else
 	  space_curr_location=`df -k $curr_location| grep -iv "avail" | awk '{ print $4}'`
        fi 
        if [ $awk_col_tmp  -gt 0 ]
        then
 	  space_tmp_location=`df -k $tmp_location |grep -iv "avail" | awk '{ print $3}'|tail -1 `  
        else
 	  space_tmp_location=`df -k $tmp_location |grep -iv "avail" | awk '{ print $4}'`
        fi 
        if [[ -n "$tmp_out_location" && $no_chk_tmpoutput -eq "0" ]]; then
          if [ $awk_col_tmp_out  -gt 0 ]
          then
 	    space_tmp_out_location=`df -k $tmp_out_location |grep -iv "avail" | awk '{ print $3}'|tail -1 `  
          else
 	    space_tmp_out_location=`df -k $tmp_out_location |grep -iv "avail" | awk '{ print $4}'`
          fi 
	fi
      fi

      if [ $min_curr_space -lt $space_curr_location ]
      then
        space_pass_msg="Space available on $space at $curr_location is $space_curr_location KB"
        curr_loc_space_status=0
      else
        space_fail_msg="${RED}Space available on $space at $curr_location is $space_curr_location KB and required space is $min_curr_space KB $NORM"
        curr_loc_space_status=1
      fi
      #$READ -p "space_pass_msg =$space_pass_msg and space_fail_msg =$space_fail_msg"
      if [ $min_tmp_space -lt $space_tmp_location ]
      then
        space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_location is $space_tmp_location KB"
        local_tmp_space_status=0
      else
        space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_location is $space_tmp_location KB and required space is $min_tmp_space KB $NORM "
        local_tmp_space_status=1
      fi
      if [[ -n "$tmp_out_location" && $no_chk_tmpoutput -eq "0" ]]; then
        if [ $min_tmp_space -lt $space_tmp_out_location ]
        then
          space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_out_location is $space_tmp_out_location KB"
          local_tmp_out_space_status=0
        else
          space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_out_location is $space_tmp_out_location KB and required space is $min_tmp_space KB $NORM "
          local_tmp_out_space_status=1
        fi
      fi
      #$READ -p "space_curr_location=$space_curr_location space_tmp_location=$space_tmp_location min_curr_space=$min_curr_space and min_tmp_space=$min_tmp_space"
    else
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
      then 
	if [ -z $RAT_TMPDIR ]; then tmp_location=`$SSHELL ${node_ssh_user}@$space "echo "\\\$HOME""`; fi

        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && $no_chk_tmpoutput -eq "0" ]]; then
	  #tmp_out_location=`$SSHELL ${node_ssh_user}@$space "bash_scr -c \"if [[ -d $tmp_out_location && -w $tmp_out_location ]]; then echo "\$tmp_out_location"; else echo \"/tmp\"; fi"`
	  tmp_out_location=`$SSHELL ${node_ssh_user}@$space "bash_scr -c \"if [[ -d $tmp_out_location && -w $tmp_out_location ]]; then echo "$tmp_out_location"; else echo 'USR_HOMEDIR'; fi"`
        fi
      fi
      TMPDIRMAP=("${TMPDIRMAP[@]}" $space:$tmp_location);
      TMPOUTMAP=("${TMPOUTMAP[@]}" $space:$tmp_out_location);

      if [ -n "$RAT_TMPDIR" ]
      then
	rattmpdir=`$SSHELL ${node_ssh_user}@$space " $bash_scr -c \"if [ -d $tmp_location ]; then echo 1; else echo 0;fi\""`;
	if [ $rattmpdir -eq 0 ]; then
		echo -e "$RED\n\n$tmp_location does not exist on $space. Please create the directory and rerun ${program_name}$NORM\n\n"   
	        echo -e "$RED\n\n${program_name} is exiting...$NORM\n\n";
        	exit 1
	fi
      fi

      if [[ "$RAT_TMP_OUTPUT" != "USR_HOMEDIR" ]]
      then
	  rattmpdir=`$SSHELL ${node_ssh_user}@$space " $bash_scr -c \"if [ -d $tmp_out_location ]; then echo 1; else echo 0;fi\""`;
        if [ $rattmpdir -eq 0 ]; then
		echo -e "$RED\n\n$tmp_out_location does not exist on $space. Please create the directory and rerun ${program_name}$NORM\n\n"   
                echo -e "$RED\n\n${program_name} is exiting...$NORM\n\n";
                exit 1
        fi

      fi

      if [ `uname -s` = "HP-UX" ] ; then
        space_tmp_location=`$SSHELL ${node_ssh_user}@$space df -k $tmp_location| grep free |awk '{print $1}'`
	if [[ -n "$tmp_out_location" && $no_chk_tmpoutput -eq "0" ]]; then space_tmp_out_location=`$SSHELL ${node_ssh_user}@$space df -k $tmp_out_location 2>/dev/null| grep free |awk '{print $1}'`; fi
      else
        awk_col_tmp=`$SSHELL ${node_ssh_user}@$space df -k  $tmp_location 2>/dev/null|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
	if [[ -n "$tmp_out_location" && $no_chk_tmpoutput -eq "0" ]]; then awk_col_tmp_out=`$SSHELL ${node_ssh_user}@$space df -k  $tmp_out_location 2>/dev/null|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`; fi
        if [ $awk_col_tmp  -gt 0 ]
        then
 	  space_tmp_location=`$SSHELL ${node_ssh_user}@$space df -k $tmp_location 2>/dev/null |grep -iv "avail" | awk '{ print $3}'|tail -1`  
        else
 	  space_tmp_location=`$SSHELL ${node_ssh_user}@$space df -k $tmp_location 2>/dev/null|grep -iv "avail" | awk '{ print $4}'`
        fi 
	if [[ -n "$tmp_out_location" && $no_chk_tmpoutput -eq "0" ]]; then
	  if [ $awk_col_tmp_out -gt 0 ]
	  then
 	    space_tmp_out_location=`$SSHELL ${node_ssh_user}@$space df -k $tmp_out_location 2>/dev/null|grep -iv "avail" | awk '{ print $3}'|tail -1`  
	  else
 	    space_tmp_out_location=`$SSHELL ${node_ssh_user}@$space df -k $tmp_out_location 2>/dev/null|grep -iv "avail" | awk '{ print $4}'`
	  fi
	fi
      fi 
      if  [[ -n "$min_tmp_space" && $min_tmp_space -lt $space_tmp_location ]]
      then
        space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_location is $space_tmp_location KB"
        remote_tmp_space_status=0
      else
        space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_location is $space_tmp_location KB and required space is $min_tmp_space KB $NORM"
        remote_tmp_space_status=1
      fi
      if [[ -n "$tmp_out_location" && $no_chk_tmpoutput -eq "0" ]]; then
        if [[ -n "$min_tmp_space" &&  $min_tmp_space -lt $space_tmp_out_location ]]
        then
          space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_out_location is $space_tmp_out_location KB"
          remote_tmp_out_space_status=0
        else
          space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_out_location is $space_tmp_out_location KB and required space is $min_tmp_space KB $NORM "
          remote_tmp_out_space_status=1
        fi
      fi
    fi
    if [[ $curr_loc_space_status -eq 1 || $local_tmp_space_status -eq 1 || $remote_tmp_space_status -eq 1 || $local_tmp_out_space_status -eq 1 || $remote_tmp_out_space_status -eq 1 ]]; then space_status=1; break; else space_status=0;fi;
  done
  if [[ -n "$1" ]]; then
    if [[ "$1" != "NOLOCALNODE" ]]; then
      if [[ -e $HOSTLIST.bak ]]; then mv -f $HOSTLIST.bak $HOSTLIST; fi
    fi
  fi
}

#Function to compare rpm versions
function compare_rpmversion()
{
  unset rpm_dot1
  unset rpm_dot2
  local IFS=$'.'
  vd_counter1=0
  digits1=0
  for vd in $1
  do
    if [ `echo $vd|grep -c "_" ` -ge 1 ]
    then
      vd=$(echo $vd|cut -d_ -f1)
    fi  
    rpm_dot1[$vd_counter1]=$vd
    vd_counter1=$(expr $vd_counter1 + 1)
  done
  vd_counter2=0
  digits2=0
  for vd in $2
  do
    if [ `echo $vd|grep -c "_" ` -ge 1 ]
    then
      vd=$(echo $vd|cut -d_ -f1)
    fi  
    rpm_dot2[$vd_counter2]=$vd
    vd_counter2=$(expr $vd_counter2 + 1)
  done
  loop_digits=0
  while [ "$loop_digits" -lt "$vd_counter1" ]
  do
    isdigit=$(echo ${rpm_dot1[$loop_digits]}|grep -E '^[0-9]+$')
    if [ -n "$isdigit" ]
    then
      #echo "went to numeric comparision"
      if [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -eq "${rpm_dot1[$loop_digits]}" ]]
      then
        func_rpm_status=0
        #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
      elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -gt "${rpm_dot1[$loop_digits]}" ]]
      then
        func_rpm_status=1
        #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
        return
      elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -lt "${rpm_dot1[$loop_digits]}" ]]
      then
        func_rpm_status=2
        #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
        return
      fi
    else
      isdigit=$(echo ${rpm_dot2[$loop_digits]}|grep -E '^[0-9]+$')
      if [ -n "$isdigit" ]; then
        func_rpm_status=1
        return
      else
        #echo "went to string comparision"
        if [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" = "${rpm_dot1[$loop_digits]}" ]]
        then
          func_rpm_status=0
          #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
        elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" > "${rpm_dot1[$loop_digits]}" ]]
        then
          func_rpm_status=1
          #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
          return
        elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" < "${rpm_dot1[$loop_digits]}" ]]
        then
          func_rpm_status=2
          #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
          return
        fi
      fi
    fi
    loop_digits=$(expr $loop_digits + 1)
  done
}

function nodelist_without_olsnodes ()
{
  if [[ -n "$setup_inittab" ]] && [[ $setup_inittab -eq "3" || $setup_inittab -eq "10" ]] ; then touch $HOSTLIST; return; fi
 
  if [[ $EM_PROBE_MODE -eq 1 ]]
  then
    cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <text nls_id="orhc_exadata_n9_nlsid">
      Unable to determine nodes in cluster. Do you want to enter manually? 
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n10_nlsid">
      Enter cluster node names delimited by comma (for example: node2,node3,node4).
    </text>
  </question>
</group>
EOF
    PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

    readNodeNames="Yes"
    echo `hostname|cut -d. -f1`>$HOSTLIST   

    printf  $RED"Unable to determine nodes in cluster.  Do you want to enter manually.[y/n][y]"$NORM
    echo "\nEnter cluster node names delimited by comma.by defalut localhost will be printed. (eg. node2,node3,node4)"
  else
    printf  $RED"Unable to determine nodes in cluster.  Do you want to enter manually.[y/n][y]"$NORM
    if [[ $EM_XMLD_MODE -eq 1 ]]
    then
      read_probe_xml "Unable to determine nodes in cluster. Do you want to enter manually?"
      readNodeNames=$xml_rvalue
    else
      if [[ $daemon_init_mode -eq 1 ]]; then
	readNodeNames='Y'	
      else
        $READ readNodeNames
      fi
    fi

    case $readNodeNames in
      y|Y|yes|YES|Yes)
        echo `hostname|cut -d. -f1`>$HOSTLIST
        echo "Enter cluster node names delimited by comma.by defalut localhost will be printed. (eg. node2,node3,node4)"
        printf "`hostname|cut -d. -f1`,"
	
	if [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  read_probe_xml "Enter cluster node names delimited by comma (for example: node2,node3,node4)."
	  nodeList=$xml_rvalue
	else
	  if [[ $daemon_init_mode -eq 1 ]]; then
	    nodeList=''
	  else
            $READ nodeList
	  fi
	fi
        echo $nodeList|awk 'BEGIN {RS=","} {print}'|sed '/^$/d'>>$HOSTLIST   
        ;;
      n|N|No|NO) 
        echo ""
        echo `hostname|cut -d. -f1`>$HOSTLIST
        echo -e $RED"Since you did not enter any node names, this script will execute only on the local node.\n"$NORM
        echo "Since you did not enter any node names, this script will execute only on the local node\n" >>$LOGFIL
        echo "">>$LOGFIL
        ;;
      *)
        echo `hostname|cut -d. -f1`>$HOSTLIST
        echo "Enter cluster node names delimited by comma.by default localhost will be printed (eg. node2,node3,node4)"
        printf "`hostname|cut -d. -f1`,"
        $READ nodeList
        #echo $nodeList|sed 's/,/\n/g'>>$HOSTLIST
        echo $nodeList|tr "," "\n">>$HOSTLIST
        ;;
    esac
  fi
}

function func_what_platform ()
{
  os_name=$(uname -s)
  case  ${os_name} in
  Linux)
    #os_bit=$( file /sbin/modinfo |awk '{print $3}'|cut -d- -f1 )
     os_bit=$(getconf LONG_BIT)  
    if [ $os_bit -eq 64 ]
    then
      os_arch="X8664"
      os_arch_env_file="X86-64"
    elif [ $os_bit -eq 32 ]
    then
      os_arch="X86"
      os_arch_env_file="X86"
    fi
    if [ -f /etc/redhat-release ] 
    then
      os_type_full="OELRHEL"
      #os_version=$(cat /etc/redhat-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version_json=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 && `grep -icw "vm server" /etc/redhat-release` -ge 1 && $os_version -eq 3 ]];then os_version=5;fi
      if [[ $is_exadata_dom0_machine -eq 1 && `grep -icw "vm server" /etc/redhat-release` -ge 1 && $os_version -eq 3 ]];then os_version=6;os_version_json=6.4; fi
      if [[ $is_opc -eq 1 && `grep -icw "vm server" /etc/redhat-release` -ge 1 && $os_version -eq 3 ]];then os_version=6;os_version_json=6.4;fi
      if [[ -n $is_bda_dom0 && $is_bda_dom0 -eq 1 && `grep -icw "vm server" /etc/redhat-release` -ge 1 && $os_version -eq 3 ]];then os_version=6;os_version_json=6.4;fi
    elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      os_type_full="OELRHEL"
      os_version=6
      os_version_json=6.4
    elif [ -f /etc/SuSE-release ] 
    then
      os_type_full="Suse" 
      #os_version=$(cat /etc/SuSE-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version_json=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d'(' -f1|sed 's/ //g'|head -1)
      #if [ -z "$os_version" ]; then os_version=$(cat /etc/SuSE-release|grep -i version|awk '{print $3}');fi 
      if [ -z "$os_version" ]; then os_version=$(grep -i version /etc/SuSE-release|awk '{print $3}');fi 
    else
      os_type_full="Unsupported OS"
    fi
    if [[ -n $is_zfssa_machine && $is_zfssa_machine -eq 1 ]];then
      if [[ $os_version -eq 5 || $os_version -eq 6 || $os_version -eq 7 ]];then
        echo
      else
        echo -e "$RED\n\n$program_name is not supported on $os_name version $os_version for checking ZFS best practices.$NORM\n\n"   
        echo -e "$RED\n\n${program_name} is exiting...$NORM\n\n"; 
        exit 1
      fi
    fi
    if [ $(uname -p) = "s390x" ];then os_name="LINUXZ";fi
    what_os=$(echo ${os_name}${os_arch}${os_type_full}${os_version}|tr "[a-z]" "[A-Z]")
  ;;
  SunOS)
    os_bit=$(/usr/bin/isainfo -b)     
    os_version=$(uname -r |cut -d. -f2)
    os_arch=$(uname -p|tr "[a-z]" "[A-Z]")
    if [ "$os_arch" = "I386" ]; then os_arch="X86";os_arch_env_file="X86";fi
    os_arch_env_file=$(echo "(${os_arch}${os_bit}-BIT)")
    os_name="SOLARIS"
    #$READ -p "${os_name}${os_arch_env_file}"
    what_os=$(echo ${os_name}${os_arch}${os_bit}${os_version})
    if [[ -n $is_zfssa_machine && $is_zfssa_machine -eq 1 ]];then
      if [[ $os_version -eq 11 || $os_version -eq 12 ]];then
        echo
      else
        echo -e "$RED\n\n$program_name is not supported on $os_name version $os_version for checking ZFS best practices.$NORM\n\n"
        echo -e "$RED\n\n${program_name} is exiting...$NORM\n\n";
        exit 1
      fi
    fi

    #$READ -p "what os $what_os"
  ;;
  AIX)
    os_bit=$(getconf -a | grep KERN|cut -d: -f2|awk '{print $1}')
    os_version=$(oslevel|awk 'BEGIN { FS = "." } ;{print $1$2}')
    os_name=$(uname -s)
    os_arch=$(uname -p)
    if [ $os_arch = "powerpc" ]; then os_arch="PPC"; fi
    what_os=$(echo ${os_name}${os_arch}${os_bit}${os_version}|sed 's/ //g')
    os_version_env_file=$(oslevel|cut -d. -f1)
    os_name=$(echo ${os_name}${os_version_env_file})
    if [ $os_version_env_file -eq 5 ]; then os_name=$(echo "${os_name}L");fi
    os_arch_env_file=$(echo "(${os_bit}-BIT)")
    if [[ -n $is_zfssa_machine && $is_zfssa_machine -eq 1 ]];then
      echo -e "$RED\n\n$program_name is not supported on $os_name for checking ZFS best practices.$NORM\n\n"
      echo -e "$RED\n\n${program_name} is exiting...$NORM\n\n";
      exit 1
    fi
  ;;
  HP-UX)
    os_name="HPUX"
    os_arch=$(uname -m)
    if [ $os_arch = "ia64" ]; then os_arch="Itanium" ; else os_arch="PARISC"; fi;
    os_version=$(uname -r |  sed 's/[^0-9]*\([0-9][0-9]*\)[^0-9]*/\1/g')
    what_os=$(echo ${os_name}${os_arch}${os_version})
    os_bit=$(getconf KERNEL_BITS);
    if [ "$(uname -m)" = "ia64" ]
    then
      os_arch_env_file=$(echo $(uname -s) $os_arch|tr "[a-z]" "[A-Z]")
    else
      os_bit=$(getconf KERNEL_BITS);
      os_arch_env_file=$(echo $(uname -s) PA-RISC "(${os_bit}-BIT)")
    fi
    if [[ -n $is_zfssa_machine && $is_zfssa_machine -eq 1 ]];then
      echo -e "$RED\n\n$program_name is not supported on $os_name for checking ZFS best practices.$NORM\n\n"
      echo -e "$RED\n\n${program_name} is exiting...$NORM\n\n";
      exit 1
    fi
  ;;
  CYGWIN_NT-[0-9].[0-9])
    os_name="MSWINDOWS"
    os_arch="X86";
    os_bit=64
    os_version=`uname -s | sed 's/CYGWIN_NT-//'| sed 's/\r//'`
    what_os="MSWINDOWS64";
  ;;
  *)
    os_arch="Not supported OS"
    exit 1;
  ;;
  esac
}

function func_what_db ()
{
  if [[ ${rdbms_installed[0]} -eq 1 ]]
  then
    unset what_db
    if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
      what_db=$(grep "RDBMS_ORACLE_HOME = $ORACLE_HOME|" $MASTERFIL|awk '{print $3}'|cut -d '|' -f2)
      DBVERSION=$(grep -i "DB_NAME" $MASTERFIL |grep "|$ORACLE_HOME"|awk '{print $3}'|cut -d'|' -f2)
      if [[ -z "$DBVERSION" ]]; then DBVERSION=$what_db;fi
    else 
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner  
	if [[ -n "$dbOwner" ]]; then
          what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
	fi
    	write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR	
      else
        what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
      fi

      if [ -z $what_db ]; then
        t_flag="-T";
        for hosts in `cat $HOSTLIST`
        do
          if [[ "$hosts" = "$localnode" ]]; then continue; fi

          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            get_dbOwner "$hosts" "1"
	    if [[ -n "$dbOwner" ]]; then 
              what_db=$($SSHELL $t_flag $hosts $bash_scr <<EOF
              cd $dbhome_dir 2>/dev/null; \
              export ORACLE_HOME=$ORACLE_HOME; \
              su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF
)         	
	    fi
    	    write_del_rolbk_tmpoutput
          else
            what_db=$($SSHELL $t_flag $hosts $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME; \
            $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF
)         
          fi
          what_db=$(echo "$what_db"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
          if [[ -n $what_db ]]; then break; fi
        done
      fi

      unset DBVERSION
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner
	if [[ -n "$dbOwner" ]]; then
          DBVERSION=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v|awk '{print \$3}'|sed '/^$/d'")
	fi
    	write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR
      else
        DBVERSION=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed '/^$/d')
      fi

      if [ -z $DBVERSION ]; then
        t_flag="-T";
        for hosts in `cat $HOSTLIST`
        do
          if [[ "$hosts" = "$localnode" ]]; then continue; fi

          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            get_dbOwner "$hosts" "1"
	    if [[ -n "$dbOwner" ]]; then
              DBVERSION=`$SSHELL $t_flag $hosts<<EOF
              cd $dbhome_dir 2>/dev/null;
              export ORACLE_HOME=$ORACLE_HOME
              su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF`  		
	    fi
    	    write_del_rolbk_tmpoutput
          else
            DBVERSION=`$SSHELL $t_flag $hosts<<EOF
            export ORACLE_HOME=$ORACLE_HOME
            $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF`  		
          fi
          DBVERSION=$(echo "$DBVERSION"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed '/^$/d')
          if [[ -n $DBVERSION ]]; then break; fi
        done
      fi
    fi
  else
    what_db="NODATABASE"
    DBVERSION="NODATABASE"  
    #RAT_DB="NODATABASE"
  fi

  if [[ `echo "$what_db"|grep -ic "^1220"` -gt "0" ]]; then what_db="122010"; fi
  if [[ `echo "$DBVERSION"|grep -ic "^1220"` -gt "0" ]]; then DBVERSION="122010"; fi
}

function select_collections4profile_in_perl
{
  if [[ -z $cindex_collect ]]; then cindex_collect=0; fi
  if [[ -z $cindex_root ]]; then cindex_root=0; fi
  if [[ -z $osCheckIndexNo ]]; then osCheckIndexNo=0; fi

  PRF_CC_STATUS=0
  perl_exe=$(which perl| tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi

  if [[ -n $MERGEFILES ]]; then TMP_EXCLUDEFIL="/dev/null"; fi

  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/profile_collections.pl -b \"$bs_reffil\" -i \"$INPUTDIR\" -t \"$targetVesionCheckFil\" -r \"$profileids2run\" -e \"$profileids2exclude\" -u \"$upgrade_mode\" -s \"$SCRIPTPATH\" -c \"$cindex_collect\" -a \"$cindex_root\" -o \"$osCheckIndexNo\" -f \"$RTEMPDIR\" -w \"$RTEMPDIR/nowatch.pid\" -m \"$OFFLINE\" -x \"$EXCLUDEFIL\" -d \"$TMP_EXCLUDEFIL\""
  fi
  $perl_exe $SCRIPTPATH/.cgrep/profile_collections.pl -b "$bs_reffil" -i "$INPUTDIR" -t "$targetVesionCheckFil" -r "$profileids2run" -e "$profileids2exclude" -u "$upgrade_mode" -s "$SCRIPTPATH" -c "$cindex_collect" -a "$cindex_root" -o "$osCheckIndexNo" -f "$RTEMPDIR" -w "$RTEMPDIR/nowatch.pid" -m "$OFFLINE" -x "$EXCLUDEFIL" -d "$TMP_EXCLUDEFIL"

  PRF_CC_STATUS=`echo $?`;
  
  if [[ $OFFLINE -eq 0 ]]; then
    TEMPDIR=$RTEMPDIR
  else
    TEMPDIR=$INPUTDIR
  fi
  if [ -e "$TEMPDIR/.collections.cfg" ]; then osCheckIndexNo=`grep -w "osCheckIndexNo" $TEMPDIR/.collections.cfg|cut -d= -f2|sed 's/ //g'`; fi
  if [ -e "$TEMPDIR/.collections.cfg" ]; then cur_check_index=`grep -w "cur_check_index" $TEMPDIR/.collections.cfg|cut -d= -f2|sed 's/ //g'`; fi
}

# Create small file with only checks from profile
function select_collections4profile
{
  if [[ $aprofile_id = "RANDOMID" ]]
  then
    if [[ $OFFLINE -eq "0" && -n "$run_profile" && $run_profile -eq "1" ]] ; then
      echo "PROFILE_RUN = 1">>$MASTERFIL
      echo "PROFILES = $profileids2run">>$MASTERFIL
      echo "PROFILE_NAMES = $profiles2run">>$MASTERFIL	
    fi
    echo > $INPUTDIR/collections.dat
    echo > $INPUTDIR/rules.dat
    echo "COLLECTIONS_START" > $INPUTDIR/collections.dat
    echo "COLLECTIONS_END" >> $INPUTDIR/collections.dat
    echo "APPENDIX_START" > $INPUTDIR/rules.dat
    echo "APPENDIX_END" >> $INPUTDIR/rules.dat
    echo "RULES_START" >> $INPUTDIR/rules.dat
    echo "RULES_END" >> $INPUTDIR/rules.dat
  else
  #echo Started selecting profile checks : `date`
  bs_reffil=$INPUTDIR/collections.dat.beforeselect
  targetVesionCheckFil=$INPUTDIR/collections.dat.tvc
  cp -f $INPUTDIR/collections.dat $bs_reffil
  grep ".-CHECK_ID" $INPUTDIR/collections.dat > $INPUTDIR/cm.dat
  echo > $INPUTDIR/collections.dat
  #create checks with targetversion values from collections.dat
  if [[ -n "$upgrade_mode" && $upgrade_mode -eq 2 ]]
  then
    grep -w "TARGET_VERSION" $bs_reffil|sed 's/\.//g'|grep $targetversion|cut -d- -f1|sed 's/_//g'>$targetVesionCheckFil
  elif [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 ]]
  then
    grep -w "COMPONENTS" $bs_reffil|grep POSTUPGR|cut -d- -f1|sed 's/_//g'>$targetVesionCheckFil
  fi
  #####################
  cur_check_index=1
  selected_collect_count=0
  selected_root_count=0
  
  cindex_collect=$(grep "OS_COLLECT_COUNT" $bs_reffil|grep -v 'OS_COLLECT_COUNT 0' | cut -d. -f1|sed 's/_//g')
  cindex_root=$(grep "REQUIRES_ROOT_COUNT" $bs_reffil|grep -v 'REQUIRES_ROOT_COUNT 0' | cut -d. -f1|sed 's/_//g')

  if [[ $OFFLINE -eq "0" && -n "$run_profile" && $run_profile -eq "1" ]] ; then
    echo "PROFILE_RUN = 1">>$MASTERFIL
    echo "PROFILES = $profileids2run">>$MASTERFIL
    echo "PROFILE_NAMES = $profiles2run">>$MASTERFIL
  fi
  if [[ $OFFLINE -eq "0" && -n "$exclude_profile" && $exclude_profile -eq "1" ]] ; then
    echo "EXCLUDE_PROFILE_RUN = 1">>$MASTERFIL
    echo "EXCLUDE_PROFILES = $profileids2exclude">>$MASTERFIL
    echo "EXCLUDE_PROFILE_NAMES = $profiles2exclude">>$MASTERFIL
  fi

  if [[ -z $RAT_NO_INSTANT_COLLECTION ]]; then
    select_collections4profile_in_perl
    return;
  fi

  previous_index="";

  while read cline
  do
    CHECK_ID=$(echo "$cline" | awk '{print $3}');
    cindex=$(echo "$cline" | sed 's/\..*//' |sed 's/_//')

    in_profile=0
    ex_profile=1
    if [[ -n "$run_profile" && $run_profile -eq "1" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq 1 ]]
    then
      check_in_profiles
    elif [ $upgrade_mode -ge 2 ]
    then
      check_in_targetversion
    fi
   
    if [[ -n "$run_profile" && $run_profile -eq "1" && $in_profile -eq "1" ]] || [[ $ex_profile -eq "1" && -n "$exclude_profile" && $exclude_profile -eq 1 ]] || [[ -n "$upgrade_mode" && $upgrade_mode -ge 2 && $in_profile -eq "1" ]]
    then
      if [[ `grep -c ".-CHECK_ID $CHECK_ID" $INPUTDIR/collections.dat` -eq 0 ]]
      then # Add only if it does not exists already
        #if [ -z "$previous_index" ] ; then previous_index=$cindex; fi
        #if [ $cindex -ne $previous_index ] ; then
        #  index_to_print=$(expr $cur_check_index + 1)
        #  increment_index=1
        #  previous_index=$cindex
        #else
        #  index_to_print=$cur_check_index
        #  increment_index=0
        #fi
        grep "^_$cindex\." $bs_reffil | grep -v "OS_COLLECT_COUNT" | grep -v "REQUIRES_ROOT_COUNT" | sed 's/_'$cindex'\./_'${cur_check_index}'./' >> $INPUTDIR/collections.dat
        #echo $cline | grep -v "OS_COLLECT_COUNT" | grep -v "REQUIRES_ROOT_COUNT" | sed 's/_'$cindex'\./_'${index_to_print}'./' >> $INPUTDIR/collections.dat
        check_type=$(grep "_${CHECK_ID}-TYPE" $bs_reffil | awk '{print $2}');
        require_root=$(grep "_${CHECK_ID}-REQUIRES_ROOT" $bs_reffil | awk '{print $2}');
        if [[ -n "$check_type" && $check_type = "OS_COLLECT" ]] ; then
          selected_collect_count=$(expr $selected_collect_count + 1)
        fi
        if [[ -n "$require_root" && $require_root -eq "1" ]] ; then
          selected_root_count=$(expr $selected_root_count + 1)
        fi
        #if [[ $increment_index -eq "1" ]] ; then
        cur_check_index=$(expr $cur_check_index + 1)
        #fi
      fi
    fi
    if [[ $cindex_collect -eq $cindex ]] ; then
      echo "_$cur_check_index.0.0.0.0.0.0.0.0.0-OS_COLLECT_COUNT $selected_collect_count" >> $INPUTDIR/collections.dat
      osCheckIndexNo=$cur_check_index
      cindex_collect=0
    fi
    if [[ $cindex_root -eq $cindex ]] ; then
      echo "_$cur_check_index.0.0.0.0.0.0.0.0.0-REQUIRES_ROOT_COUNT $selected_root_count" >> $INPUTDIR/collections.dat
      cindex_root=0
    fi
  done < $INPUTDIR/cm.dat 
  rm -f $INPUTDIR/cm.dat
  sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $bs_reffil >> $INPUTDIR/collections.dat
  #echo Done selecting profile checks : `date`
  #cp -f $bs_reffil $OUTPUTDIR/collections_org.dat
  rm -f $bs_reffil $targetVesionCheckFil >/dev/null 2>&1
  #cp -f $INPUTDIR/collections.dat $OUTPUTDIR/collections_saved.dat
  ##$READ -p "stop"
 fi
}

#calculate no of child processes that can be initiated for SQL checks(psqlplus utility)
function calculate_no_of_child_proc 
{
  perl_exe=$(which perl|tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi

  no_of_child_proc=1
  if [[ -n "$RAT_DB_PAR_LIMIT" && `echo "$RAT_DB_PAR_LIMIT"|grep -c "^[0-9][0-9]*$"` -gt 0 ]] || [[ -n "$RAT_DB_PAR_LIMIT" && `echo "$RAT_DB_PAR_LIMIT"|grep -c "max"` -gt 0 ]]; then LIMIT=$RAT_DB_PAR_LIMIT; fi

  NO_OF_SEL_DBS=${#mb_db_names[@]}
  if [[ -z $NO_OF_SEL_DBS ]]; then NO_OF_SEL_DBS=1; fi

  if [[ -z $LIMIT ]]; then LIMIT=0; fi
  if [[ `echo "$LIMIT"|grep -ic "max"` -eq "0" ]]; then 
    if [[ -z $LIMIT || $LIMIT -eq "0" ]]; then
      LIMIT=`$perl_exe $SCRIPTPATH/.cgrep/psqlplus -q "function:no_of_child_proc"`
    fi
  fi
  
  PROCESSORS=`$perl_exe $SCRIPTPATH/.cgrep/psqlplus -q "function:no_of_cpus"`
  
  if [[ `echo "$LIMIT"|grep -ic "max"` -gt "0" ]]; then 
    if [[ $PROCESSORS > $NO_OF_SEL_DBS ]]; then
      LIMIT=$NO_OF_SEL_DBS
    else
      LIMIT=$PROCESSORS
    fi
  else
    if [[ $LIMIT -gt $NO_OF_SEL_DBS ]]; then 
      print_old_limit=$LIMIT
      LIMIT=$NO_OF_SEL_DBS; 
      if [[ $set_db_par_limit -eq 1 ]]; then 
	print_old_limit=$RAT_DB_PAR_LIMIT
        echo -e "Number of processes to be initiated to run SQL check in parallel is adjusted to $LIMIT from $print_old_limit as number of running databases are $NO_OF_SEL_DBS"
      fi
      echo "Number of processes to be initiated to run SQL check in parallel is adjusted to $LIMIT from $print_old_limit as number of running databases are $NO_OF_SEL_DBS" >> $LOGFIL
    fi
    if [[ $LIMIT -gt $PROCESSORS ]]; then
      echo -e "Warning:Number of processes($LIMIT) to be initiated to run SQL check in parallel will be more than number of processors($PROCESSORS)\n"
      echo "Warning:Number of processes($LIMIT) to be initiated to run SQL check in parallel will be more than number of processors($PROCESSORS)" >> $LOGFIL
      #LIMIT=$PROCESSORS
    fi
  fi
  echo "Number of processes to be initiated to run SQL check in parallel:$LIMIT" >> $LOGFIL
  echo "" >> $LOGFIL

  no_of_child_proc=$LIMIT
}

# Remove checks from collections.dat for which component attributes doesn't 
# matches/fall with/within host components
function host_specific_collections 
{
  CCHOST=$1
  HOST_COMPONENTS=$2

  PERL_CF_STATUS=0
  perl_exe=$(which perl| tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi
   
  if [[ -n $MERGEFILES ]]; then TMP_EXCLUDEFIL="/dev/null"; fi

  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/host_specific_collections.pl -i \"$INPUTDIR\" -w \"$is_windows\" -t \"$RTEMPDIR\" -k \"$RTEMPDIR/nowatch.pid\" -h \"$CCHOST\" -c \"$HOST_COMPONENTS\" -r \"$profileids2run\" -l \"$localnode\" -m \"$RAT_RUNMODE_INTERNAL\" -v \"$mixed_hardware $mixed_hardware_v2 $mixed_hardware_x2_2 $mixed_hardware_x3_2 $mixed_hardware_x4_2 $mixed_hardware_x5_2 $mixed_hardware_x6_2  $mixed_hardware_x7_2\" -o \"$OFFLINE\" -f \"$LOGFIL\" -a \"$is_fmw_machine\" -e \"$fmw_run_comps\" -g \"$fmw_comps_running\" -s \"$SCRIPTPATH\" -b \"$CELLIP\" -x \"$EXCLUDEFIL\" -z \"$exclude_profile\" -d \"$TMP_EXCLUDEFIL\" -u \"$upgrade_mode\""
  fi
  $perl_exe $SCRIPTPATH/.cgrep/host_specific_collections.pl -i "$INPUTDIR" -w "$is_windows" -t "$RTEMPDIR" -k "$RTEMPDIR/nowatch.pid" -h "$CCHOST" -c "$HOST_COMPONENTS" -r "$profileids2run" -l "$localnode" -m "$RAT_RUNMODE_INTERNAL" -v "$mixed_hardware $mixed_hardware_v2 $mixed_hardware_x2_2 $mixed_hardware_x3_2 $mixed_hardware_x4_2 $mixed_hardware_x5_2 $mixed_hardware_x6_2 $mixed_hardware_x7_2" -o "$OFFLINE" -f "$LOGFIL" -a "$is_fmw_machine" -e "$fmw_run_comps" -g "$fmw_comps_running" -s "$SCRIPTPATH" -b "$CELLIP" -x "$EXCLUDEFIL" -z "$exclude_profile" -d "$TMP_EXCLUDEFIL" -u "$upgrade_mode"


  if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]]; then
    cp -f $INPUTDIR/collections.dat $DUMPDIR
  fi

  PERL_CF_STATUS=`echo $?`;
  if [[ $OFFLINE -eq 0 ]]; then
    TEMPDIR=$RTEMPDIR
  else
    TEMPDIR=$INPUTDIR
  fi
}

#combine versions of different products
function combine_versions_checks
{
  cp -f ${REFFIL} ${REFFIL}.beforecombine

  PERL_COMB_STATUS=0
  perl_exe=$(which perl| tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi
  
  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/combine_collections.pl -o \"$OFFLINE\" -p \"$what_os\" -e \"$DUMPDIR/$CHKFIL\" -r \"$REFFIL\" -i \"$INPUTDIR\" -w \"$is_windows\" -a \"$GREP\" -g \"$grp_str\" -t \"$RTEMPDIR\" -v \"${mb_diff_version[@]}\" -k \"$RTEMPDIR/nowatch.pid\" -s \"$SCRIPTPATH\""
  fi
  $perl_exe $SCRIPTPATH/.cgrep/combine_collections.pl -o "$OFFLINE" -p "$what_os" -e "$DUMPDIR/$CHKFIL" -r "$REFFIL" -i "$INPUTDIR" -w "$is_windows" -a "$GREP" -g "$grp_str" -t "$RTEMPDIR" -v "${mb_diff_version[@]}" -k "$RTEMPDIR/nowatch.pid" -s "$SCRIPTPATH"

  PERL_COMB_STATUS=`echo $?`;
  if [[ $OFFLINE -eq 0 ]]; then
    TEMPDIR=$RTEMPDIR
  else
    TEMPDIR=$INPUTDIR
  fi
}

#multiple version support
# create collection.dat file for clusterware. it will be base version. 
# say we have 11202 clusterware & 11107 and 10204 databases
# we loop through check-ids. if for any checkid needs_running=RDBMS or 
# PARAM_PATH=RDBMS then we write the database next to same checkid if 
# its there in basefile
# if not then we add at the end
function append_version_checks_in_perl 
{
  if [[ -z $cur_check_index ]]; then cur_check_index=0; fi

  PERL_AM_STATUS=0
  perl_exe=$(which perl| tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi
 
  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/append_merge_collections.pl -o \"$OFFLINE\" -p \"$what_os\" -e \"$DUMPDIR/$CHKFIL\" -d \"$reffil_old\" -i \"$INPUTDIR\" -w \"$is_windows\" -a \"$GREP\" -g \"$grp_str\" -c \"$cur_check_index\" -t \"$RTEMPDIR\" -v \"${mb_oracle_versions_distinct[@]} $crs_version_in_loop\" -k \"$RTEMPDIR/nowatch.pid\""
  fi 
  $perl_exe $SCRIPTPATH/.cgrep/append_merge_collections.pl -o "$OFFLINE" -p "$what_os" -e "$DUMPDIR/$CHKFIL" -d "$reffil_old" -i "$INPUTDIR" -w "$is_windows" -a "$GREP" -g "$grp_str" -c "$cur_check_index" -t "$RTEMPDIR" -v "${mb_oracle_versions_distinct[@]} $crs_version_in_loop" -k "$RTEMPDIR/nowatch.pid"

  PERL_AM_STATUS=`echo $?`;
  if [[ $OFFLINE -eq 0 ]]; then
    TEMPDIR=$RTEMPDIR
  else
    TEMPDIR=$INPUTDIR
  fi
  if [ -e "$TEMPDIR/.collections.cfg" ]; then cur_check_index=`grep -w "cur_check_index" $TEMPDIR/.collections.cfg|cut -d= -f2|sed 's/ //g'`; fi
}

function append_version_checks ()
{
  #if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; return; fi;
   
  cur_check_index=$(grep ".-CHECK_ID" $INPUTDIR/collections.dat |tail -1 | sed 's/\..*//' |sed 's/_//')
  rm -f $INPUTDIR/insert.dat
  cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.beforemerge

  if [[ -n $RAT_NO_INSTANT_COLLECTION ]]; then
    if [ -z "$stk_line_header" ]; then stk_line_header=$fmt_line_header;fi
    echo -e "\n$stk_line_header" 
    printf "Found multiple combinations of Clusterware and/or RDBMS versions. Preparing necessary checks.This will take some time.  Be Patient\n"
    echo -e "$stk_line_header\n"
  fi
  if [[ -n "$RAT_SKIP_MERGE_INTERNAL" && $RAT_SKIP_MERGE_INTERNAL -eq "1" ]] ; then 
    echo 
    echo "Skipping version checks merge as RAT_SKIP_MERGE_INTERNAL is set";
    echo
    return;
  fi
  # If there is no database with $CRSVERSION, then we need to add it
  crs_version_in_loop="";
  if [[ -n "${mb_oracle_versions_distinct[@]}" && ` echo ${mb_oracle_versions_distinct[@]}|grep -icw "$CRSVERSION"` -eq 0 ]]
  then
    crs_version_in_loop="$CRSVERSION";
  fi

  if [[ -z $RAT_NO_INSTANT_COLLECTION ]]
  then
    append_version_checks_in_perl
    return;
  fi

  for mb_db_version in ${mb_oracle_versions_distinct[@]} $crs_version_in_loop
  do
    #if [ "xxx${CRSVERSION}" != "${mb_db_version}" ]
    #then # Already exists in collection.dat.. commented as we need to update 
      if [ $OFFLINE -eq 0 ]
      then
        grp_str=$(echo ${what_os}"_"${mb_db_version})
      else
        what_os_offline=$(grep "grp_str" $DUMPDIR/$CHKFIL |awk '{print $3}'|cut -d_ -f1)
        grp_str=$(echo ${what_os_offline}"_"${mb_db_version})
      fi
      grp_str=$(echo ${grp_str}"-")
      get_winpath "reffil_old"
      $GREP $grp_str $reffil_old >$INPUTDIR/collections_new_${mb_db_version}.dat
      restore_winpath "reffil_old"
      sed 's/'$grp_str'//g' $INPUTDIR/collections_new_${mb_db_version}.dat > $INPUTDIR/collections_${mb_db_version}.dat

      cat $INPUTDIR/collections_${mb_db_version}.dat |tr -d '\r' >$INPUTDIR/collections_new_${mb_db_version}.dat

      cp -f $INPUTDIR/collections_new_${mb_db_version}.dat $INPUTDIR/collections_${mb_db_version}.dat
      rm -f $INPUTDIR/collections_new_${mb_db_version}.dat
  
      # Go through all collections_new_${mb_db_version}.dat and update collections.dat
      merge_version_dat;
      if [ -f "$INPUTDIR/insert_${mb_db_version}.dat" ]
      then
        cat $INPUTDIR/insert_${mb_db_version}.dat >> $INPUTDIR/insert.dat #fordebug
        cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.saved
        sed -n /_1.0.0.0.0.0.0.0.0.0-LEVEL.1-/,/COLLECTIONS_START/p $INPUTDIR/collections.dat.saved |grep -v COLLECTIONS_START > $INPUTDIR/collections.dat
        cat $INPUTDIR/insert_${mb_db_version}.dat >> $INPUTDIR/collections.dat
        sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $INPUTDIR/collections.dat.saved >> $INPUTDIR/collections.dat
        rm -f $INPUTDIR/insert_${mb_db_version}.dat
        rm -f $INPUTDIR/insert_${mb_db_version}.log
      fi
      rm -f $INPUTDIR/update_${mb_db_version}.dat
      rm -f $INPUTDIR/collections_${mb_db_version}.dat
    #fi
  done
  echo ""
  rm -f $INPUTDIR/insert.dat 
  rm -f $INPUTDIR/collections.dat.beforemerge
  rm -f $INPUTDIR/collections.dat.saved
}

function merge_version_dat ()
{
  #printf "\nSearching for new checks to run for version ${mb_db_version}..."
  #$READ -p "merging $INPUTDIR/collections_${mb_db_version}.dat to $INPUTDIR/collections.dat"
  grep ".-CHECK_ID" $INPUTDIR/collections_${mb_db_version}.dat > $INPUTDIR/cm.dat
  if [[ -n $RAT_DEBUG_V ]] ; then date; fi;
  while read cline
  do
    check_id=$(echo "$cline" | awk '{print $3}');
    merge_this_check=0

    if [[ `grep -c "$check_id-PARAM_PATH RDBMS" $INPUTDIR/collections.dat` -gt 0 || `grep -c "$check_id-NEEDS_RUNNING RDBMS" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-HOME_PATH RDBMS" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-TYPE SQL" $INPUTDIR/collections.dat` -gt 0 ]]
    then  # check need tobe merged
      merge_this_check=1
    fi;

    if [[ `grep -c "$check_id-PARAM_PATH ASM" $INPUTDIR/collections.dat` -gt 0 || `grep -c "$check_id-NEEDS_RUNNING ASM" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-HOME_PATH ASM" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-SOURCE_FILE v_parameter_asm" $INPUTDIR/collections.dat` -gt 0 ]]
    then  # ignore ASM
      merge_this_check=0
    fi;

    if [[ $merge_this_check -eq "1" ]]
    then
      if [[ `grep -c ".-CHECK_ID $check_id" $INPUTDIR/collections.dat` -gt 0 ]]
      then # Exists in base file, just update version
        echo "Update: $cline" >> $INPUTDIR/update_${mb_db_version}.dat #fordebug
        cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.saved
        sed 's/CHECK_ID '$check_id'/CHECK_ID '$check_id' '${mb_db_version}'/' $INPUTDIR/collections.dat.saved > $INPUTDIR/collections.dat
      else # add a new row
        printf ". "
        if [[ -f "$INPUTDIR/insert_${mb_db_version}.dat" && `grep -c ".-CHECK_ID $check_id" $INPUTDIR/insert_${mb_db_version}.dat` -gt 0 ]]
        then #inserted already
	  if [[ `grep ".-CHECK_ID $check_id" $INPUTDIR/insert_${mb_db_version}.dat | grep -c "no-release"` -gt 0 && `grep ".-CHECK_ID $check_id" $INPUTDIR/insert_${mb_db_version}.dat | grep -c "${mb_db_version}"` -eq "0" ]] ; then
            cp -f $INPUTDIR/insert_${mb_db_version}.dat $INPUTDIR/insert_${mb_db_version}.dat.saved
            sed 's/CHECK_ID '$check_id'/CHECK_ID '$check_id' '${mb_db_version}'/' $INPUTDIR/insert_${mb_db_version}.dat.saved > $INPUTDIR/insert_${mb_db_version}.dat
          else
            echo "Already inserted : $cline" >> $INPUTDIR/insert_${mb_db_version}.log
          fi
        else
          echo "Insert: $cline" >> $INPUTDIR/insert_${mb_db_version}.log
          cur_check_index=$(expr $cur_check_index + 1)
          cindex=$(echo "$cline" | sed 's/\..*//' |sed 's/_//')
          echo "Old: " >> $INPUTDIR/insert_${mb_db_version}.log
          grep "^_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat >> $INPUTDIR/insert_${mb_db_version}.log
          echo "New: " >> $INPUTDIR/insert_${mb_db_version}.log
          grep "^_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat | sed 's/_'$cindex'\./_'${cur_check_index}'./' | awk '{print $0" "'${mb_db_version}' }'>> $INPUTDIR/insert_${mb_db_version}.log
	  insert_version_dat "$cindex" "${cur_check_index}" "${mb_db_version}" "$cline"
          #grep "_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat | sed 's/_'$cindex'\./_'${cur_check_index}'./' | awk '{print $0" "'${mb_db_version}' }'>> $INPUTDIR/insert_${mb_db_version}.dat
        fi
      fi
    fi
  done < $INPUTDIR/cm.dat
  rm -f $INPUTDIR/cm.dat
}

function insert_version_dat ()
{
  index="$1"
  cur_index="$2"
  db_version="$3"
  line="$4"

  level=$(echo "$line" | awk -F"-" '{print $2}' | awk '{print $2}' | sed 's/^\s*|\s*$//g')
  m_check_id=$(echo "$line" | awk -F"-" '{print $1}');

  counter=0;
  declare -a parent_check_ids=()
  unset tmp
  for (( i=$level; i>1; i-- ))
  do
    if [[ -z "$tmp" ]]
    then
      tmp=$m_check_id
    fi
    tmp=$(echo "$tmp" | sed "s/[0-9]\./0\./$i")
    parent_check_ids[$counter]=$tmp
    counter=$(expr $counter + 1)
  done
  parent_check_ids[$counter]=$m_check_id

  OIFS=$IFS
  IFS=$'\n'
  for iline in `grep "^_$cindex\." $INPUTDIR/collections_${db_version}.dat`
  do
    icheck_id=$(echo "$iline" | awk -F"-" '{print $1}');
    mark=0
    for pchkid in ${parent_check_ids[@]}
    do
      if [[ "$pchkid" = "$icheck_id" ]]
      then
        mark=1
        break
      fi
    done
    
    if [[ "$mark" -eq "1" ]]
    then
      iline=$(echo $iline |sed 's/_'$index'\./_'${cur_index}'./' | awk '{print $0" "'${db_version}'}')
      echo $iline >> $INPUTDIR/insert_${db_version}.dat
    else
      iline=$(echo $iline |sed 's/_'$index'\./_'${cur_index}'./')
      echo $iline 'no-release' >> $INPUTDIR/insert_${db_version}.dat
    fi
  done
  IFS=$OIFS
}

function set_skip_this_version()
{
  l_mb_db_homes="$1"
  if [[ -n "$rskip_os_sql" && $rskip_os_sql == 1 ]]; then
    skip_this_version=1
    call_get_log_result=0
  else
    skip_this_version=0
  fi
  l_mb_db_home_dname="all"
  if [[ $l_mb_db_homes = "-" ]]
  then
    if [ $OFFLINE -eq 0  ]
    then
      l_mb_db_homes="${mb_oracle_homes[$mb_db_counter]}"
    else
      l_mb_db_homes=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
    fi
    l_mb_db_home_dname="$db_name_to_check"
  fi

  if [[ $RAT_RUNMODE_INTERNAL = "slave" ]] && [[ $COMTYPE = "SQL_COLLECT" || $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]] ; then
    skip_this_version=1
    call_get_log_result=0
  fi

  #if [[ $crsdb_mixed_version=1 && -z $versions_to_run && $COMTYPE = "ORACLE_PATCH"  ]]
  #then # We assumed that all checks with CRSVERSION should be run on all databases. But when crs version is 112 and db is 102, 112 patch checks are run on 10.2 db.
  #  versions_to_run=$CRSVERSION
  #  run_in_multiple_versions=1
  #  echo "Skipping patch check for $CRSVERSION"
  #fi

  if [[ $run_in_multiple_versions -eq 1 ]]
  then
    if [ $OFFLINE -eq 0  ]
    then
      current_version=$(grep "RDBMS_ORACLE_HOME = $l_mb_db_homes|" $MASTERFIL|awk '{print $3}'|cut -d '|' -f2)
    else
      current_version=$(grep "RDBMS_ORACLE_HOME = $l_mb_db_homes|" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f2)
    fi
    if [[ -n "$current_version" && `echo "$versions_to_run" | grep -ic "$current_version"` -eq 0 ]]
    then #dont run
      skip_this_version=1
      call_get_log_result=0
    else
      call_get_log_result=1
    fi
  fi

  #In upgrade mode, we need to skip checks on some versions which are not upgraded
  if [[ $upgrade_mode -gt 0 && ${mb_skip[$mb_db_counter]} -eq "1" ]]
  then
    skip_this_version=1
    call_get_log_result=0
  fi

  # Incase of a branch, a check needs to executed only if the branch succeded on the db
  if [[ $skip_this_version -eq "0" && $CUR_LEVEL -gt "1" ]]
  then
    prev_level=$(expr $CUR_LEVEL - 1)
    if [[ -n "${m_opstat[$prev_level]}" && `echo ${m_opstat[$prev_level]} | grep -ic "$l_mb_db_homes\-$l_mb_db_home_dname"` -eq "0"  && `echo ${m_opstat[$prev_level]} | grep -ic "$l_mb_db_homes\-all"` -eq "0" ]]
    then
      if [[ $l_mb_db_home_dname = "all" && `echo ${m_opstat[$prev_level]} | grep -ic $l_mb_db_homes-` -gt "0" ]] ; then
        # passed on some db. so should not skip.
        echo;
      else
        if [[ -n "${m_opstat[$prev_level]}" && ${m_opstat[$prev_level]} != "passed_on_all_targets" ]] ; then
          #echo
          #echo "Skipping below check "
          #echo "ROW=$ROW"
          #echo "COM=$COM"
          #echo "Passed on ${m_opstat[$prev_level]}"
          #echo "Current Home: $l_mb_db_homes"
          #echo
          skip_this_version=1
          call_get_log_result=0
        fi
      fi
    elif [ -z "${m_opstat[$prev_level]}" ] ; then
     skip_this_version=1
     call_get_log_result=0
    fi
  fi
}

function set_skip_this_target ()
{
  targetname=$1
  # Incase of a branch, a check needs to executed only if the branch succeded on the db
  #echo "$ROW $targetname - $skip_this_target - $CUR_LEVEL"
  if [[ $skip_this_target -eq "0" && $CUR_LEVEL -gt "1" ]]
  then
    prev_level=$(expr $CUR_LEVEL - 1)
    if [[ -n "${m_opstat[$prev_level]}" && `echo ${m_opstat[$prev_level]} | grep -ic $targetname` -eq "0"  ]]
    then
      if [[ `echo ${m_opstat[$prev_level]} | grep -ic passed_on_all_targets` -eq "0" ]] ; then
        skip_this_target=1
        call_get_log_result=0
      fi
    #elif [ -z "${m_opstat[$prev_level]}" ] ; then
    #  if [[ -n "$OPSTAT" && $OPSTAT -eq "0" ]] ; then
    #    skip_this_target=1
    #    call_get_log_result=0
    #  fi
    fi
  fi
}

function func_create_small_files ()
{
  if [[ $EM_PROBE_MODE -eq 1 && -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]]; then return; fi

  #$READ -p "what os=$what_os and what db=$what_db and dbversion=$DBVERSION components=$components"
  combine_version_cntr=0
  reffil_old=$REFFIL
  reffil1_old=$REFFIL1 
  no_of_db_version=${#mb_oracle_versions_distinct[*]}
  if [[ $OFFLINE -eq 0 ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]];
  then
    if [[ -n "$run_acchk" && $run_acchk -eq "1" ]]
    then
      grp_str=$(echo ${what_os}"_1229900");
    else
      #if [ "$TYP" = "-u" ]
      #then
      #   CRSVERSION=$(cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out|head -1|cut -d '|' -f2)
      #   #CRSVERSION=112020
      #else
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq 1 ]]
      then
        CRSVERSION=$exalogic_version
      elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
      then 
        CRSVERSION=$exalytics_version
      elif [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
      then
        CRSVERSION=$bda_version
        CRSVERSION=$(echo $CRSVERSION|sed 's/[^0-9\.]//g'|sed 's/\.//g')
      elif [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]]
      then
        CRSVERSION=$zfssa_version
        CRSVERSION=$(echo $CRSVERSION|sed 's/[^0-9\.]//g'|sed 's/\.//g') 
      elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]] && [[ -n $single_instance_run && $single_instance_run -eq 0 ]] && [[ -n $multiple_db && $multiple_db -eq 0 ]]
      then
        CRSVERSION=$fmw_version
        CRSVERSION=$(echo $CRSVERSION|sed 's/[^0-9\.]//g'|sed 's/\.//g')
      elif [[ -n "$is_exadata_dom0_machine" && $is_exadata_dom0_machine -eq 1 ]] || [[ -n "$is_ssc_globalzone_machine" && $is_ssc_globalzone_machine -eq 1 ]]
      then
        CRSVERSION=122010 
      elif [[ -n "$is_opc" && $is_opc -eq "1" ]] ; then
        CRSVERSION=$(echo $nimbula_version"00"|sed 's/[^0-9\.]//g'|sed 's/\.//g')  #OPCTODO two zeroes are hardcoded
      #following branch is to run preinstall profile to check best practice before installing target database version
      elif [[ -n "$RAT_TORSWITCHES" ]] ; then
        CRSVERSION=$(echo $nimbula_version"00"|sed 's/[^0-9\.]//g'|sed 's/\.//g')
      elif [[ "$profiles2run" = "preinstall" && -n "$targetversion" && $crs_up -eq 0 ]]
      then
        CRSVERSION=$targetversion 
      elif [[ -n "$what_db" && "$what_db" = "NODATABASE"  && $crs_up -eq 0 ]]
      then
        CRSVERSION=122010
        if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]]; then
          CRSVERSION=$fmw_version
          CRSVERSION=$(echo $CRSVERSION|sed 's/[^0-9\.]//g'|sed 's/\.//g')
        fi
      else
       local CRSVERSION=$(echo ${stack_crs_version[0]}|sed 's/\.//g')
        if [[ -z "$CRSVERSION" && -n "$CRS" && $is_exalogic_machine -eq "0" && $is_exalytics_machine -eq "0" && $is_exalogic_foxtrot -eq "0" ]]
        then
          save_crs
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            OLD_OH=$ORACLE_HOME
            ORACLE_HOME=$CRS
            get_dbOwner
            ORACLE_HOME=$OLD_OH
            su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch>/dev/null 2>&1"
            if [ $? -eq 0 ]; then
              CRSVERSION=$(su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'|sed 's/[^0-9\.]//g' | sed 's/[^0-9\.]//g'|sed 's/\.//g'");
            fi
    	    write_del_rolbk_tmpoutput
            cd $OLD_DIR
            unset OLD_DIR
          else
            $CRS/bin/crsctl query $crs_version_switch>/dev/null 2>&1
            if [ $? -eq 0 ]; then CRSVERSION=$($CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'|sed 's/[^0-9\.]//g' | sed 's/[^0-9\.]//g'|sed 's/\.//g'); fi
          fi
          ret_crs
        elif [[ -z "$CRSVERSION" && -z "$CRS" && $is_exalogic_machine -eq "0" && $is_exalogic_foxtrot -eq "0" && $is_exalytics_machine -eq "0" && -n "$what_db" && $single_instance_run -eq 1 ]]
        then
          CRSVERSION=$what_db
        fi

        if [[ `echo "$CRSVERSION"|grep -ic "^1220"` -gt "0" ]]; then CRSVERSION="122010"; fi

        if [[ -n "$RAT_DB" ]]
        then
          CRSVERSION=$(echo "$RAT_DB" |sed 's/\.//g')
        elif [[ -z "$CRSVERSION" && -z "$RAT_DB" ]]
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
            EMSG="${program_name} did not find the Clusterware version from environment.\nPlease set RAT_DB to cluster version in current shell to override and re- run it.\neg export RAT_DB=112020"
            update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e "${RED}${program_name} did not find the Clusterware version from environment.\n\nPlease set RAT_DB to cluster version in current shell to override and re- run it.${NORM}\n\n\neg export RAT_DB=112020"
          exit 1
        fi
        if [ "$what_db" != "NODATABASE" ] && [[ "$what_db" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] &&  [[ "$TYP" != "-b" && $SILENT -eq 0 ]];then crsdb_mixed_version=1;else crsdb_mixed_version=0;fi
        if [ "$what_db" != "NODATABASE" ] && [[ "$what_db" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] &&  [[ $SILENT -eq 0 ]];then crsdb_mixed_version4checks=1;else crsdb_mixed_version4checks=0;fi
      fi
      if [ $is_windows -eq "1" ]; then
        CRSVERSION=$(echo "$CRSVERSION"|sed 's/\.//g')
      fi

      #####code to remove database from list if its already upgraded
      if [ $upgrade_mode -eq 2 ]
      then
        for db_name_to_check in ${mb_db_names_upgraded[@]}
        do
          echo -e "\n${GREEN}Database ${db_name_to_check} is already running at version $targetversion so no upgrade checks are required${NORM}"|tee -a $LOGFIL
        done
        if [[ $CRSVERSION -eq $targetversion && ${#mb_db_names[@]} -eq ${#mb_db_names_upgraded[@]} ]]
        then
          echo -e "\n${GREEN}grid infrastructure and all databases are already upgraded and no pre upgrade checks are required\nExiting....${NORM}"|tee -a $LOGFIL
          exit 0
        fi
        if [ "$CRSVERSION" -gt "$targetversion" ]
        then
          echo -e "${RED}Source vesrsion ($CRSVERSION) is higher than Target version ($targetversion).\n\n${program_name} is exiting...${NORM}\n\n"
          exit 1
        fi
      elif [ $upgrade_mode -eq 3 ]
      then
        targetversion=$CRSVERSION
        if [[ `echo $supportedTargetVersion|grep -icw $CRSVERSION` -lt 1 ]]
        then
          echo -e "\n${GREEN}grid infrastructure is not running $supportedTargetVersionPrint version so can not run post upgrade checks.\nExiting....${NORM}"|tee -a $LOGFIL
          exit 0
        fi
        for db_name_to_check in "${mb_db_names[@]}"
        do
          if [[ -n "${mb_db_names_need_upgrade[@]}" && ` echo ${mb_db_names_need_upgrade[@]}|grep -icw $db_name_to_check` -ge 1 ]]
          then
            echo -e "\n${GREEN}Database version for ${db_name_to_check} is not $supportedTargetVersionPrint so no post upgrade checks are required${NORM}"|tee -a $LOGFIL
          fi
          #for db_name_to_check in ${mb_db_names_upgraded[@]}
          #echo -e "\n${GREEN}Database ${db_name_to_check} is already running at version $what_db so no upgrade checks are required${NORM}"|tee -a $LOGFIL
        done
      fi

      if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]]; then
        if [[ -n "$same_idmdb_usern" && $same_idmdb_usern -eq "1" ]]; then
          combine_version=1
          mb_diff_version[$combine_version_cntr]=$(echo $fmw_version|sed 's/[^0-9\.]//g'|sed 's/\.//g')
          combine_version_cntr=$(expr $combine_version_cntr + 1)
	else
          CRSVERSION=$fmw_version
          CRSVERSION=$(echo $CRSVERSION|sed 's/[^0-9\.]//g'|sed 's/\.//g')
	fi
      fi

      #$READ -p "stop for deleteing databases"
      ###################
      grp_str=$(echo ${what_os}"_"${CRSVERSION})
      #if [ -n "$components" ];then grp_str=$(echo ${grp_str}-${components});fi
      #$READ -p "DBVERSION=$what_db and CRSVERSION=$CRSVERSION crsdb_mixed_version=$crsdb_mixed_version grp_str=$grp_str"
      echo "grp_str = $grp_str">>$MASTERFIL
    fi
  else
    TENVFIL=$DUMPDIR/$CHKFIL
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 && $RAT_RUNMODE_INTERNAL != "slave" ]]; then TENVFIL=$MASTERFIL; fi

    local CRSVERSION=$(echo ${stack_crs_version[0]}|sed 's/\.//g')
    local DBVERSION_OFFLINE=$(grep -i "DB_NAME"  $TENVFIL|cut -d= -f2|cut -d'|' -f2|head -1|sed 's/\.//g')
    upgrade_mode=$(grep UPGRADE_MODE $TENVFIL |awk '{print $3}');
    if [ ! -n "$upgrade_mode" ] ; then upgrade_mode=0; fi

    if [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 ]] ; then targetversion=$CRSVERSION ; fi
    #DB=$(grep -i "DB_NAME" $DUMPDIR/$CHKFIL |cut -d= -f2)
    if [ -n "$DBVERSION_OFFLINE" ] && [[ "$DBVERSION_OFFLINE" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] && [[ "$RUNSWITCH" != "-b" ]];then crsdb_mixed_version=1;else crsdb_mixed_version=0;fi
    if [ -n "$DBVERSION_OFFLINE" ] && [[ "$DBVERSION_OFFLINE" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] ;then crsdb_mixed_version4checks=1;else crsdb_mixed_version4checks=0;fi

    if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]]; then  
      if [[ -n "$same_idmdb_usern" && $same_idmdb_usern -eq "1" ]]; then
        combine_version=1
        mb_diff_version[$combine_version_cntr]=$(echo $fmw_version|sed 's/[^0-9\.]//g'|sed 's/\.//g')
        combine_version_cntr=$(expr $combine_version_cntr + 1)
      else
        CRSVERSION=$fmw_version
        CRSVERSION=$(echo $CRSVERSION|sed 's/[^0-9\.]//g'|sed 's/\.//g')
      fi
    fi 

    #$READ -p "DBVERSION=$DBVERSION_OFFLINE and CRSVERSION=$CRSVERSION crsdb_mixed_version=$crsdb_mixed_version"
    grp_str=$(grep "grp_str" $TENVFIL |awk '{print $3}')
    INPUTDIR_OLD=$INPUTDIR

    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 && $RAT_RUNMODE_INTERNAL != "slave" ]]; then
      printf ""
    else
      INPUTDIR=$DUMPDIR
    fi
    if [[ `grep "PROFILE_RUN = 1" $TENVFIL|grep -v 'EXCLUDE'|wc -l|sed 's/ //g'` -gt "0" ]] ; then
      run_profile=1
      profileids2run=$(grep "PROFILES =" $TENVFIL |grep -v 'EXCLUDE' |cut -d= -f2)
      profiles2run=$(grep "PROFILE_NAMES =" $TENVFIL |grep -v 'EXCLUDE' |cut -d= -f2)
    fi
  fi

  #CRSVERSION was coming empty in insert statement so declared this new variable to use in insert statement because CRSVERSION is local to this function
  CRSVERSION_UPLOAD=$CRSVERSION
  VERSION_DAT=$SCRIPTPATH/.cgrep/versions.dat;
  if [[ -z "$RAT_RUNMODE_INTERNAL" ]] ; then
    if [[ $DECRYPT_VDAT = 1 ]];
    then
      get_winpath "VERSION_DAT"
      $GREP '' $VERSION_DAT > $INPUTDIR/versions.dat
      restore_winpath "VERSION_DAT"
    else
      cp -f $VERSION_DAT $INPUTDIR/versions.dat
    fi

    get_winpath "REFFIL"
    $GREP $grp_str $REFFIL >$INPUTDIR/collections_new.dat
    grp_str=$(echo ${grp_str}"-")
    #$READ -p "grep string =$grp_str"
    sed 's/'$grp_str'//g' $INPUTDIR/collections_new.dat > $INPUTDIR/collections.dat
    #$READ -p "stop 1"
    if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
    then
      $GREP -s -n /COLLECTIONS_START/,/COLLECTIONS_END/p $REFFIL >> $INPUTDIR/collections.dat
    else
      sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $REFFIL >> $INPUTDIR/collections.dat
    fi
    restore_winpath "REFFIL"
    #to remove control-M after creating small files.
    cat $INPUTDIR/collections.dat |tr -d '\r' >$INPUTDIR/collections_new.dat

    cp -f $INPUTDIR/collections_new.dat $INPUTDIR/collections.dat
    osCheckIndexNo=$(grep "OS_COLLECT_COUNT" $INPUTDIR/collections.dat|grep -v "_-OS_COLLECT_COUNT 0" | cut -d. -f1|sed 's/_//g')
    #$READ -p "osCheckIndexNo=$osCheckIndexNo"
    rm -f  $INPUTDIR/collections_new.dat
    #$READ -p "stop 2"
    # Merge the collections from other db versions
    if [[ -n "$crsdb_mixed_version4checks" && $crsdb_mixed_version4checks -eq 1 && -n "$upgrade_mode" && $upgrade_mode -ne "3" && $TYP != "-p" && $aprofile_id != "RANDOMID" ]]
    then #multiple_version_support. But for post upgrade we only check latest, no need to merge
      append_version_checks;
    fi
    if [[ -n "$run_profile" && $run_profile -eq "1" ]] || [ $upgrade_mode -eq 2 ] || [[ -n "$exclude_profile" && $exclude_profile -eq 1 ]]; then
      select_collections4profile
    fi
    if [ $SILENT -eq 0 ]
    then
      get_winpath "REFFIL1"
      $GREP $grp_str $REFFIL1 >$INPUTDIR/rules_new.dat
      sed 's/'$grp_str'//g' $INPUTDIR/rules_new.dat > $INPUTDIR/rules.dat
      if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
      then
        $GREP -s -n /APPENDIX_START/,/APPENDIX_END/p $REFFIL1 >> $INPUTDIR/rules.dat
        $GREP -s -n /RULES_START/,/RULES_END/p $REFFIL1 >> $INPUTDIR/rules.dat
      else
        sed -n /APPENDIX_START/,/APPENDIX_END/p $REFFIL1 >> $INPUTDIR/rules.dat
        sed -n /RULES_START/,/RULES_END/p $REFFIL1 >> $INPUTDIR/rules.dat
      fi
      restore_winpath "REFFIL1"
      REFFIL1=$INPUTDIR/rules.dat
      cat $REFFIL1 | tr -d '\r'> $INPUTDIR/rules_new.dat
      cp -f $INPUTDIR/rules_new.dat $REFFIL1
      rm -f $INPUTDIR/rules_new.dat
      if [[ -n "$crsdb_mixed_version" && $crsdb_mixed_version -eq 1 ]]
      then
        for mb_db_version in ${mb_oracle_versions_distinct[@]}
        do
          if [ $OFFLINE -eq 0 ]
          then
            grp_str=$(echo ${what_os}"_"${mb_db_version})
          else
            TENVFIL=$DUMPDIR/$CHKFIL
            if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 && $RAT_RUNMODE_INTERNAL != "slave" ]]; then TENVFIL=$MASTERFIL; fi

            what_os_offline=$(grep "grp_str" $TENVFIL |awk '{print $3}'|cut -d_ -f1)
            grp_str=$(echo ${what_os_offline}"_"${mb_db_version})
            #$READ -p "grp_str=$grp_str"
          fi
          grp_str=$(echo ${grp_str}"-")
          get_winpath "reffil1_old"
          $GREP $grp_str $reffil1_old >$INPUTDIR/rules_new_${mb_db_version}.dat
          sed 's/'$grp_str'//g' $INPUTDIR/rules_new_${mb_db_version}.dat > $INPUTDIR/rules_${mb_db_version}.dat
          if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
          then
            $GREP -s -n /RULES_START/,/RULES_END/p $reffil1_old >> $INPUTDIR/rules_${mb_db_version}.dat
          else
            sed -n /RULES_START/,/RULES_END/p $reffil1_old >> $INPUTDIR/rules_${mb_db_version}.dat
          fi
          restore_winpath "reffil1_old"
          #REFFIL2=$INPUTDIR/rules_crs.dat
          cat $INPUTDIR/rules_${mb_db_version}.dat |tr -d '\r' >$INPUTDIR/rules_new_${mb_db_version}.dat
          cp -f $INPUTDIR/rules_new_${mb_db_version}.dat $INPUTDIR/rules_${mb_db_version}.dat
          rm -f $INPUTDIR/rules_new_${mb_db_version}.dat
        done
      fi
    fi
    REFFIL=$INPUTDIR/collections.dat
 
    if [[ -n $combine_version_cntr && $combine_version_cntr -ne 0 && -n $no_of_db_version && $no_of_db_version -ne 0 ]]; then combine_versions_checks; fi

    #APPENDIX=$INPUTDIR/appendix.dat
    if [ $OFFLINE -eq 1 ]
    then
      INPUTDIR=$INPUTDIR_OLD
    else
      validate_data_file
    fi
  else
    REFFIL=$INPUTDIR/collections.dat
    INPUTDIR=$INPUTDIR_OLD
  fi
  #$READ -p "REFFIL=$REFFIL REFFIL1=$REFFIL1 REFFIL2=$REFFIL2"
  if [[ -z $RAT_USER_DEFINED_CHECKS && -e "$SCRIPTPATH/user_defined_checks.xml" ]]
  then
    RAT_USER_DEFINED_CHECKS="$SCRIPTPATH/user_defined_checks.xml";
  fi

  if [[ -z $RAT_USER_DEFINED_CHECKS &&  $aprofile = "user_defined_checks" ]]
  then
    echo "User defined checks profile cannot be run as RAT_USER_DEFINED_CHECKS is null and user_defined_checks.xml does not exist. Exiting...";
    exit 1;
  fi

  if [[ -n $RAT_USER_DEFINED_CHECKS && $run_check -eq 0 ]]
  then
    UDC=$WRKDIR/user_defined_checks.out
    touch $UDC >/dev/null 2>&1
  fi

  if [[ -n $RAT_USER_DEFINED_CHECKS && $skip_usr_def_checks -eq 0 && $run_check -eq 0 ]]
  then
    if [[ -n $RAT_SKIP_XML_VALIDATION ]]
    then
      validate_xml="xml validates";
    else
      XMLLINT=`which xmllint`	
      `$XMLLINT --noout --schema $XSD_FILE $RAT_USER_DEFINED_CHECKS >& $WRKDIR/xml_validation.out`;
      if [[ -e "$WRKDIR/xml_validation.out" ]]
      then
        validate_xml=`cat $WRKDIR/xml_validation.out`;
      fi
    fi
    if [[ -n $validate_xml && $validate_xml == *" validates"* ]]
    then
      if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
      then
        if [[ $usern = "root" ]]
        then
    	  echo "User defined checks will not be run as the user is root..";
        else
          echo "
    	User defined checks xml found. Parsing ...";
          $perl_exe $SCRIPTPATH/.cgrep/parse_user_defined_checks.pl $grp_str $REFFIL $REFFIL1 $UDC $components $RAT_USER_DEFINED_CHECKS $WRKDIR
        fi
      fi
    else
      curnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`; 
      if [[ $curnode = "$localnode" ]]
      then
 	touch $WRKDIR/udc_skipped.log >/dev/null 2>&1
	echo "User defined checks will not be executed as the xml $RAT_USER_DEFINED_CHECKS did not validate against the given xsd user_defined_checks.xsd

Command to validate- $XMLLINT --noout --schema $XSD_FILE $RAT_USER_DEFINED_CHECKS

Tool to validate xml over xsd: http://xmlsoft.org/xmllint.html";

 	 echo "\nUser defined checks will not be executed as the xml did not validate against the given xsd user_defined_checks.xsd\n" >> $WRKDIR/${program_name}.log 2>/dev/null
      fi
    fi
  fi

  if [ $run_check -eq 1 ]
  then
    hostvv=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`;
    $perl_exe $SCRIPTPATH/.cgrep/run_individual_checks.pl "run" $EXCLUDEFIL $REFFIL $REFFIL1 $check2run $INPUTDIR $OUTPUTDIR $SKIPFIL $components $hostvv $EXCLUDELOG
  fi

  if [ $exclude_check -eq 1 ]
  then
    hostvv=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`;
    $perl_exe $SCRIPTPATH/.cgrep/run_individual_checks.pl "exclude" $EXCLUDEFIL $REFFIL $REFFIL1 $check2run $INPUTDIR $OUTPUTDIR $SKIPFIL $components $hostvv $EXCLUDELOG
  fi

  #if [[ -n "$RAT_LOAD_CHECK_ATTRIBUTES" && -z $MERGEFILES ]]; then load_checks_attributes; fi   
}

load_checks_attributes ()
{
  PERL_CA_STATUS=0
  perl_exe=$(which perl| tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi

  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/load_checks_attributes.pl -b \"$bash_scr\" -i \"$INPUTDIR\" -f \"$RTEMPDIR\" -w \"$RTEMPDIR/nowatch.pid\""
  fi
  $perl_exe $SCRIPTPATH/.cgrep/load_checks_attributes.pl -b "$bash_scr" -i "$INPUTDIR" -f "$RTEMPDIR" -w "$RTEMPDIR/nowatch.pid"

  PERL_CA_STATUS=`echo $?`;
  if [[ -n "$PERL_CA_STATUS" && $PERL_CA_STATUS -ne 0 ]]; then unset RAT_LOAD_CHECK_ATTRIBUTES; fi
}

validate_data_file ()
{
if [[ $aprofile_id != "RANDOMID" ]]
then
  no_of_checks=$(grep -ic "CHECK_ID" $REFFIL)
  if [[ -n "$no_of_checks" && $no_of_checks -le 0 ]]
  then
    if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]
    then  
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="RC-003- Your platform/version is not currently supported.\nPlease refer to the section for this error code in \"Appendix A - Troubleshooting Scenarios\" of the ${program_name} User Guide."
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      errm="RC-003- Your platform/version is not currently supported.  Please refer to the section for this error code in Appendix A - Troubleshooting Scenarios of the ${program_name} User Guide" 
      echo -e "\n${RED}RC-003- Your platform/version is not currently supported.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n${program_name} exiting .....\n${NORM}" 
    else
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="RC-003 - Your platform/version is not currently supported but more platform/version support is being added regularly.\nPlease check My Oracle Support (MOS) Note 1070954.1 for information about planned support for platforms/versions."
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      errm="RC-003- Your platform/version is not currently supported.  Please refer to the section for this error code in Appendix A - Troubleshooting Scenarios of the ${program_name} User Guide" 
      echo -e "\n${RED}RC-003 - Your platform/version is not currently supported but more platform/version support is being added regularly. Please check My Oracle Support (MOS) Note 1070954.1 for information about planned support for platforms/versions.\n\n${program_name} exiting .....\n${NORM}" 
    fi 
    update_errm_in_syslog; 
    exit 1;       
  fi
fi
}

function validate_datafile_date ()
{
  #Check that data file are  not too old. if data file is more than 90 days
  #it will ask the confirmation and if customer wants, can abort and get new data files
  if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then return; fi
  #Not to execute validate_datafile_date on ODA because no warning to customer and update should be from ODA bundle only
  if [[ -z "$RAT_ENABLE_STALENESS_VALIDATION" ]]
  then
      if [ -e /opt/oracle/oak/install/inittab ];then return; fi
      if [ -e /opt/oracle/bda ];then return; fi
  fi
  if [ $is_opc -eq 1 ] ; then return; fi
  if [ -f "/etc/nimbula_version" ] ; then return; fi
  if [[ -n "$RAT_DISABLE_STALENESS_VALIDATION" && $RAT_DISABLE_STALENESS_VALIDATION -eq 1 ]];then return; fi 
  sysDateYear=$(date '+%Y')
  sysDateMonth=$(date '+%m'|sed 's/^0//')
  sysDateDay=$(date '+%d'|sed 's/^0//')
  dataFIleDay=$(echo $dataFIleDay|sed 's/^0//')
  dataFIleMonthNo=$(echo $dataFIleMonthNo|sed 's/^0//') 
  file_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,00,"'$dataFIleDay'",'$dataFIleMonthNo'-1,'$dataFIleYear');')
  sys_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,00,"'$sysDateDay'",'$sysDateMonth'-1,'$sysDateYear');')
  diff_epoch=`expr $sys_epoch - $file_epoch`
  #echo "\n\ndataFIleDay=$dataFIleDay dataFIleMonthNo=$dataFIleMonthNo dataFIleYear=$dataFIleYear file_epoch=$file_epoch diff_epoch=$diff_epoch\n\n">>$LOGFIL


  if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]] || [[ -z "$RAT_NOUPGRADE" && $no_upgrade -eq "0" ]]
  then
    if [[ -n "$diff_epoch" && $diff_epoch -lt 11232000 ]]
    then
	validVersionDays=$(expr $diff_epoch / 60 / 60 / 24)
        validVersionDays=$(expr 120 - $validVersionDays)	
    fi

    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      unset RAT_UPGRADE_LOC
    fi

    if [[ -n "$RAT_UPGRADE_LOC" ]]
    then
      check_upgrade
      if [ "$check_upgrade_ret_val" = "-1" ]
      then
	echo "
	unzip is not found. please install unzip, add it to the path and run again.
	";
      fi
      if [[ "$check_upgrade_ret_val" != "0" && "$check_upgrade_ret_val" != "-1" ]]
      then	
        if [[ $daemon_running -ne "1" ]] 
        then
          #latest_ver=$(echo $check_upgrade_ret_val | tr "," "\n");
          PRERDIR=`pwd`;
	  if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
	  then
            echo -e $RED"This version of ${program_name} was released on $dataFilesDate and its older than 120 days.${NORM}\n\n"
	  fi
          oldVersionWarningMessage="Ran older version of ${program_name} released on ${dataFilesDate}"
          exec 3<&2; exec 2<&0
	  veratloc=`cat $WRKDIR/versionfil.dat`;
	  rm -rf $WRKDIR/versionfil.dat;
	  newscrloc=$(echo $check_upgrade_ret_val|sed 's/extract_files//g');
	  if [[ $daemon_init_mode -eq 1 || $daemon_init_mode_sudo -eq "1" ]] ; then
            $READ -p  "
Latest version of ${program_name} ($veratloc) is available at $newscrloc."
            exec 2<&3
	    cdfYesNo='y'
	  else
            $READ -p  "
Latest version of ${program_name} ($veratloc) is available at $newscrloc.

Do you want to upgrade to the latest version of ${program_name}? [y/n][y]" cdfYesNo
	    read_code=`echo $?`;
            exec 2<&3
	    write_in_env "UPG_VERSION_OPTION" "$cdfYesNo"
	    process_prompt "$read_code" "cdfYesNo" "n"
	  fi

          case $cdfYesNo in
            y|Y|yes|YES|Yes) 
              cdfYes=1
              #UPDATE_RUN=1 
              #au_checked=1
              #download_from_mos
              upgrade_orachk
	      if [ $readonlyval -eq "1" ] ; then
		exec 3<&2; exec 2<&0
		$READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
		read_code=`echo $?`;
	        exec 2<&3
	  	write_in_env "RUN_AVAILABLE_VERSION_OPTION" "$cdfYesNo"
		process_prompt "$read_code" "cdfYesNo" "y"

	        case $cdfYesNo in
	          y|Y|yes|YES|Yes)
	            cdfYes=1
	            ;;
	          n|N|No|NO) echo "Exiting ... "
	            exit 0;
	            ;;
	          *)
	            cdfYes=1
	            ;;
	        esac

		echo "Running older version...";
	      else
                echo "Running the latest version...";
		NEWDIR=$(dirname $0)
		rm -rf $WRKDIR/cgrep;
                $NEWDIR/${program_name} ${argsaved};
                exit 0;
	      fi		
              ;;
            n|N|No|NO) echo ""
              #cdfYes=1
              #cleanup
              #exit 1
	      rm -rf $check_upgrade_ret_val;
              ;;
            *)
              cdfYes=1
              #UPDATE_RUN=1 
              #au_checked=1
              #download_from_mos
              upgrade_orachk
	      if [ $readonlyval -eq "1" ] ; then
		exec 3<&2; exec 2<&0
                $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
		read_code=`echo $?`;
                exec 2<&3
	  	write_in_env "RUN_AVAILABLE_VERSION_OPTION" "$cdfYesNo"
		process_prompt "$read_code" "cdfYesNo" "y"

                case $cdfYesNo in
                  y|Y|yes|YES|Yes)
                    cdfYes=1
                    ;;      
                  n|N|No|NO) echo "Exiting ... "
                    exit 0; 
                    ;;      
                  *)      
                    cdfYes=1
                    ;;      
                esac
		echo "Running older version...";
              else             
                echo "Running the latest version...";
		NEWDIR=$(dirname $0)
		rm -rf $WRKDIR/cgrep;
                $NEWDIR/${program_name} ${argsaved};
                exit 0;
	      fi
              ;;
          esac
        else
	  if [[ $daemon_init_mode -eq 1 || $daemon_init_mode_sudo -eq "1" ]] ; then  
	    echo ""
          else
            echo "Daemon is running. Sending email!!";
            upgrade_email_subj="New version of ${program_name} is available";
	    veratloc=`cat $WRKDIR/versionfil.dat`;
	    rm -rf $WRKDIR/versionfil.dat;
	    newscrloc=$(echo $check_upgrade_ret_val|sed 's/extract_files//g');
            matter="A new version of ${program_name} ($veratloc) is available at $newscrloc. Please restart the ${program_name} daemon to upgrade to latest version";
            send_email "$upgrade_email_subj" "$matter" "0" "all";
          fi
        fi #Daemon 
      else
       if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
       then
        echo -e $RED"This version of ${program_name} was released on $dataFilesDate and its older than 120 days. No new version of ${program_name} is available in RAT_UPGRADE_LOC. It is highly recommended that you download the latest version of ${program_name} from my oracle support to ensure the highest level of accuracy of the data contained within the report.${NORM}\n\n"
	if [[ $daemon_init_mode -eq 1 || $daemon_init_mode_sudo -eq "1" ]] ; then
	  dlYesNo="No"
	  cdfYesNo="Yes"
        else
          exec 3<&2; exec 2<&0
	  $READ -p  "Do you want to download latest version from my oracle support? [y/n][y]" dlYesNo
	  read_code=`echo $?`;
          exec 2<&3
	  echo ""
	  write_in_env "DOWNLOAD_VERSION_OPTION" "$dlYesNo"
	  process_prompt "$read_code" "dlYesNo" "y"
	  	  
          case $dlYesNo in
            y|Y|yes|YES|Yes)
              dlYes=1
              mkdir $OUTPUTDIR >/dev/null 2>&1
              if [ ! -d $RTEMPDIR ]; then mkdir $RTEMPDIR >/dev/null 2>&1;fi

              download_from_ARU
              ;;
            n|N|No|NO)
              dlYes=0
   	      DOWNLOAD_STATUS=0
              ;;
            *)
              dlYes=1
              mkdir $OUTPUTDIR >/dev/null 2>&1
              if [ ! -d $RTEMPDIR ]; then mkdir $RTEMPDIR >/dev/null 2>&1;fi

              download_from_ARU
              ;;
          esac 

	  if [[ -n $DOWNLOAD_STATUS && $DOWNLOAD_STATUS -eq "0" ]]; then
            exec 3<&2; exec 2<&0
            $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
	    read_code=`echo $?`;
            exec 2<&3
	    write_in_env "RUN_AVAILABLE_VERSION_OPTION" "$cdfYesNo"
	    process_prompt "$read_code" "cdfYesNo" "y"
	  else
	    which zip >/dev/null 2>&1
	    if [ `echo $?` -ne 0 ]; then
	      echo "
	      unzip is not found. please install unzip, add it to the path and run again.
	      ";
              exec 3<&2; exec 2<&0
              $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
	      read_code=`echo $?`;
              exec 2<&3
	      write_in_env "RUN_AVAILABLE_VERSION_OPTION" "$cdfYesNo"
	      process_prompt "$read_code" "cdfYesNo" "y"
	    else
              exec 3<&2; exec 2<&0
	      $READ -p  "Do you want to upgrade to the latest version of ${program_name}? [y/n][y]" upgYesNo
              read_code=`echo $?`;
              exec 2<&3
              write_in_env "UPG_VERSION_OPTION" "$upgYesNo"
              process_prompt "$read_code" "upgYesNo" "n"
		
              case $upgYesNo in
                y|Y|yes|YES|Yes)
                  upgYes=1
                  ;;
                n|N|No|NO) echo ""
                  upgYes=0
                  exec 3<&2; exec 2<&0
                  $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
	          read_code=`echo $?`;
                  exec 2<&3
	          write_in_env "RUN_AVAILABLE_VERSION_OPTION" "$cdfYesNo"
	          process_prompt "$read_code" "cdfYesNo" "y"
                  ;;
                *)
                  upgYes=1
                  ;;
              esac

	      if [[ -n $upgYes && $upgYes -eq "1" ]]; then
	        mkdir $OUTPUTDIR/extract_files >/dev/null 2>&1
		unzip -o $DOWNLOADED_ZIP -d $OUTPUTDIR/extract_files >/dev/null 2>&1
		check_upgrade_ret_val=$OUTPUTDIR/extract_files
	
	        upgrade_orachk
                if [ $readonlyval -eq "1" ] ; then
                  exec 3<&2; exec 2<&0
                  $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
                  read_code=`echo $?`;
                  exec 2<&3
                  write_in_env "RUN_AVAILABLE_VERSION_OPTION" "$cdfYesNo"
                  process_prompt "$read_code" "cdfYesNo" "y"
                else
                  echo "Running the latest version...";
                  NEWDIR=$(dirname $0)
		  rm -rf $WRKDIR/cgrep;
                  $NEWDIR/${program_name} ${argsaved};
                  exit 0;
                fi
	      fi
	    fi	    
          fi
	fi

        case $cdfYesNo in
          y|Y|yes|YES|Yes)
            cdfYes=1
            echo "Running older version...";
            ;;
          n|N|No|NO) echo "Exiting ... "
            exit 0;
            ;;
          *)
            cdfYes=1
            echo "Running older version...";
            ;;
        esac 
       fi
      fi # check_upgrade_ret_val !=  0
    else
     if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
     then
      echo -e $RED"This version of ${program_name} was released on $dataFilesDate and its older than 120 days. It is highly recommended that you download the latest version of ${program_name} from my oracle support to ensure the highest level of accuracy of the data contained within the report.${NORM}\n\n"
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
        cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n27_nlsid">
        This version of ${program_name} was released on {1} and is older than 120 days. Download the latest version of ${program_name} from My Oracle Support to ensure the highest level of accuracy of the data contained within the report. 
      </text>
      <tokens>
        <token index="1">$dataFilesDate</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n11_nlsid">
      Do you want to continue running this version? 
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
        cdfYesNo="Yes"

        echo -e "Do you want to continue running this version? [y/n][y]"
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
        echo -e "Do you want to continue running this version? [y/n][y]"

        read_probe_xml "Do you want to continue running this version?"
	cdfYesNo=$xml_rvalue
      else
	if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
        then
	  if [[ $daemon_init_mode -eq 1 || $daemon_init_mode_sudo -eq "1" ]] ; then
	    cdfYesNo="Yes"
          else
            exec 3<&2; exec 2<&0
	    $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
	    read_code=`echo $?`;
            exec 2<&3
	    write_in_env "RUN_AVAILABLE_VERSION_OPTION" "$cdfYesNo"
	    process_prompt "$read_code" "cdfYesNo" "y"
	  fi
	else
	  cdfYesNo="Yes"
	fi
      fi
      case $cdfYesNo in
        y|Y|yes|YES|Yes)
          cdfYes=1
          ;;
        n|N|No|NO) echo "Exiting ... "
          exit 0;
          ;;
        *)
          cdfYes=1
          ;;
      esac
     fi
    fi #if [[ -n "$RAT_UPGRADE_LOC" ]]
  else
    validVersionDays=$(expr $diff_epoch / 60 / 60 / 24)
    validVersionDays=$(expr 120 - $validVersionDays)
  fi # if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
}

function write_asm_version_master ()
{
  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then return; fi

  if [[ ${stack_asm_up[0]} -eq 1 ]]
  then
    OLD_ORACLE_HOME=$ORACLE_HOME
    OLD_ORACLE_SID=$ORACLE_SID
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then
      export ORACLE_SID=${stack_asm_sid[$stack_counter]}
      export ORACLE_HOME=$CRS
    else
      export ORACLE_HOME=${stack_asm_home[$stack_counter]}
      export ORACLE_SID=${stack_asm_sid[$stack_counter]}
    fi
    #$READ -p "IS_SYSDBA=$IS_SYSDBA ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID"
    # added 1=2 in first part of if to always fail because we never ask asm sysdba password and always login as / as sysdba
    if [[ -n $IS_SYSDBA && $IS_SYSDBA -eq 0 && 1 -eq 2 ]]
    then 
      #$READ -p "write asm version without asm sysdba"
      if [ `hostname|grep -c "\."` -ge 1 ]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
          select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\\\\\\\$instance;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"`

	  echo "$STORE_VAL" >> $MASTERFIL
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	  write_del_rolbk_tmpoutput
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          echo "set feedback  off heading off
          select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$>>$MASTERFIL
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	fi
      else
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
          select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\\\\\\\$instance;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"`

	  echo "$STORE_VAL" >> $MASTERFIL
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	  write_del_rolbk_tmpoutput
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          echo "set feedback  off heading off
          select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$>>$MASTERFIL
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	fi
      fi
    else
      if [ `hostname|grep -c "\."` -ge 1 ]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

	  STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
	  select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\\\\\\\$instance;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"`
	  echo "$STORE_VAL" >> $MASTERFIL
    	  write_del_rolbk_tmpoutput
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          echo "set feedback  off heading off
          select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$>>$MASTERFIL
	fi
      else
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

          STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
          select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\\\\\\\$instance;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"`
	  echo "$STORE_VAL" >> $MASTERFIL
    	  write_del_rolbk_tmpoutput
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          echo "set feedback  off heading off
          select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$>>$MASTERFIL
	fi
      fi
    fi
    export ORACLE_HOME=$OLD_ORACLE_HOME
    export ORACLE_SID=$OLD_ORACLE_SID

    if [[ $olsnodes_ssh_disabled -eq 1 ]];
    then
      tmp_client_host=""
      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*};
        client_host=${mapping#*:};
      	tmp_client_host=$(echo $client_host|awk -F"." '{print $1}');
        sed 's/'$tmp_client_host'\.+/'$management_host'\.+/' $MASTERFIL >$MASTERFIL.new
        mv -f $MASTERFIL.new $MASTERFIL
      done
    fi
  fi
}

# this fucntion to check the environment is set for uplaoding raccehck result to database or not
# modified by kumar
function upload_result_env_check ()
{
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  if [[ -n "$1" && -n "$RAT_UPLOAD_USER"  && -n "$RAT_UPLOAD_PASSWORD" && -n "$RAT_UPLOAD_CONNECT_STRING" ]]
  then
    raccheck_upload_env_set=1
  else
    raccheck_upload_env_set=0
  fi
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
}

# this function is to check the database connectvity before uploading raccheck result to database at the end of the run
function upload_result_conn_check () 
{
  #$READ -p "raccheck_upload_env_set=$raccheck_upload_env_set"
  if [[ -n $raccheck_upload_env_set && $raccheck_upload_env_set -eq 1  ]]
  then
    if [ -n "$RAT_UPLOAD_ORACLE_HOME" ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
        get_dbOwner
	ORACLE_HOME=$OLD_OH
        if [[ -z $ORACLE_HOME ]];then export ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME; fi
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        upload_result_conn=$(su $dbOwner -c "echo \"set heading off
        select 1 from dual;\"|$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" 2>&1|grep -v ^$")
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	write_del_rolbk_tmpoutput
	cd $OLD_DIR
 	unset OLD_DIR
      else
        OLD_OH=$ORACLE_HOME 
        export ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME";
        if [[ $wallet_upload -eq 3 ]];then
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          upload_result_conn=$(echo "set heading off
          select 1 from dual;"|$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING" 2>&1|grep -v ^$)
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
         else
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          upload_result_conn=$(echo "set heading off
          select 1 from dual;"|$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING" 2>>$ERRFIL|grep -v ^$)
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        fi
          unset ORACLE_HOME
          ORACLE_HOME=$OLD_OH
      fi
    else
      if [[ -n $ORACLE_HOME ]]; then 
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          get_dbOwner
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          upload_result_conn=$(su $dbOwner -c "echo \"set heading off
          select 1 from dual;\"|$ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" 2>&1|grep -v ^$")
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
          unset OLD_DIR
        else
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          upload_result_conn=$(echo "set heading off
          select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING" 2>>$ERRFIL|grep -v ^$)
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        fi
      fi
    fi
    if [[ `echo $upload_result_conn | grep -c "ORA-01017"` -ge 1 ]];then
      #ORA-01017 Invalid username or password 
      upload_result_conn_status=2
    elif [[ `echo $upload_result_conn | grep -c "ORA-28002"` -ge 1 ]];then
      #ORA-28002 : the password will expire within 7 days
      upload_result_conn_status=3
    elif [[ `echo $upload_result_conn | grep -c "ORA-28000"` -ge 1 ]];then
      #ORA-28000: the account is locked
      upload_result_conn_status=4
    elif [[ `echo $upload_result_conn | grep -c "ORA-12545"` -ge 1 ]];then
      #ORA-12545: Connect failed because target host or object does not exist (WRONG HOST NAME IN CONNECT STRING)
      upload_result_conn_status=5
    elif [[ `echo $upload_result_conn | grep -c "ORA-12514"` -ge 1 ]];then
      #ORA-12514: TNS:listener does not currently know of service requested in connect descriptor (WRONG SERVICE NAME IN CONNECT STRING)
      upload_result_conn_status=6
    elif  [[ -z $upload_result_conn ]];then
      #Not able to make successful connection to the database
      upload_result_conn_status=0
    elif [[ -n $upload_result_conn && $upload_result_conn -eq 1 ]];then
      #successful connection
      upload_result_conn_status=1
    else
      #unknown case
      echo
    fi
  fi
}
#Following function is used to print the error message if database conectivity can not be established to upload the collections
print_conn_check_msg ()
{
  if [[ -n $upload_result_conn_status && $upload_result_conn_status -eq 1 ]];then
    return 0;
  elif [[ -n $upload_result_conn_status && $upload_result_conn_status -eq 2 ]];then
    echo -e "\nDatabase connectivity can not be established. Invalid username or password.\n"|tee -a $LOGFIL
  elif [[ -n $upload_result_conn_status && $upload_result_conn_status -eq 3 ]];then
    echo -e "\nDatabase connectivity can not be established.The password is expired.\n"|tee -a $LOGFIL
  elif [[ -n $upload_result_conn_status && $upload_result_conn_status -eq 4 ]];then
    echo -e "\nDatabase connectivity can not be established. The account is locked.\n"|tee -a $LOGFIL
  elif [[ -n $upload_result_conn_status && $upload_result_conn_status -eq 5 ]];then
    echo -e "\nDatabase connectivity can not be established. Connect failed because target host or object does not exist.\n"|tee -a $LOGFIL
  elif [[ -n $upload_result_conn_status && $upload_result_conn_status -eq 6 ]];then
    echo -e "\nDatabase connectivity can not be established. TNS:listener does not currently know of service requested in connect descriptor.\n"|tee -a $LOGFIL
  elif [[ -n $upload_result_conn_status ]];then
    echo -e "\nDatabase connectivity can not be established.\n"|tee -a $LOGFIL
  fi 
  return 1;
}
function upload_zip_file ()
{
  upload_result_env_check $RAT_ZIP_UPLOAD_TABLE
  if [[ $run_conn_check_once -eq 0 ]];then
    upload_result_conn_check
    run_conn_check_once=1
  fi
  zip_data_upload_status=0
  
  OLD_RAT_UPLOAD_CONNECT_STRING=$RAT_UPLOAD_CONNECT_STRING
  RAT_UPLOAD_CONNECT_STRING=$(echo $RAT_UPLOAD_CONNECT_STRING|sed s'/=/\\=/g')
  if [ $raccheck_upload_env_set -eq 0 ]
  then
    zip_data_upload_status=1
  elif [ $upload_result_conn_status -ne 1 ]
  then
    zip_data_upload_status=2
  else
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      if [ -n "$RAT_SQL_LOADER_HOME" ]; then 
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$RAT_SQL_LOADER_HOME
      else
        OLD_OH=$ORACLE_HOME
        if [[ -n $RAT_UPLOAD_ORACLE_HOME ]];then
          ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME"
        elif [[ -n $CRS ]];then
          ORACLE_HOME="$CRS"
        fi
      fi
      get_dbOwner
      if [[ $upload_failed -eq 1 ]];then
        TMP_OUTPUT=${UPLOADFIL}
        OUTPUTDIR=${UPLOADFIL}
      else
        mkdir $TMP_OUTPUT/upload >/dev/null 2>&1; 
        mkdir $TMP_OUTPUT/log >/dev/null 2>&1;
      fi
      #chmod 777 $TMP_OUTPUT/log >/dev/null 2>&1;
      #copy zip file to temporary location so oracle can access when its being run as root
      cp -f $1 $TMP_OUTPUT/upload >/dev/null 2>&1
      LDRCTLFIL="$TMP_OUTPUT/upload/${program_name}_upload_zip_loader.ctl"
      LDRLOGFIL="$TMP_OUTPUT/${program_name}_upload_zip_loader.log"

      OLD_LDRCTLFIL="$OUTPUTDIR/upload/${program_name}_upload_zip_loader.ctl"
      OLD_LDRLOGFIL="$OUTPUTDIR/log/${program_name}_upload_zip_loader.log"
    else
      if [[ $upload_failed -eq 1 ]];then
        TMP_OUTPUT=${UPLOADFIL}
        OUTPUTDIR=${UPLOADFIL}
      fi  
      LDRCTLFIL="$OUTPUTDIR/upload/${program_name}_upload_zip_loader.ctl"
      LDRLOGFIL="$OUTPUTDIR/log/${program_name}_upload_zip_loader.log"
    fi
    LDRCTLFIL_NEW="$OUTPUTDIR/upload/${program_name}_upload_zip_loader.ctl"
    LDRLOGFIL_NEW="$OUTPUTDIR/log/${program_name}_upload_zip_loader.log"

    echo "LOAD DATA" > $LDRCTLFIL
    echo "INFILE *" >> $LDRCTLFIL
    echo "INTO TABLE $RAT_ZIP_UPLOAD_TABLE" >> $LDRCTLFIL
    echo "APPEND" >> $LDRCTLFIL
    echo "FIELDS TERMINATED BY ','" >> $LDRCTLFIL
    echo "(" >> $LDRCTLFIL
    echo "FILENAME CHAR(1000)," >> $LDRCTLFIL
    echo "FILE_BLOB LOBFILE (FILENAME) TERMINATED BY EOF," >> $LDRCTLFIL
    echo "ATTR1 CHAR(40)" >> $LDRCTLFIL
    echo ")" >> $LDRCTLFIL
    echo "BEGINDATA" >> $LDRCTLFIL
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]
    then
       echo $TMP_OUTPUT/upload/`basename $1`,ZIP_FILE >> $LDRCTLFIL
       write_del_rolbk_tmpoutput
       cd $OLD_DIR
       unset OLD_DIR
    else
      echo `basename $1`,ZIP_FILE >> $LDRCTLFIL  
    fi
    if [ -n "$RAT_SQL_LOADER_HOME" ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then

	OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$RAT_SQL_LOADER_HOME
	get_dbOwner

	chg_files_for_usr "LDRLOGFIL" "$LDRLOGFIL"

	ORACLE_HOME=$OLD_OH
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	DB_CONNECT_STRING=$RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$OLD_RAT_UPLOAD_CONNECT_STRING\"
        su $dbOwner -c "$RAT_SQL_LOADER_HOME/bin/sqlldr \\\"$DB_CONNECT_STRING\\\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1"
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        move_files "$LDRCTLFIL" "$OLD_LDRCTLFIL" 
        move_files "$LDRLOGFIL" "$OLD_LDRLOGFIL"    
    	write_del_rolbk_tmpoutput
	cd $OLD_DIR
	unset OLD_DIR
      else
        #export ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME";
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        $RAT_SQL_LOADER_HOME/bin/sqlldr $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
    else
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        if [[ -n $RAT_UPLOAD_ORACLE_HOME ]];then
          ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME"
        elif [[ -n $CRS ]];then
          ORACLE_HOME="$CRS"
        fi
	get_dbOwner 
	chg_files_for_usr "LDRLOGFIL" "$LDRLOGFIL"
        ORACLE_HOME=$OLD_OH
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	DB_CONNECT_STRING=$RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$OLD_RAT_UPLOAD_CONNECT_STRING\"
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        export ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME;
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	su $dbOwner -c "$ORACLE_HOME/bin/sqlldr \\\"$DB_CONNECT_STRING\\\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1"
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        move_files "$LDRCTLFIL" "$OLD_LDRCTLFIL" 
        move_files "$LDRLOGFIL" "$OLD_LDRLOGFIL"    
    	write_del_rolbk_tmpoutput
	cd $OLD_DIR
	unset OLD_DIR
        LDRLOGFIL=$OLD_LDRLOGFIL
        LDRCTLFIL=$OLD_LDRCTLFIL
      else
        export ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME";
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        $ORACLE_HOME/bin/sqlldr $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        unset ORACLE_HOME
      fi
    fi

    if [ -r $LDRLOGFIL ]; then zip_upload_error=$(grep -wic '1 row successfully loaded' $LDRLOGFIL);fi
    if [ -r $LDRLOGFIL ]; then zip_upload_error2=$(grep -ic "SQL\*Loader-5" $LDRLOGFIL);fi
    if [[ -n "$zip_upload_error" && $zip_upload_error -gt 0 && -n "$zip_upload_error2" && $zip_upload_error2 -eq 0 ]]
    then
      zip_data_upload_status=0
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && $upload_failed -eq 1 ]];then
        zip_upload_message="\n\n${GREEN}$OLD_UPLOADFIL_ZIP successfully uploaded to ${RAT_ZIP_UPLOAD_TABLE} table.${NORM}\n";
      else
        zip_upload_message="\n\n${GREEN}${1} successfully uploaded to ${RAT_ZIP_UPLOAD_TABLE} table.${NORM}\n"
      fi
      DATABASE_UPLOAD_STATUS=1 
    else  
      zip_data_upload_status=3
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && $upload_failed -eq 1 ]];then
        zip_upload_message="\n\n${RED}$OLD_UPLOADFIL_ZIP file upload to database failed. check $LDRLOGFIL_NEW for more detail.\n\nLoad ${OLD_UPLOADFIL_ZIP} using $ORACLE_HOME/bin/sqlldr. SQL Loader controle file = $LDRCTLFIL_NEW${NORM}\n\n"
      else
        zip_upload_message="\n\n${RED}${1} file upload to database failed. check $LDRLOGFIL_NEW for more detail.\n\nLoad ${1} using $ORACLE_HOME/bin/sqlldr. SQL Loader controle file = $LDRCTLFIL_NEW${NORM}\n\n"
      fi
      DATABASE_UPLOAD_STATUS=0

    fi
    echo "DATABASE_UPLOAD_STATUS = $DATABASE_UPLOAD_STATUS" >> ${UPLOADFIL}/outfiles/check_env.out 
  fi
  RAT_UPLOAD_CONNECT_STRING=$OLD_RAT_UPLOAD_CONNECT_STRING
}

#Added by kumar
function insert_data_into_table ()
{
  sql_spool_file=$3
  upload_result_env_check $1
  upload_result_conn_check
  #$READ -p "RAT_UPLOAD_ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME and ORACLE_HOME=$ORACLE_HOME"
  if [ $raccheck_upload_env_set -eq 0 ] 
  then
    data_upload_status=1
  elif [[ $upload_result_conn_status -ne 1 ]];then
    data_upload_status=2
  else 
    if [ -n "$RAT_UPLOAD_ORACLE_HOME" ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	OLD_OH=$ORACLE_HOME
        if [[ -n $RAT_SQL_LOADER_HOME ]];then
	  ORACLE_HOME=$RAT_SQL_LOADER_HOME
        else
          ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
        fi
	get_dbOwner
	export ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
      
        chg_files_for_usr "sql_spool_file" "$sql_spool_file"
	 
        su $dbOwner -c "$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" >/dev/null 2>&1 <<EOF
 		     set head off
 		     set lines 80
 		     set serveroutput on
 		     spool $sql_spool_file
 		     @@$2
 		     spool off
 		     exit
EOF
"
	
    	write_del_rolbk_tmpoutput
	cd $OLD_DIR
	unset OLD_DIR
      else
        export ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
        $RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING"  >/dev/null 2>&1 <<EOF
 		     set head off
 		     set lines 80
 		     set serveroutput on
 		     spool $sql_spool_file
 		     @@$2
 		     spool off
 		     exit
EOF
      fi
    else
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner

        chg_files_for_usr "sql_spool_file" "$sql_spool_file"

        su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\"  >/dev/null 2>&1 <<EOF
 		     set head off
 		     set lines 80
 		     set serveroutput on
 		     spool $sql_spool_file
 		     @@$2
 		     spool off
 		     exit
EOF
"
    	write_del_rolbk_tmpoutput
	cd $OLD_DIR
	unset OLD_DIR
      else
        $ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING"  >/dev/null 2>&1 <<EOF
 		     set head off
 		     set lines 80
 		     set serveroutput on
 		     spool $sql_spool_file
 		     @@$2
 		     spool off
 		     exit
EOF
      fi
    fi
    upload_error=$(grep -c "ORA-" $sql_spool_file)
    if [[ -n "$upload_error" && $upload_error -gt 0 ]]
    then
      data_upload_status=3
    else
      data_upload_status=0      
      if [ -n "$upload_pass_msg" ]
      then
        upload_pass_msg2="and `grep -i "1 row created" $sql_spool_file |wc -l|sed 's/ //g'` rows were added to $1 table.\n\n"
      else   
        upload_pass_msg="Uploading of ${program_name} result to database was successful. `grep -i "1 row created" $sql_spool_file |wc -l|sed 's/ //g'` rows were added to $1 table.\n\n"
      fi
    fi            
  fi
}

#Added by Kumar
#following code is to get insert statements for installed patches into file
function insertStatementsForInstalledPatches ()
{
 l_version=$3;
 if [[ -n "$l_version" && `echo "$l_version"|grep -c "\."` -eq 0 ]]; then format_l_version; fi

 for host in `cat $HOSTLIST`
 do
  if [ -f $OUTPUTDIR/o_${1}_patchlist_${host}.out ]
  then
   for patch_no in `cat $OUTPUTDIR/o_${1}_patchlist_${host}.out`
   do
    if [[ -f $OUTPUTDIR/o_patch_result_${host}.out && $(grep -c $patch_no $OUTPUTDIR/o_patch_result_${host}.out) -ge 1 ]]
    then 
      echo "Do nothing" > /dev/null
    else
      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      then
        echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$host','$1','$2','$l_version','$patch_no','$cluster_name','null','null',1,0,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      fi
    fi
   done
  fi
 done
}

uploadInstalledPatches ()
{
  installedPatchesFiles=$(find $OUTPUTDIR -name '*installed_patchlist*' -print)
  for installedPatchesFile in $(echo "$installedPatchesFiles")
  do
    installedPatchHostname=$(cat $installedPatchesFile|head -1|cut -d'|' -f1)
    installedPatchOracleHOmeType=$(cat $installedPatchesFile|head -1|cut -d'|' -f2)
    installedPatchOracleHOme=$(cat $installedPatchesFile|head -1|cut -d'|' -f3)
    installedPatchOracleHOmePath=$(echo $installedPatchOracleHOme|sed 's/\///g')
    installedPatchOracleHOmeVersion=$(cat $installedPatchesFile|head -1|cut -d'|' -f4)

    platform=`uname -s`
    if [ $platform = "SunOS" ]; then
      installedPatch_command=$(cat $installedPatchesFile|tail +2)
    else
      installedPatch_command=$(cat $installedPatchesFile|tail -n +2)
    fi

    #for installedPatch in $(cat $installedPatchesFile|tail -n +2)
    for installedPatch in $installedPatch_command
    do
      if [ "$installedPatchOracleHOmeType" = "crs" ]
      then
        installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchHostname}.out| grep -wi description)
        if [ -z "$installedPatchDescription" ]
        then    
          installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchHostname}.out|grep ^Patch)
        fi
      elif [[  "$installedPatchOracleHOmeType" == "asm" ]];then
          installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchHostname}.out| grep -wi description)
          if [[ -z "$installedPatchDescription" ]];then
            installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchHostname}.out| grep -wi ^Patch)
          fi
      else
        installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchOracleHOmePath}_${installedPatchHostname}.out| grep -wi description)
        if [[ -z "$installedPatchDescription" ]];then    
          installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchOracleHOmePath}_${installedPatchHostname}.out|grep ^Patch)
        fi
      fi
      l_version=${installedPatchOracleHOmeVersion}
      if [[ -n "$l_version" && `echo "$l_version"|grep -c "\."` -eq 0 ]]; then format_l_version; fi

      echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'${installedPatchHostname}','${installedPatchOracleHOmeType}','${installedPatchOracleHOme}','${l_version}','$installedPatch','$cluster_name','$installedPatchDescription','Not Found',1,0,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
    done
  done

  if [ -e "$upload_raccheck_patch_result_fil" ]; then
    sort $upload_raccheck_patch_result_fil|uniq > $upload_raccheck_patch_result_fil.tmp
    mv -f $upload_raccheck_patch_result_fil.tmp $upload_raccheck_patch_result_fil
  fi
}

is_this_db_machine ()
{
  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then return; fi
  if [ $OFFLINE -eq 0 ]
  then
    if [[ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" || $ssctuner_exists -gt 0 || $is_opc -eq 1 ]]
    then
      db_machine_compute=1
      sunfire_x4270m2=0
      sunfire_x4270m3=0  
      is_avm_machine=0 
      dbm_vm=0
      decide_on_cpu=0
      is_eighth_rack=0
      if [ -e ${SYSTEM_DESC_FIL} ]
      then
        #sunfire_x4270m2=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M2"|wc -l)
        #sunfire_x4270m3=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M3"|wc -l) 
        #sunfire_x4270x4=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN SERVER X4-2"|wc -l) 
        sunfire_x4270m2=$(grep "SUN FIRE X4[1-2]70 M2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ')
        sunfire_x4270m3=$(grep "SUN FIRE X4[1-2]70 M3" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x4=$(grep "SUN SERVER X4-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x5=$(grep "ORACLE SERVER X5-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x6=$(grep "ORACLE SERVER X6-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x7=$(grep "ORACLE SERVER X7-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        is_eighth_rack=$(grep -c "TRUE$" ${SYSTEM_DESC_FIL} 2>/dev/null|tr -d ' ') 
      fi 
      if [[ ! -e ${SYSTEM_DESC_FIL} && -e ${SerialNumberFil} && $# -lt 2 ]]
      then
        #sed -e '/FRU Device Description[\t ]\+:[\t ]\+\/SYS/,/Product Name[\t ]\+:/!d;/Product Name[\t ]\+:/!d;s/Product Name[\t ]\+:[\t ]\+//g;' $SerialNumberFil | sort -u >$SYSTEM_DESC_FIL
        sed -e '/FRU Device Description[\t ]\+:[\t ]\+\/SYS/,/Product Name[\t ]\+:/!d;/Product Name[\t ]\+:/!d;s/Product Name[\t ]\+:[\t ]\+//g;' $SerialNumberFil | sort -u > ${RTEMPDIR}/cell_system_description.out
        #sunfire_x4270m2=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M2"|wc -l)
        #sunfire_x4270m3=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M3"|wc -l) 
        #sunfire_x4270x4=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN SERVER X4-2"|wc -l) 
        sunfire_x4270m2=$(grep "SUN FIRE X4[1-2]70 M2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ')
        sunfire_x4270m3=$(grep "SUN FIRE X4[1-2]70 M3" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x4=$(grep "SUN SERVER X4-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x5=$(grep "ORACLE SERVER X5-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x6=$(grep "ORACLE SERVER X6-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x7=$(grep "ORACLE SERVER X7-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
      fi  
      if [ -r $AVMIDFIL ]; then is_avm_machine=$(grep -iwc "<BACKUP_APPLIANCE>true</BACKUP_APPLIANCE>" $AVMIDFIL 2>/dev/null);fi
      if  [[ -n "$is_avm_machine" && $is_avm_machine -gt 0 ]]; then is_avm_machine=1;fi  
      print_compute_node=$(echo -e on ${BLINK}DATABASE SERVER${NORM})
      if [ -z "$platform" ]; then platform=$(uname -s);fi;

      if [ $platform = "Linux" ]
      then 
        #Change to support OL 6 where udevinfo does not exist
        if [ -x /usr/bin/udevinfo ]; then  dbm_status_v2=$(udevinfo -q all -p /sys/block/sda|grep -iq LSI;echo $?);else dbm_status_v2=0;fi 
        dbm_status_v1=$(ls /sys/block | grep -qi cciss;echo $?) 
        if [ "$1" = "$localnode" ]
        then  
          #no_of_cores=$(cat /proc/cpuinfo | grep -w "processor"|wc -l)
          if [ $is_exadata_dom0_machine -eq 0 ]
          then
            no_of_cores=$(grep -w "processor" /proc/cpuinfo |wc -l)
          else
            no_of_cores=$(/usr/sbin/xm info |grep -w nr_cpus|$AWK '{print $NF}')
          fi
          exadata_platform=$(uname -p) 
          if [ $exadata_platform = "sparc64" ]
          then
            cpu_model=$(grep -w ^cpu /proc/cpuinfo |$AWK '{print $NF}')
          else
            cpu_model=$(grep -wi "Intel(R)" /proc/cpuinfo|sort -u|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
	    if [ -z "$cpu_model" ] || [ "$cpu_model" == "" ]; then
	      cpu_model=$(grep -wi "Intel(R)" /proc/cpuinfo|sort -u|$AWK 'BEGIN{FS="CPU"}{print $1}'|$AWK '{print $6$7}')
	    fi
          fi
        else
          if [ $is_exadata_dom0_machine -eq 0 ]
          then
            no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 '/usr/sbin/xm info |grep -w nr_cpus')
            no_of_cores=$(echo "$no_of_cores"|$AWK '{print $NF}')
          else
            no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'cat /proc/cpuinfo | grep -w "processor"|wc -l')
          fi
          exadata_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
          if [ $exadata_platform = "sparc64" ]
          then
             remote_cpuinfo=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'cat /proc/cpuinfo | grep -w ^cpu')
             cpu_model=$(echo "$remote_cpuinfo"|$AWK '{print $NF}')
          else
             remote_cpuinfo=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'cat /proc/cpuinfo | grep -wi "Intel(R)"|sort -u')
             cpu_model=$(echo "$remote_cpuinfo"|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
          fi
        fi
      else
        dbm_status_v2=0
        dbm_status_v1=1
        if [ "$1" = "$localnode" ]
        then 
          no_of_cores=$(/sbin/psrinfo|wc -l|tr -d ' ')
          exadata_platform=$(uname -p) 
          cpu_model=$(/usr/sbin/prtconf -v 2>/dev/null|grep -wi "Intel(R)"|sort -u|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
        else
          no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 '/sbin/psrinfo|wc -l|tr -d ' '')
          exadata_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
          remote_prtconf=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 '/usr/sbin/prtconf -v 2>/dev/null|grep -wi "Intel(R)"|sort -u')
          cpu_model=$(echo "$remote_prtconf"|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
        fi
      fi
      if [ -e "$CELLIP" ]; then no_of_cells=$(grep "cell=" $CELLIP|grep -v ^#|wc -l|tr -d ' ');fi
      it_is_rac=0
      if [ -n "$no_of_cells" ] && [[ $no_of_cells -eq 3 || $no_of_cells -eq 4 ]]
      then
        EXADATA_RACK=QUARTER
      elif [[ -n "$no_of_cells" && $no_of_cells -eq 7 ]]
      then
        EXADATA_RACK=HALF
      elif [[ -n "$no_of_cells" && $no_of_cells -ge 14 ]]
      then
        EXADATA_RACK=FULL
      fi
      if [ $is_exadata_dom0_machine -eq 1 ]; then add_vm_module="VM";else add_vm_module="";fi
      if [[ $is_opc -eq 1 || $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 || $is_ssc_localzone_machine -eq 1 || $is_ssc_globalzone_dbmachine -eq 1  || "$HOSTTYPE" = "BAREMETAL" ]]
      then
        decide_on_cpu=1
      fi
      if [ $is_opc -eq 1 ] ; then
        cp -f $SCRIPTPATH/.cgrep/ipmitool $TMPDIR/
        chmod +x $TMPDIR/ipmitool
        ipmi_product_name=$($TMPDIR/ipmitool sunoem cli force "show /SYS" |grep product_name)
        if [ -z "$ipmi_product_name" ] ; then
          ipmi_product_name=$($TMPDIR/ipmitool sunoem cli force "show /SYS" |grep product_name)
        fi
        if [ -z "$ipmi_product_name" ] ; then
          ipmi_product_name=$($TMPDIR/ipmitool sunoem cli force "show /SYS" |grep product_name)
        fi
        if [ `echo "$ipmi_product_name" | grep -wci "SUN FIRE X4[1-2]70 M2"` -gt 0 ] 
        then
          EXADATA_VERSION="X2-2"
        fi
        if [ `echo "$ipmi_product_name" | grep -wci "SUN FIRE X4[1-2]70 M3"` -gt 0 ]
        then
          EXADATA_VERSION="X3-2"
        fi
        if [ `echo "$ipmi_product_name" | grep -ci "SUN SERVER X4-2"` -gt 0 ]
        then
          EXADATA_VERSION="X4-2"
        fi
        if [ `echo "$ipmi_product_name" |grep -ci "ORACLE SERVER X5-2"` -gt 0 ]
        then
          EXADATA_VERSION="X5-2"
        fi
        if [ `echo "$ipmi_product_name" |grep -ci "ORACLE SERVER X6-2"` -gt 0 ]
        then
          EXADATA_VERSION="X6-2"
        fi
        if [ `echo "$ipmi_product_name" |grep -ci "ORACLE SERVER X7-2"` -gt 0 ]
        then
          EXADATA_VERSION="X7-2"
        fi
      fi
      if [[ $dbm_status_v2 -eq 0 && $dbm_status_v1 -eq 1 && $decide_on_cpu -eq 1 ]]
      then
        #if [[ $no_of_cores -eq 16 && $sunfire_x4270m3 -ge 1  && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        if [[ "$cpu_model" = "E5-26900" && $is_eighth_rack -gt 0  && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          dbm_x3_2=1
          EXADATA_VERSION="EIGHTH RACK"
          EXADATA_RACK="EIGHTH RACK"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}EIGHTH:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGREIGHTH)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGREIGHTH)
          fi
        #elif [[ $no_of_cores -eq 24 && $sunfire_x4270x4 -ge 1  && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-2697v2" && $is_eighth_rack -gt 0 && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          dbm_x3_2=1
          EXADATA_VERSION="EIGHTH RACK"
          EXADATA_RACK="EIGHTH RACK"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}EIGHTHX4-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGREIGHTHX4-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGREIGHTHX4-2)
          fi
        elif [[ "$cpu_model" = "E5-2699v3" && $is_eighth_rack -gt 0  && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          dbm_x3_2=1
          EXADATA_VERSION="EIGHTH RACK"
          EXADATA_RACK="EIGHTH RACK"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}EIGHTHX5-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGREIGHTHX5-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGREIGHTHX5-2)
          fi
        elif [[ "$cpu_model" = "E5-2699v4" && $is_eighth_rack -gt 0  && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          dbm_x3_2=1
          EXADATA_VERSION="X6-2 EIGHTH RACK"
          EXADATA_RACK="X6-2 EIGHTH RACK"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}EIGHTHX6-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGREIGHTHX6-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGREIGHTHX6-2)
          fi
        elif [[ "$cpu_model" = "Platinum8160" && $is_eighth_rack -gt 0  && -n "$is_avm_machine" && $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          dbm_x3_2=1
          EXADATA_VERSION="X7-2 EIGHTH RACK"
          EXADATA_RACK="X7-2 EIGHTH RACK"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}EIGHTHX7-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGREIGHTHX7-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGREIGHTHX7-2)
          fi
        elif [[ "$cpu_model" = "E5-26900"  && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          #This branch is to cover IAAS where X3-2 will run in reduced capacity 
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X3-2" 
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X3-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX3-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX3-2)
          fi
        #elif [[ $no_of_cores -gt 16 && $no_of_cores -le 24 && $sunfire_x4270m2 -ge 1 ]]
        #elif [[ $no_of_cores -gt 16 && $no_of_cores -le 24 && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc"  ]] 
        elif [[ "$cpu_model" = "X5670" || "$cpu_model" = "X5675" ]] && [[ -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc"  ]] 
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=1
          dbm_x2_8=0
          dbm_x3_2=0
          EXADATA_VERSION="X2-2" 
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X2-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX2-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX2-2)
          fi
        #elif [[ $no_of_cores -gt 24 && $no_of_cores -le 32 && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-26900" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X3-2" 
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X3-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX3-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX3-2)
          fi 
        #elif [[ $no_of_cores -gt 32 && $no_of_cores -le 48 && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-2697v2" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X4-2"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X4-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX4-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX4-2)
          fi 
        elif [[ "$cpu_model" = "E5-2699v3" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X5-2"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X5-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX5-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX5-2)
          fi
        elif [[ "$cpu_model" = "E5-2699v4" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X6-2"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X6-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX6-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX6-2)
          fi
        elif [[ "$cpu_model" = "Platinum8160" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X7-2"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X7-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX7-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX7-2)
          fi
        elif [[ "$cpu_model" = "SPARC-M7" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X6-2"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}SX6-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRSX6-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRSX6-2)
          fi
        elif [[ "$cpu_model" = "SPARC-M7" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
	  # Pending - need to change above condition
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X7-2"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}SX7-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRSX7-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRSX7-2)
          fi
        #if [[ $no_of_cores -ge 240  ]]
        elif [[ "$cpu_model" = "E7-8895v2" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then 
	     dbm_v1=0
	     dbm_v2=0
	     dbm_x2_2=0
	     dbm_x2_8=1
	     dbm_x3_2=0
	     EXADATA_VERSION="X4-8"
	    if  [ $upgrade_mode -eq 0 ]
	    then
	      components=$(echo ${user_components}:${add_vm_module}X4-8:MAA)
	    elif [ $upgrade_mode -eq 2 ]
	    then
	      components=$(echo ${components}|sed 's/PREUPGR://g')
	      components=$(echo ${components}:PREUPGRX4-8)
	    elif [ $upgrade_mode -eq 3 ]
	    then
	      components=$(echo ${components}|sed 's/POSTUPGR://g')
	      components=$(echo ${components}:POSTUPGRX4-8)
	    fi
        #elif [[ $no_of_cores -ge 160  ]]
        elif [[ "$cpu_model" = "E7-8895v3" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then 
	     dbm_v1=0
	     dbm_v2=0
	     dbm_x2_2=0
	     dbm_x2_8=1
	     dbm_x3_2=0
	     EXADATA_VERSION="X5-8"
	    if  [ $upgrade_mode -eq 0 ]
	    then
	      components=$(echo ${user_components}:${add_vm_module}X5-8:MAA)
	    elif [ $upgrade_mode -eq 2 ]
	    then
	      components=$(echo ${components}|sed 's/PREUPGR://g')
	      components=$(echo ${components}:PREUPGRX5-8)
	    elif [ $upgrade_mode -eq 3 ]
	    then
	      components=$(echo ${components}|sed 's/POSTUPGR://g')
	      components=$(echo ${components}:POSTUPGRX5-8)
	    fi

        elif [[ "$cpu_model" = "E7-8870" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then 
             dbm_v1=0
	     dbm_v2=0
	     dbm_x2_2=0
	     dbm_x2_8=1
	     dbm_x3_2=0
	     EXADATA_VERSION="X3-8"
	    if  [ $upgrade_mode -eq 0 ]
	    then
	      components=$(echo ${user_components}:X3-8:MAA)
	    elif [ $upgrade_mode -eq 2 ]
	    then
	      components=$(echo ${components}|sed 's/PREUPGR://g')
	      components=$(echo ${components}:PREUPGRX3-8)
	    elif [ $upgrade_mode -eq 3 ]
	    then
	      components=$(echo ${components}|sed 's/POSTUPGR://g')
	      components=$(echo ${components}:POSTUPGRX3-8)
	    fi
        elif [[ "$cpu_model" = "X7560" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc"  ]] 
        then
             dbm_v1=0
	     dbm_v2=0
	     dbm_x2_2=0
	     dbm_x2_8=1
	     dbm_x3_2=0
	     EXADATA_VERSION="X2-8"
	    if  [ $upgrade_mode -eq 0 ]
	    then
	      components=$(echo ${user_components}:X2-8:MAA)
	    elif [ $upgrade_mode -eq 2 ]
	    then
	      components=$(echo ${components}|sed 's/PREUPGR://g')
	      components=$(echo ${components}:PREUPGRX2-8)
	    elif [ $upgrade_mode -eq 3 ]
	    then
	      components=$(echo ${components}|sed 's/POSTUPGR://g')
	      components=$(echo ${components}:POSTUPGRX2-8)
	    fi
        elif [[ "$exadata_platform" = "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=1
          dbm_x3_2=0
          #added this branch to support X4-2 storage servers on super cluster      
          if [[ $sunfire_x4270x5 -eq 1 && $is_ssc_localzone_machine -eq 0 ]]
          then
            if  [ $upgrade_mode -eq 0 ]
            then
              EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTERX4-2:MAA)
              is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
          elif [[ $sunfire_x4270x4 -eq 1 && $is_ssc_localzone_machine -eq 0 ]]
          then
            if  [ $upgrade_mode -eq 0 ]
            then
              EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTERX4-2:MAA)
              is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
            #added this branch to support X3-2 storage servers on super cluster      
          elif [[ $sunfire_x4270m3 -eq 1 && $is_ssc_localzone_machine -eq 0 ]]
       	  then
       	    if  [ $upgrade_mode -eq 0 ]
       	    then
       	      EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTERX3-2:MAA)
       	      is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
            #X3-2 storage server support for supercluster code ends her  
            
          elif [[ $sunfire_x4270x4 -eq 0 && $sunfire_x4270m3 -eq 0 && $is_ssc_localzone_machine -eq 0 ]]
       	  then
       	    if  [ $upgrade_mode -eq 0 ]
       	    then
       	      EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTER:MAA)
       	      is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
          elif [[ $is_ssc_localzone_machine -eq 1 ]] 
          then
            if  [ $upgrade_mode -eq 0 ]
       	    then
       	      EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTERVM:MAA)
       	      is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
            #X3-2 storage server support for supercluster code ends her  
            #fi Need to check why its extra
          fi
        elif [[ $no_of_cores -gt 16 && $no_of_cores -le 32 && $sunfire_x4270m2 -eq 0  && $sunfire_x4270m2 -eq 0 && "$platform" = "SunOS" ]]
        then
          #this branch is to cover when storage server are skipped and serial number file is not found on database server  
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X3-2" 
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:X3-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX3-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX3-2)
          fi
        elif [[ -n "$is_avm_machine" &&  $is_avm_machine -eq 1 ]] 
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          AVM_VERSION="X3-2"
          dbm_x3_2=1
          if [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:AVM)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRAVM)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRAVM)
          fi 
        elif [[ "$cpu_model" = "E5540" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
            dbm_v1=0
       	    dbm_x2_2=0
       	    dbm_x2_8=0
       	    dbm_v2=1
       	    EXADATA_VERSION="V2"
       	    dbm_x3_2=0
       	    if [ $upgrade_mode -eq 0 ]
       	    then
       	      components=$(echo ${user_components}:EXADATA:MAA)
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRDBM)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRDBM)
       	    fi
        elif [ -z "$ipmi_product_name" ] ; then
           #Added this condition so if exachk misclasify exadata hardware and end up thinking that its V2 but its not actually V2 than exit if -c command line is not used
           if [ -z "$options_components" ]
           then   
             mname="Exadata "
             if [ $is_opc -eq 1 ] ; then mname=""; fi   
	     if [[ $EM_PROBE_MODE -eq 1 ]]
	     then
	       EMSG="$program_name is not able to determine ${mname}Hardware type. Please use -c option to specify hardware type like ./${program_name} -c X4-2,MAA."
	       update_probe_xml "ERROR" "GENERIC" "$EMSG"
	     fi
	     echo -e "${RED}$program_name is not able to determine ${mname}Hardware type. Please use -c option to specify hardware type like ./${program_name} -c X4-2,MAA.${NORM}"
	     errm="$program_name is not able to determine ${mname}Hardware type. Please use -c option to specify hardware type like ./${program_name} -c X4-2,MAA."
             update_errm_in_syslog
	     exit 1
           else
             #-c command line was used to override modules so making it some kind of exadata
             dbm_v1=0
             dbm_v2=0
             dbm_x2_2=0
             dbm_x2_8=1
             dbm_x3_2=0
           fi
        fi
      elif [[ $dbm_status_v2 -eq 1 && $dbm_status_v1 -eq 0 && $HOSTTYPE = "BAREMETAL" ]]
      then
        dbm_x2_2=0
        dbm_x2_8=0
        dbm_v1=1
        dbm_v2=0
        EXADATA_VERSION=V1
      elif [[ $HOSTTYPE = "XENDOMU" ]]
      then
         dbm_x2_2=0
         dbm_x2_8=0
         dbm_vm=1
         dbm_v2=0
         dbm_v1=0
         dbm_x3_2=0
         EXADATA_VERSION="EXADATA-GUEST"
         if [ $upgrade_mode -eq 0 ]
         then
           components=$(echo ${user_components}:EDVM:MAA)
         elif [ $upgrade_mode -eq 2 ]
         then
           components=$(echo ${components}|sed 's/PREUPGR://g')
           components=$(echo ${components}:PREUPGREDVM)
         elif [ $upgrade_mode -eq 3 ]
         then
           components=$(echo ${components}|sed 's/POSTUPGR://g')
           components=$(echo ${components}:POSTUPGREDVM)
         fi 
      fi
    else 
       print_compute_node=""
       db_machine_compute=0
       dbm_v1=0
       dbm_v2=0
       dbm_x2_2=0
       dbm_x2_8=0
       if [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
       then 
         it_is_rac=0
       elif [[ -n "$single_instance_run" && $single_instance_run -eq 1 ]]
       then
         it_is_rac=0
       else 
         it_is_rac=1
       fi 
       dbm_x3_2=0 
       dbm_vm=0 
       if [[ $upgrade_mode -eq 0 && "$components" = "NONE" ]]; then components=$(echo ${components}:RACCHECK:MAA);fi
    fi
  fi
  #If its running on Exadata DOM0 then change component for DOM0 by adding VM
  if [ -n "$options_components" ]; then components=$final_components;fi
  #$READ -p "see values in $components"
  if [[  -n $run_acchk && $run_acchk -eq "1" ]] ; then
    components=$(echo ${components}:ACCHK);
  fi
  if [ $is_opc -eq 1 ] ; then 
    db_machine_compute=0; 
    dbm_v1=0
    dbm_v2=0
    dbm_x2_2=0
    dbm_x2_8=0
    dbm_x3_2=0
    dbm_vm=0
    if [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]] ; then
      components=OPCZFSSA
    else
      components=OPC$EXADATA_VERSION$opc_machine_type
    fi
  fi
  if [ -n "$RAT_TORSWITCHES" ] ; then
    components=TORSWITCH
  fi

}

#Function to write Exadata components in env file. This function was added because exadata discover function will be called for each node
write_db_machine_info_to_envfile ()
{
  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then return; fi

  if [[ $OFFLINE -eq 0 ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]];
  then
    echo "${1}.EXADATA_COMPUTE = $db_machine_compute">>$MASTERFIL
    echo "${1}.EXADATA_DBMV1 = $dbm_v1">>$MASTERFIL
    echo "${1}.EXADATA_DBMV2 = $dbm_v2">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X2_2 = $dbm_x2_2">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X2_8 = $dbm_x2_8">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X3_2 = $dbm_x3_2">>$MASTERFIL
    echo "${1}.EXADATA_RACK = $EXADATA_RACK">>$MASTERFIL
    echo "${1}.EXADATA_VERSION = $EXADATA_VERSION">>$MASTERFIL
    echo "${1}.IT_IS_RAC = $it_is_rac">>$MASTERFIL
    echo "${1}.COMPONENTS = $components" >>$MASTERFIL
    echo "${1}.IS_AVM_MACHINE = $is_avm_machine">>$MASTERFIL
    echo "db_machine_compute=$db_machine_compute dbm_status_v2=$dbm_status_v2 dbm_status_v1=$dbm_status_v1 dbm_v1=$dbm_v1 dbm_v2=$dbm_v2">> $LOGFIL
  else
    TENVFIL=$DUMPDIR/$CHKFIL
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 && $RAT_RUNMODE_INTERNAL != "slave" ]]; then TENVFIL=$MASTERFIL; fi
      
    db_machine_compute=$(grep ${1}.EXADATA_COMPUTE $TENVFIL|awk '{print $3}')
    dbm_v1=$(grep ${1}.EXADATA_DBMV1 $TENVFIL|awk '{print $3}')
    dbm_v2=$(grep ${1}.EXADATA_DBMV2 $TENVFIL|awk '{print $3}')
    dbm_x2_2=$(grep ${1}.EXADATA_DBM_X2_2 $TENVFIL|awk '{print $3}')
    dbm_x2_8=$(grep ${1}.EXADATA_DBM_X2_8 $TENVFIL|awk '{print $3}')
    it_is_rac=$(grep ${1}.IT_IS_RAC $TENVFIL|awk '{print $3}')
    is_avm_machine=$(grep ${1}.IS_AVM_MACHINE $TENVFIL|awk '{print $3}')
    dbm_x3_2=$(grep ${1}.EXADATA_DBM_X3_2 $TENVFIL|awk '{print $3}')
    EXADATA_RACK=$(grep ${1}.EXADATA_RACK $TENVFIL|awk '{print $3}')
    EXADATA_VERSION=$(grep ${1}.EXADATA_VERSION $TENVFIL|head -1|awk '{print $3}')
    components=$(grep ${1}.COMPONENTS $TENVFIL|head -1|awk '{print $3}')  
  fi
  #$READ -p "see values in $components"
}

ports_find_sid ()
{
  case `/bin/uname` in
    Linux)
      #$READ -p "db_name_to_check=$db_name_to_check"
      oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $8}'|cut -d_ -f3)
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
      ;;
    SunOS)
      oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      if [ -z "$oSID" ]; then  oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $8}'|cut -d_ -f3);fi;
      if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
      #$READ -p "oSID=$oSID and db_name_to_check=$db_name_to_check"
      ;;
    HP-UX) 
      oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
      ;;
    AIX)  
      oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
      ;;
    *) 
      /bin/echo "ERROR: Unknown Operating System"
      exit -1
      ;;
  esac
}

function GetMachineRole()
{
  if [[ $OFFLINE -eq 0 ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]];
  then
    HOSTTYPE=BAREMETAL; ROLE="";VMTYPE="NONE";
    if [ -d /proc/xen ]
    then
      if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
      then
        HOSTTYPE=XENDOM0
      else
        HOSTTYPE=XENDOMU
        #xblk=`/sbin/lsmod |grep -i xenblk`
        #xnet=`/sbin/lsmod |grep -i xennet`
        xblk=`/sbin/lsmod |egrep -i 'xenblk|xen_blkfront'`
        xnet=`/sbin/lsmod |egrep -i 'xennet|xen_netfront'`   
        if [[ -n $xblk && -n $xnet ]]
        then
          VMTYPE=PVM
        else
          VMTYPE=HVM_PVHVM
        fi
      fi
    fi

    if grep "Oracle VM server release 2.2" /etc/ovs-release > /dev/null 2>&1
    then
      OVMSERVER=`cat /etc/ovs-release`
      ROLE="OVMSERVER" # will include 2.2.1
    elif rpm --quiet -q ovs-manager > /dev/null 2>&1
    then
      ROLE="OVMMANAGER"
    elif [ -f /etc/enterprise-release ]
    then
      GENERIC="`cat /etc/enterprise-release`"
      ROLE="GENERIC"
    elif [ -f /etc/redhat-release ]
      then GENERIC="`cat /etc/redhat-release`"
      ROLE="GENERIC"
    else
      ROLE="Not_Supported"
      return 1 # not a RH, EL or Fedora based distro... maybe someday, but not today
    fi
    echo "HOST_ROLE = "$ROLE >>$MASTERFIL
    echo "HOST_TYPE = "$HOSTTYPE >>$MASTERFIL
    echo "VM_TYPE = "$VMTYPE >>$MASTERFIL
  else
    TENVFIL=$DUMPDIR/$CHKFIL
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 && $RAT_RUNMODE_INTERNAL != "slave" ]]; then TENVFIL=$MASTERFIL; fi

    ROLE=$(grep HOST_ROLE $TENVFIL|awk '{print $3}')
    HOSTTYPE=$(grep HOST_TYPE $TENVFIL|awk '{print $3}')
    VMTYPE=$(grep VM_TYPE $TENVFIL|awk '{print $3}')
  fi
  #echo "HOST_ROLE = $ROLE  HOST_TYPE = $HOSTTYPE VM_TYPE = $VMTYPE"
}

function killtree() {
  local _pid=$1
  local _sig=${2-TERM}
  if [[ `uname -a|grep 'SunOS'|grep 'sparc'|grep -c '5.11'` -eq "0" ]]; then kill -stop ${_pid}; fi
  for _child in $(ps -ef |awk '$3 == '${_pid}' {print $2}'); do 
     killtree ${_child} ${_sig}
  done
  kill -${_sig} ${_pid}
}

cleanup () 
{
  if [[ -n "$v_chk_run" && $v_chk_run -eq "1" ]]; then return; fi

  rs=$?
  if [ $rs -ne "0" ] ; then
    json_to_rsyslog="@cee: {\"ERROR\" : \"Failure during $program_name run. $errm\"}"
    if [[ -n "$RAT_SEND_TO_RSYSLOG_CMDLINE" && $RAT_SEND_TO_RSYSLOG_CMDLINE -eq 1 ]] ; then
      logger -t ${program_name} -p user.err "$json_to_rsyslog"
    fi
    if [[ -n "$RAT_CREATE_CLOUD_JSON" && $RAT_CREATE_CLOUD_JSON -eq 1 ]] ; then
      drfc=$(date --rfc-3339=ns)
      echo "[$drfc] [exachk] [$json_sev] [] exachk: [HOST_ID: $localnode]$opc_syslog_tag -- @cee: $json_to_rsyslog" >> $CLOUDLOG
    fi
  fi

  if [[ $MCLEANUP -eq "1" ]]; then echo -e "\nCleanup started on all nodes"; fi

  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]]; then
    if [[ -e $HOSTLIST.bak ]]; then
      cat $HOSTLIST.bak >> $HOSTLIST
      rm -f $HOSTLIST.bak >/dev/null 2>&1;
    fi
    if [[ -e $HOSTLIST.ndh ]]; then
      cat $HOSTLIST.ndh >> $HOSTLIST
      rm -f $HOSTLIST.ndh >/dev/null 2>&1;
    fi 
    if [[ -e $HOSTLIST ]]; then 
      cat $HOSTLIST|sort|uniq > $HOSTLIST.2
      mv -f $HOSTLIST.2 $HOSTLIST
    fi
  fi
 
  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then umask ${oumask} >/dev/null; fi

  if [[ -n $RAT_LOAD_CHECK_ATTRIBUTES ]]; then . $RTEMPDIR/unset_checks_attributes.sh 2>/dev/null; fi
  
  if [[ -n "$initexit" && "$initexit" -eq "-1" ]]; then return; fi
  old_IFS=$IFS
  unset IFS
  #commenting this function because bug was fixed long back and now we should not have internal data in log files and report files.
  #update_zip_files

  if [[ ! -n "$RAT_KEEP_PASSWORD_IN_DEBUG" && -f "$RAT_DEBUG_FILENAME_INTERNAL" && ! -f "$RAT_DEBUG_FILENAME_INTERNAL.orig" ]] ; then
    if [[ -n "$RAT_KEEP_ORIG_DEBUG_FILE" && $RAT_KEEP_ORIG_DEBUG_FILE -eq "1" ]] ; then
      cp -f $RAT_DEBUG_FILENAME_INTERNAL $RAT_DEBUG_FILENAME_INTERNAL.orig
    fi
    remove_passwords_in_debug;
  fi

  if [[ $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
    child_pid=$(ps -ef |grep "$watchdog_pid"|grep -v 'grep'|grep -w 'sleep'|awk '{print $2}'|sed 's/ //g')
    kill $watchdog_pid > /dev/null 2>&1
    if [[ -n "$child_pid" ]] ; then kill $child_pid > /dev/null 2>&1;fi   
    #kill $watchdog_pid > /dev/null 2>&1
    return;
  fi
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] ; then cp -rf $INPUTDIR $OUTPUTDIR > /dev/null 2>&1; fi

  tty -s && stty echo

  if [ -e "$ROOT_LCKFIL" ] ; then rm -f $ROOT_LCKFIL >/dev/null 2>&1; fi
  if [[ -d $INPUTDIR && -z "$RAT_NOCLEAN_DIR" ]]
  then 
    # if it's run from NFS in Exalogic Machine, need to kill watchdog.sh first to delete .input dir 

    if [[ $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then wrkdir_filesystem_type=$(stat -f -L -c %T $(echo $WRKDIR));fi
 
    if [[ $is_exalogic_machine -eq 1 && "$wrkdir_filesystem_type" = "nfs" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && "$wrkdir_filesystem_type" = "nfs" ]]
    then
      child_pid=$(ps -ef |grep $watchdog_pid|grep -v 'grep'|grep 'sleep'|awk '{print $2}'|sed 's/ //g')
      kill $watchdog_pid > /dev/null 2>&1
      if [[ -n "$child_pid" ]] ; then   kill $child_pid > /dev/null 2>&1;fi 
      #kill $watchdog_pid > /dev/null 2>&1
    fi
    rm -rf $INPUTDIR >/dev/null 2>&1
  elif [[ -d $INPUTDIR && -n "$RAT_NOCLEAN_DIR" ]]
  then
    cp -rf $INPUTDIR $OUTPUTDIR >/dev/null 2>&1
    zip -u {$UPLOADFIL}.zip $INPUTDIR >/dev/null 2>&1
  fi
  if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
    saved_errfil=$ERRFIL
    ERRFIL=/dev/null
    on_signal_cell_cleanup;
    ERRFIL=$saved_errfil
  fi
  if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
    saved_errfil=$ERRFIL
    ERRFIL=/dev/null
    on_signal_ib_cleanup;
    ERRFIL=$saved_errfil
  fi

  if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" ]]
  then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      saved_errfil=$OLD_ERRFIL
    else
      saved_errfil=$ERRFIL
    fi
    ERRFIL=/dev/null
    on_signal_compute_cleanup;
    ERRFIL=$saved_errfil
  fi

  if [ -d "$TMPDIR/report1_$$" ]; then rm -rf $TMPDIR/report1_$$ >/dev/null 2>&1; fi
  if [ -d "$TMPDIR/report2_$$" ]; then rm -rf $TMPDIR/report2_$$ >/dev/null 2>&1; fi

  for chkid in `if [ -e $TMP_EXCLUDEFIL ]; then cat $TMP_EXCLUDEFIL; fi`
  do
    if [[ -e $EXCLUDEFIL ]]; then 
      sed "/$chkid/d" $EXCLUDEFIL > $EXCLUDEFIL.2
      mv -f $EXCLUDEFIL.2 $EXCLUDEFIL
    fi
  done

  if [[ $temp_d_dir_created -eq 1 ]];then rm -rf $RTEMPDIR_D >/dev/null 2>&1; fi
  if [[ $delete_lock_file -eq 0 ]];then rm -rf $RTEMPDIR >/dev/null 2>&1; fi
  if [[ -n $test_email_config && $test_email_config -eq 1 ]];then
    rm -rf $RTEMPDIR/test_attachment.txt >/dev/null 2>&1;
    #rm -rf $RTEMPDIR_D >/dev/null 2>&1;
    rm -rf $RTEMPDIR/cellip_for_mail.ora >/dev/null 2>&1;
  fi 

  if [ -e "$HOSTLIST.org" ] ; then mv -f $HOSTLIST.org $HOSTLIST; fi
  if [[ -e $EXCLUDEFIL ]] && [[ ! -s $EXCLUDEFIL || `cat $EXCLUDEFIL|wc -l` -eq "0" ]]; then rm -f $EXCLUDEFIL; fi

  if [[ -n "$delete_lock_file" && $delete_lock_file -eq 0 ]]
  then
    #if [[ -z $RAT_COPY_UTL_NO_PARALLEL ]]; then
    #  OLD_DIR=`pwd`
    #  cd $TMPDIR
    #  if [[ -n $is_zip_unzip_available && $is_zip_unzip_available -eq "1" ]]; then
    #    if [ -e $RTEMPDIR/${program_name}_utlscripts.zip ]; then unzip -Z -1 $RTEMPDIR/${program_name}_utlscripts.zip|xargs rm -f>/dev/null 2>&1; fi
    #  else
    #    if [ -e $RTEMPDIR/${program_name}_utlscripts.tar.gz ]; then tar -tf $RTEMPDIR/${program_name}_utlscripts.tar.gz|xargs rm -f>/dev/null 2>&1; fi	
    #  fi
    #  if [[ -e $OLD_DIR ]]; then cd $OLD_DIR; fi
    #fi

    if [ -d $RTEMPDIR ]; then rm -rf $RTEMPDIR >/dev/null 2>&1; fi; 
    if [ -e $LOCKFIL ]; then rm -f $LOCKFIL >/dev/null 2>&1; fi;

    SYSTEMD_USED=0; SYSTEMD_USED=`ps -ef |grep systemd|head -1|awk '{print $2}'|sed 's/ //g'`

    if [[ -e "${RATENV_FIL}" && $SYSTEMD_USED -eq 0 ]] || [[ -e "${RATENV_FIL}" && -n "$setup_inittab" && $setup_inittab -eq "10" && $SYSTEMD_USED -gt 0 ]]; then 
      rm -f ${RATENV_FIL} >/dev/null 2>&1;
    fi;

    if [ -e  $HOSTLIST ]
    then
      for hname in `cat $HOSTLIST`
      do
	dirlist_to_clean=$(echo "$USR_DIRS"|sed "s/^\s*//g"|sed "s/\s*$//g")
        if [ $hname = $localnode ]
        then
	  rm -rf $dirlist_to_clean >/dev/null 2>&1
          rm -f ${RTEMPDIR}/o_*.out >/dev/null 2>&1 # gadiga - not needed as dir is already purged
          if [ -e $EXADATA_CELL_COLLECTIONS ]; then rm -f $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1; fi;
          #if [ -e $TMPDIR/raccheck_env.out ]; then  rm -f $TMPDIR/raccheck_env.out >/dev/null 2>&1; fi;
          #if [ -e $TMPDIR/CellFlashCacheMode.out ]; then  rm -f $TMPDIR/CellFlashCacheMode.out >/dev/null 2>&1; fi;
          #if [ -e $TMPDIR/set_orcl_env.sh ]; then rm -f $TMPDIR/set_orcl_env.sh >/dev/null 2>&1;fi;
          if [ -e $ROOTSCRPT ]; then rm -f $ROOTSCRPT >/dev/null 2>&1;fi;
          #if [ -e /tmp/cprofile.sh ]; then rm -f /tmp/cprofile.sh >/dev/null 2>&1;fi;
          if [ -e $TMPDIR/mail.out ]; then rm -f $TMPDIR/mail.out >/dev/null 2>&1;fi;
          if [ -e "${TMP_RATENV_FIL}" ]; then rm -f ${TMP_RATENV_FIL} >/dev/null 2>&1;fi;
          #if [ -e "${RATENV_FIL}" ]; then rm -f ${RATENV_FIL} >/dev/null 2>&1; fi;
    	  if [[ -e "${RATENV_FIL}" && $SYSTEMD_USED -eq 0 ]] || [[ -e "${RATENV_FIL}" && -n "$setup_inittab" && $setup_inittab -eq "10" && $SYSTEMD_USED -gt 0 ]]; then rm -f ${RATENV_FIL} >/dev/null 2>&1; fi;
          if [ -e "${TMPSTFILE}" ]; then rm -f ${TMPSTFILE} >/dev/null 2>&1;fi;
          #rm -f $TMPDIR/o_root_clusterwide_check*.out >/dev/null 2>&1
          #if [ -e $RTEMPDIR/cells.out ]; then rm -f $RTEMPDIR/cells.out >/dev/null 2>&1;fi
          if [ -e ${PROBE_XML}.tmp ]; then rm -f ${PROBE_XML}.tmp >/dev/null 2>&1;fi;
          if [ -e ${PROBE_XML}.tmp2 ]; then rm -f ${PROBE_XML}.tmp2 >/dev/null 2>&1;fi;
	  if [ -e "$UDC" ]; then rm -f $UDC >/dev/null 2>&1;fi;
	  if [ -e "$WRKDIR/udc_skipped.log" ]; then rm -f $WRKDIR/udc_skipped.log >/dev/null 2>&1;fi;
	  if [ -e "$WRKDIR/xml_validation.out" ]; then rm -f $WRKDIR/xml_validation.out >/dev/null 2>&1;fi;
	  if [ -e "$WRKDIR/udc_no_comments.xml" ]; then rm -f $WRKDIR/udc_no_comments.xml >/dev/null 2>&1;fi;		
	  if [ -e "$WRKDIR/.log" ]; then rm -f $WRKDIR/.log >/dev/null 2>&1;fi;		
	  if [ -e "$COLLDIFFFIL" ]; then rm -f $COLLDIFFFIL >/dev/null 2>&1;fi;
          if [[ -n "$exclude_check" && $exclude_check -eq 1 ]] ; then
            if [ -e "$EXCLUDEFIL" ]; then rm -f $EXCLUDEFIL >/dev/null 2>&1;fi;
          fi
	  if [ -e "$OUTPUTDIR/cmdexfil.txt" ]; then rm -f $OUTPUTDIR/cmdexfil.txt >/dev/null 2>&1;fi;
          if [ -e "$CHECKSFILE" ]; then rm -f $CHECKSFILE >/dev/null 2>&1;fi;
          if [ -e "$TMPDIR/.initdaemon.pid" ]; then rm -f $TMPDIR/.initdaemon.pid >/dev/null 2>&1;fi;
	  if [[ -e $WRKDIR/cellip2.ora ]]; then rm -f $WRKDIR/cellip2.ora; fi

          ##delete utility script at the end of execution

	  #if [[ -n $RAT_COPY_UTL_NO_PARALLEL ]]; then
          #  for utlscrpt in "${a_utlscrpt[@]}"
          #  do
          #    if [ -e $TMPDIR/${utlscrpt} ]; then rm -f $TMPDIR/${utlscrpt} >/dev/null 2>&1;fi
          #  done	
	  #fi

	  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	    if [ -d $TMP_OUTPUT ]; then rm -rf $TMP_OUTPUT >/dev/null 2>&1; fi
	  fi
        else
          node_ssh_user=$usern
          if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
            if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
              node_ssh_user="${root_user}"
            else
              node_ssh_user="${foxtrot_dom0_user}"
            fi
            if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$hname "echo \"\$HOME\""); fi
            l_RTEMPDIR=${l_TMPDIR}/.${program_name}
          else
            l_TMPDIR=$TMPDIR
            l_RTEMPDIR=$RTEMPDIR
          fi

	  #if [[ -z $RAT_COPY_UTL_NO_PARALLEL ]]; then
	  #  if [[ -n $is_zip_unzip_available && $is_zip_unzip_available -eq "1" ]]; then
	  #    $SSHELL $node_ssh_user@$hname " $bash_scr -c \"cd $l_TMPDIR/;if [ -e ${l_RTEMPDIR}/${program_name}_utlscripts.zip ]; then unzip -Z -1 $l_RTEMPDIR/${program_name}_utlscripts.zip|xargs rm -f>/dev/null 2>&1; fi;\""
	  #  else
	  #    $SSHELL $node_ssh_user@$hname " $bash_scr -c \"cd $l_TMPDIR/;if [ -e ${l_RTEMPDIR}/${program_name}_utlscripts.tar.gz ]; then tar -tf $l_RTEMPDIR/${program_name}_utlscripts.tar.gz|xargs rm -f>/dev/null 2>&1; fi;\""
    	  #  fi
	  #fi

          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -rf $dirlist_to_clean >/dev/null 2>&1\""
          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"if [ -d $l_RTEMPDIR ]; then rm -rf $l_RTEMPDIR >/dev/null 2>&1; fi\""
          #$SSHELL $node_ssh_user@$hname "$bash_scr -c \"if [ -e $l_TMPDIR/o_exadata_disk.out ]; then rm -f $l_TMPDIR/o_exadata_disk.out >/dev/null 2>&1; fi;\""
          #$SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f $l_TMPDIR/raccheck_env.out >/dev/null 2>&1\""
          #$SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f $l_TMPDIR/set_orcl_env.sh >/dev/null 2>&1\""
          #$SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f $ROOTSCRPT >/dev/null 2>&1\""
          #$SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f $l_TMPDIR/CellFlashCacheMode.out >/dev/null 2>&1\""
          #$SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f $l_TMPDIR/o_root_clusterwide_check*.out >/dev/null 2>&1\""
          #$SSHELL$node_ssh_user@ $hname "$bash_scr -c \"rm -f /tmp/cprofile.sh >/dev/null 2>&1\""
          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f ${TMP_RATENV_FIL} >/dev/null 2>&1\""
          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f ${RATENV_FIL} >/dev/null 2>&1\""
	  b_TMPSTFILE=$(basename $TMPSTFILE)
          #$SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f $l_TMPDIR/$b_TMPSTFILE >/dev/null 2>&1\""
          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f ${PROBE_XML}.tmp >/dev/null 2>&1\""
          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"rm -f ${PROBE_XML}.tmp2 >/dev/null 2>&1\""
	  get_winpath "COLLDIFFFIL"
	  get_winpath "CHECKSFILE"
          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"if [ -e $COLLDIFFFIL ]; then rm -f ${COLLDIFFFIL} >/dev/null 2>&1; fi;\""
	  $SSHELL $node_ssh_user@$hname "$bash_scr -c \"if [ -e $CHECKSFILE ]; then rm -f ${CHECKSFILE} >/dev/null 2>&1; fi;\""
	  restore_winpath "COLLDIFFFIL"
	  restore_winpath "CHECKSFILE"

          ##delete utility script at the end of execution
	  #if [[ -n $RAT_COPY_UTL_NO_PARALLEL ]]; then
          #  for utlscrpt in "${a_utlscrpt[@]}"
          #  do
          #     $SSHELL $node_ssh_user@$hname " $bash_scr -c \"if [ -e $l_TMPDIR/${utlscrpt} ]; then rm -f $l_TMPDIR/${utlscrpt} >/dev/null 2>&1;fi\""
          #  done
	  #fi

          #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	     $SSHELL $node_ssh_user@$hname " $bash_scr -c \"if [ -d $TMP_OUTPUT ]; then rm -rf $TMP_OUTPUT >/dev/null 2>&1;fi\"";
	  fi
        fi
      done
    fi

    if [ -e $WRKDIR/cgrep ]; then rm -f $WRKDIR/cgrep >/dev/null 2>&1;fi;
    if [ -e a_dbm_asm_diskgroup_attributes_dbmv2.out ]; then rm -f a_dbm_asm_diskgroup_attributes_dbmv2.out >/dev/null 2>&1;fi;
  fi

  if [ -e  $HOSTLIST ]
  then 
    if [ $OFFLINE -eq 0 ]
    then
      if [[ -n $arr && $arr -ge 0 ]]; then arr=`expr $arr - 1`;fi
      while [[ -n $arr && $arr -ge 0 ]]
      do
        if [ ${hnameArr[$arr]} = $localnode ]
        then
          #rm -rf ~/.ssh 2>/dev/null
          mv -f $HOME/.ssh/authorized_keys.tmp $HOME/.ssh/authorized_keys 
          mv -f $HOME/.ssh/known_hosts.tmp $HOME/.ssh/known_hosts 
        else
          #ssh ${hnameArr[$arr]} rm -rf ~/.ssh
          $SSHELL -o StrictHostKeyChecking=no -x -l $usern ${hnameArr[$arr]} "/bin/sh -c \"mv -f \$HOME/.ssh/known_hosts.tmp \$HOME/.ssh/known_hosts; mv -f \$HOME/.ssh/authorized_keys.tmp \$HOME/.ssh/authorized_keys\""  
        fi
        arr=`expr $arr - 1`
      done
    fi 
  fi

  if [ -n "$watchdog_pid" ]; then child_pid=$(ps -ef |grep "$watchdog_pid"|grep -v 'grep'|grep -w 'sleep'|awk '{print $2}'|sed 's/ //g'); fi
  kill $watchdog_pid > /dev/null 2>&1
  if [[ -n "$child_pid" ]] ; then kill $child_pid > /dev/null 2>&1;fi
  #kill $watchdog_pid > /dev/null 2>&1

  if [[ -d $INPUTDIR && -z "$RAT_NOCLEAN_DIR" ]]
  then
    rm -rf $INPUTDIR >/dev/null 2>&1
  fi

  if [[ -d $OUTPUTDIR && -z "$RAT_NOCLEAN_DIR" && $download_ARU -eq "0" ]];
  then
    ZIPFIL=${UPLOADFIL}.zip
    if [ ! -e $ZIPFIL ]; then ZIPFIL=${UPLOADFIL}.tar.gz; fi
    if [[ -n "$ZIPFIL" && ! -e $ZIPFIL ]] || [[ -n "$stack_counter" && $stack_counter -lt 1 && -n $SSH_blocked && $SSH_blocked -eq 0 ]]
    then
      rm -rf $OUTPUTDIR >/dev/null 2>&1
    fi
  fi
 
  #removed unrequired messages from log file
  if [[ -e $LOGFIL ]];
  then
    ftdir=$(dirname $LOGFIL);
    $(grep -iv "bash: line.*: Not a directory" $LOGFIL > $ftdir/.${program_name}.log);
    if [[ -e $ftdir/.${program_name}.log ]];
    then
      $(mv -f $ftdir/.${program_name}.log $LOGFIL >/dev/null 2>&1);
      $(rm -f $ftdir/.${program_name}.log >/dev/null 2>&1);
    fi
  fi

  if [[ $upload_failed -eq 1 ]];then
    rm -rf $OUTPUTDIR >/dev/null 2>&1
    rm -rf $CM_OUTPUTDIR >/dev/null 2>&1
  fi

  if [[ -d $WRKDIR/.MERGED_COLLECTIONS/ ]];
  then
    rm -rf $WRKDIR/.MERGED_COLLECTIONS >/dev/null 2>&1
  fi

  #lock the cells using exacli if any cell remained unlock due to some reason
  if [[ -n $unlocked_storage_cell && $unlocked_storage_cell -eq 1 ]];then
    exacli_passwd_list_index=0
    for (( exacli_passwd_list_index = 0; exacli_passwd_list_index < $cell_ip_max_index; exacli_passwd_list_index++ ))
    do
      cell_ip=${exacli_passwd_list[exacli_passwd_list_index]}
      exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      lock_storage_cell_exacli "$exacli_user" "$cell_ip" "${exacli_passwd_list[exacli_passwd_list_index]}"
      if [[ $? -eq "0" ]]; then
        echo -e "\n\n Unable to lock Storage Server $cell_ip"
        if [[ $EM_PROBE_MODE -eq 1 ]]
          then
          EMSG= "$EMSG Unable to lock Storage Server $cell_ip"
          unable_to_lock_cell=1
        fi
      fi
    done
    if [[ $EM_PROBE_MODE -eq 1 && $unable_to_lock_cell -eq 1 ]]
    then
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      unable_to_lock_cell=0
      exit
    fi
  fi
  if [[ $MCLEANUP -eq "1" ]]; then echo -e "\nCleanup successfully finished on all nodes"; fi
  echo
}

remove_redirection_in_scripts ()
{
  #for SCRIPT in `find $OUTPUTDIR/scripts -name "root*\.sh";find $OUTPUTDIR/scripts -name "${program_name}_*\.sh";`
  for SCRIPT in `find $OUTPUTDIR/scripts -name "*.sh";`
  do
    sed "s/2>>.*$//g" $SCRIPT > ${SCRIPT}.tmp 
    mv -f ${SCRIPT}.tmp $SCRIPT >/dev/null 2>&1

    sed "s/>>.*$//g" $SCRIPT > ${SCRIPT}.tmp 
    mv -f ${SCRIPT}.tmp $SCRIPT >/dev/null 2>&1

    sed "s/.*set_orcl_env.*//g" $SCRIPT > ${SCRIPT}.tmp
    mv -f ${SCRIPT}.tmp $SCRIPT >/dev/null 2>&1
  done
}

reorg_output_dir ()
{
  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]]; then
    mv -f $OUTPUTDIR/logs $OUTPUTDIR/idmlogs/healthcheck/logs_${localnode} >/dev/null 2>&1
    rm -rf $WRKDIR/idmlogs_${FDS} >/dev/null 2>&1
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    move_files "$ERRFIL" "$OLD_ERRFIL"  
    if [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
      t_utildir=$(dirname $TMP_OUTPUT)
      mv -f $TMP_OUTPUT/pxhcdr*.zip $OUTPUTDIR >/dev/null 2>&1
      mv -f $t_utildir/pxhcdr*.zip $OUTPUTDIR >/dev/null 2>&1
    else
      dirlist=$(echo "$USR_DIRS"|sed "s/^\s*//g"|sed "s/\s*$//g")
      n_old_ifs=$IFS
      IFS=' '
      for utildir in `echo "$dirlist"`
      do
	t_utildir=$(dirname $utildir)
        mv -f $utildir/pxhcdr*.zip $OUTPUTDIR >/dev/null 2>&1
        mv -f $t_utildir/pxhcdr*.zip $OUTPUTDIR >/dev/null 2>&1
      done
      IFS=$n_old_ifs
    fi
  fi
 
  if [[ -n "$RAT_COPY_EM_XML_FILES" && $RAT_COPY_EM_XML_FILES -eq "2" ]]; then 
    mv -f $XMLREPFIL $WRKDIR >/dev/null 2>&1
    mv -f $JSONREPFIL $WRKDIR >/dev/null 2>&1
    mv -f $XMLSKIPFIL $WRKDIR >/dev/null 2>&1
    mv -f $JSONSKIPFIL $WRKDIR >/dev/null 2>&1

    BASEXMLREPFIL=$(basename $XMLREPFIL)
    BASEXMLSKIPFIL=$(basename $XMLSKIPFIL)
    BASEJSONREPFIL=$(basename $JSONREPFIL)
    BASEJSONSKIPFIL=$(basename $JSONSKIPFIL)

    if [[ -z $MERGEFILES && $OFFLINE -eq "0" ]]; then
      security_fix "fix_file_attributes" "$WRKDIR/$BASEXMLREPFI" "" "540"
      security_fix "fix_file_attributes" "$WRKDIR/$BASEXMLSKIPFIL" "" "540"
      security_fix "fix_file_attributes" "$WRKDIR/$BASEJSONREPFIL" "" "540"
      security_fix "fix_file_attributes" "$WRKDIR/$BASEJSONSKIPFIL" "" "540"
    fi
  else 
    XMLREPFIL_NEW=$(echo "$XMLREPFIL"|sed "s/${program_name}_results.xml/${localnode}_${program_name}_results.xml/g")
    XMLSKIPFIL_NEW=$(echo "$XMLSKIPFIL"|sed "s/${program_name}_exceptions.xml/${localnode}_${program_name}_exceptions.xml/g")
    JSONREPFIL_NEW=$(echo "$JSONREPFIL"|sed "s/${program_name}_results.json/${localnode}_${program_name}_results.json/g")
    JSONSKIPFIL_NEW=$(echo "$JSONSKIPFIL"|sed "s/${program_name}_exceptions.json/${localnode}_${program_name}_exceptions.json/g")
    mv -f "$XMLREPFIL" "$XMLREPFIL_NEW" >/dev/null 2>&1
    mv -f "$XMLSKIPFIL" "$XMLSKIPFIL_NEW" >/dev/null 2>&1
    mv -f "$JSONREPFIL" "$JSONREPFIL_NEW" >/dev/null 2>&1
    mv -f "$JSONSKIPFIL" "$JSONSKIPFIL_NEW" >/dev/null 2>&1


    if [[ -z $MERGEFILES && $OFFLINE -eq "0" ]]; then
      security_fix "fix_file_attributes" "$XMLREPFIL_NEW" "" "540"
      security_fix "fix_file_attributes" "$XMLSKIPFIL_NEW" "" "540"
      security_fix "fix_file_attributes" "$JSONREPFIL_NEW" "" "540"
      security_fix "fix_file_attributes" "$JSONSKIPFIL_NEW" "" "540"

    fi
  fi
 
  if [ ! -e $OUTPUTDIR/outfiles ]; then mkdir $OUTPUTDIR/outfiles >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/scripts ]; then mkdir $OUTPUTDIR/scripts >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/reports ]; then mkdir $OUTPUTDIR/reports >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/upload ]; then mkdir $OUTPUTDIR/upload >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/log ]; then mkdir $OUTPUTDIR/log >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/outfiles/asrexachk ]; then mkdir $OUTPUTDIR/outfiles/asrexachk >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/outfiles/vmpscan ]; then mkdir $OUTPUTDIR/outfiles/vmpscan >/dev/null 2>&1;fi

  for usrdir in "${usr_dirs[@]}"
  do
    if [[ -e $OUTPUTDIR/$usrdir ]]; then rm -rf $OUTPUTDIR/$usrdir > /dev/null 2>&1; fi
  done
  if [  -e $OUTPUTDIR/outfiles/vmpscan ]; then mv -f $OUTPUTDIR/merge.sh $OUTPUTDIR/outfiles/vmpscan >/dev/null 2>&1;fi 
  if [  -e $OUTPUTDIR/outfiles ]; then mv -f $OUTPUTDIR/*.out $OUTPUTDIR/outfiles >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/scripts ]; then 
    mv -f $OUTPUTDIR/*.sh $OUTPUTDIR/scripts >/dev/null 2>&1;
    mv -f $OUTPUTDIR/*.aksh $OUTPUTDIR/scripts >/dev/null 2>&1;
    mv -f $OUTPUTDIR/*_con.sql $OUTPUTDIR/scripts >/dev/null 2>&1;
  fi
  if [  -e $OUTPUTDIR/reports ]; then mv -f $OUTPUTDIR/*.rep $OUTPUTDIR/reports >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/upload ]; then mv -f $OUTPUTDIR/*.sql $OUTPUTDIR/upload >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/upload ]; then mv -f $OUTPUTDIR/*.ctl $OUTPUTDIR/upload >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/outfiles/vmpscan ]; then mv -f $OUTPUTDIR/*vmpscan.tar.gz $OUTPUTDIR/outfiles/vmpscan >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/outfiles/asrexachk ]; then mv -f $OUTPUTDIR/asrexacheck_*.zip $OUTPUTDIR/outfiles/asrexachk >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/outfiles/asrexachk ]; then find $OUTPUTDIR/.CELLDIR/ -name 'asrexacheck_*.zip' -exec mv -f {} $OUTPUTDIR/outfiles/asrexachk \; >/dev/null 2>&1;fi 
  
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] || [[ -n $RAT_PDEBUG && $RAT_PDEBUG -eq 1 ]]; then cp -rf $INPUTDIR $OUTPUTDIR > /dev/null 2>&1; fi

  if [[ -z "$RAT_COPY_EM_XML_FILES" && -e $OUTPUTDIR/upload ]]; then mv -f $OUTPUTDIR/*.xml $OUTPUTDIR/upload >/dev/null 2>&1;fi
  if [[ -z "$RAT_COPY_EM_XML_FILES" && -e $OUTPUTDIR/upload ]]; then mv -f $OUTPUTDIR/*.json $OUTPUTDIR/upload >/dev/null 2>&1;fi

  #if [[  -e $HTML_REPFILE && -e $OUTPUTDIR/reports ]] && [ -z "$MERGEFILES" ]
  #then
  #  cp -f $HTML_REPFILE ${HTML_REPFILE}_copy >/dev/null 2>&1
  #  mv -f $OUTPUTDIR/*.html $OUTPUTDIR/reports >/dev/null 2>&1
  #  cp -f ${HTML_REPFILE}_copy $HTML_REPFILE >/dev/null 2>&1
  #  cp -f $HTML_REPFILE $OUTPUTDIR/reports >/dev/null 2>&1
  #  rm -f ${HTML_REPFILE}_copy >/dev/null 2>&1
  #fi

  if [  -e $OUTPUTDIR/log ]; then mv -f $OUTPUTDIR/*.log $OUTPUTDIR/log >/dev/null 2>&1;mv -f $OUTPUTDIR/*.txt $OUTPUTDIR/log >/dev/null 2>&1;mv -f $OUTPUTDIR/*.lst $OUTPUTDIR/log >/dev/null 2>&1;fi
  ERRFIL=${OUTPUTDIR}/log/${program_name}_error.log
  LOGFIL=${OUTPUTDIR}/log/${program_name}.log
  HOSTLIST=${OUTPUTDIR}/outfiles/$(basename $HOSTLIST)
  #merge vmpscan from different nodes and cleanup
  vmpscanFileCount=$(ls -l $OUTPUTDIR/outfiles/vmpscan/*vmpscan.tar.gz 2>/dev/null|wc -l)
  if [[ -e $OUTPUTDIR/outfiles/vmpscan/merge.sh && $vmpscanFileCount -gt 1 ]] && [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]
  then  
    pushd . > /dev/null 2>&1
    cd $OUTPUTDIR/outfiles/vmpscan/ >/dev/null 2>&1
    security_fix "fix_file_attributes" "$OUTPUTDIR/outfiles/vmpscan/merge.sh" "" "540"  
    vmpScanMergeLog=$($bash_scr -c "$OUTPUTDIR/outfiles/vmpscan/merge.sh -b" 2>&1)
    echo -e "$vmpScanMergeLog">>$LOGFIL
    security_fix "fix_file_attributes" "$OUTPUTDIR/outfiles/vmpscan/clean.sh" "" "540"  
    if [ -e $OUTPUTDIR/outfiles/vmpscan/index.htm ]; then mv -f $OUTPUTDIR/outfiles/vmpscan/index.htm $OUTPUTDIR/outfiles/vmpscan/*vmpscan $OUTPUTDIR/reports >/dev/null 2>&1;fi
    vmpScanCleanLog=$($bash_scr -c "$OUTPUTDIR/outfiles/vmpscan/clean.sh -b" 2>&1)
    echo -e "$vmpScanCleanLog">>$LOGFIL
    popd > /dev/null 2>&1
  fi
  #### 
  if [[ -n "$RAT_CLIENT_DEBUG" && $RAT_CLIENT_DEBUG -eq "1" ]]
  then
    if [[ ! -z "$RAT_CLIENT_DEB_FIL" ]]
    then
      debugFileName=$RAT_CLIENT_DEB_FIL
      for slave_debug in `find $OUTPUTDIR/log -name "*_slave_debug.log"`
      do
        echo "" 			>> $debugFileName
        echo "\n\nCopying results from ${slave_debug}\n\n" >> $debugFileName
        echo ""			>> $debugFileName 
        cat "$slave_debug" 	>> $debugFileName
        rm -f "$slave_debug" >/dev/null 2>&1;
      done
    fi
  fi

  if [[ -d $INPUTDIR && -n "$RAT_NOCLEAN_DIR" ]]; then cp -rf $INPUTDIR $OUTPUTDIR >/dev/null 2>&1; fi

  mv -f $COLLDIFFFIL $OUTPUTDIR/log >/dev/null 2>&1
  mv -f $CHECKSFILE $OUTPUTDIR/outfiles >/dev/null 2>&1
  mv -f $UDC $OUTPUTDIR/outfiles >/dev/null 2>&1

  if [[ -e $RAT_DAEMONDEB_INTERNAL ]]; then cp -f $RAT_DAEMONDEB_INTERNAL $OUTPUTDIR/log >/dev/null 2>&1; fi
}

mb_validate_oracle_home ()
{
  oracle_home_to_check=$1
  if [[ -d $oracle_home_to_check && -f $oracle_home_to_check/bin/oracle ]];then validate_oracle_home_status=1;else validate_oracle_home_status=0;fi;
}

mb_read_oracle_home ()
{
  mb_read_oracle_home_called=0
  mb_read_oracle_home_found=0
  if [ -z "$1" ] || [[ -n "$valideate_oracle_home_status" && $valideate_oracle_home_status -eq 0 ]]
  then
    mb_db_counter_read=0
    for db_name_to_check_to_read in "${mb_db_names[@]}"
    do
      if [[ "$db_name_to_check_to_read" = ${2} && -n "${mb_oracle_homes[$mb_db_counter_read]}" ]]
      then 
        mb_ask_oracle_home=${mb_oracle_homes[$mb_db_counter_read]}
        mb_read_oracle_home_found=1
        mb_read_oracle_home_called=1
        break
      else
	if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]]
	then
	  sid=$db_name_to_check_to_read
	  search_oh_si;
	  mb_ask_oracle_home=$oh
	  mb_read_oracle_home_found=1
	  mb_read_oracle_home_called=1
	  break
	fi
      fi
      mb_db_counter_read=$(expr $mb_db_counter_read + 1 )
    done

    if [[ -n "$validate_oracle_home_tries" && $validate_oracle_home_tries -lt 1 && $mb_read_oracle_home_found -eq 0 ]]
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
        cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" outcome="No">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n79_nlsid">
        Unable to find ORACLE_HOME for {1} database. Enter it here
      </text>
      <tokens>
	<token index="1">${2}</token>
      </tokens>
      </tokenizedtext>
  </question>
</group>
EOF
        PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
	#read_probe_xml "Unable to find ORACLE_HOME for {1} database. Enter it here"
	read_probe_xml "<token index=\"1\">${2}</token>"
	mb_ask_oracle_home=$xml_rvalue

        mb_read_oracle_home_called=1
      else
        exec 3<&2; exec 2<&0
        $READ -p "${program_name} did not find ORACLE_HOME for ${2} database.Please enter it here:- " mb_ask_oracle_home
        exec 2<&3

        mb_read_oracle_home_called=1
      fi
    elif [[ $mb_read_oracle_home_found -eq 0 ]]
    then
      exec 3<&2; exec 2<&0
      $READ -p "Invalid ORACLE_HOME for ${2} database.you can try `expr 4 - $validate_oracle_home_tries ` more times including this:- " mb_ask_oracle_home
      exec 2<&3

      mb_read_oracle_home_called=1
    fi
    #mb_read_oracle_home_value=$mb_ask_oracle_home
  fi
  mb_db_counter_read=0
}

read_targetversion ()
{
  if [ $read_targetversion_count -eq 0 ]
  then
    exec 3<&2; exec 2<&0
    $READ -p "Enter upgrade target version (valid versions are 11.2.0.4.0, 12.1.0.2.0 and 12.2.0.1.0):- " targetversion
    exec 2<&3

    targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
    targetversion=$(echo $targetversion|sed 's/\.//g')
    #$READ -p "$targetversion"
    if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
    then
      echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
      correct_target_version=0
    else
      correct_target_version=1
    fi
  else
    exec 3<&2; exec 2<&0
    $READ -p "Enter upgrade target version (valid versions are 11.2.0.4.0, 12.1.0.2.0 and 12.2.0.1.0) `expr 3 - $read_targetversion_count` tries left:- " targetversion
    exec 2<&3

    targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
    targetversion=$(echo $targetversion|sed 's/\.//g')
    if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
    then
      echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
      correct_target_version=0
    else
      correct_target_version=1
    fi 
  fi
}

function update_zip_files ()
{
  is_update_needed

  #echo "is_update_needed=$update_needed "
  if [[ $update_needed -eq "0" ]] ; then return; fi

  cd $WRKDIR
  for collection_dir in `find . -name "check_env.out" | sed 's/\/check_env.out//'`
  do
    #echo "replacing $collection_dir" 
    fdir=$(dirname $collection_dir)
    cd $WRKDIR/$fdir
    collection_dir=$(basename $collection_dir)
    replace_string "$collection_dir/$collection_dir.html"
    replaced_files="$collection_dir/$collection_dir.html"

    for ofile in `find $collection_dir/ -name "9EC87FB8BF2E4ED8E040E50A1EC03015*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done
    for ofile in `find $collection_dir/ -name "595A436B3A7172FDE0401490CACF5BA5*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done
    for ofile in `find $collection_dir/ -name "A18401E2DDFF63D2E040E50A1EC077C4*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done

    if [[ -e "$collection_dir.zip" && -n "$replaced_files" ]] ; then
      zip $collection_dir.zip $replaced_files >/dev/null 2>&1
    elif [  -e "$collection_dir.tar.gz" ] ; then
      rm -f $collection_dir.tar.gz
      tar -cf "$collection_dir.tar.gz"  $collection_dir/* >/dev/null 2>&1
    fi
  done
  mark_update_done
  #exit
}

function replace_string ()
{ 
  OLD_TMPDIR=$TMPDIR
  TMPDIR=$RTEMPDIR
  l_file=$1
  if [ -e "$l_file" ] ; then
    sed 's/RAT_COMPUTEPASSWORD_INTERNAL=.*//g' $l_file > $TMPDIR/$$.2replace.txt
    cp -f $TMPDIR/$$.2replace.txt $l_file
    rm -f $TMPDIR/$$.2replace.txt
  fi
  TMPDIR=$OLD_TMPDIR
}

function is_readme_writable ()
{ 
  readme_writable=1
  if [[ -e "$SCRIPTPATH/readme.txt" && -w "$SCRIPTPATH/readme.txt" ]] ; then
    readme_writable=1
  else
    readme_writable=0
  fi
}

function is_update_needed ()
{ 
  is_readme_writable

  #echo "$readme_writable $SCRIPTPATH/readme.txt"
  update_needed=1
  if [[ $readme_writable -eq "1" && `grep -ic "f20130501" $SCRIPTPATH/readme.txt` -eq "0"  ]] ; then
    update_needed=0
  else 
    if [ -e "$WRKDIR/.f20130501.txt" ] ; then update_needed=0; fi
  fi
}

function mark_update_done ()
{ 
  OLD_TMPDIR=$TMPDIR
  TMPDIR=$RTEMPDIR
  is_readme_writable 
  if [ $readme_writable -eq "1" ] ; then
    sed 's/f20130501//' $SCRIPTPATH/readme.txt > $TMPDIR/$$.2replace.txt
    cp -f $TMPDIR/$$.2replace.txt $SCRIPTPATH/readme.txt
    rm -f $TMPDIR/$$.2replace.txt
  else
    touch $WRKDIR/.f20130501.txt
  fi
  TMPDIR=$OLD_TMDIR
}

function check_wrkdir ()
{
  touch ${WRKDIR}/$$.touched >/dev/null 2>&1
  if [ $? -ne "0" ] ; then
    # $WRKDIR is not writable
    echo;
    echo -e "${RED}${WRKDIR} is not writable. Please set the RAT_OUTPUT and run again.";
    echo -e "${NORM}"
    echo "ex: export RAT_OUTPUT=/directory/writable"
    echo;
    echo;
    exit 1;
  fi
  rm -f ${WRKDIR}/$$.touched >/dev/null 2>&1
}

change_old_env_variables ()
{
  if [ -n "$RACCHECK_TIMEOUT" ]; then RAT_TIMEOUT=$RACCHECK_TIMEOUT;fi
  if [ -n "$RACCHECK_UPLOAD_CONNECT_STRING" ]; then RAT_UPLOAD_CONNECT_STRING=$RACCHECK_UPLOAD_CONNECT_STRING;fi
  if [ -n "$RACCHECK_UPLOAD_TABLE" ]; then RAT_UPLOAD_TABLE=$RACCHECK_UPLOAD_TABLE;fi
  if [ -n "$RACCHECK_ZIP_UPLOAD_TABLE" ]; then RAT_ZIP_UPLOAD_TABLE=$RACCHECK_ZIP_UPLOAD_TABLE;fi
  if [ -n "$RACCHECK_PATCH_UPLOAD_TABLE" ]; then RAT_PATCH_UPLOAD_TABLE=$RACCHECK_PATCH_UPLOAD_TABLE;fi
  if [ -n "$RACCHECK_UPLOAD_USER" ]; then RAT_UPLOAD_USER=$RACCHECK_UPLOAD_USER;fi
  if [ -n "$RACCHECK_UPLOAD_PASSWORD" ]; then RAT_UPLOAD_PASSWORD=$RACCHECK_UPLOAD_PASSWORD;fi
  if [ -n "$RACCHECK_UPLOAD_ORACLE_HOME" ]; then RAT_UPLOAD_ORACLE_HOME=$RACCHECK_UPLOAD_ORACLE_HOME;fi
  if [ -n "$RACCHECK_INV_LOC" ]; then RAT_INV_LOC=$RACCHECK_INV_LOC;fi
  if [ -n "$RACCHECK_CRS_HOME" ]; then RAT_CRS_HOME=$RACCHECK_CRS_HOME;fi
  if [ -n "$RACCHECK_ORACLE_HOME" ]; then RAT_ORACLE_HOME=$RACCHECK_ORACLE_HOME;fi
  if [ -n "$RACCHECK_ASM_HOME" ]; then RAT_ASM_HOME=$RACCHECK_ASM_HOME;fi
  if [ -n "$RACCHECK_OS" ]; then RAT_OS=$RACCHECK_OS;fi
  if [ -n "$RACCHECK_DB" ]; then RAT_DB=$RACCHECK_DB;fi
  if [ -n "$RACCHECK_DBNAMES" ]; then RAT_DBNAMES=$RACCHECK_DBNAMES;fi
  if [ -n "$RACCHECK_DBHOMES" ]; then RAT_DBHOMES=$RACCHECK_DBHOMES;fi
  if [ -n "$RACCHECK_OUTPUT" ]; then RAT_OUTPUT=$RACCHECK_OUTPUT;fi
  if [ -n "$RACCHECK_DEBUG" ]; then RAT_DEBUG=$RACCHECK_DEBUG;fi
  if [ -n "$RACCHECK_INFOPASS" ]; then RAT_INFOPASS=$RACCHECK_INFOPASS;fi
}

# set variable node_type based on system
set_node_type ()
{
  l_node_name=$1
  node_type="Compute Node";
  if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
  then
    node_type="Database server"
  fi
  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
    get_el_prefix "$l_node_name"
    if [[ $el_prefix = "DB" ]] ; then
        node_type="Control DB Node"
    elif [[ $el_prefix = "EC" ]] ; then
        node_type="Enterprise Controller"
    elif [[ $el_prefix = "PC" ]] ; then
        node_type="Proxy Controller"
    elif [[ $el_prefix = "OVMM" ]] ; then
        node_type="OVM Manager Node"
    elif [[ $el_prefix = "CS" ]] ; then
        node_type="Control vServer"
    fi
  fi
}

generate_exadata_report ()
{
  h_printed=0
  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]
  then
    h_printed=1
    echo "<h2>Systemwide firmware and software versions</h2>">> $OUTPUTDIR/${program_name}_versions.html
    echo "<p>Please compare these versions against Database Machine and Exadata Storage Server 11g Release 2 (11.2) Supported Versions (<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=888828.1\">Doc ID 888828.1</a>) in MyOracle Support</p>" >> $OUTPUTDIR/${program_name}_versions.html
  fi
 
  if [[ `echo $components|grep -iwc SUPERCLUSTER` -le 0 && -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]] 
  then
    echo "<h2>Systemwide Automatic Service Request (ASR) healthcheck</h2>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
  elif [ $h_printed -eq "0" ] ; then
    echo "<h2>Systemwide firmware and software versions</h2>">> $OUTPUTDIR/${program_name}_versions.html
  fi
  #echo "<p>Please check ASR Exadata Configuration Check via ASREXACHECK (<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=1450112.1\">Doc ID 1450112.1</a>) in MyOracle Support</p>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
 
   
  for xfilename in `find $OUTPUTDIR \( -name '*asrexachk*' -o -name '*exadata_versions*' \) -print|grep -v cbc|sort`
  do
    if [[ -e $xfilename &&  `echo $xfilename|grep -c report` -lt 1 ]]
    then
      if [[ -e $xfilename &&  `echo $xfilename|grep -c asrexachk` -ge 1 ]]
      then
        node_name_f=$(basename $xfilename|awk -F_ '{print $NF}')
        if [ `echo $node_name_f | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
          node_name=$(echo $node_name_f| sed 's/\.out//');
        else
          node_name=$(echo $node_name_f| cut -d. -f1)
        fi
        set_node_type $node_name
        if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
        then  
          echo "<h3>Database server $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        else
          echo "<h3>$node_type $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        fi
        echo "<pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        echo "</pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
      else
        node_name_f=$(basename $xfilename|awk -F_ '{print $NF}')
        if [ `echo $node_name_f | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
          node_name=$(echo $node_name_f| sed 's/\.out//');
        else
          node_name=$(echo $node_name_f| cut -d. -f1)
        fi
        set_node_type $node_name
        if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
        then  
          echo "<h3>Database server $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
        else
          echo "<h3>$node_type $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
        fi
        echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
        cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
        echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
      fi
    fi 
  done
 
  for xfilename in `find $OUTPUTDIR \( -name '*asrexachk_*' -o -name '*exadata_versions*' \) -print|grep cbc|sort`
  do
    if [[ -e $xfilename &&  `echo $xfilename|grep -c report` -lt 1 ]]
    then 
      node_name=$(basename $xfilename|$AWK 'BEGIN { FS = "_" } {printf $4"."$5"."$6"."$7}'|sed 's/\.out//g')
      #node_name=$(cat $CELLDIR/cells.out |grep -w "$node_name"|cut -d= -f2|tr -d ' ')
      node_name=$(grep -w "$node_name" $CELLDIR/cells.out|cut -d= -f2|tr -d ' ')
      if [[ -e $xfilename &&  `echo $xfilename|grep -c asrexachk` -ge 1 ]]
      then
        echo "<h3>Storage server $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        echo "<pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        echo "</pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
      else 
        echo "<h3>Storage server $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
        echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
        cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g'>> $OUTPUTDIR/${program_name}_versions.html
        echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
      fi
    fi
  done
 
  for sfilename in `find $OUTPUTDIR -name 's_nm2version*' -print |grep -v _report.out |grep -v .CELLDIR |sort`
  do
    if [[ -e $sfilename &&  `echo $sfilename|grep -c report` -lt 1 ]]
    then
      switch_name_f=$(basename $sfilename)
      if [ `echo $switch_name_f | grep -c '[0-9]*\_[0-9]*\_[0-9]*\_[0-9]*\.out'` -gt "0" ] ; then
        switch_name=$(basename $sfilename|sed 's/s_nm2version_//' |sed 's/\.out//' | sed 's/\_/./g')
      else
        switch_name=$(echo $switch_name_f|cut -d_ -f3| cut -d. -f1)
      fi
      echo "<h3>InfiniBand switch $switch_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
      echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
      cat $sfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
      echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
    fi
  done

  for zfsfilename in `find $OUTPUTDIR -name '*exalogic_zfs_checks*' -print |sort`
  do
    if [ -e $zfsfilename ]
    then
      storage_name_f=$(basename $zfsfilename)
      if [ `echo $storage_name_f | grep -c '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\.exalogic'` -gt "0" ] ; then
        storage_name=$(echo $storage_name_f|sed 's/\.exalogic\_zfs\_checks\.out//')
      else
	storage_name=$(echo $storage_name_f|cut -d. -f1)
      fi	
      echo "<h3>ZFS Storage Appliance $storage_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
      #echo "<h3>ZFS Storage Appliance $storage_name</h3>">> /tmp/check.out
      echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
      
      begin=0
      for i in `cat $zfsfilename` 
      do
        if [ `echo $i| grep -ic "END_OF_REPORT_chkHWInfo"` -gt 0 ]; then
          begin=0
        fi
        if [ $begin -eq "1" ]; then
          #echo $i >>/tmp/check.out
	  if [ `echo $i| grep -ic "Hardware Version Information"` -gt 0 ]; then
            echo "<b>$i</b>"| sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
	  else
	    echo $i| sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
	  fi 
        fi
        if [ `echo $i| grep -ic "START_OF_REPORT_chkHWInfo"` -gt 0 ]; then
          begin=1
        fi
      done 
      echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
    fi
  done
}

#Function to write entries of collection to log file if that requires root 
write_root_collections_log ()
{
  echo "OS DATA COLLECTION BY ROOT SENT TO $1" >>$LOGFIL
  echo "ROW = $ROW" >>$LOGFIL
  echo "PARAMETER OR PATH = $PARAM_PATH" >>$LOGFIL
  echo "COMMAND = $COM" >>$LOGFIL
  echo -e "CHECK ID = $CHECK_ID \nCOLLECTION_NAME = $COLLECTION_NAME\n">>$LOGFIL
  echo -e "---------------------------------------------\n\n" >>$LOGFIL
 }
#Function to write values of environment variables to log file if they are set before executing the tool

log_env_varaibles ()
{
  if [ -n "$2" ]; then echo "$1 = $2">>$LOGFIL;echo $fmt_line_header >>$LOGFIL;fi
  #To remove commas if user has used while setting envrionment variable
  if [[ $# -gt 2 && -n "$2"  && `echo $2|grep -ic ","` -gt 0 ]]
  then
    env_var_name=$1
    export $env_var_name="$(echo $2|tr '\054' " ")"  
  fi
}

function wait_for_compute_completion ()
{
  if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  first_time_in_loop=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;
    for cell_pid in "${cpids[@]}"
    do
      # wait till we finish collection running on node
      if [ `ps -ef | grep _compute |grep -c $cell_pid` -gt 0 ]
      then
        if [[ $first_time_in_loop -eq "1" ]] ; then
          printf "\nWaiting for ${program_name} to finish on remote nodes \n\n"
          first_time_in_loop=0
        fi
        printf "."
      else
        cname=${cpid_names[$cell_pid]};
        #echo "Finished run on $cname `date`";
        copy_from_compute;
        unset cpids[$cell_pid]; # remove from array
        cls_check_host_list[$stack_counter]=$cname
        stack_counter=$(expr $stack_counter + 1)
        #echo "Finished report generation on $cname `date`";
        #return;
      fi
    done
    sleep 2
  done

}

function on_signal_compute_cleanup ()
{
  if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;

  for ib_pid in "${cpids[@]}"
  do
    kill $ib_pid >/dev/null 2>&1
  done
}

function copy_from_compute ()
{
  printf "\n\nCopying results from $cname and generating report. This might take a while. Be patient.\n\n"
  mkdir $OUTPUTDIR/$cname
  get_cygpath "OUTPUTDIR"
  get_cygpath "RTEMPDIR"

  node_ssh_user="$usern"
  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
  then
    if [[ `echo "$ea_dom0_nodes" | grep -ic "$cname"` -le 0 ]]; then
      node_ssh_user="${root_user}"
    else
      node_ssh_user="${foxtrot_dom0_user}"
    fi
    if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$cname "echo \"\$HOME\""); fi
    l_RTEMPDIR=${l_TMPDIR}/.${program_name}		
  else
    l_TMPDIR=$TMPDIR
    l_RTEMPDIR=$RTEMPDIR
  fi

  $SCOPY -r $node_ssh_user@$cname:$l_RTEMPDIR $OUTPUTDIR/$cname >/dev/null 2>&1

  restore_cygpath "OUTPUTDIR"
  restore_cygpath "RTEMPDIR"
  rm -f $OUTPUTDIR/$cname/.${program_name}/*.sh 
  rm -f $OUTPUTDIR/$cname/.${program_name}/*.dat 
  rm -f $OUTPUTDIR/$cname/.${program_name}/${program_name}
  rm -f $OUTPUTDIR/$cname/.${program_name}/cgrep

  if [[ -n $RAT_COPY_UTL_NO_PARALLEL ]]; then $SSHELL $node_ssh_user@$cname rm -rf $l_RTEMPDIR; fi

  cp -f $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*$cname* $OUTPUTDIR 2>/dev/null

  if [[ -n "$RAT_CLIENT_DEBUG" && $RAT_CLIENT_DEBUG -eq "1" ]]
  then
    cp -f $OUTPUTDIR/$cname/.${program_name}/*_slave_debug.log $OUTPUTDIR 2>/dev/null
  fi
  
  crs_cid_file=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/crs_checkids.out 2>/dev/null)
  cross_node_cid_file=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/cross_node_checkids.out 2>/dev/null)
  
  if [[ -z "$clusterware_check_count" ]] ; then clusterware_check_count=0; fi
  if [[ -n "$crs_cid_file" && -e "$crs_cid_file" ]] ; then
    while read crs_cid
    do
      if [[ $clusterware_check_count -gt "0" ]] ; then
        # Check if it exists in array else insert
        crs_cid_exists=0
        for cid_in_arr in "${crs_check_id[@]}"
        do
          if [[ $cid_in_arr = $crs_cid ]] ; then crs_cid_exists=1; fi
        done
        if [[ $crs_cid_exists -eq "0" ]] ; then
          crs_check_id[$clusterware_check_count]=$crs_cid
          clusterware_check_count=$(expr $clusterware_check_count + 1)
        fi
      else
        crs_check_id[$clusterware_check_count]=$crs_cid
        clusterware_check_count=$(expr $clusterware_check_count + 1)
      fi
    done < $crs_cid_file
  fi

  crs_stack_counter=$clusterware_check_count
  crs_check_file_counter=0
  while [[ $crs_stack_counter -gt 0 && $SILENT -eq 0 ]]
  do  # append cluster wide check o/p
    CLUSTERCHECK_FIL=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out
    caf=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${crs_check_id[$crs_check_file_counter]}.out 2>/dev/null)
    if [[ -n "$caf" ]] ; then
      cat $caf >> $CLUSTERCHECK_FIL
      rm -f $caf
    fi
    crs_check_file_counter=$(expr $crs_check_file_counter + 1);
    crs_stack_counter=$(expr $crs_stack_counter - 1)
  done

  run_report;

  if [[ ! -z $RAT_SCRIPT_DEBUG ]]; then
    cat $OUTPUTDIR/$cname.slave.log
    #due to security concerns deleting slave log.
    #rm -rf $OUTPUTDIR/$cname.slave.log >/dev/null 2>&1
  else
    #cat $OUTPUTDIR/$cname.slave.log |grep -v "Pseudo-terminal will not be allocated"
    grep -v "Pseudo-terminal will not be allocated" $OUTPUTDIR/$cname.slave.log
  fi

  if [[ -n "$is_fmw_machine" && $is_fmw_machine  -eq "1" ]]; then
    if [[ -e  $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/logs ]]; then  cp -rf $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/logs $OUTPUTDIR/idmlogs/healthcheck/logs_$cname;  fi
  fi
  rm -rf $OUTPUTDIR/$cname/ 
}

function copy_from_dir ()
{
  if [ $d_index -ne 0 ];
  then
    cp -rf $WRKDIR/.MERGED_COLLECTIONS/$xdir $OUTPUTDIR >/dev/null 2>&1
    cp -f $OUTPUTDIR/$xdir/outfiles/*.* $OUTPUTDIR 2>/dev/null
    cp -rf $OUTPUTDIR/$xdir/.CELLDIR $OUTPUTDIR 2>/dev/null
   
    crs_cid_file=$(ls $OUTPUTDIR/$xdir/outfiles/crs_checkids.out 2>/dev/null)
    cross_node_cid_file=$(ls $OUTPUTDIR/$xdir/outfiles/cross_node_checkids.out 2>/dev/null)

    #-reset values...
    multiple_db=$(grep MULTIPLE_DATABASE $OUTPUTDIR/$xdir/outfiles/check_env.out |awk '{print $3}')  
    multiple_oracle_homes=$(grep MULTIPLE_ORACLE_HOMES $OUTPUTDIR/$xdir/outfiles/check_env.out |awk '{print $3}'|head -1)  
  else
    CELLDIR=$OUTPUTDIR
    crs_cid_file=$(ls $OUTPUTDIR/crs_checkids.out 2>/dev/null)
    cross_node_cid_file=$(ls $OUTPUTDIR/cross_node_checkids.out 2>/dev/null)
  fi

  if [[ -n "$cross_node_cid_file" && -e "$cross_node_cid_file" ]] ; then
    process_cross_node_checks=1
    while read cross_cid
    do
      cross_node_checkids[$cross_node_checkids_counter]=$cross_cid
      cross_node_checkids_counter=$(expr $cross_node_checkids_counter + 1 )
    done < $cross_node_cid_file
  fi

  if [[ -z "$clusterware_check_count" ]] ; then clusterware_check_count=0; fi
  if [[ -n "$crs_cid_file" && -e "$crs_cid_file" ]] ; then
    while read crs_cid
    do
      if [[ $clusterware_check_count -gt "0" ]] ; then
        crs_cid_exists=0
        for cid_in_arr in "${crs_check_id[@]}"
        do
          if [[ $cid_in_arr = $crs_cid ]] ; then crs_cid_exists=1; fi
        done
        if [[ $crs_cid_exists -eq "0" ]] ; then
          crs_check_id[$clusterware_check_count]=$crs_cid
          clusterware_check_count=$(expr $clusterware_check_count + 1)
        fi
      else
        crs_check_id[$clusterware_check_count]=$crs_cid
        clusterware_check_count=$(expr $clusterware_check_count + 1)
      fi
    done < $crs_cid_file
  fi

  crs_stack_counter=$clusterware_check_count
  crs_check_file_counter=0
  while [[ $crs_stack_counter -gt 0 && $SILENT -eq 0 ]]
  do  
    CLUSTERCHECK_FIL=$WRKDIR/.MERGED_COLLECTIONS/${crs_check_id[$crs_check_file_counter]}.out
    if [ $d_index -ne 0 ]; 
    then
      caf=$(ls $OUTPUTDIR/$xdir/outfiles/${crs_check_id[$crs_check_file_counter]}.out 2>/dev/null)
    else
      caf=$(ls $OUTPUTDIR/${crs_check_id[$crs_check_file_counter]}.out 2>/dev/null)
    fi
    if [[ -n "$caf" ]] ; then
      cat $caf >> $CLUSTERCHECK_FIL
      rm -f $caf
    fi
    crs_check_file_counter=$(expr $crs_check_file_counter + 1);
    crs_stack_counter=$(expr $crs_stack_counter - 1)
  done

  dir_run_report;
  if [ $d_index -ne 0 ];
  then
    rm -rf $OUTPUTDIR/$xdir/ 
  fi
}

function dir_run_report ()
{
  cname=`grep LOCALNODE $DUMPDIR/$CHKFIL |awk '{print $3}'`
  cnt=0

  rm -f $OUTPUTDIR/slave_results.out.new 2>/dev/null 
  if [ $d_index -ne 0 ];
  then
    #cat $OUTPUTDIR/$xdir/upload/*_results.xml |grep -v "Results modelVersion=" > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
    grep -v "Results modelVersion=" $OUTPUTDIR/$xdir/upload/*_results.xml > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
    cat $OUTPUTDIR/$xdir/upload/*_results.json > $OUTPUTDIR/${cname}_results.json 2>/dev/null
    cat $OUTPUTDIR/$xdir/upload/patch_summary.html >> $OUTPUTDIR/patch_summary.html 2>/dev/null
    cat $OUTPUTDIR/$xdir/upload/patch_detailed.html >> $OUTPUTDIR/patch_detailed.html 2>/dev/null
    rm -f $OUTPUTDIR/$xdir/upload/patch_summary.html $OUTPUTDIR/$xdir/upload/patch_detailed.html 2>/dev/null

    for file in `ls $OUTPUTDIR/$xdir/outfiles/*_timings.out 2>/dev/null`
    do
      filen=$(basename $file)
      cat $file >> $OUTPUTDIR/$filen
    done
    slave_pattern="$OUTPUTDIR/$xdir/outfiles/slave_results_*"
  else
    slave_pattern="$OUTPUTDIR/slave_results_*"
  fi
    
  printf "  ."
  for file in `ls $slave_pattern 2>/dev/null`
  do
    i=$(basename $file)
    i=$(echo $i|sed 's/slave_results_//g')
    i=$(echo $i|sed 's/\.out//g')

    OSCHECKRESULT=$OUTPUTDIR/o_audit_result_${i}.out
    unset CHECK_ID
    while read line
    do
      printf "."
   
      CHECK_ID=$(echo $line | cut -d"|" -f1)
      ALVL=$(echo $line | cut -d"|" -f2)
      COMTYPE=$(echo $line | cut -d"|" -f3)
      status_on_target=$(echo $line | cut -d"|" -f4)
      db_name_to_check=$(echo $line | cut -d"|" -f5)
      inst_name=$(echo $line | cut -d"|" -f6)
      mb_db_homes=$(echo $line | cut -d"|" -f7)
      message4Home=$(echo $line | cut -d"|" -f8)
      cch_cname=$(echo $line | cut -d"|" -f9)
      sl_hosts=$(echo $line | cut -d"|" -f10)

      storage_id_file=$(grep -i "^storage|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
      switch_id_file=$(grep -i "^switch|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
      if [ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${switch_id_file}.prf` -gt 0 ];
      then
        switchname=$sl_hosts;
      elif [ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${storage_id_file}.prf` -gt 0 ];
      then
	cell_count_cwc=0
	unset a_cellname
	unset a_cellCheckStatus

	if [[ -e $CELLIP && -e $CELLDIR/cells.out ]]
	then
	  for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'`
	  do
	    check_status=0
	    cellipaddr=$cellname

	    cellname=$(cat $CELLDIR/cells.out|grep -w "$cellname"|awk '{print $NF}')
	    if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log ]
	    then
	      is_it_skipped_cell=$(grep -icw $cellipaddr $OUTPUTDIR/${program_name}_skipped_nodes.log)
	    fi

            if [ -z "$sl_hosts" ]
	    then
	      a_cellCheckStatus[$cell_count_cwc]="PASS"
	    else
              if [ `echo "$sl_hosts"|grep -icw "$cellname"` -gt 0 ];
	      then 
	    	a_cellCheckStatus[$cell_count_cwc]=$ALVL
	      else
	    	a_cellCheckStatus[$cell_count_cwc]="PASS"
              fi
	    fi

 	    a_cellname[$cell_count_cwc]=$cellname;
	    cell_count_cwc=$(expr $cell_count_cwc + 1);
	  done
	fi	
      fi

      if [ $d_index -eq 0 ];
      then
        htmlf=$(ls $OUTPUTDIR/$CHECK_ID.html.out 2>/dev/null |tail -1)
      else
        htmlf=$(ls $OUTPUTDIR/$xdir/outfiles/$CHECK_ID.html.out 2>/dev/null |tail -1)
      fi

      for cid_in_arr in "${crs_check_id[@]}"
      do
  	if [[ $cid_in_arr = $CHECK_ID ]] ; then htmlf=""; fi	
      done

      for crosscid_in_arr in "${cross_node_checkids[@]}"
      do
	if [[ $cross_cid_in_arr = $CHECK_ID ]] ; then htmlf=""; fi
      done

      #--exclude duplicates
      if [ `echo "$slave_check_index"|grep -ic "${CHECK_ID}|$sl_hosts;"` -eq 0 ]
      then
	slave_check_index="${slave_check_index};${CHECK_ID}|${sl_hosts};"
      else
	htmlf="";
      fi

      if [ -e "$htmlf" ] ; then
        if [[ -n $RAT_LOAD_CHECK_ATTRIBUTES ]]; then	
	  ORIG_ALVL=$ALVL
	fi
        read_checkid_vars;
	if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
	then
	  maa_id_file=$(grep -i "^maa|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
	  if [[ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${maa_id_file}.prf` -gt 0 ]] || [[ -n "$MERGEFILES" ]]; then
	    create_report_files;
	  else
	    printf "."
	  fi
	elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
	then
	  maa_id_file=$(grep -i "^maa|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
	  if [[ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${maa_id_file}.prf` -gt 0 ]] || [[ -n "$MERGEFILES" ]]; then
	    create_report_files;
	  else
	    printf "."
	  fi
	else
          create_report_files;
        fi
      fi
    done < $file
    cat $file >> $CURRDIR/.MERGED_COLLECTIONS/slave_results.out.merge
  done
  echo -e ""   

  cat $OUTPUTDIR/${cname}_results.xml >> $XMLREPFIL 2>/dev/null
  cat $OUTPUTDIR/${cname}_results.json >> $JSONREPFIL 2>/dev/null

  rm -f $OUTPUTDIR/${cname}_results.xml 2>/dev/null;
  rm -f $OUTPUTDIR/${cname}_results.json 2>/dev/null;
  if [ $d_index -ne 0 ];
  then
    #cat $OUTPUTDIR/$xdir/upload/*_exceptions.xml |grep -v "Exclusions modelVersion" >> $XMLSKIPFIL 2>/dev/null
    grep -v "Exclusions modelVersion" $OUTPUTDIR/$xdir/upload/*_exceptions.xml >> $XMLSKIPFIL 2>/dev/null
    cat $OUTPUTDIR/$xdir/upload/*_exceptions.json >> $JSONSKIPFIL 2>/dev/null
  fi
  if [ -e "$OUTPUTDIR/$xdir/reports/${program_name}.rep" ]
  then
    for file in $OUTPUTDIR/$xdir/reports/*.rep
    do
      fname=$(basename $file)
      cat $file >> $OUTPUTDIR/$fname
    done
  fi

  if [ $d_index -ne 0 ];
  then
    cat $OUTPUTDIR/$xdir/log/*_skipped_checks_runtime.log >> $OUTPUTDIR/${program_name}_skipped_checks_runtime.log 2>/dev/null
    cat $OUTPUTDIR/$xdir/log/*_skipped_checks.log >> $OUTPUTDIR/${program_name}_skipped_checks.log 2>/dev/null
    echo "LOG FROM $xdir" >> $OUTPUTDIR/watchdog.log
    cat $OUTPUTDIR/$xdir/log/watchdog.log >> $OUTPUTDIR/watchdog.log 2>/dev/null
    cat $OUTPUTDIR/$xdir/log/${program_name}.log >> $OUTPUTDIR/${program_name}.log 2>/dev/null
    echo "LOG FROM $xdir" >> $OUTPUTDIR/${program_name}_error.log 
    cat $OUTPUTDIR/$xdir/log/${program_name}_error.log >> $OUTPUTDIR/${program_name}_error.log 2>/dev/null
    cat $OUTPUTDIR/$xdir/log/excluded_check_ids.log >> $OUTPUTDIR/excluded_check_ids.log 2>/dev/null
  fi
}

function run_report ()
{
  i=$cname
  cnt=0
  #echo "checkinmg and removing files from .${program_name}/${program_name}_${FDS}/"
  #cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_results.xml |grep -v "Results modelVersion=" > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
  grep -v "Results modelVersion=" $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_results.xml > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_results.json > $OUTPUTDIR/${cname}_results.json 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_summary.html >> $OUTPUTDIR/patch_summary.html 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_detailed.html >> $OUTPUTDIR/patch_detailed.html 2>/dev/null
  #fix to upload data to databae from remote nodes
  R_OUTPUTDIR=$OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}
  r_upload_raccheck_result_fil_base=$R_OUTPUTDIR/upload_${program_name}_result_base.sql
  r_upload_raccheck_result_fil=$R_OUTPUTDIR/upload_${program_name}_result.sql
  r_upload_raccheck_patch_result_fil=$R_OUTPUTDIR/upload_${program_name}_patch_result.sql
  R_UPDATEFIL=$R_OUTPUTDIR/db_update_$FDS.sql

  if [ -f "$r_upload_raccheck_result_fil_base" ] ; then cat $r_upload_raccheck_result_fil_base >> $upload_raccheck_result_fil_base 2>/dev/null ; fi
  if [ -f "$r_upload_raccheck_result_fil" ] ; then cat $r_upload_raccheck_result_fil >> $upload_raccheck_result_fil 2>/dev/null ; fi
  if [ -f "$r_upload_raccheck_patch_result_fil" ] ; then cat $r_upload_raccheck_patch_result_fil >> $upload_raccheck_patch_result_fil 2>/dev/null; fi
  if [ -f "$R_UPDATEFIL" ] ; then cat $R_UPDATEFIL >> $UPDATEFIL 2>/dev/null; fi
 #fix to upload data to databae from remote nodes ends here

  rm -f $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_summary.html $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_detailed.html 2>/dev/null
  for file in `ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_timings.out 2>/dev/null`
  do
    filen=$(basename $file)
    cat $file >> $OUTPUTDIR/$filen
  done

  #while read line
  #do
  #  if [[ `echo $line | grep -ic CheckID` -gt 0 ]] ; then
  #    CHECK_ID=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #    status_on_target="";
  #  fi
  #  if [[ `echo $line | grep -ic CheckType` -gt 0 ]] ; then
  #    COMTYPE=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #  fi
  #  if [[ `echo $line | grep -ic "<Status>"` -gt 0 ]] ; then
  #    l_chk_status=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #    if [[ $l_chk_status = "PASS" ]] ; then ALVL="PASS"; fi;
  #  fi
  #  if [[ `echo $line | grep -ic "<AlertType>"` -gt 0 ]] ; then
  #    ALVL=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #  fi
  #  if [[ `echo $line | grep -ic "<ColumnValue Name=.InstanceName."` -gt 0 ]] ; then
  #    status_on_target=$(echo $line | cut -d"\"" -f4)
  #  fi
  #  if [[ `echo $line | grep -ic "/[a-zA-Z]*Result>"` -gt 0 ]] ; then
  #    read_checkid_vars;
  #    create_report_files;
  #  fi
  #done  < $OUTPUTDIR/${cname}_results.xml
  if [ -e "$OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/slave_results_${cname}.out" ]
  then 
    while read line
    do
      CHECK_ID=$(echo $line | cut -d"|" -f1)
      ALVL=$(echo $line | cut -d"|" -f2)
      COMTYPE=$(echo $line | cut -d"|" -f3)
      status_on_target=$(echo $line | cut -d"|" -f4)
      db_name_to_check=$(echo $line | cut -d"|" -f5)
      inst_name=$(echo $line | cut -d"|" -f6)
      mb_db_homes=$(echo $line | cut -d"|" -f7)
      message4Home=$(echo $line | cut -d"|" -f8)
      cch_cname=$(echo $line | cut -d"|" -f9)
      sl_hosts=$(echo $line | cut -d"|" -f10)
      htmlf=$(ls $OUTPUTDIR/$i/.${program_name}/${program_name}_${FDS}/$CHECK_ID.html 2>/dev/null |tail -1)
      if [ -e "$htmlf" ] ; then
        if [[ -n $RAT_LOAD_CHECK_ATTRIBUTES ]]; then	
	  ORIG_ALVL=$ALVL
	fi
        read_checkid_vars;
        create_report_files;
      fi
    done < $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/slave_results_${cname}.out
  fi

  cat $OUTPUTDIR/${cname}_results.xml >> $XMLREPFIL 2>/dev/null
  rm -f $OUTPUTDIR/${cname}_results.xml 2>/dev/null
  cat $OUTPUTDIR/${cname}_results.json >> $JSONREPFIL 2>/dev/null
  rm -f $OUTPUTDIR/${cname}_results.json 2>/dev/null
  rm -f $OUTPUTDIR/${cname}_results_file.json 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_exceptions.xml 2>/dev/null |grep -v "Exclusions modelVersion" >> $XMLSKIPFIL 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_exceptions.json >> $JSONSKIPFIL 2>/dev/null
  if [ -e "$OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}.rep" ]
  then
    for file in $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*.rep
    do
      fname=$(basename $file)
      cat $file >> $OUTPUTDIR/$fname
    done
  fi

  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_skipped_checks_runtime.log >> $OUTPUTDIR/${program_name}_skipped_checks_runtime.log 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_skipped_checks.log >> $OUTPUTDIR/${program_name}_skipped_checks.log 2>/dev/null
  echo "LOG FROM $i" >> $OUTPUTDIR/watchdog.log
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/watchdog.log >> $OUTPUTDIR/watchdog.log 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_env.out.diff 2>/dev/null | grep '^> ' | sed 's/^..//' >> $MASTERFIL 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}.log >> $LOGFIL 2>/dev/null
  echo "LOG FROM $i" >> $ERRFIL
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}_error.log >> $ERRFIL 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/excluded_check_ids.log >> $EXCLUDELOG 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/np_exclude_checks.txt >> $TMP_EXCLUDEFIL 2>/dev/null
}

function create_report_files ()
{
  #echo "creating report for  $ALVL $CHECK_ID";
  init_arrays_html "$ALVL"
  write_additional_info $ALVL
  # gadiga for SHS

  skip_count=0
  if [ -n "$MERGEFILES" ]
  then
    if [ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${storage_id_file}.prf` -gt 0 ];
    then
      skip_count=1
    elif [ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${switch_id_file}.prf` -gt 0 ];
    then
      skip_count=0
    fi
  fi
  
  if [ $skip_count -eq 0 ]
  then
    if [[ $ALVL != "PASS" ]] ; then
      case "$ALVL" in
        "FAIL")
           let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
           ;;
        "WARNING")
           let G_WARN_CHECKS=$G_WARN_CHECKS+1
           ;;
        "INFO")
	   if [[ -n "$LOGIC" && "$LOGIC" = "Y" ]]
           then
             let G_INFO_CHECKS_SCORE=$G_INFO_CHECKS_SCORE+1
	   fi
	   let G_INFO_CHECKS=$G_INFO_CHECKS+1
           ;;
        *)
           let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
           ;;
      esac
    fi
    let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
    validate_needs_running;
  fi
  #end code for SHS
}

function read_checkid_vars()
{
  if [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && -n $CHECK_ID ]]; then
    . $INPUTDIR/${CHECK_ID}_load_checks_attributes.sh 2>>$ERRFIL

    export ALVL=$ORIG_ALVL
  else
    PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}`
    HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}`
    ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
    EPFILRES_ROOT_OS=`grep _$CHECK_ID\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
    PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
    NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
    TARGET_TYPE=`grep "_"$CHECK_ID"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'| sed 's/^ *\(.*\) *$/\1/'`
    execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
    check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
    check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
    SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
    check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
    OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
    if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
    COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'`
    if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
    audit_check_name=`grep "_"${CHECK_ID}"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
    #COM=`grep "_"$CHECK_ID"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
    com_begin_pattern="_${CHECK_ID}-OS_COMMAND_START"
    com_end_pattern="_${CHECK_ID}-OS_COMMAND_END"
    COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
  fi
  #assign_execute_once

  if [[ `echo $COM|grep -ic "limits.conf"` -ge 1 || `echo $COM|grep -ic "usrlimit"` -ge 1 ]]; then ulimit_cmd=1;else ulimit_cmd=0;fi

  if [ -n "$MERGEFILES" ]
  then
    if [ $d_index -eq 0 ];
    then
      htmlf=$(ls $OUTPUTDIR/$CHECK_ID.html.out |tail -1)
    else
      htmlf=$(ls $OUTPUTDIR/$xdir/outfiles/$CHECK_ID.html.out |tail -1)
    fi
  else
    htmlf=$(ls $OUTPUTDIR/$i/.${program_name}/${program_name}_${FDS}/$CHECK_ID.html |tail -1)
  fi

  FMSG="$cch_cname"
  PMSG="$cch_cname"
  SOURCEFIL_REPORT=""
  SOURCEFIL_REPORT_NEW=""
  if [ -n "$htmlf" ] ; then
    #grep_for="Status"
    #if [[ `grep -ic "Status on" $htmlf` -gt 1 && -n "$status_on_target" ]] ; then
    #  grep_for="$status_on_target"
    #fi

    #FMSG=$(grep "Status on" $htmlf |grep "$grep_for" |sed 's/.*=> //' | sed 's/<\/p.*//')
    #PMSG=$FMSG
    #ALVL=$(grep "Status on" $htmlf |grep "$grep_for" |tail -1 | sed 's/<\/span> =>.*//' |sed 's/.*span class="status_//' | cut -d">" -f2)
    SOURCEFIL_REPORT=$htmlf
    SOURCEFIL_REPORT_NEW=$htmlf
  else
    echo "#### Did not find html file for $CHECK_ID on $i"
  fi
}

function copy_env_files_to_tmp ()
{
  #localcmdval=$RTEMPDIR/.localcmd.val

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ -n $1 && "$1" = "${root_user}" ]]; then 
    OLD_TMPDIR=$TMPDIR; 
    TMPDIR=$TMP_OUTPUT; 
    COM=$(echo "$COM"|sed 's/\$TMPDIR/\$TMP_OUTPUT/g'|sed 's/\$RTEMPDIR/\$TMP_OUTPUT/g')
    COM_REPORT=$(echo "$COM_REPORT"|sed 's/\$TMPDIR/\$TMP_OUTPUT/g'|sed 's/\$RTEMPDIR/\$TMP_OUTPUT/g')
  elif [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] || [[ -n "$OLD_RAT_ROOT_RUN" && $OLD_RAT_ROOT_RUN -eq "1" ]]; then
    OLD_TMP_OUTPUT=$TMP_OUTPUT 
    TMP_OUTPUT=$RTEMPDIR
  else
    TMP_OUTPUT=$RTEMPDIR
  fi  
 
  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then localcmdval=$TMP_OUTPUT/.localcmd.val; fi
  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ -n $1 && "$1" = "${root_user}" ]]; then localcmdval=$TMP_OUTPUT/.localcmd.val; fi
  localcmdval=$TMP_OUTPUT/.localcmd.val;

  #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`
  #localcmd=$TMPDIR/localcmd.sh
  TRGTORCLENV=$TMP_OUTPUT/`basename $ORCLENVFIL`
  localcmd=$TMP_OUTPUT/localcmd.sh

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ -n $1 && "$1" = "${root_user}" ]]; then rm -f $TRGTORCLENV >/dev/null 2>&1; fi

  if [ $OFFLINE -eq 0 ]
  then
    if [ $i = $localnode ]
    then
      #if [ ! -e "$TRGTORCLENV" ]; then cp -rf $ORCLENVFIL $TMPDIR >/dev/null 2>&1;fi
      #if [ ! -e "$TRGTORCLENV" ]; then cp -rf $ORCLENVFIL $TMP_OUTPUT >/dev/null 2>&1; fi
      cp -rf $ORCLENVFIL $TMP_OUTPUT >/dev/null 2>&1
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] || [[ -n "$OLD_RAT_ROOT_RUN" && $OLD_RAT_ROOT_RUN -eq "1" ]]; then subs_files_to_usr_files "$TRGTORCLENV" "$OLD_TMP_OUTPUT"; fi
      #if [ ! -e "$TMPDIR/raccheck_env.out" ]; then cp -rf $MASTERFIL $TMPDIR >/dev/null 2>&1;fi
      if [ ! -e "$TMP_OUTPUT/raccheck_env.out" ]; then cp -rf $MASTERFIL $TMP_OUTPUT >/dev/null 2>&1;fi
    else
      get_cygpath "ORCLENVFIL"
      get_cygpath "TMPDIR"
      get_cygpath "MASTERFIL"
      remote_trgtenvfile=0
      #remote_trgtenvfile=$($SSHELL $i  "ls -l $TRGTORCLENV 2>/dev/null|wc -l")
      #if [[ $remote_trgtenvfile -le 0 ]]; then $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null 2>&1;fi
      if [[ $remote_trgtenvfile -le 0 ]]; then
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] || [[ -n "$OLD_RAT_ROOT_RUN" && $OLD_RAT_ROOT_RUN -eq "1" ]]; then 
          cp -f $ORCLENVFIL $ORCLENVFIL.bak >/dev/null 2>&1
          subs_files_to_usr_files "$ORCLENVFIL.bak" "$OLD_TMP_OUTPUT"
          #$SCOPY $ORCLENVFIL.bak $i:$TMPDIR/ >/dev/null 2>&1
          $SCOPY $ORCLENVFIL.bak $i:$TMP_OUTPUT/set_orcl_env.sh >/dev/null 2>&1
	  cp -f $ORCLENVFIL.bak $TRGTORCLENV >/dev/null 2>&1
          rm -f $ORCLENVFIL.bak >/dev/null 2>&1
        else
          #$SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null 2>&1
          $SCOPY $ORCLENVFIL $i:$TMP_OUTPUT/ >/dev/null 2>&1
        fi
      fi
      #remote_masterfile=$($SSHELL $i  "ls -l $TMPDIR/raccheck_env.out 2>/dev/null|wc -l")
      #if [[ $remote_masterfile -le 0 ]]; then $SCOPY $MASTERFIL $i:$TMPDIR/ >/dev/null 2>&1;fi
      remote_masterfile=$($SSHELL $i  "ls -l $TMP_OUTPUT/raccheck_env.out 2>/dev/null|wc -l")
      if [[ $remote_masterfile -le 0 ]]; then $SCOPY $MASTERFIL $i:$TMP_OUTPUT/ >/dev/null 2>&1;fi
      restore_cygpath "ORCLENVFIL"
      restore_cygpath "TMPDIR"
      restore_cygpath "MASTERFIL"
    fi
  fi

  if [[ ! -e $TMP_OUTPUT/o_host_list.out ]]; then cp -f $HOSTLIST $TMP_OUTPUT >/dev/null 2>&1; fi
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ -n $1 && "$1" = "${root_user}" ]]; then TMPDIR=$OLD_TMPDIR; fi  
}

# watch all pids running in background and unset array element when not found  
# exit when there are no elements

function wait_for_cell_completion ()
{
  if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;
    for cell_pid in "${cell_pids[@]}"
    do
      # wait till we finish collection running on cell
      if [ `ps -ef | grep _cell |grep -c $cell_pid` -gt 0 ]
      then
        if [[ -n "$cell_type" && $cell_type  = "zfscell" ]] ; then 
	  #if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] ; then
	  #if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ; then 
          printf "."
	  #fi
	fi
        #echo "runing $cell_pid on ${cell_pid_names[$cell_pid]}";
      else
        #echo "Finished run($cell_pid) on ${cell_pid_names[$cell_pid]}";
        cellname=${cell_pid_names[$cell_pid]};
        cell_rootpassword=${cell_root_password[$cell_pid]}
        copy_from_cell;
        cleanup_cell;
        unset cell_pids[$cell_pid]; # remove from array
      fi
    done
    sleep 2
  done
}

function on_signal_cell_cleanup ()
{
  if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;
  for cell_pid in "${cell_pids[@]}"
  do
    kill -9 $cell_pid >/dev/null 2>&1
    cell_rootpassword=${cell_root_password[$cell_pid]}
    cellname=${cell_pid_names[$cell_pid]};
    cleanup_cell;
  done
}

function setup_cell ()
{
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  fixRootPassword "$cell_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $CELLSSCRPT $SCRIPTPATH/.cgrep/$ASREXACHK $SCRIPTPATH/.cgrep/$checkFlashCache $SCRIPTPATH/.cgrep/$validatePassword $cell_ssh_user@$cellname:$CELLTMPDIR
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while copying on $cellname\n";
        exit
      }

    }
IBEOF
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname mkdir ${CELLRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while running mkdir on $cellname\n";
        exit
      }

    }
IBEOF
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname chmod 540 $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache $CELLTMPDIR/$validatePassword
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while chmod on $cellname\n";
        exit
      }

    }
IBEOF
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
}

# TODOS
# Create this as a script so that different passwords are handled. This will work only when password is same on all cells.

function copy_from_cell ()
{
  cellname_short=$(echo $cellname|sed 's/\./_/g')
  CELLDIR_SHORT=$CELLDIR/$cellname_short
  #delete directory in exachk output directory for this cell if it exits 
  if [ -e $CELLDIR_SHORT ]; then rm -rf $CELLDIR_SHORT >/dev/null 2>&1; fi
  mkdir -p $CELLDIR_SHORT
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  fixRootPassword "$cell_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    #set timeout 5
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $cell_ssh_user@$cellname:${CELLRTEMPDIR}/* $CELLDIR_SHORT
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while copying files from $cellname\n";
        exit
      }

    }
IBEOF
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
  then
    cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
    collect_duration "$CELLDIR/c_root_collect_timing.out" "$COLLECT_TIMING"
    rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
  elif [[ -e $CELLDIR_SHORT/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
  then
    cat $CELLDIR_SHORT/c_root_collect_timing.out >> $COLLECT_TIMING
    collect_duration "$CELLDIR_SHORT/c_root_collect_timing.out" "$COLLECT_TIMING"
    rm -f $CELLDIR_SHORT/c_root_collect_timing.out  >/dev/null 2>&1
  fi

  TMP_CELLDIR_SHORT=$RTEMPDIR/.CELLDIR/$cellname_short
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then TMP_CELLDIR_SHORT=$TMP_OUTPUT/.CELLDIR/$cellname_short; fi
  BASE_TMP_CELLDIR_SHORT=$(dirname $TMP_CELLDIR_SHORT);
  mkdir -p ${TMP_CELLDIR_SHORT} >/dev/null 2>&1
  for cfiles in `echo "$cell_files_for_copy"`
  do 
    cp -f $CELLDIR_SHORT/c_cbc_${cfiles}*.out ${TMP_CELLDIR_SHORT} >/dev/null 2>&1 
    cp -f $CELLDIR/c_cbc_${cfiles}*.out $BASE_TMP_CELLDIR_SHORT >/dev/null 2>&1 
  done

  if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
}

function cleanup_cell ()
{
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  fixRootPassword "$cell_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname rm -f ${CELLRTEMPDIR}/SSH_chk_file.sh ${CELLRTEMPDIR}/c_*.out ${CELLRTEMPDIR}/o_*.out $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache $CELLTMPDIR/$validatePassword  ${CELLRTEMPDIR}/*.zip
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while removing files on $cellname\n";
        exit
      }

    }
IBEOF
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname rmdir  ${CELLRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while removing temp dir on $cellname\n";
        exit
      }

    }
IBEOF
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
}

# Start the run in  background
# Put the current pid in cell_pids[pid]=pid

function start_run_on_cell_in_background ()
{
  cleanup_cell;
  setup_cell;
  t_flag="";
  sudo_flag="";
  if [[ -n "$DOROOT" && $DOROOT -eq 1 && -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin" ]] || [[ -n "$RAT_CELL_SSH_USER" && "$RAT_CELL_SSH_USER" = "cellmonitor" ]]
  then
    t_flag="-t";
    sudo_flag="sudo";
  fi
  rm -f $RTEMPDIR/cell.pid
  cr_file=$RTEMPDIR/${program_name}_cell_$cellname.sh
  #cp -f ${CELLSSCRPT} /tmp/${program_name}_cells_$cellname.sh
  security_fix "check_and_fix_script_existence" "$cr_file"
  echo "#!/bin/env bash" > $cr_file
  echo "$RAT_DEBUG_FLG" >>$cr_file
  echo "echo \$\$ > $RTEMPDIR/cell.pid" >> $cr_file
  if [[ $in_last_cell -eq 1 ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]]; then
    echo "$SSHELL $t_flag $cell_ssh_user@$cellname  $sudo_flag \"$CELLTMPDIR/${program_name}_cells.sh\" 2>>$ERRFIL|tee ${RTEMPDIR}/${cellname}.out" >> $cr_file
  else
    echo "$SSHELL $t_flag $cell_ssh_user@$cellname  $sudo_flag \"$CELLTMPDIR/${program_name}_cells.sh\" > ${RTEMPDIR}/${cellname}.out 2>>$ERRFIL" >> $cr_file
  fi
  #chmod +x $cr_file
  security_fix "fix_plugin_or_rtscript_attributes" "$cr_file" "" "540"

  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  is_SSH_blocked "$cellname" "$cell_ssh_user" "$cell_rootpassword" "CELL"
  if [[ $SSH_blocked -eq 1 ]]; then
    echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL
    add_to_skipped_nodes "${cellname}" "SSH Issue: STORAGE SERVER is reachable but SSH is blocked"
    return;
  fi
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  fixRootPassword "$cell_rootpassword"
  $EXPECT -f - 2>>$WATCHLOG << IBEOF &
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn -noecho $cr_file
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
         send -- "yes\n"
       }
      -nocase "*?assword:*" {
	send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
         exit
       }
    }
    # Look for passwd prompt
    set timeout $watchdog_wakeup_root
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "\nTimed out while running collections on $cellname\n";
        exit
      }
    }
IBEOF

  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  #only for execution
  returncode=`echo $?`
  move_failed_to_skipped "$returncode" "$CELLTMPDIR/${program_name}_cells.sh execution"
			

  #sleep 2;
  #cell_pid=$(cat $RTEMPDIR/cell.pid)
  cell_pid=$!
  cell_pids[$cell_pid]="$cell_pid";
  cell_pid_names[$cell_pid]="$cellname"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  cell_root_password[$cell_pid]="$cell_rootpassword"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
}

# functions to run collection on ib switches in background
function start_run_on_ib_in_background ()
{
  cleanup_ib;
  setup_ib;
  rm -f $RTEMPDIR/ib.pid
  cr_file=$RTEMPDIR/${program_name}_run_ibswitch_$switchname.sh
  cp -f $IBSWITCHSCRPT $RTEMPDIR/${program_name}_ibswitch_$switchname.sh
  security_fix "check_and_fix_script_existence" "$cr_file"
  echo "#!/bin/env bash" > $cr_file
  echo "$RAT_DEBUG_FLG" >> $cr_file
  echo "echo \$\$ > $RTEMPDIR/ib.pid" >> $cr_file
  if [[ $in_last_ib -eq 1 ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]]; then
    echo "$SSHELL_EL $ibswitch_user@$switchname  < $RTEMPDIR/${program_name}_ibswitch_$switchname.sh 2>>$ERRFIL |tee ${RTEMPDIR}/${switchname}.out" >> $cr_file
  else
    echo "$SSHELL_EL $ibswitch_user@$switchname  < $RTEMPDIR/${program_name}_ibswitch_$switchname.sh > ${RTEMPDIR}/${switchname}.out 2>>$ERRFIL" >> $cr_file
  fi
  #chmod +x $cr_file
  security_fix "fix_plugin_or_rtscript_attributes" "$cr_file" "" "540"

  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  is_SSH_blocked "$switchname" "$ibswitch_user" "$switch_rootpassword" "SWITCH"
  if [[ $SSH_blocked -eq 1 ]]; then
    echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${RED} ${switchname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL 
    add_to_skipped_nodes "${switchname}" "SSH Issue: INFINIBAND SWITCH is reachable but SSH is blocked"
    return;
  fi   
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  fixRootPassword "$switch_rootpassword"

  $EXPECT -f - 2>>$WATCHLOG << IBEOF &
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn -noecho $cr_file
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
         send -- "yes\n"
       }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
         exit
       }
    }
    # Look for passwd prompt
    set timeout $watchdog_wakeup_root
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "\nTimed out while running collections on $switchname\n";
        exit
      }
    }
IBEOF
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  #only for execution
  returncode=`echo $?`		
  move_failed_to_skipped "$returncode" "$RTEMPDIR/${program_name}_ibswitch_$switchname.sh execution"

  #sleep 2;
  #ib_pid=$(cat $RTEMPDIR/ib.pid)
  ib_pid=$!
  ib_pids[$ib_pid]="$ib_pid";
  ib_pid_names[$ib_pid]="$switchname"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  ib_root_password[$ib_pid]="$switch_rootpassword"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
}

function wait_for_ib_completion ()
{
  if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;
    for ib_pid in "${ib_pids[@]}"
    do
      # wait till we finish collection running on ib switch
      if [ `ps -ef | grep _ibswitch_ |grep -c $ib_pid` -gt 0 ]
      then
        printf ""
      else
        #echo "Finished run on ${ib_pid_names[$ib_pid]}";
        switchname=${ib_pid_names[$ib_pid]};
        switch_rootpassword=${ib_root_password[$ib_pid]}
        copy_from_ib;
        cleanup_ib;
        unset ib_pids[$ib_pid]; # remove from array
      fi
    done
    sleep 2
  done
}

function wait_for_system_completion ()
{
  if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] && [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]]; then return ; fi;

  keep_looping=1
  start_rd=1;
  last_rd=0;
  if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]]; then
    if [[ "$last_ib_name" != "" ]] || [[ "$profiles2run" = "storage" ]] || [[ $no_ib_switch -eq "1" ]]; then
      if [[ "$last_cell_name" != "" ]]; then
      	if [[ -n "$cell_type" && $cell_type  != "zfscell" ]] || [[ -z $cell_type ]] ; then
      	  echo -e "\n"
      	  echo "Collections from STORAGE SERVER:";
      	  echo "----------------------------------";
      	fi
      fi
    fi
  fi
	
  while [ $keep_looping -eq "1" ]
  do
    print_ib=0;
    if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] && [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]]; then print_ib=1; return ; fi;

    if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]]; then
      if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -gt "0" ]] ; then
        for cell_pid in "${cell_pids[@]}"
        do
          if [ `ps -ef | grep _cell |grep -c $cell_pid` -gt 0 ]
          then
            if [[ -n "$cell_type" && $cell_type  = "zfscell" ]] ; then
              if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ;
              then
        	printf "."
              fi
            fi
          else
            cellname=${cell_pid_names[$cell_pid]};
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            cell_rootpassword=${cell_root_password[$cell_pid]}
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            copy_from_cell;
            cleanup_cell;
            unset cell_pids[$cell_pid]; # remove from array
          fi
        done
      fi
    fi
    
    if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]]; then
      if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -gt "0" ]] ; then
        for ib_pid in "${ib_pids[@]}"
        do
          if [ `ps -ef | grep _ibswitch_ |grep -c $ib_pid` -gt 0 ]
          then
            printf ""
          else
            switchname=${ib_pid_names[$ib_pid]};
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            switch_rootpassword=${ib_root_password[$ib_pid]}
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            copy_from_ib;
            cleanup_ib;
            unset ib_pids[$ib_pid]; # remove from array
          fi
        done
      fi
    fi
    
    if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]]; then
      if [[ "$last_ib_name" != "" ]] || [[ "$profiles2run" = "storage" ]] || [[ $no_ib_switch -eq "1" ]]; then
        if [[ "$last_cell_name" != "" ]]; then
          if [[ -n "$cell_type" && $cell_type  != "zfscell" ]] || [[ -z $cell_type ]] ; then
            last_rd=$(cat ${RTEMPDIR}/${last_cell_name}.out|wc -l);
            last_rd=$(echo "$last_rd"|sed 's/[ ]*//g');
            sed -n "$start_rd,${last_rd}p" ${RTEMPDIR}/${last_cell_name}.out; 		
            start_rd=$(expr $last_rd + 1);
          fi
        fi
      fi
    fi
    sleep 2	
  done
}

function on_signal_ib_cleanup ()
{
  if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;

  for ib_pid in "${ib_pids[@]}"
  do
    kill -9 $ib_pid >/dev/null 2>&1
    switchname=${ib_pid_names[$ib_pid]};
    switch_rootpassword=${ib_root_password[$ib_pid]}
    cleanup_ib;
  done
}

function setup_ib ()
{
  ibTmpDirStatus=0
  ibs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?)
  if [ $ibs_ssh_status -eq 0 ]
  then
    ibTmpDirStatus=$($SSHELL $ibswitch_user@$switchname "if [ -e $IBTMPDIR ]; then echo 0;else echo 1;fi") 
  else 
    ibTmpDirStatus=0
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    fixRootPassword "$switch_rootpassword"
    $EXPECT -f - << IBEOF
                                    set timeout $passwordcheck_timeout
                                    set le_switch_rootpassword "$fixedRootPassword"
				    log_user 0
                                    if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                      exp_internal 1
                                    } 
                                    spawn $SSHELL $ibswitch_user@$switchname "ls -ltr $IBTMPDIR"
				    match_max 100000
			       	    expect {
				      -nocase "permission denied *" {
				      exit 4;
			            }
			      	      -nocase "no)?" {
				      send -- "yes\n"
			            }
			              -nocase "*?assword:*" {
				      send -- "\$le_switch_rootpassword\n"
			            }
				      -nocase "*no such file*directory*" {
				      exit 1
				    }
			      	      -nocase eof {
				      exit 0
			            }
			    }
			    expect {
			      -nocase "*?assword:*" {
				send -- "\$le_switch_rootpassword\n"
			      }
			      -nocase eof {
				exit 0
			      } -nocase timeout {
                                send_error "Timed out while checking temp dir existance on $switchname\n";
				exit 2
			      }
				-nocase "*no such file*directory*" {
				  exit 1
			      }
			    }
			    expect -nocase eof
IBEOF
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    ibTmpDirStatus=$(echo $?)
  fi
  #echo "ibTmpDirStatus=$ibTmpDirStatus"
  if [ $ibTmpDirStatus -eq 1 ]
  then
    echo -e "${RED}home directory(\$HOME) for $ibswitch_user user does not exists on $switchname"
    echo -e "${RED}Please set RAT_IB_TMPDIR(eg export RAT_IB_TMPDIR=/home/nm2user) to directory available on $switchname which is accessible to $ibswitch_user ${NORM}\n\n"
    exit 1
  else 
    echo -e "\n$IBTMPDIR is avilable on $switchname\n" >>$LOGFIL
  fi
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $ibswitch_user@$switchname mkdir ${IBRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while creating temp dir on $switchname\n";
        exit
      }

    }
IBEOF

  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${IBRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while creating temp dir on $switchname\n";
        exit
      }

    }
IBEOF
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
}

function copy_from_ib ()
{
  #Following code is to change switch ip address to fully qualified domain name so OS_OUT_CHECK dont get skipped
  is_ibswitch_ip=$(echo $switchname|grep -c '[A-Za-z]')
  if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
  then
    switchname_short=$(echo $switchname|sed 's/\./_/g')
  else
    switchname_short=$(echo $switchname|cut -d. -f1)            
  fi
  switchDirShort=$OUTPUTDIR/$switchname_short
  if [ -e $switchDirShort ]; then rm -rf $switchDirShort >/dev/null 2>&1; fi
  mkdir -p $switchDirShort  
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  fixRootPassword "$switch_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    #set timeout 5
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $ibswitch_user@$switchname:${IBRTEMPDIR}/s_*.out $switchDirShort
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while copying files from $switchname\n";
        exit
      }

    }
IBEOF
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  if [[ -e $OUTPUTDIR/s_root_collect_timing.out && -e $COLLECT_TIMING ]]
  then
    cat $OUTPUTDIR/s_root_collect_timing.out >> $COLLECT_TIMING
    collect_duration "$OUTPUTDIR/s_root_collect_timing.out" "$COLLECT_TIMING"
    rm -f $OUTPUTDIR/s_root_collect_timing.out  >/dev/null 2>&1
  elif [[ -e $switchDirShort/s_root_collect_timing.out && -e $COLLECT_TIMING ]]
  then
    cat $switchDirShort/s_root_collect_timing.out >> $COLLECT_TIMING
    collect_duration "$switchDirShort/s_root_collect_timing.out" "$COLLECT_TIMING"
    rm -f $switchDirShort/s_root_collect_timing.out  >/dev/null 2>&1
  fi

  if [ -e $switchDirShort ]; then format_cell_switch_files "$switchname_short" "$switchDirShort" "switch";fi

}

function cleanup_ib ()
{
  #if [ -e "$TMPDIR/${program_name}_ibswitch_$switchname.sh" ] ; then
  #  rm -f $TMPDIR/${program_name}_ibswitch_$switchname.sh
  #fi

  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  fixRootPassword "$switch_rootpassword"

  $EXPECT -f - 2>>$ERRFIL << IBEOF
  set timeout $passwordcheck_timeout
  set le_switch_rootpassword "$fixedRootPassword"
  log_user 0
  spawn $SSHELL $ibswitch_user@$switchname rm -f ${IBRTEMPDIR}/SSH_chk_file.sh ${IBRTEMPDIR}/s_*.out ${IBRTEMPDIR}/o_*.out ${IBRTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while cleaning files on $switchname\n";
        exit
      }

    }
IBEOF
  $EXPECT -f - 2>>$ERRFIL << IBEOF
  set timeout $passwordcheck_timeout
  set le_switch_rootpassword "$fixedRootPassword"
  log_user 0
  spawn $SSHELL $ibswitch_user@$switchname rmdir ${IBRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while removing temp dir on $switchname\n";
        exit
      }

    }
IBEOF
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
}

#Function to validate root password for exalogic foxtrot
efCheckrootPassword ()
{
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  nodeToCheck=$1
  userToLogin=$2
  userToVerify=$3
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  passwordToCheck=$4
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi

  passwordCheckStatus=1 
  validateUserPassword=3

  while [[ $passwordCheckStatus -ne 0 && $validateUserPassword -ge 1 ]]
  do
    validateUserPassword=$(expr $validateUserPassword - 1 )
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    fixRootPassword "$passwordToCheck"

    CONNECTTIMEOUT=$passwordcheck_timeout
    $EXPECT -f - << IBEOF
        set timeout $CONNECTTIMEOUT
        set le_passwordToCheck "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn -noecho $SSHELL -o NumberOfPasswordPrompts=0 -t -l $userToLogin $nodeToCheck "su - ${userToVerify}"
        match_max 100000
        expect {
          -nocase "no)?" {
              send -- "yes\n"
          }
          -nocase "*?assword:*" {
             send -- "\$le_passwordToCheck\n"
          }
          -nocase "permission denied *" {
             exit 4;
          }
          -nocase timeout {
             exit 0;
          }
          -nocase eof {
             exit 0;
          }
        }
        expect {
          -nocase "*incorrect*" {
             exit 5;
          }
          -nocase "*?assword:*" {
             exit 5;
          }
          -nocase "permission denied *" {
             exit 4;
          }
          -nocase timeout {
             exit 0;
          }
          -nocase eof {
             exit 0;
          }
       }
       expect {
          -nocase default {exit 0}
       }
       exit 0
IBEOF
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    passwordCheckStatus=$(echo $?)     
    if [[ $passwordCheckStatus -ne "0" ]] ; then
      if [[ -n "$validateUserPassword" && $validateUserPassword -eq 0 ]]; then 
        echo -e "\n\n${RED}${userToVerify} password for $nodeToCheck was incorrect.${NORM}"
        echo -e "\n${RED}$userToVerify privileged checks will not be executed on $nodeToCheck ${NORM}\n\n"

	noRootScriptNode[$noRootScriptNodeCount]=$nodeNameToCheck
        noRootScriptNodeCount=$( expr $noRootScriptNodeCount + 1 )
      else
        echo -e "\n\n${RED}${userToVerify} password for $nodeToCheck was incorrect. $validateUserPassword retries remaining.${NORM}\n"
        printf  "Enter $userToVerify password for ${BLINK}${node}${NORM} :- "
        tty -s && stty -echo
        $READ -r passwordToCheck

        printf "\n\nVerifying ${userToCheck} password.\n\n. . ";
      fi
    fi
  done
}

#Function to validate root password
checkUserPassword ()
{
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  validateUserPassword=$4
  nodeNameToCheck=$1
  userToCheck=$2
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  passwordToCheck=$3
 
  fixRootPassword "$passwordToCheck"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
 
  if [ -n "$5" ] 
  then
   targetHostType="$5"
  else
   targetHostType="normal"
  fi
  if [[ -n "$5" && "$5" = "ibswitch" ]]; then hostTypeSwitch=1;else hostTypeSwitch=0;fi
  if [[ -n "$5" && "$5" = "normal" ]]; then hostTypeCell=1;else hostTypeCell=0;fi
  if [[ `uname -s` = "Linux" || $hostTypeCell -eq 1 ]] && [ $hostTypeSwitch -eq 0 ];then loginDelayHost=1;else loginDelayHost=0;fi  
 
  if [[ -n "$RAT_PASSWORDCHECK_TIMEOUT" && $RAT_PASSWORDCHECK_TIMEOUT -gt 1 ]] 
  then 
    passwordcheck_timeout=$RAT_PASSWORDCHECK_TIMEOUT
  else 
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] || [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]]
    then
      passwordcheck_timeout=20
    else
      passwordcheck_timeout=10
    fi
  fi

  #Node is pingable but ssh takes long time...
  CONNECTTIMEOUT=$passwordcheck_timeout
  $EXPECT -f - << IBEOF
            set timeout $CONNECTTIMEOUT
            log_user 0
            if { "$RAT_EXPECT_DEBUG" == "-d" } {
              exp_internal 1
            }
            if { "$targetHostType" == "normal" } {
              spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck "ls >/dev/null 2>&1"
            } else {
              spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck script "ls >/dev/null 2>&1;"
            }
            match_max 100000
            expect {
              -nocase "no)?" {
                  send -- "yes\n"
              }
              -nocase "*?assword:*" {
		 exit 5;
              }
              -nocase "permission denied *" {
                  exit 4;
              }
              -nocase timeout {
                  exit 2;
              }
              -nocase eof {
                  exit 0;
              }
           }
            expect {
              -nocase "*?assword:*" {
           	  exit 5; 
              }
              -nocase "permission denied *" {
                  exit 4;
              }
              -nocase timeout {
                  exit 2;
              }
              -nocase eof {
                  exit 0;
              }
           }
         expect {
                 -nocase default {exit 0}
              }
         exit 0
IBEOF
  tmp_passwordCheckStatus=$(echo $?)
  if [[ $tmp_passwordCheckStatus -eq "2" ]] ; then
    echo -e  "\n\n${RED}Timed out while checking password on ${nodeNameToCheck}.\nSet RAT_PASSWORDCHECK_TIMEOUT to increase timeout. Ex: export RAT_PASSWORDCHECK_TIMEOUT=10\n\n${program_name} is exiting.${NORM}"
    exit 1;
  fi
  tty -s && stty echo
  #...........................................
 
  #tty -s && stty -echo
  #echo "passwordcheck_timeout=$passwordcheck_timeout"
  #if [ $validateUserPassword -gt 1 ]; then  hasDollar=$(echo $passwordToCheck|grep -c "$");if [ $hasDollar -ge 1 ]; then passwordToCheck=$(echo $passwordToCheck|sed 's/\$/\\$/g');fi;fi
 
  #if [[ $targetHostType = "zfscell" ]] ; then passwordcheck_timeout=10; fi
 
  PCSHELL=$(echo $SSHELL|sed 's/ -q//g')
 
  if [[ -n "$PubkeyAuthentication" && "$PubkeyAuthentication" -eq "no" ]];
  then
    PCSHELL=$(echo "$PCSHELL -o PubkeyAuthentication=$PubkeyAuthentication")
  fi
 
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  $EXPECT -f - << IBEOF
                           set timeout $passwordcheck_timeout
			   set le_passwordToCheck "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   if { "$targetHostType" != "zfscell" } {
                             spawn -noecho $PCSHELL $userToCheck@$nodeNameToCheck "echo \"LoginSuccessfull\""
			   } else {
                             spawn -noecho $PCSHELL $userToCheck@$nodeNameToCheck script "printf(\"LoginSuccessfull\\\\n\");"
			   }
                           match_max 100000
                           expect {
                             -nocase "no)?" {
                                 send -- "yes\n"
                                 }
                             -nocase "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             -nocase "permission denied *" {
                                 exit 4;
                                 }
                             LoginSuccessfull { exit 0; }
 			     -nocase timeout {
                                 send_error "Timed out\n";
                                 exit 3
                             }
                             -nocase eof {
                                 exit 0
                                 }
                          }
                           expect {
                             -nocase "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             -nocase "permission denied *" {
                                 exit 4;
                                 }
                             LoginSuccessfull { exit 0; }
 			     -nocase timeout {
                                 send_error "Timed out\n";
                                 exit 3
                             }
                             -nocase eof {
                                 exit 0
                                 }
                          }
                        expect {
                                -nocase default {exit 2}
                                LoginSuccessfull
                               }
                         exit 0
IBEOF
  #tty -s && stty echo
   passwordCheckStatus=$(echo $?)
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  if [[ $passwordCheckStatus -eq "4" ]] ; then
    echo -e "\n\n${RED}Login to ${nodeNameToCheck} as ${userToCheck} is disabled in ssh configuration. Please review ssh configuration and retry ${program_name} run.\n\n${program_name} is exiting.${NORM}\n"
    noRootScriptNode[$noRootScriptNodeCount]=$nodeNameToCheck
    noRootScriptNodeCount=$( expr $noRootScriptNodeCount + 1 )
    exit 1;
  fi

  if [[ $passwordCheckStatus -eq "3" ]] ; then
    passwordCheckStatus=2
    #echo -e  "\n\n${RED}Timed out while checking password on ${nodeNameToCheck}\n. Set RAT_PASSWORDCHECK_TIMEOUT to increase timeout. Ex: export RAT_PASSWORDCHECK_TIMEOUT=10\n\n${program_name} is exiting.${NORM}"
  fi
  if [[ -n "$prepare_init" && $prepare_init -eq "1" ]] && [[ -z "$cell_type" ]]
  then
    if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $loginDelayHost -eq 1 && $passwordCheckStatus -ne 0 && $validateUserPassword -gt 1 ]]
    then
      #echo -e  "\n\n${RED}The password entered for the ${userToCheck} userid did not validate on ${nodeNameToCheck}\n\nThis userid may now be subject to a login delay on the specified node.Please review the pam utility configuration, and allow the specified amount of login delay time to elapse before retrying exachk.Please also check your pam failed login counts for this userid against the permitted total, and clear if required.\n\n${program_name} is exiting.${NORM}"
      echo -e  "\n\n${RED}Either the password entered for the ${userToCheck} userid did not validate on ${nodeNameToCheck} or Login to ${nodeNameToCheck} as ${userToCheck} is disabled in ssh configuration.Please review ssh configuration.\n\nThis userid may now be subject to a login delay on the specified node.Please review the pam utility configuration, and allow the specified amount of login delay time to elapse before retrying exachk.Please also check your pam failed login counts for this userid against the permitted total, and clear if required.\n\n${program_name} is exiting.${NORM}"
      exit 1
    fi
  fi

  while [[ $passwordCheckStatus -ne 0  && $validateUserPassword -gt 1 ]]
   do
     if [[ -n "$PubkeyAuthentication" && "$PubkeyAuthentication" -eq "no" ]];
     then
       OLD_SSHELL="$SSHELL"
       SSHELL=$(echo "$SSHELL -o PubkeyAuthentication=$PubkeyAuthentication")
     fi
 
     validateUserPassword=$(expr $validateUserPassword - 1 )
 
     if [[ $EM_XMLD_MODE -eq 1 ]]
     then
       break;
     fi

     echo -e "\n\n${RED}${userToCheck} password for $nodeNameToCheck was incorrect. $validateUserPassword retries remaining.${NORM}\n"
     printf  "Enter $userToCheck  password for ${BLINK}${nodeNameToCheck}${NORM} :- "
     tty -s && stty -echo
     $READ -r passwordToCheck
     printf "\n\nVerifying ${userToCheck} password.\n\n. . ";
     if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi 
     fixRootPassword "$passwordToCheck"
     if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
 
     #if [ $validateUserPassword -gt 1 ]; then  hasDollar=$(echo $passwordToCheck|grep -c "$");if [ $hasDollar -ge 1 ]; then passwordToCheck=$(echo $passwordToCheck|sed 's/\$/\\$/g');fi;fi
     $EXPECT -f - << IBEOF
                           set timeout $passwordcheck_timeout
			   set le_passwordToCheck "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   if { "$targetHostType" == "normal" } {
                             spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck "echo \"LoginSuccessfull\""
			   } else {
                             spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck script "printf(\"LoginSuccessfull\\\\n\");"
			   }
                           match_max 100000
                           expect {
                             -nocase "no)?" {
                                 send -- "yes\n"
                                 }
                             -nocase "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             LoginSuccessfull { exit 0; }
 			     -nocase timeout {
                                 send_error "Timed out\n";
                                 exit 2
                             }
                             -nocase eof {
                                 exit 0
                                 }
                          }
                           expect {
                             -nocase "*?assword:*" {
				send -- "\$le_passwordToCheck\n"
                                 }
                             LoginSuccessfull { exit 0; }
 			     -nocase timeout {
                                 send_error "Timed out\n";
                                 exit 2
                             }
                             -nocase eof {
                                 exit 0
                                 }
                          }
                        expect {
                                -nocase default {exit 3}
                                LoginSuccessfull
                               }
                         exit 0
IBEOF
    passwordCheckStatus=$(echo $?)

    if [[ -n "$PubkeyAuthentication" && "$PubkeyAuthentication" -eq "no" ]];
    then
      SSHELL="$OLD_SSHELL"
    fi

    if [[ $passwordCheckStatus -eq "2" ]] ; then
      echo -e  "\n\n${RED}Timed out while checking password on ${nodeNameToCheck}.\nSet RAT_PASSWORDCHECK_TIMEOUT to increase timeout. Ex: export RAT_PASSWORDCHECK_TIMEOUT=10\n\n${program_name} is exiting.${NORM}"
      exit 1;
    fi
    tty -s && stty echo
  done

  if [[ $passwordCheckStatus -ne 0 && $4 -gt 1 ]]
  then
    #echo -e "\n\n${RED}${userToCheck} password for $nodeNameToCheck was incorrect. $userToCheck privileged checks will not be executed on $nodeNameToCheck ${NORM}\n"
    echo -e "\n\n${RED}Either ${userToCheck} password for $nodeNameToCheck was incorrect or Login to ${nodeNameToCheck} as ${userToCheck} is disabled in ssh configuration.${NORM}"
    echo -e "\n${RED}$userToCheck privileged checks will not be executed on $nodeNameToCheck ${NORM}\n\n"

    noRootScriptNode[$noRootScriptNodeCount]=$nodeNameToCheck
    noRootScriptNodeCount=$( expr $noRootScriptNodeCount + 1 )
  fi
  #echo "\n noRootScriptNode=${noRootScriptNode[*]}"
  #echo "passwordCheckStatus=$passwordCheckStatus"
}

checkCellSshConfig ()
{
  cell_ssh_counter=0
  for cellip in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
  do
    cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $1 $cellip pwd >/dev/null 2>&1;echo $?);
    if [ $cell_ssh_status -ne 0 ];then a_cellWithNoSsh[$cell_ssh_counter]=$cellip;fi
    cell_ssh_counter=$(expr $cell_ssh_counter + 1 )
  done
  cell_ssh_counter=0
}

show_version ()
{
  get_winpath "REFFIL"
  dataFilesDate=$($GREP FILE_DATE $REFFIL|awk '{print $3}')
  restore_winpath "REFFIL"
  dataFIleMonth=$(echo $dataFilesDate|cut -d- -f2|tr "[a-z]" "[A-Z]")  
  case $dataFIleMonth in
    JAN) dataFIleMonthNo=01;;
    FEB) dataFIleMonthNo=02;;
    MAR) dataFIleMonthNo=03;;
    APR) dataFIleMonthNo=04;;
    MAY) dataFIleMonthNo=05;;
    JUN) dataFIleMonthNo=06;;
    JUL) dataFIleMonthNo=07;;
    AUG) dataFIleMonthNo=08;;
    SEP) dataFIleMonthNo=09;;
    OCT) dataFIleMonthNo=10;;
    NOV) dataFIleMonthNo=11;;
    DEC) dataFIleMonthNo=12;;
    *) dataFIleMonthNo=00;;
  esac
  dataFIleDay=$(echo $dataFilesDate|cut -d- -f1|tr "[a-z]" "[A-Z]")  
  dataFIleYear=$(echo $dataFilesDate|cut -d- -f3|tr "[a-z]" "[A-Z]")  
  #echo -e "\n$program_name  version: 2.1.0.${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}\n"
}
 
# gadiga : create /tmp/.program in all nodes to store temp files
create_rtemp_dir ()
{
  if [[ -n "$1" ]]; then 
    if [[ -e $HOSTLIST ]]; then mv -f $HOSTLIST $HOSTLIST.bak; fi
    echo "$1" > $HOSTLIST
  fi
  node_ssh_user=$usern
  for hname in `cat $HOSTLIST`
  do
    node_ssh_user=$usern
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
    then
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
        node_ssh_user="${root_user}"
      else
        node_ssh_user="${foxtrot_dom0_user}"
      fi
    fi

    if [ $hname != $localnode ]
    then
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$hname "echo \"\$HOME\""); fi
        l_RTEMPDIR=${l_TMPDIR}/.${program_name}
      else
        l_TMPDIR=$TMPDIR
        l_RTEMPDIR=$RTEMPDIR
      fi

      $SSHELL ${node_ssh_user}@${hname} "$bash_scr -c \"if [ -f ${l_RTEMPDIR} ] ; then rm -f ${l_RTEMPDIR}>/dev/null 2>&1; fi; if [ ! -d ${l_RTEMPDIR} ]; then mkdir -p ${l_RTEMPDIR}>/dev/null 2>&1;fi\""
      #$SSHELL ${node_ssh_user}@$hname "$bash_scr -c \"if [ ! -e $l_TMPDIR/o_exadata_disk.out ]; then touch $l_TMPDIR/o_exadata_disk.out;fi\""
      $SSHELL ${node_ssh_user}@$hname "$bash_scr -c \"if [ ! -e $l_RTEMPDIR/o_exadata_disk.out ]; then touch $l_RTEMPDIR/o_exadata_disk.out;fi\""
      remote_script='
         i=0;
	 hname=$(hostname);
         if [ -e "/etc/profile" ] ;
         then
                   pfiles[$i]="/etc/profile";
                   i=$(($i + 1));
         fi;
         bpfile=""
         if [ -e "$HOME/.bash_profile" ] ;
         then
                   pfiles[$i]="$HOME/.bash_profile";
                   bpfile="$HOME/.bash_profile";
                   i=$(($i + 1));
         elif [ -e "$HOME/.bash_login" ] ;
         then
                   pfiles[$i]="$HOME/.bash_login";
                   bpfile="$HOME/.bash_login";
                   i=$(($i + 1));
         elif [ -e "$HOME/.profile" ] ;
         then
                   pfiles[$i]="$HOME/.profile";
                   bpfile="$HOME/.profile";
                   i=$(($i + 1));
         fi
         C_PROMPT=0;
         FFILES="";
	 TRAPS=(0 1 2 3);
         for pfile in ${pfiles[*]}
         do
	   profile_prompt_check=0
	   for ctrap in ${TRAPS[@]}; do
             echo "#!$bash_scr"    		>  ${l_RTEMPDIR}/trap_checker.sh
             echo ". $pfile >/dev/null 2>&1;"   >> ${l_RTEMPDIR}/trap_checker.sh
             echo "echo $ctrap"    		>> ${l_RTEMPDIR}/trap_checker.sh
             echo "exit $ctrap"  		>> ${l_RTEMPDIR}/trap_checker.sh

	     chmod 540 ${l_RTEMPDIR}/trap_checker.sh

             TRAP_VAL=`${l_RTEMPDIR}/trap_checker.sh 2>/dev/null`;
             if [[ -n "$TRAP_VAL" && `echo "$TRAP_VAL"|wc -l` -gt 1 ]]; then
               profile_prompt_check=1
             fi
	     rm -f ${l_RTEMPDIR}/trap_checker.sh >/dev/null 2>&1;
             #if [[ -n "$remote_profile_prompt_check" ]] && [[ $remote_profile_prompt_check -gt 0 || $remote_profile_trap_check -gt 0 || $remote_profile_oraenv_check -gt 0 ]]
	   done
	   if [[ -n "$profile_prompt_check" && $profile_prompt_check -gt 0 ]]; then
             C_PROMPT=1;
             FFILES=$FFILES" "$pfile;
           fi
	   #rm -f ${l_RTEMPDIR}/trap_checker.sh >/dev/null 2>&1;
         done
         if [ $C_PROMPT -eq 1 ];
         then
           echo -e "There are traps in $FFILES on $hname which will cause issue in $program_name successful execution. Please remove trap statements and run again"
         else
           echo "PASS";
         fi
'
      #-----Different shell issue
      if [[ -z $RAT_SKIP_TRAP_VALIDATION ]]; then
        echo "#!$bash_scr" 			>  ${RTEMPDIR}/cprofile.sh
        echo "$RAT_DEBUG_FLG" 			>> ${RTEMPDIR}/cprofile.sh
        echo "export l_RTEMPDIR=$l_RTEMPDIR" 	>> ${RTEMPDIR}/cprofile.sh
        echo "export bash_scr=\"$bash_scr\"" 	>> ${RTEMPDIR}/cprofile.sh
        echo "$remote_script" 			>> ${RTEMPDIR}/cprofile.sh
        #chmod +x ${RTEMPDIR}/cprofile.sh

        $SCOPY ${RTEMPDIR}/cprofile.sh ${node_ssh_user}@$hname:${l_RTEMPDIR} >/dev/null 2>&1

        $($SSHELL -o NumberOfPasswordPrompts=0 ${node_ssh_user}@${hname} "chmod 540 ${l_RTEMPDIR}/cprofile.sh >/dev/null");
        remote_node_profile=$($SSHELL -o NumberOfPasswordPrompts=0 ${node_ssh_user}@${hname} ${l_RTEMPDIR}/cprofile.sh)
        $($SSHELL -o NumberOfPasswordPrompts=0 ${node_ssh_user}@${hname} "rm -f ${l_RTEMPDIR}/cprofile.sh >/dev/null");

        if [[ -z $remote_node_profile || $remote_node_profile = "" ]]
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
            EMSG="SSH issue on $hname node. Please review ssh configuration or set RAT_CLUSTERNODES like RAT_CLUSTERNODES=node1,node2 to skip $hname and retry ${program_name} run."
            update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e $RED"SSH issue on $hname node. Please review ssh configuration or set RAT_CLUSTERNODES like RAT_CLUSTERNODES=node1,node2 to skip $hname and retry ${program_name} run."$NORM;
          echo -e $RED"${program_name} is exiting..."$NORM;
          exit 1;
        fi

        if [ "$remote_node_profile" != "PASS" ];
        then
          if [[ `echo "$remote_node_profile"|grep -wc 'PASS'` -eq 0 ]]
          then
            if [[ $EM_PROBE_MODE -eq 1 ]]
            then
              EMSG="$remote_node_profile"
              update_probe_xml "ERROR" "GENERIC" "$EMSG"
            fi
            echo -e $RED"\n\n$remote_node_profile\n\n"$NORM;
            exit 1;
          fi
        fi
      fi
    else
      if [[ -n "$RAT_SKIP_TRAP_VALIDATION" ]]; then continue; fi
      i=0;
      if [ -e "/etc/profile" ] ;
      then
        pfiles[$i]="/etc/profile";
        i=$(($i + 1));
      fi;
      bpfile=""
      if [ -e "$HOME/.bash_profile" ] ;
      then
        pfiles[$i]="$HOME/.bash_profile";
        bpfile="$HOME/.bash_profile";
        i=$(($i + 1));
      elif [ -e "$HOME/.bash_login" ] ;
      then
        pfiles[$i]="$HOME/.bash_login";
        bpfile="$HOME/.bash_login";
        i=$(($i + 1));
      elif [ -e "$HOME/.profile" ] ;
      then
        pfiles[$i]="$HOME/.profile";
        bpfile="$HOME/.profile";
        i=$(($i + 1));
      fi

      C_PROMPT=0;
      FFILES='';
      TRAPS=(0 1 2 3);
      for pfile in ${pfiles[*]}
      do
        profile_prompt_check=0
        for ctrap in ${TRAPS[@]}; do 
	  echo "#!$bash_scr"			>  ${RTEMPDIR}/trap_checker.sh
          echo ". $pfile >/dev/null 2>&1;" 	>> ${RTEMPDIR}/trap_checker.sh
	  echo "echo $ctrap"			>> ${RTEMPDIR}/trap_checker.sh
	  echo "exit $ctrap"			>> ${RTEMPDIR}/trap_checker.sh	
	
  	  security_fix "fix_plugin_or_rtscript_attributes" "${RTEMPDIR}/trap_checker.sh" "" "540"

  	  TRAP_VAL=`${RTEMPDIR}/trap_checker.sh 2>/dev/null`;
	  if [[ -n "$TRAP_VAL" && `echo "$TRAP_VAL"|wc -l` -gt 1 ]]; then 
	    profile_prompt_check=1
	  fi
  	  security_fix "check_and_fix_script_existence" "${RTEMPDIR}/trap_checker.sh"
	  #rm -f ${RTEMPDIR}/trap_checker.sh >/dev/null 2>&1;
	done
        if [[ -n "$profile_prompt_check" && $profile_prompt_check -gt 0 ]]; then
          C_PROMPT=1;
          FFILES=$FFILES" "$pfile;
        fi
	#rm -f ${RTEMPDIR}/trap_checker.sh >/dev/null 2>&1;
      done

      if [ $C_PROMPT -eq 1 ];
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  EMSG="There are traps in $FFILES on $hname which will cause issue in $program_name successful execution. Please remove or comment all trap statements and run again"	  
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
	fi
        echo -e $RED"\n\nThere are traps in $FFILES on $hname which will cause issue in $program_name successful execution. Please remove or comment all trap statements and run again\n\n"$NORM
        exit 1
      fi
    fi
    #profile trap checking code ends here
  done
  if [[ -n "$1" ]]; then 
    if [[ -e $HOSTLIST.bak ]]; then mv -f $HOSTLIST.bak $HOSTLIST; fi
  fi
  if [ $is_windows -eq "1" ] ; then
    run_windiscovery;
  fi
}

function run_windiscovery ()
{
  for hname in `cat $HOSTLIST`
  do
    if [ $hname != $localnode ] ; then
      get_cygpath "SCRIPTPATH"
      get_cygpath "RTEMPDIR"
      $SCOPY $SCRIPTPATH/.cgrep/readreg.pl $hname:${RTEMPDIR}/readreg.pl >/dev/null 2>$ERRFIL
      $SSHELL $hname "$bash_scr -c \"$perl_exe $RTEMPDIR/readreg.pl $RTEMPDIR\"" >/dev/null 2>$ERRFIL
      $SCOPY $hname:$RTEMPDIR/win_services.out $RTEMPDIR/$hname.win_services.out >/dev/null 2>$ERRFIL
      $SCOPY $hname:$RTEMPDIR/windiscover.out $RTEMPDIR/$hname.windiscover.out >/dev/null 2>$ERRFIL
      restore_cygpath "SCRIPTPATH"
      restore_cygpath "RTEMPDIR"
    fi
  done
}

function get_cygpath
{
  if [ $is_windows -eq "0" ] ; then
    return
  else
    #echo "var : $1";
    cygpath_orig="${1}_cygpath_orig"
    cygpath_ip=\$"$1"
    cygpath_ip_val=`eval echo $cygpath_ip`;
    eval "$cygpath_orig=\"$cygpath_ip_val\""
    #echo "Before : $cygpath_ip_val"

    cygpath_val=$(cygpath `eval echo $cygpath_ip;`)
    eval "$1=\"$cygpath_val\""
    #echo "After : $cygpath_val";
  fi
}

function restore_cygpath
{
  if [ $is_windows -eq "0" ] ; then
    return
  else
    cygpath_orig=\$"${1}_cygpath_orig"
    cygpath_ip=\$"$1"

    cygpath_orig_val=`eval echo $cygpath_orig`;
    eval "$1=\"$cygpath_orig_val\""
    #echo "Restore: $cygpath_orig_val";
  fi
}

function get_winpath
{
  if [ $is_windows -eq "0" ] ; then
    return
  else
    #echo "win var : $1";
    winpath_orig="${1}_winpath_orig"
    winpath_ip=\$"$1"
    winpath_ip_val=`eval echo $winpath_ip`;
    eval "$winpath_orig=\"$winpath_ip_val\""
    #echo "win Before : $winpath_ip_val"

    winpath_val=$(cygpath -w `eval echo $winpath_ip;`)
    eval "$1=\"$winpath_val\""
    #echo "win After : $winpath_val";
  fi
}

function restore_winpath
{
  if [ $is_windows -eq "0" ] ; then
    return
  else
    winpath_orig=\$"${1}_winpath_orig"
    winpath_ip=\$"$1"

    winpath_orig_val=`eval echo $winpath_orig`;
    eval "$1=\"$winpath_orig_val\""
    #echo "Restore: $winpath_orig_val";
  fi
}

create_rtemp_dir_in_cells ()
{
  for cellname in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
  do
    $SSHELL $cell_ssh_user@$cellname " if [ ! -d $RTEMPDIR ]; then mkdir -p $RTEMPDIR>/dev/null 2>&1;fi"
  done
}


# IDM functions
function join_array
{
  joined_str=""
  for arg in $*
  do
    if [ -n "$joined_str" ] ; then
      joined_str="$joined_str.$arg"
    else
      joined_str="$arg"
    fi
  done
}

function xml2kv
{
  kv_file=$1
  kv_outfile=$2
  old_IFS=$IFS
  unset IFS
  while IFS='' read -r -d '<' chunk; do
    IFS='>' read -r tag data <<< "$chunk"
    case "$tag" in
      '?'*) ;;
      '!--'*) ;;
      '![CDATA['*) data="${tag:8:${#tag}-10}" ;;
      ?*'/') ;;
      '/'?*) unset path[${#path[@]}-1] ;;
      ?*) path+=("$tag") ;;
    esac

    if [ -n "$data" ] ; then
      join_array ${path[@]}
      echo "$joined_str = $data" >> $kv_outfile
    fi
  done < $kv_file
  IFS=$old_IFS
}


is_this_oda ()
{
  if [[ $OFFLINE -eq 0 ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]];
  then
    if [ -e /opt/oracle/oak/install/inittab ] 
    then
      oda_machine=1
      oda_machine_type='ODA'
      it_is_rac=0
      ORANGE="\033[35;40m"
      ODA_CONF_FIL='/proc/cmdline'
      if [[ -e $ODA_CONF_FIL ]]; then 
	if [[ `grep -ic "TYPE=X.*_LITE_S" $ODA_CONF_FIL` -gt 0 ]]; then
	  oda_machine_type='ODALITE_S'
	elif [[ `grep -ic "TYPE=X.*_LITE_M" $ODA_CONF_FIL` -gt 0 ]]; then
	  oda_machine_type='ODALITE_M'
	elif [[ `grep -ic "TYPE=X.*_LITE_L" $ODA_CONF_FIL` -gt 0 ]]; then
	  oda_machine_type='ODALITE_L'
	elif [[ `grep -ic "TYPE=X.*_LITE_HA" $ODA_CONF_FIL` -gt 0 ]]; then
	  oda_machine_type='ODALITE_HA'
	fi
      fi
      components=$(echo ${user_components}:$oda_machine_type)
      #changin default timeout for ODA
      if [ -z "$RAT_ROOT_TIMEOUT" ]; then watchdog_wakeup_root=600;echo -e "\nincreasing root collection time out to 600 for ODA\n">>$LOGFIL;fi
      #Added new model to support VM in ODA
      if [[ -n "$VMTYPE" && "$VMTYPE" = "PVM" ]]; then components=$(echo ${user_components}:ODA_VM) ;fi
      #To copy rpm_list.out file from script dir to .cgrep to be used for custom rpm audit check
      if [ -f $SCRIPTPATH/bm_rpm_list.out ]; then cp -f  $SCRIPTPATH/bm_rpm_list.out $SCRIPTPATH/.cgrep;fi
      if [ -f $SCRIPTPATH/vm_rpm_list.out ]; then cp -f  $SCRIPTPATH/vm_rpm_list.out $SCRIPTPATH/.cgrep;fi
      if [ $upgrade_mode -gt 0 ]
      then
        echo -e "${RED}Checking upgrade best practices are not yet supported by ${program_name} for Oracle database appliance${NORM}"
        exit 1
      fi 
      if [ $TYP = "-p" ]
      then
        echo -e "${RED}Patch recommendations are not yet supported by ${program_name} for Oracle database appliance${NORM}"
        exit 1
      fi 
      if [ $upgrade_mode -eq 2 ]
      then
        components=$(echo ${components}:PREUPGR)
      elif [ $upgrade_mode -eq 3 ]
      then
        components=$(echo ${components}:POSTUPGR)
      fi
    else
      oda_machine=0
    fi 
    echo "ORACLE_DATABASE_APPLIANCE = $oda_machine">>$MASTERFIL   
    echo "ORACLE_DATABASE_APPLIANCE_TYPE = $oda_machine_type">>$MASTERFIL   
  else
    TENVFIL=$DUMPDIR/$CHKFIL
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 && $RAT_RUNMODE_INTERNAL != "slave" ]]; then TENVFIL=$MASTERFIL; fi

    oda_machine=$(grep -w "ORACLE_DATABASE_APPLIANCE" $TENVFIL|awk '{print $3}')
    oda_machine_type=$(grep -w "ORACLE_DATABASE_APPLIANCE_TYPE" $TENVFIL|awk '{print $3}')

    if [[ -n "$oda_machine" && $oda_machine -eq 1 ]];then 
      it_is_rac=0; 
      ORANGE="\033[35;40m"; 
    fi
  fi
}

is_this_minicluster ()
{
 if [[ $cgrep_platform = "SunOS" && -x /usr/sbin/svccfg ]]; then
   minicluster_machine=$(/usr/sbin/svccfg -s svc:/system/oes/id:default listprop oes/type 2>/dev/null)
   if [[ $OFFLINE -eq 0 ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
     if [[ -n $minicluster_machine && `echo $minicluster_machine|grep -icw MiniCluster` -eq 1 ]]; then
       is_minicluster=1
       it_is_rac=0
       TYP="-b"
       ORANGE="\033[35;40m"
       components=$(echo ${user_components}:MINICLUSTER:MAA)
     else
       is_minicluster=0
     fi
     echo "MINICLUSTER = $is_minicluster">>$MASTERFIL
   else
     TENVFIL=$DUMPDIR/$CHKFIL
     if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 && $RAT_RUNMODE_INTERNAL != "slave" ]]; then TENVFIL=$MASTERFIL; fi
     is_minicluster=$(grep -w "MINICLUSTER" $TENVFIL|awk '{print $3}')
     if [[ -n "$is_minicluster" && $is_minicluster -eq 1 ]];then
       it_is_rac=0;
       TYP="-b"
       ORANGE="\033[35;40m";
     fi
   fi
else  
   is_minicluster=0
 fi
}


#-- done creating tmp dir
copy_em_xml_files_to_remote_nodes ()
{
  old_IFS=$IFS
  unset IFS
  EMSSHELL=$(echo $SSHELL|sed 's/ -q//g')
  EMSCOPY=$(echo $SCOPY|sed 's/ -q//g')
  if [[ -n "$RAT_OUTPUT" && -n "$RAT_COPY_EM_XML_FILES" && $RAT_COPY_EM_XML_FILES -eq 1 ]]
  then
    for racNodeName in `cat $HOSTLIST`
    do
      BASEXMLREPFIL=$(basename $XMLREPFIL)
      BASEXMLSKIPFIL=$(basename $XMLSKIPFIL) 
      BASEJSONREPFIL=$(basename $JSONREPFIL)
      BASEJSONSKIPFIL=$(basename $JSONSKIPFIL)
      BASEXMLRECFIL=$(basename $XMLRECFIL)
      if [ $racNodeName = $localnode ]
      then
        if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL}_${FDS} >/dev/null 2>&1;fi
        if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}_${FDS} >/dev/null 2>&1;fi
        if [ -e $RAT_OUTPUT/${localnode}_${BASEJSONREPFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEJSONREPFIL} $RAT_OUTPUT/${localnode}_${BASEJSONREPFIL}_${FDS} >/dev/null 2>&1;fi
        if [ -e $RAT_OUTPUT/${localnode}_${BASEJSONSKIPFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEJSONSKIPFIL} $RAT_OUTPUT/${localnode}_${BASEJSONSKIPFIL}_${FDS} >/dev/null 2>&1;fi

        if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL} $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL}_${FDS} >/dev/null 2>&1;fi
        cp -f $XMLREPFIL $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} >/dev/null 2>&1
        cp -f $XMLSKIPFIL $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}  >/dev/null 2>&1
        cp -f $JSONREPFIL $RAT_OUTPUT/${localnode}_${BASEJSONREPFIL} >/dev/null 2>&1
        cp -f $JSONSKIPFIL $RAT_OUTPUT/${localnode}_${BASEJSONSKIPFIL}  >/dev/null 2>&1
        cp -f $XMLRECFIL $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL}  >/dev/null 2>&1
      else
        $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
        $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
        $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEJSONREPFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEJSONREPFIL} $RAT_OUTPUT/${localnode}_${BASEJSONREPFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
        $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEJSONSKIPFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEJSONSKIPFIL} $RAT_OUTPUT/${localnode}_${BASEJSONSKIPFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
        $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL} ];then mv -f $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL} $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
        $EMSSHELL $usern@$racNodeName "ls -l $RAT_OUTPUT >/dev/null 2>&1" >/dev/null 2>&1
        ratOutputExists=$(echo $?)
        if [ $ratOutputExists -eq 0 ]
        then
          $EMSCOPY $XMLREPFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} >/dev/null 2>&1 
          $EMSCOPY $XMLSKIPFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}  >/dev/null 2>&1
	  $EMSCOPY $JSONREPFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEJSONREPFIL} >/dev/null 2>&1 
          $EMSCOPY $JSONSKIPFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEJSONSKIPFIL}  >/dev/null 2>&1
          $EMSCOPY $XMLRECFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEXMLRECFIL}  >/dev/null 2>&1
        else
          echo "$RAT_OUTPUT does not exists on $racNodeName so can not copy $XMLREPFIL and $XMLSKIPFIL" >>$LOGFIL
        fi       
      fi
    done
  else
    echo "RAT_OUTPUT is not set or RAT_COPY_EM_XML_FILES is not set to 1 so can not copy xml files to remote compute nodes" >>$LOGFIL
  fi
  IFS=$old_IFS
}

# Added this function to not to check MAA score card if no database was chosen or no database was running on cluster
check_maa_scorecard ()
{
  if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
  then 
    maa_scorecard=0
  elif [[ -n "$upgrade_mode" && $upgrade_mode -eq 2 ]]
  then
    maa_scorecard=0
  else
    #Not to have MAA scorecard for DBLRA
    if [[ "$is_avm_machine" &&  $is_avm_machine -eq 1 ]]
    then
      maa_scorecard=0
    elif [ ${#mb_db_names[@]} -gt 0 ]
    then
      maa_scorecard=1
    else
      maa_scorecard=0
    fi
  fi  

  if [[ $is_exadata_dom0_machine -eq "1" || $is_ssc_globalzone_machine -eq 1 ]]; then maa_scorecard=1; fi

  #if [ "$TYP" = "-m" ]; then skip_maa_scorecard=1;else skip_maa_scorecard=0;fi  
}

check_hacheck ()
{
  if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
  then 
    include_hacheck=0
  elif [[ -n "$upgrade_mode" && $upgrade_mode -gt 0 ]]
  then
    include_hacheck=0
  else
    if [ ${#mb_db_names[@]} -gt 0 ]
    then
      include_hacheck=1
    else
      include_hacheck=0
    fi
  fi   
  #if [ "$TYP" = "-r" ]; then skip_hacheck=1;else skip_hacheck=0;fi  
}

function check_if_opc ()
{
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] ; then return; fi
  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] ; then return; fi
  if [[ -f "/usr/sbin/imageinfo" ]] ; then return; fi # Exalogic 

  if [[ -f "/etc/nimbula_version" ]] ; then
    is_opc=1
    nimbula_version=$(grep Version: /etc/nimbula_version |awk '{print $2}' |cut -d"-" -f1)
    if [ "$nimbula_version" != "14.1.15" ] ; then nimbula_version="14.1.15"; fi #OPCTODO ideally other versions should be added in RAT
  fi
  if [[ -n "$is_opc" && $is_opc -eq 1 && $usern != "root" ]]
  then
    echo ""
    echo "Only root user can run ${program_name} on Oracle Public Compute nodes. Exiting.";
    echo ""
    exit
  fi

}

###########################################################
# Test if this is an Exalogic compute node
# Returns 1 if it's Exalogic, 0 otherwise
###########################################################

check_if_exalogic()
{
  EMOC_FILE=/usr/lib/init-exalogic-node/.emoc_version
  ELControl_FILE=/usr/lib/init-exalogic-node/.el_control_version
  IMAGE_ID_FILE=/usr/lib/init-exalogic-node/.image_id
  IMAGE_HISTORY_FILE=/var/log/init-exalogic-node/.image_history
  IMAGEINFO=/usr/sbin/imageinfo

  is_exalogic_machine=0
  in_ec_exalogic=0

  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
  then
    return;
  fi

  if [[ -f "$EMOC_FILE" || -f "$ELControl_FILE" ]] ; then
    in_ec_exalogic=1
    is_exalogic_machine=1
  fi

  only_hacheck_run=0
  if [[ $is_exalogic_machine -eq "0" ]] ; then
    check_if_exalogic_physical;
  else
    set_exalogic_env;
  fi

  #if [[ ! -f "exadiscover/exadiscover.sh" && $in_ec_exalogic -eq "1" ]] ; then
  if [[ ! -f "$SCRIPTPATH/exadiscover/exadiscover.sh" && $in_ec_exalogic -eq "1" ]] ; then
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] ; then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="Error: exadiscover does not exists"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "${RED}Error: exadiscover does not exists.. exiting${NORM}";
      exit 1;
    fi
  fi
}

check_if_exalogic_physical()
{
  is_exalogic_machine=1
  if [ $is_exalytics_machine -eq 0 ]; then  RackIdentifier="";fi
  exalogic_version_actual="";
  exalogic_version_cn="";

  # Testing if /usr/lib/init-exalogic-node/.image_id file exists
  if [ ! -f ${IMAGE_ID_FILE} ] ; then
    #echo "ERROR: This is not an Exalogic compute node"
    is_exalogic_machine=0
  fi
  # Testing if /var/log/init-exalogic-node/.image_history file exists
  if [ ! -f ${IMAGE_HISTORY_FILE} ] ; then
    #echo "ERROR: This is not an Exalogic compute node"
    is_exalogic_machine=0
  fi

  dom0_node=0
  if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
  then
    dom0_node=1
  fi

  localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
  if [[ $is_exalogic_machine -eq "1" && $in_ec_exalogic -eq "0" && $dom0_node -eq "1" ]] && [[ -z "$is_exalogic_foxtrot" || -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -ne "1" ]]; then
    printf "$localnode is an Oracle Virtual Server Node. It is recommended to run ${program_name} from Enterprise Controller Node. Do you want to continue running on this node [y|n] [n] :"

    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n28_nlsid">
        {1} is an Oracle Virtual Server Node. It is recommended to run ${program_name} from Enterprise Controller Node
      </text>
      <tokens>
        <token index="1">$localnode</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n12_nlsid">
      Do you want to continue running on this node?
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>	
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
      ans="n"
    elif [[ $EM_XMLD_MODE -eq 1 ]]
    then
      read_probe_xml "Do you want to continue running on this node?"
      ans=$xml_rvalue
    else
      $READ ans;
      read_code=`echo $?`;
      write_in_env "RUN_AVAILABLE_VERSION_OPTION" "$ans"
      process_prompt "$read_code" "ans" "y"

      case "$ans" in 
        Y|y)
          echo "Running ${program_name} on $localnode";;
          #in_ec_exalogic=1;;
        *)
          echo "Exiting.."; exit;;
      esac
    fi
  fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
  then
    set_exalogic_env;
  else
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]]	
    then
      echo -e "${RED}${program_name} is running on non exalogic system. '-vmguest' can only be specified for exalogic systems.${NORM}"
      echo -e "${RED}${program_name} is exiting...  ${NORM}\n";
      exit 1;
    fi
  fi
}

function set_exalogic_env ()
{
  html_rack_type="System"
  it_is_rac=0
  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
    #RackIdentifier=$(grep rack_name $EOUT | cut -d= -f2 | awk '{print $NF}')
    RackIdentifier=""
  else
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -ne "1" || -z "$is_exalogic_foxtrot" ]]; then
      #checking for existance of binary to support solaris because ipmitool does not exists there
      if [ `uname -s` = "Linux" ]; then IPMITOOL="/usr/bin/ipmitool";elif [ `uname -s` = "SunOS" ]; then IPMITOOL="/opt/ipmitool/bin/ipmitool";fi
      if [ -e $IPMITOOL ]; then RackIdentifier=$($IPMITOOL sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}');fi
      #RackIdentifier=$(ipmitool sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}')
    fi
  fi

  elversion_fmsg="";
  if [ -n "$RAT_DB" ]
  then
    exalogic_version_actual=$RAT_DB
  elif [ -e "$IMAGEINFO" ]
  then
    elversion_fmsg="because $IMAGEINFO execution failed";
    exalogic_version_actual=$($IMAGEINFO|grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
  elif [ -e "/usr/lib/init-exalogic-node/.emoc_version" ]
  then
    elversion_fmsg=". Failed to find version from /usr/lib/init-exalogic-node/.emoc_version file. ";
    exalogic_version_actual=$(cat /usr/lib/init-exalogic-node/.emoc_version | cut -d= -f2 | sed "s/'//g")
  elif [ -e "/usr/lib/init-exalogic-node/.el_control_version" ]
  then 
     elversion_fmsg=". Failed to find version from /usr/lib/init-exalogic-node/.el_control_version file. ";
     exalogic_version_actual=$(cat /usr/lib/init-exalogic-node/.el_control_version | cut -d= -f2 | sed "s/'//g") 
  else
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="${program_name} did not find Exalogic version from environment. Please set RAT_DB like RAT_DB=1.0.0.2 and run $program_name again"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "${RED} ${program_name} did not find Exalogic version from environment. Please set RAT_DB like RAT_DB=1.0.0.2 and run $program_name again${NORM}"
    exit 1
  fi

  if [ ! -n "$exalogic_version_actual" ] ; then
    echo -e "${RED} ${program_name} did not find Exalogic version from environment $elversion_fmsg. Please set RAT_DB like RAT_DB=1.0.0.2 and run $program_name again${NORM}"
    exit 1
  fi

  #if [[ -n "$exalogic_version" && $exalogic_version -eq 20100 ]]; then components=$(echo ${components}:EXALOGIC_VM);else components=$(echo ${components}:EXALOGIC);fi 
  exalogic_version=$(echo $exalogic_version_actual |tr -d '.')
  if [ -n "$exalogic_version" ]; then exalogic_version=10020;fi

  if [ $upgrade_mode -gt 0 ]
  then
    echo -e "${RED}Checking upgrade best practices are not supported by ${program_name} for Exalogic${NORM}"
    exit 1
  fi

  if [ $TYP = "-p" ]
  then
    echo -e "${RED}Patch recommendations are not supported by ${program_name} for Exalogic${NORM}"
    exit 1
  fi 

}

node_pingable ()
{
  nodename="$1"
  ping -c 1 $nodename >/dev/null 2>&1
  if [ $? -eq "0" ]
  then
    pingable=1
  else #Not Pingable - Check SSH Speed
    #check_ssh_speed $USER $nodename
    check_ssh_speed $nodename $USER
    if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then
      pingable=0;
    else
      pingable=1
    fi
  fi
}

get_app_user ()
{
  db_name_to_check="$1"
  
  export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
  export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
  if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]
  then
    dbConnectString="${RAT_PDB_USER}/${mb_db_sys_password[$mb_db_counter]}@"${mb_db_connect_string[$mb_db_counter]}" as sysdba"
  else
    DBUSR=${mb_sysdba_user[$mb_db_counter]}
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
    dbConnectString="$DBUSR/$DBPWD as sysdba"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  fi
  
  OUTFILAPP="$OUTPUTDIR/d_app_user_$db_name_to_check.out"
  INFILAPP="${INPUTDIR}/d_app_user_$db_name_to_check.sql"
  ALTSES="${INPUTDIR}/d_alter_session_$db_name_to_check.sql"
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    NEW_OUTFILAPP="$TMP_OUTPUT/d_app_user_$db_name_to_check.out"
    NEW_INFILAPP="${TMP_OUTPUT}/d_app_user_$db_name_to_check.sql"
    NEW_ALTSES="${TMP_OUTPUT}/d_alter_session_$db_name_to_check.sql"
  fi
  
  security_fix "check_and_fix_script_existence" "$ALTSES"
  echo "set serveroutput on" > $ALTSES;

  if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]; then echo "alter session set container=$db_name_to_check;">>$ALTSES;fi

  security_fix "check_and_fix_script_existence" "$INFILAPP"

  echo "declare v_init number:=0; v_appname number:=0; v_ebsver varchar2(100); v_owner varchar2(100); v_parowner varchar2(100); begin 
" > $INFILAPP;

  echo " select count(*) into v_init FROM dba_views where view_name =upper('schema_version_registry') ; 
if v_init > 0  then 
EXECUTE IMMEDIATE 'SELECT count(*) FROM schema_version_registry WHERE comp_name = ''Oracle Identity Manager'' and (VERSION LIKE ''11.1.2.2%'' OR VERSION LIKE ''11.1.2.3%'')' into v_appname; 
end if; 
if v_appname > 0  then 
EXECUTE IMMEDIATE 'SELECT owner FROM schema_version_registry WHERE comp_name = ''Oracle Identity Manager'' and (VERSION LIKE ''11.1.2.2%'' OR VERSION LIKE ''11.1.2.3%'') and rownum=1' into v_owner; 
if v_appname > 1  then
dbms_output.put_line('msg=true');
end if ;
end if ; 
if v_owner is NULL then 
EXECUTE IMMEDIATE 'select count(*) from dba_tab_columns where table_name=''S_APP_VER'' and column_name=''APP_VER''' into v_appname; 
if v_appname > 0 then 
EXECUTE IMMEDIATE 'select owner from dba_tab_columns where table_name=''S_APP_VER'' and column_name=''APP_VER''' into v_owner; 
end if; 
end if; 
if v_owner is NULL then 
select count(*) into v_init FROM dba_tables where table_name = 'FND_ORACLE_USERID'; 
if v_init > 0  then
EXECUTE IMMEDIATE 'select owner from dba_tables where table_name=''FND_ORACLE_USERID''' into v_parowner; 
end if;
if v_parowner IS NOT NULL then 
EXECUTE IMMEDIATE 'SELECT oracle_username FROM '||v_parowner||'.fnd_oracle_userid WHERE read_only_flag = ''U'' AND   install_group_num = 1' into v_owner; 
EXECUTE IMMEDIATE 'select release_name from '||v_owner||'.fnd_product_groups where release_name like ''12%'' and rownum=1' into v_ebsver;
dbms_output.put_line('v_ebsver='||v_ebsver);
end if;  
end if; 
if v_owner is NULL then 
select count(*) into v_init FROM dba_tables where table_name =upper('psdbowner');
if v_init > 0  then
EXECUTE IMMEDIATE 'select count(distinct ownerid) from ps.psdbowner where rownum=1' into v_appname; 
end if;
if v_appname > 0 then 
EXECUTE IMMEDIATE 'select distinct ownerid from ps.psdbowner where rownum=1' into v_owner; 
end if; 
end if;
dbms_output.put_line('owner='||v_owner);
end;
/" >> $INFILAPP;

  if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
  then
    if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner

    	#chg_files_for_usr "NEW_OUTFILAPP" "$NEW_OUTFILAPP"
    	chg_files_for_usr "NEW_OUTFILAPP,NEW_INFILAPP,NEW_ALTSES" "$NEW_OUTFILAPP,$NEW_INFILAPP,$NEW_ALTSES"

        security_fix "check_and_fix_script_existence" "$NEW_INFILAPP"
  	security_fix "check_and_fix_script_existence" "$NEW_ALTSES"

        cp -f $INFILAPP $NEW_INFILAPP
	cp -f $ALTSES $NEW_ALTSES

        chown $dbOwner:$dbGroup $NEW_INFILAPP
	chown $dbOwner:$dbGroup $NEW_ALTSES

        if [ ! -e "$NEW_OUTFILAPP" ]
        then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" as sysdba >/dev/null 2>&1 <<EOF
          set head off
          set lines 80
          set feedback off
          set timing off
	  @@$NEW_ALTSES
          set serveroutput on
          spool $NEW_OUTFILAPP 
          @@$NEW_INFILAPP
          spool off
          exit
EOF
"
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        fi
        if [ -e "$NEW_OUTFILAPP" ]
        then
          RAT_DB_APP_USER=`grep "owner=" $NEW_OUTFILAPP`;
	  APPMSG=`grep "msg=true" $NEW_OUTFILAPP`;
	  EBS_VER=`grep "v_ebsver=" $NEW_OUTFILAPP`;
        fi
    	write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR
      else
        if [ ! -e "$OUTFILAPP" ]
        then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
          set head off
          set lines 80
          set feedback off
          set timing off  
	  @@$ALTSES
          set serveroutput on
          spool $OUTFILAPP 
          @@$INFILAPP
          spool off
          exit
EOF
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        fi
        if [ -e "$OUTFILAPP" ]
        then
          RAT_DB_APP_USER=`grep "owner="  $OUTFILAPP`;
	  APPMSG=`grep "msg=true" $OUTFILAPP`;
	  EBS_VER=`grep "v_ebsver=" $OUTFILAPP`;
        fi
      fi
    else
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner ${mb_running_host[$mb_db_counter]} "1"

        TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out

    	#chg_files_for_usr "TMP_SPOOLFIL" "$TMP_SPOOLFIL"
    	chg_files_for_usr "TMP_SPOOLFIL,NEW_INFILAPP,NEW_ALTSES" "$TMP_SPOOLFIL,$NEW_INFILAPP,$NEW_ALTSES"

        security_fix "check_and_fix_script_existence" "$NEW_INFILAPP"
  	security_fix "check_and_fix_script_existence" "$NEW_ALTSES"

        cp -f $INFILAPP $NEW_INFILAPP
	cp -f $ALTSES $NEW_ALTSES

        get_cygpath "NEW_INFILAPP"
	get_cygpath "NEW_ALTSES"
        $SCOPY $NEW_INFILAPP ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
	$SCOPY $NEW_ALTSES ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorunaltses.sql
        restore_cygpath "NEW_INFILAPP"
	restore_cygpath "NEW_ALTSES"
        $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun.sql"
	$SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorunaltses.sql"
  
        if [ ! -e "$TMP_SPOOLFIL" ]
        then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
          export ORACLE_HOME=$ORACLE_HOME;
          export ORACLE_SID=$ORACLE_SID;
          cd "$dbhome_dir";
          su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
          set head off
          set lines 80
          set feedback off
          set timing off
	  @@$TMP_OUTPUT/sqltorunaltses.sql
          set serveroutput on
          spool $TMP_SPOOLFIL 
          @@$TMP_OUTPUT/sqltorun.sql
          spool off
          exit
EOF
"
EOF2
          REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_OUTPUT/sqltorun.sql>/dev/null 2>&1;echo \\$?;"`
	  security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql" "$REM_RC"
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        fi
        if [ -e "$TMP_SPOOLFIL" ]
        then
          RAT_DB_APP_USER=`grep "owner="  $TMP_SPOOLFIL`;
	  APPMSG=`grep "msg=true" $TMP_SPOOLFIL`;
	  EBS_VER=`grep "v_ebsver=" $TMP_SPOOLFIL`;
        fi
    	write_del_rolbk_tmpoutput
      else
        TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
        get_cygpath "INFILAPP"
	get_cygpath "ALTSES"
        $SCOPY $INFILAPP ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
	$SCOPY $ALTSES ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorunaltses.sql
        restore_cygpath "INFILAPP"
	restore_cygpath "ALTSES"
        if [ ! -e "$TMP_SPOOLFIL" ]
        then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
          export ORACLE_HOME=$ORACLE_HOME;
          export ORACLE_SID=$ORACLE_SID;
          $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
          set head off
          set lines 80
          set feedback off
          set timing off
	  @@$RTEMPDIR/sqltorunaltses.sql
          set serveroutput on
          spool $TMP_SPOOLFIL 
          @@$RTEMPDIR/sqltorun.sql
          spool off
          exit
EOF
EOF2
          REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_OUTPUT/sqltorun.sql>/dev/null 2>&1;echo \\$?;"`
	  security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql" "$REM_RC"
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        fi
        if [ -e "$TMP_SPOOLFIL" ]
        then
          RAT_DB_APP_USER=`grep "owner="  $TMP_SPOOLFIL`;
	  APPMSG=`grep "msg=true" $TMP_SPOOLFIL`;
	  EBS_VER=`grep "v_ebsver=" $TMP_SPOOLFIL`;
        fi
      fi     
    fi
  else
    if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner

    	#chg_files_for_usr "NEW_OUTFILAPP" "$NEW_OUTFILAPP"
    	chg_files_for_usr "NEW_OUTFILAPP,NEW_INFILAPP,NEW_ALTSES" "$NEW_OUTFILAPP,$NEW_INFILAPP,$NEW_ALTSES"
  
        security_fix "check_and_fix_script_existence" "$NEW_INFILAPP"
  	security_fix "check_and_fix_script_existence" "$NEW_ALTSES"

        cp -f $INFILAPP $NEW_INFILAPP
	cp -f $ALTSES $NEW_ALTSES

        chown $dbOwner:$dbGroup $NEW_INFILAPP
	chown $dbOwner:$dbGroup $NEW_ALTSES
        if [ ! -e "$NEW_OUTFILAPP" ]
        then
          #$READ -p "before asm collection"
          su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
          set head off
          set lines 80
          set feedback off
          set timing off
	  @@$NEW_ALTSES
          set serveroutput on
          spool $NEW_OUTFILAPP 
          @@$NEW_INFILAPP
          spool off
          exit
EOF
"
        fi
        if [ -e "$NEW_OUTFILAPP" ]
        then
          RAT_DB_APP_USER=`grep "owner="  $NEW_OUTFILAPP`;
	  APPMSG=`grep "msg=true" $NEW_OUTFILAPP`;
	  EBS_VER=`grep "v_ebsver=" $NEW_OUTFILAPP`;
        fi
    	write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR
      else
        if [ ! -e "$OUTFILAPP" ]
        then
          $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
          set head off
          set lines 80
          set feedback off
          set timing off
	  @@$ALTSES
          set serveroutput on
          spool $OUTFILAPP 
          @@$INFILAPP
          spool off
          exit
EOF
	fi
	if [ -e "$OUTFILAPP" ]
        then
	  RAT_DB_APP_USER=`grep "owner="  $OUTFILAPP`;
	  APPMSG=`grep "msg=true" $OUTFILAPP`;
	  EBS_VER=`grep "v_ebsver=" $OUTFILAPP`;
	fi
      fi
    else
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner ${mb_running_host[$mb_db_counter]} "1"

        TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out

    	#chg_files_for_usr "TMP_SPOOLFIL" "$TMP_SPOOLFIL"
    	chg_files_for_usr "TMP_SPOOLFIL,NEW_INFILAPP,NEW_ALTSES" "$TMP_SPOOLFIL,$NEW_INFILAPP,$NEW_ALTSES"

        security_fix "check_and_fix_script_existence" "$NEW_INFILAPP"
  	security_fix "check_and_fix_script_existence" "$NEW_ALTSES"

        $SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_OUTPUT >/dev/null 2>&1; mkdir -p $TMP_OUTPUT >/dev/null 2>&1;"

        cp -f $INFILAPP $NEW_INFILAPP
        cp -f $ALTSES $NEW_ALTSES
        get_cygpath "NEW_INFILAPP"
        get_cygpath "NEW_ALTSES"
        $SCOPY $NEW_INFILAPP ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql
        $SCOPY $NEW_ALTSES ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorunaltses.sql
        restore_cygpath "NEW_INFILAPP"
        restore_cygpath "NEW_ALTSES"
        $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun.sql"
        $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorunaltses.sql"
        if [ ! -e "$TMP_SPOOLFIL" ]
        then
          $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
          export ORACLE_HOME=$ORACLE_HOME;
          export ORACLE_SID=$ORACLE_SID;
          cd "$dbhome_dir";
          su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
          set head off
          set lines 80
          set feedback off
          set timing off
          @@$TMP_OUTPUT/sqltorunaltses.sql
          set serveroutput on
          spool $TMP_SPOOLFIL
          @@$TMP_OUTPUT/sqltorun.sql
          spool off
          exit
EOF
"
EOF2
          REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_OUTPUT/sqltorun.sql>/dev/null 2>&1;echo \\$?;"`
	  security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql" "$REM_RC"
        fi
        if [ -e "$TMP_SPOOLFIL" ]
        then
	  RAT_DB_APP_USER=`grep "owner="  $TMP_SPOOLFIL`;
	  APPMSG=`grep "msg=true" $TMP_SPOOLFIL`;
	  EBS_VER=`grep "v_ebsver=" $TMP_SPOOLFIL`;
        fi
    	write_del_rolbk_tmpoutput
      else
        TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
        get_cygpath "INFILAPP"
	get_cygpath "ALTSES"
        $SCOPY $INFILAPP ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
	$SCOPY $ALTSES ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorunaltses.sql
        restore_cygpath "INFILAPP"
	restore_cygpath "ALTSES"
        if [ ! -e "$TMP_SPOOLFIL" ]
        then
          $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
          export ORACLE_HOME=$ORACLE_HOME;
          export ORACLE_SID=$ORACLE_SID;
          $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
          set head off
          set lines 80
          set feedback off
          set timing off
	  @@$RTEMPDIR/sqltorunaltses.sql
          set serveroutput on
          spool $TMP_SPOOLFIL
          @@$RTEMPDIR/sqltorun.sql
          spool off
          exit
EOF
EOF2
          REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_OUTPUT/sqltorun.sql>/dev/null 2>&1;echo \\$?;"`
	  security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql" "$REM_RC"
	fi
	if [ -e "$TMP_SPOOLFIL" ]
        then
	  RAT_DB_APP_USER=`grep "owner="  $TMP_SPOOLFIL`;
	  APPMSG=`grep "msg=true" $TMP_SPOOLFIL`;
	  EBS_VER=`grep "v_ebsver=" $TMP_SPOOLFIL`;
	fi
      fi
    fi
  fi
  security_fix "check_and_fix_script_existence" "$NEW_INFILAPP"
  security_fix "check_and_fix_script_existence" "$NEW_ALTSES"

  RAT_DB_APP_USER=$(echo "$RAT_DB_APP_USER"|sed 's/owner=//g'|sed 's/^\s*//g'|sed 's/\s*$//g'|sed 's/ //g');
  APPMSG=$(echo "$APPMSG"|sed 's/^\s*//g'|sed 's/\s*$//g'|sed 's/ //g');
  EBS_VER=$(echo "$EBS_VER"|sed 's/v_ebsver=//g'|sed 's/^\s*//g'|sed 's/\s*$//g'|sed 's/ //g');
  
  if [ -z "$RAT_DB_APP_USER" ]	
  then
    RAT_DB_APP_USER="apps";
  fi

  if [[ `echo "$APPMSG" | grep -c "msg=true"` -gt 0 ]]
  then
	echo -e "${RED}Multiple IDM schemas found on ${db_name_to_check}. User $RAT_DB_APP_USER has been picked.\nPlease set RAT_DB_APP_USER variable to override this value.\n${NORM}"	
	echo -e "\nMultiple IDM schemas found on ${db_name_to_check}. User $RAT_DB_APP_USER has been picked.\nPlease set RAT_DB_APP_USER variable to override this value.\n" >> $LOGFIL
  fi

  mb_database_app_user[$mb_db_counter]=$RAT_DB_APP_USER;
  echo "${db_name_to_check}.DATABASE_APP_USER = $RAT_DB_APP_USER" >>$MASTERFIL
  RAT_DB_APP_USER="apps"; 
}

add_to_swlist_file ()
{
  if [[ $el_node_ping -eq "0" || $switch_version_valid -lt 1 ]]
  then
    echo
    echo "Failed to ping switch or Entered IP is not a valid gateway switch"
  else
    echo "${n_prefix}" >> $swlist_file
  fi
}

get_ip_from_user ()
{
  u_msg=$1
  unset n_prefix

  if [[ $EM_XMLD_MODE -eq 1 ]]
  then
    if [[ `echo "$u_msg" | grep -c "second"` -gt 0 ]]
    then
      read_probe_xml "Enter IP address for second gateway infiniband switch"
    elif [[ `echo "$u_msg" | grep -c "third"` -gt 0 ]]
    then
      read_probe_xml "Enter IP address for third gateway infiniband switch"
    elif [[ `echo "$u_msg" | grep -c "fourth"` -gt 0 ]]
    then
      read_probe_xml "Enter IP address for fourth gateway infiniband switch"
    fi
    n_prefix=$xml_rvalue
  else
    el_done=0
    while [ $el_done -lt 3 ] 
    do
      el_done=$(expr $el_done + 1)
      exec 3<&2; exec 2<&0
      $READ -p "$u_msg" n_prefix
      exec 2<&3
      #$READ -p "Enter the $USER password for the above gateway infiniband switch : " n_passwd
      #exec 2<&3
      test_node_reachability;
      #if [ $el_node_ping -eq "1" ] ; then break; fi;
      if [ $el_node_ping -eq "1" ] ; then
        if [ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
          echo -e "\n"
          printf  "Enter the $USER password for the above gateway infiniband switch :- "
          tty -s && stty -echo
          $READ -r n_passwd
          tty -s && stty echo
          echo
          echo

          isSwitch ${n_prefix} ${n_passwd}
          if [ $switch_version_valid -ge 1 ]
          then
            break
          else
            echo "Entered IP is not a valid gateway switch"
          fi
        fi
      fi
    done
  fi
}

isSwitch()
{
	switchipval=$1
        userpasswd=$2 
	
              switch_version=$($EXPECT -f - << IBEOF
                                    set timeout $passwordcheck_timeout
                                    set le_zfs_password "$userpasswd"
                                    spawn -noecho $SSHELL $USER@$switchipval "version"
                                    match_max 100000
                                    expect {
                                      -nocase "permission denied *" {
                                      exit 4;
                                    }
                                      -nocase "no)?" {
                                      send -- "yes\n"
                                    }
                                      -nocase "*?assword:*" {
                                      send -- "\$le_zfs_password\n"
                                    }
                                      -nocase eof {
                                      exit
                                    }
                                    }
                                    # Look for passwd prompt
                                    expect {
                                      -nocase "*?assword:*" {
                                        send -- "\$le_zfs_password\n"
                                      }
                                      # Stop the on logon tests and if asked to connect to master switch choose no
                                      -nocase eof {
                                        exit
                                      } -nocase timeout {
                                        send_error "Timed out while running version command on $switchipval\n";
                                        exit
                                      }
                                    }
                                    expect -nocase eof
IBEOF
)
              switch_version_valid=$(echo "$switch_version"|grep -wc "DCS gw")

}

test_node_reachability ()
{
  #Calling Format: test_node_reachability ["hostname"] ["usern"] ["hostip"] ["hosttype"] 
  nodename=$1;
  tuser=$2;
  nodename_ip=$3; 
  host_type=$4;

  el_node_ping=0
  platform=`uname -s`
  tnr_note=""

  if [[ -z $nodename ]]; then nodename="${n_prefix}"; fi
  if [[ -z $tuser ]]; then tuser="$USER"; fi
  if [[ -z $host_type ]]; then host_type="Node"; fi

  PING_W_FLAG=""
  if [ $is_windows -eq "1" ] ; then
    PING=$(which ping| tr -d '\r')
    if [[ -z $PING ]]; then PING="/bin/ping"; fi
  else
    if [ $platform = "Linux" ]
    then
      PING="/bin/ping"
      PING_W_FLAG="-w 5"
    else
      PING="/usr/sbin/ping"
    fi
  fi

  #First Validation: Pingable or not
  #-------------------------------------------------------
  if [ $platform = "SunOS" ]; then
    $PING -s $nodename 5 5 >/dev/null 2>&1
  elif [ $platform = "HP-UX" ]; then
    $PING $nodename -n 5 -m 5 >/dev/null 2>&1
  elif [ $is_windows -eq "1" ] ; then
    $PING -n 5 $nodename >/dev/null 2>&1
  else
    $PING -c 1 $PING_W_FLAG $nodename >/dev/null 2>&1
  fi
  #ping -c 1 $nodename >/dev/null 2>&1
  if [ $? -eq "0" ]; then 
    el_node_ping=1; 
  else
    tnr_log=`$PING -c 1 $PING_W_FLAG $nodename 2>&1 | tr -d '\r'`
    tnr_log=`echo -e "$tnr_log \n ${host_type} ${nodename} is not reachable so its being skipped from checking best practicing."`
 
    tnr_note="Node is not reachable"
  fi

  #Second Validation: SSH speed 
  #-------------------------------------------------------
  check_ssh_speed "$nodename" "$tuser"
  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then
    if [[ $el_node_ping -eq "1" ]]; then
      tnr_log="${host_type} ${nodename} is reachable but ssh takes too long."
      tnr_note="Network latency issue: ${host_type} is reachable but ssh takes too long"
    fi
    el_node_ssh=0
    echo -e $RED"\nError: Host $nodename is not reachable.\n"$NORM;
  else
    el_node_ssh=1
  fi

  #Third Validation: DNS Configured or not
  #-------------------------------------------------------
  if [[ $el_node_ssh -eq "1" ]]; then 
    isDNSconfigured "$nodename" "$tuser"
    if [[ $DNSconfigured -eq 0 ]]; then 
      if [[ $el_node_ping -eq 0 ]]; then
        tnr_log="${host_type} ${nodename} Error: Either host is not reachable or DNS issue: failure in name resolution"
        tnr_note="Error: Either host $nodename is not reachable or DNS issue: failure in name resolution"

        echo "Error: Either host $nodename is not reachable or DNS issue: failure in name resolution"
      else
        tnr_log="${host_type} ${nodename} : failure in name resolution"
        tnr_note="DNS issue: failure in name resolution"

        echo "Error: DNS issue: failure in name resolution"
      fi
      el_node_dns=0; 
      el_node_ping=0;
    else
      el_node_dns=1;
      el_node_ping=1;
    fi
  else
    el_node_dns=0;
    el_node_ping=0;
  fi

  #Fourth Validation: SSH breaks because of Login user profile(s)
  #-------------------------------------------------------
  #if [[ $el_node_ping -eq "1" ]]; then
  #  is_SSH_blocked "$nodename" "$tuser" "$testnode_password"
  #  if [[ $SSH_blocked -ne 0 ]]; then 
  #    el_node_ping=0; 

  #    tnr_log="${host_type} ${nodename} is reachable but SSH is blocked."
  #    tnr_note="SSH Issue: ${host_type} ${nodename} is reachable but SSH is blocked"

  #    echo "${host_type} ${nodename} is reachable but SSH is blocked so its being skipped from checking best practicing."
  #  fi
  #fi

  if [[ -n $nodename_ip && $el_node_ping -eq "0" ]]; then 
    nodename="$nodename_ip"
    test_node_reachability  "$nodename" "$tuser" "" "$host_type"
    if [[ "$host_type" = 'Infiniband switch'  && $el_node_ping -eq "1" ]]; then switchname=$nodename; fi
  else
    if [ -e $LOGFIL ]; then echo "$tnr_log" >> $LOGFIL; fi
  fi
}

#Commented old way to decide either its physical or logical Rack and coverted it to function which will be called for each remote node to support hybrid rack
assign_exalogic_module ()
{
  if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]]
  then
    el_prefix="";
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$1"` -le 0 ]]; then
        if [[ `echo "$ea_grillvm_nodes" | grep -c "$1"` -ge 1 ]]; then
	  el_prefix="foxtrot_grillvm"
        elif [[ `echo "$ea_dbvm_nodes" | grep -ic "$1"` -ge 1 ]]; then
          el_prefix="foxtrot_dbvm"
        elif [[ `echo "$ea_psmvm_nodes" | grep -ic "$1"` -ge 1 ]]; then
          el_prefix="foxtrot_psmvm"
        elif [[ `echo "$ea_simvm_nodes" | grep -ic "$1"` -ge 1 ]]; then
          el_prefix="foxtrot_simvm"
        elif [[ `echo "$ea_sdivm_nodes" | grep -ic "$1"` -ge 1 ]]; then
          el_prefix="foxtrot_sdivm"
        elif [[ `echo "$ea_extvm_nodes" | grep -ic "$1"` -ge 1 ]]; then
          el_prefix="foxtrot_extvm"
        elif [[ `echo "$ea_intvm_nodes" | grep -ic "$1"` -ge 1 ]]; then
          el_prefix="foxtrot_intvm"
        elif [[ `echo "$ea_icsvm_nodes" | grep -ic "$1"` -ge 1 ]]; then
          el_prefix="foxtrot_icsvm"
        elif [[ `echo "$ea_mcsvm_nodes" | grep -ic "$1"` -ge 1 ]]; then
          el_prefix="foxtrot_mcsvm"
        else
          el_prefix="FOXTROT_CTRLVM"
        fi
      else
        if [[ -z "$el_prefix" ]]; then
	  el_prefix="FOXTROT_DOM0"
        else
          el_prefix="FOXTROT_DOM0:"$el_prefix
        fi
      fi
      components=$el_prefix

      echo "$1.COMPONENT = $components">>$MASTERFIL
      return
    else
      if [[ "$1" = "$ea_db_node" ]]; then 
        el_prefix="_DB"; 
      fi
      if [[ "$1" = "$ea_ec1_node" ]]; then 
        if [[ -z "$el_prefix" ]]; then 
       	  el_prefix="_EC"
        else
          el_prefix="_EC:EXALOGIC"$el_prefix
        fi
      fi
      if [[ "$1" = "$ea_ovmm_node" ]]; then 
        if [[ -z "$el_prefix" ]]; then 
          el_prefix="_OVMM"
        else
          el_prefix="_OVMM:EXALOGIC"$el_prefix
        fi
      fi
      if [[ "$1" = "$ea_pc1_node" ]] || [[ "$1" = "$ea_pc2_node" ]] ; then 
        if [[ -z "$el_prefix" ]]; then 
          el_prefix="_PC"
        else
          el_prefix="_PC:EXALOGIC"$el_prefix
        fi
      fi 
    fi

    #case $1 in
    #  $ea_db_node)
    #    el_prefix="_DB";;
    #  $ea_ec1_node)
    #    el_prefix="_EC";;
    #  $ea_ovmm_node)
    #    el_prefix="_OVMM";;
    #  "$ea_pc1_node"|"$ea_pc2_node")
    #    el_prefix="_PC";;
    #  *)
    #    el_prefix="";;
    #esac
    if [[ -n "$el_prefix" ]] ; then
      if [ `echo $components|grep -c ":"` -eq 0 ]
      then
        components=$(echo ${components}:EXALOGIC$el_prefix)
      else
        components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
        components=$(echo ${components}EXALOGIC$el_prefix)  
      fi
    else
      if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" && -z "$exalogic_version_actual_cn" ]] ; then
        if [[  $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
          exalogic_version_actual_cn=$(/usr/sbin/imageinfo 2>/dev/null |grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
        else
          exalogic_version_actual_cn=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $1 "/usr/sbin/imageinfo 2>/dev/null |grep -iw \"image version\"|cut -d':' -f2|cut -d' ' -f2")
        fi

        echo "EXALOGIC_ACTUAL_VERSION_CN = $exalogic_version_actual_cn" >>$MASTERFIL
      fi
      if [[  $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
        remote_node_component_check=$(ls -ld /proc/xen >/dev/null 2>&1;echo $?)
      else
        remote_node_component_check=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $1 "ls -ld /proc/xen" >/dev/null 2>&1;echo $?)
      fi
      if [ $remote_node_component_check -eq 0 ]
      then
        if [ `echo $components|grep -c ":"` -eq 0 ]
        then
          components=$(echo ${components}:EXALOGIC_VM)
        else
          components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
          components=$(echo ${components}EXALOGIC_VM)  
        fi
      else
        if [ `echo $components|grep -c ":"` -eq 0 ]
        then
          components=$(echo ${components}:EXALOGIC)
        else
          components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
          components=$(echo ${components}EXALOGIC)  
        fi
      fi
    fi

    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
    then
      components="NONE:EXALOGIC_GUEST"
    fi
    components=$(echo "$components"|sed 's/:RACCHECK//g');

    echo "$1.COMPONENT = $components">>$MASTERFIL
  else
    components=$(grep "$i.COMPONENT" $DUMPDIR/$CHKFIL |awk '{print $3}') 
  fi 
  #if [[ -n "$exalogic_version" && $exalogic_version -eq 20100 ]]; then components=$(echo ${components}:EXALOGIC_VM);else components=$(echo ${components}:EXALOGIC);fi 
}

generate_exalogic_node_info_from_exadiscover ()
{
  # More info about exadiscover here
  # https://stbeehive.oracle.com/teamcollab/wiki/Exalogic+Health+Check:Exacheck%27s+Integration+with+ExaDiscover
  # https://stbeehive.oracle.com/teamcollab/wiki/Exalogic+Diagnostics:ExaDiscover
  if [ -n "$RAT_EL_GVM" ]
  then
    echo "IS_EXALOGIC_GUEST_VM = $is_exalogic_guest_vm" >> $MASTERFIL
  else
    echo "IS_EXALOGIC_GUEST_VM = 0" >> $MASTERFIL
  fi	

  EOUT=$WRKDIR/exadiscover.out
  EAOUT=$WRKDIR/exachk_exalogic.conf

  from_exadiscover=1
  #if [[ ! -f "$EOUT" ]] ; then
    #sh exadiscover/exadiscover.sh -f shell | grep rack_ > $EAOUT
  #fi

  if [[ ! -f "$EAOUT" ]] ; then
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	#under -oracle_compute option, using exaware to get conf file. 
	discover -f shellvars >> $EAOUT
    else
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" ]]; then
    	  sh -x $SCRIPTPATH/exadiscover/exadiscover.sh -f shell | grep rack_ > $EAOUT
    	  sh -x $SCRIPTPATH/exadiscover/exadiscover.sh -f shell -a >> $EAOUT
	else
    	  sh $SCRIPTPATH/exadiscover/exadiscover.sh -f shell | grep rack_ > $EAOUT
    	  sh $SCRIPTPATH/exadiscover/exadiscover.sh -f shell -a >> $EAOUT
	fi
    fi
    cp -f $EAOUT $WRKDIR/.cgrep/
  else
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] ; then
      echo "Using cached file $EAOUT ...."
    fi
  fi
  
  if [[ -e "$EAOUT" ]] ; then
    cp -f $EAOUT $OUTPUTDIR 2>/dev/null
  fi

  # Get the racktype
  if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] ; then
	rtype=$(grep rack_*_size $EAOUT | cut -d= -f2)
  else
  	rtype=$(grep rack_size $EAOUT | cut -d= -f2)
  fi
  case "$rtype" in 
    "Full")
      exalogic_rack=3;;
    "Half")
      exalogic_rack=2;;
    "Quarter")
      exalogic_rack=1;;
    "Eighth")
      exalogic_rack=0;;
    *)
      exalogic_rack=3;;
  esac
  RackIdentifier=$(grep "rack_id_01=" $EAOUT | cut -d= -f2 | head -1|awk '{print $NF}')

  ea_need_vm=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_cvm_only -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    ea_need_vm=0
  fi

  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    #multiple DOM0s
    echo '' > $WRKDIR/o_host_list.out
    ea_dom0_nodes=$(grep "c_nodes_.*_hostnames*" $EAOUT | grep -v "ilom" | cut -d= -f2) 
    for ea_dom0_node in `echo "$ea_dom0_nodes"`
    do
      echo "$ea_dom0_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done
    sed 1d $WRKDIR/o_host_list.out > $WRKDIR/o_host_list.out.2
    mv -f $WRKDIR/o_host_list.out.2 $WRKDIR/o_host_list.out 

    #RackIdentifier information retrieved from DOM0
    dom0_rackid=`echo "$ea_dom0_nodes" | head -1`
    #RackId_output=$(/usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no $foxtrot_dom0_user@$dom0_rackid "sudo /usr/bin/ipmitool sunoem cli force 'show /SP system_identifier' | grep 'system_identifier'" 2>&1)
    RackId_output=$($SSHELL $foxtrot_dom0_user@$dom0_rackid "sudo /usr/bin/ipmitool sunoem cli force 'show /SP system_identifier' | grep 'system_identifier'" 2>&1)
    RackIdentifier=$(echo -e "$RackId_output" | tail -1 | awk '{print $NF}')
 
    #multiple priviledged control VMs
    ea_ec_nodes=$(grep "controlvm[0-9]_Eth-admin=" $EAOUT  | cut -d= -f2)

    #exclude localnode priviledged control VM Eth-admin IP, use localnode hostname instead
    local_ec_node=$(hostname -s)
    local_controlvm=$(grep $local_ec_node $EAOUT | awk -F "_" '{print $5}')
    local_controlvm_ip=$(grep "${local_controlvm}_Eth-admin=" $EAOUT  | cut -d= -f2)
    ea_ec_nodes=$(echo -e "$ea_ec_nodes" | grep -v $local_controlvm_ip)
    ea_ec_nodes=$(echo -e "$ea_ec_nodes\n`hostname`")
    for ea_ec_node in `echo "$ea_ec_nodes"`
    do
      echo "$ea_ec_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    #multiple unpriviledged control VMs
     
    #DB VM
    ea_dbvm_nodes=$(grep "control_vm_dbvm[0-9]_IPoIB-virt-admin=" $EAOUT  | cut -d= -f2)
    for ea_dbvm_node in `echo "$ea_dbvm_nodes"`
    do
      echo "$ea_dbvm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    #GRILL VM
    ea_grillvm_nodes=$(grep "control_vm_grillvm[0-9]_IPoIB-virt-admin=" $EAOUT  | cut -d= -f2)
    for ea_grillvm_node in `echo "$ea_grillvm_nodes"`
    do
      echo "$ea_grillvm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    #PSM VM
    ea_psmvm_nodes=$(grep "control_vm_psmvm[0-9]_IPoIB-virt-admin=" $EAOUT  | cut -d= -f2)
    for ea_psmvm_node in `echo "$ea_psmvm_nodes"`
    do
      echo "$ea_psmvm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    #SIM VM
    ea_simvm_nodes=$(grep "control_vm_simvm[0-9]_IPoIB-virt-admin=" $EAOUT  | cut -d= -f2)
    for ea_simvm_node in `echo "$ea_simvm_nodes"`
    do
      echo "$ea_simvm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    #SDI VM
    ea_sdivm_nodes=$(grep "control_vm_sdivm[0-9]_IPoIB-virt-admin=" $EAOUT  | cut -d= -f2)
    for ea_sdivm_node in `echo "$ea_sdivm_nodes"`
    do
      echo "$ea_sdivm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    #routing external VM
    ea_extvm_nodes=$(grep "control_vm_routing_externalvm[0-9]_IPoIB-virt-admin=" $EAOUT  | cut -d= -f2)
    for ea_extvm_node in `echo "$ea_extvm_nodes"`
    do
      echo "$ea_extvm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    #routing internal VM
    ea_intvm_nodes=$(grep "control_vm_routing_internalvm[0-9]_IPoIB-virt-admin=" $EAOUT  | cut -d= -f2)
    for ea_intvm_node in `echo "$ea_intvm_nodes"`
    do
      echo "$ea_intvm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done
 
    #ics mgmt vm
    ea_icsvm_nodes=$(grep "control_vm_ics_mgmtvm[0-9]_IPoIB-virt-admin=" $EAOUT | cut -d= -f2)
    for ea_icsvm_node in `echo "$ea_icsvm_nodes"`
    do
      echo "$ea_icsvm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    #mcs mgmt vm
    ea_mcsvm_nodes=$(grep "control_vm_mcs_mgmtvm[0-9]_IPoIB-virt-admin=" $EAOUT | cut -d= -f2)
    for ea_mcsvm_node in `echo "$ea_mcsvm_nodes"`
    do
      echo "$ea_mcsvm_node" | tr -d '\r' >> $WRKDIR/o_host_list.out
    done

    echo "IS_EXALOGIC_FOXTROT_MACHINE = $is_exalogic_foxtrot" >> $MASTERFIL
    echo "FOXTROT_DOM0_USER = $foxtrot_dom0_user" >> $MASTERFIL
    echo FOXTROT_DOM0_NODES = $ea_dom0_nodes >> $MASTERFIL
    echo FOXTROT_DBVM_NODES = $ea_dbvm_nodes >> $MASTERFIL
    echo FOXTROT_GRILLVM_NODES = $ea_grillvm_nodes >> $MASTERFIL
    echo FOXTROT_PSMVM_NODES = $ea_psmvm_nodes >> $MASTERFIL
    echo FOXTROT_SIMVM_NODES = $ea_simvm_nodes >> $MASTERFIL
    echo FOXTROT_SDIVM_NODES = $ea_sdivm_nodes >> $MASTERFIL
    echo FOXTROT_EXTVM_NODES = $ea_extvm_nodes >> $MASTERFIL
    echo FOXTROT_INTVM_NODES = $ea_intvm_nodes >> $MASTERFIL
    echo FOXTROT_ICSVM_NODES = $ea_icsvm_nodes >> $MASTERFIL
    echo FOXTROT_MCSVM_NODES = $ea_mcsvm_nodes >> $MASTERFIL
  fi

  if [[ $ea_need_vm -eq "1" ]] && [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -ne "1" || -z "$is_exalogic_foxtrot" ]]; then
    grep "c_nodes_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 > $WRKDIR/o_host_list.out
  fi

  ea_db_node=$(grep "db_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  if [[ -n "$ea_db_node" ]]; then echo "$ea_db_node" >> $WRKDIR/o_host_list.out; fi

  if [[ -z "$is_exalogic_foxtrot" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -ne "1" ]]; then
    ea_ec1_node=$(grep "ec_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
    ea_ec1_node=$localnode
    echo "$ea_ec1_node" >> $WRKDIR/o_host_list.out
  fi

  ea_ovmm_node=$(grep "ovmm_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  if [[ -n "$ea_ovmm_node" ]]; then echo $ea_ovmm_node >> $WRKDIR/o_host_list.out; fi

  ea_pc1_node=$(grep "pc_01_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  if [[ -n "$ea_pc1_node" ]] ; then echo $ea_pc1_node >> $WRKDIR/o_host_list.out; fi

  ea_pc2_node=$(grep "pc_02_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  if [[ -n "$ea_pc2_node" ]] ; then echo $ea_pc2_node >> $WRKDIR/o_host_list.out; fi

  if [[ -z $ea_db_node ]];
  then
    ea_db_node=$(grep "db_ip_01" $EAOUT  | cut -d= -f2 | head -1)
    if [[ "$ea_db_node" = "127.0.0.1" ]];
    then
      ea_db_node=$ea_ec1_node
      echo "$ea_db_node" >> $WRKDIR/o_host_list.out
    fi
  fi

  rack_id=$(grep "rack_id_01=" $EAOUT  | cut -d= -f2 | head -1)


  if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
  then
    rm -f $WRKDIR/o_storage.out
    rm -f $WRKDIR/o_external_storage.out
    rm -f $WRKDIR/o_ibswitches.out

    echo "IS_EXALOGIC_MACHINE = $is_exalogic_machine" >> $MASTERFIL
    echo "IS_EXALOGIC_EC_MACHINE = $in_ec_exalogic" >> $MASTERFIL
    echo "EXALOGIC_VERSION = $exalogic_version" >> $MASTERFIL
    echo "EXALOGIC_ACTUAL_VERSION = $exalogic_version_actual" >> $MASTERFIL
    echo "EXALOGIC_RACK = $exalogic_rack" >> $MASTERFIL
    echo "EXALOGIC_RACK_IDENTIFIER = $RackIdentifier" >> $MASTERFIL
    return;
  fi
  
  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    ea_sn_nodes=$(grep "sn_nodes_[0-9][0-9]_Eth-admin=" $EAOUT | cut -d= -f2 | sed 's/,/\n/g' |sort -u)
    ea_extsn_nodes=$(grep "sn_ext_nodes_[0-9][0-9]_[0-9][0-9]_Eth-admin=" $EAOUT | cut -d= -f2 | sed 's/,/\n/g' |sort -u)
    ea_switch_nodes=$(grep "ib_switch_[0-9][0-9]_Eth-admin=" $EAOUT | cut -d= -f2 |sort -u)
    spineswitchip=$(grep "ib_switch_spine_[0-9][0-9]_Eth-admin=" $EAOUT | cut -d= -f2 |head -1)
  else
    ea_sn_nodes=$(grep "sn_nodes_[0-9]*.*-eth-admin=" $EAOUT | cut -d= -f2 | sed 's/,/\n/g' |sort -u)
    ea_switch_nodes=$(grep "ib_switch_[0-9]*_.*-eth-admin" $EAOUT | cut -d= -f2 |sort -u)
    spineswitchip=$(grep "ib_switch_spine_[0-9]*_.*-eth-admin" $EAOUT | cut -d= -f2 |head -1)
  fi

  #grep "sn_nodes_[0-9]*.*-eth-admin=" $EAOUT | cut -d= -f2 | sed 's/,/\n/g' |sort -u> $WRKDIR/o_storage.out
  rm -f $WRKDIR/o_storage.out
  
  for snip in `echo "$ea_sn_nodes"`
  do
    sname=$(nslookup $snip |grep -w name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$sname" ]] ; then
      sname="$snip";
    fi
    echo "$sname" | tr -d '\r' >> $WRKDIR/o_storage.out
  done

  rm -f $WRKDIR/o_external_storage.out
  for snip in `echo -e "$ea_extsn_nodes"`
  do
    sname=$(nslookup $snip |grep -w name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$sname" ]] ; then
      sname="$snip";
    fi
    echo "$sname" | tr -d '\r' >> $WRKDIR/o_external_storage.out
  done

  rm -f $WRKDIR/o_ibswitches.out
  for switchip in `echo "$ea_switch_nodes"`
  do
    switchname=$(nslookup $switchip|grep -w name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$switchname" ]] ; then
      switchname=$switchip
    fi
    echo "$switchname" | tr -d '\r' >> $WRKDIR/o_ibswitches.out
  done

  #generate spine switch for virtual exalogic
  rm -f $WRKDIR/o_spineswitches.out >/dev/null 2>&1;
  if [[ -n $spineswitchip ]]; then 
    spineswitchname=$(nslookup $spineswitchip|grep -w name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$spineswitchname" ]] ; then spineswitchname=$spineswitchip; fi
  
    test_node_reachability "$spineswitchname"
    if [ $el_node_ping -eq "1" ] ; then echo ""; else spineswitchname=""; fi
    echo "$spineswitchname" > $WRKDIR/o_spineswitches.out >/dev/null 2>&1;
    cp -f $WRKDIR/o_spineswitches.out $OUTPUTDIR >/dev/null 2>&1;
    echo "$spineswitchname" | tr -d '\r' >> $WRKDIR/o_ibswitches.out
  fi
}

generate_exalogic_node_info()
{
  #assign_exalogic_module
  if [ $OFFLINE -eq "0" ]
  then
    from_exadiscover=0
    if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      generate_exalogic_node_info_from_exadiscover;
    else
      el_cfile="/usr/lib/init-exalogic-node/exalogic_machine.conf"
      if [ -z "$RAT_ELRACKTYPE" ] ;  # 3=FULL, 2=HALF, 1=QUARTER 0=1/8
      then 
        if [ -r "$el_cfile" ]
        then
          exalogic_rack=$(grep "RACK_TYPE=" $el_cfile | cut -d"=" -f2)
        fi
        if [ -z "$exalogic_rack" ]
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="Unable to determine rack type. Please set RAT_ELRACKTYPE and try again"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo "Unable to determine rack type. Please set RAT_ELRACKTYPE and try again"
          exit 1;
        fi
      else 
        exalogic_rack="$RAT_ELRACKTYPE";
      fi;
    fi;

    cnlist_file="$OUTPUTDIR/o_host_list.out"
    snlist_file="$OUTPUTDIR/o_storage.out"
    extsnlist_file="$OUTPUTDIR/o_external_storage.out"
    swlist_file="$OUTPUTDIR/o_ibswitches.out"
    spine_swlist_file="$OUTPUTDIR/o_spineswitches.out"
    HOSTLIST=$cnlist_file
    EAOUT=$WRKDIR/exachk_exalogic.conf

    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
    then
      return;
    fi
    #To generate list of compute nodes
    if [ -n "$RAT_CLUSTERNODES" ]  # First check for env
    then
      rm -f $HOSTLIST
      for nodename in `echo $RAT_CLUSTERNODES`
      do
        echo $nodename>>$cnlist_file
      done
    elif [[ -r "$WRKDIR/o_host_list.out" && -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] || [[  -r "$WRKDIR/o_host_list.out" && -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]
    then # Use cached nodes list from previous run
      if [[ $from_exadiscover -eq "0" ]] ; then
        echo -e "Using cached file $WRKDIR/o_host_list.out for nodes list ....\n\n";
      fi
      cp -f $WRKDIR/o_host_list.out $cnlist_file
    elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
    then # Read the conf file
      rm -f $cnlist_file $snlist_file $swlist_file $extsnlist_file
      generate_exalogic_node_info_from_conf;
    else
      # Compute nodes
      case $exalogic_rack in
      3) #FULL
        cn_cnt=30
        sw_cnt=4
        EXALOGIC_RACK=FULL
        ;;
      2) #HALF
        cn_cnt=16
        sw_cnt=2
        EXALOGIC_RACK=HALF
        ;;
      1) #QUARTER
        cn_cnt=8
        sw_cnt=2
        EXALOGIC_RACK=QUARTER
        ;;
      0) #1/8 rack
        cn_cnt=4
        sw_cnt=2
        EXALOGIC_RACK="1/8"
        ;;
      *)
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
	  EMSG="Invalid value for RACK '$exalogic_rack'"
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
        echo "Invalid value for RACK '$exalogic_rack'";
        exit 1;
        ;;
      esac

      n_prefix=$(hostname|cut -d. -f1|sed 's/[0-9][0-9]$//');
      n_cnt=0;
      while [[ $n_cnt -lt $cn_cnt ]]
      do
        n_cnt=$(expr $n_cnt + 1);
        nodename=$(printf "${n_prefix}%02d" $n_cnt);
        echo "$nodename" >> $cnlist_file
      done
    fi

    if [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]]
    then
      #To generate spine switch for physical
      #if [[ ! -z "$phy_nodes" ]]; then
      if [[ -z "$in_ec_exalogic" ]] || [[ -n "$in_ec_exalogic" && $in_ec_exalogic -ne "1" ]] ; then
        if [ -r "$WRKDIR/o_spineswitches.out" ]; then
	  echo -e "Using cached file $WRKDIR/o_spineswitches.out for spine infiniband switches list....\n\n";
          spineswitchip=$(cat $WRKDIR/o_spineswitches.out);
          spineswitchip=$(echo "$spineswitchip"|sed 's/ //g');
        else
	  if [[ -n $is_exalogic_foxtrot && $is_exalogic_foxtrot -ne "1" ]]; then 
  	    $READ -p "Enter IP address for spine infiniband switch : " spineswitchip
	  fi
        fi
	if [[ -n "$spineswitchip" || $spineswitchip != "" ]]; then	
	  is_IP "$spineswitchip"
	  if [[ $is_IPADDRESS -eq "1" ]]; then 
	    spineswitchname=$(nslookup $spineswitchip|grep -w name|awk '{print $NF}'|sed 's/.$//')
	    if [[ -z "$spineswitchname" ]] ; then spineswitchname=$spineswitchip; fi
	  else 
	    spineswitchname="$spineswitchip"
	  fi
	  test_node_reachability "$spineswitchname"
	  if [ $el_node_ping -eq "1" ] ; then echo ""; else spineswitchname=""; fi
	fi
        echo "$spineswitchname" > $WRKDIR/o_spineswitches.out;
        cp -f $WRKDIR/o_spineswitches.out $OUTPUTDIR;
        #echo "$spineswitchname" >> $WRKDIR/o_ibswitches.out
      fi

      #To generate list of infinband switchces to test
      if [ -n "$RAT_IBSWITCHES" ]
      then
        for switchname in `echo $RAT_IBSWITCHES`
        do
          echo "$switchname">>$swlist_file
        done
      elif [ -r "$WRKDIR/o_ibswitches.out" ]
      then # Use cached nodes list from previous run
        if [[ $from_exadiscover -eq "0" ]] ; then
          echo -e "Using cached file $WRKDIR/o_ibswitches.out for gateway infiniband switches list....\n\n";
        fi
        cp -f $WRKDIR/o_ibswitches.out $swlist_file
      elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
      then # Read the conf file
        rm -f  $swlist_file 
        generate_exalogic_node_info_from_conf;
      else
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then		
	  cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n29_nlsid">
        Could not find InfiniBand gateway switch names from env or configuration file 
      </text>
    </context>
    <text nls_id="orhc_exadata_n13_nlsid">
      Indicate your selection from one of these options 
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
        <text nls_id="orhc_exadata_n14_nlsid">Switch Name</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n15_nlsid">Switch IP address</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n30_nlsid">
      Enter the first InfiniBand gateway switch name 
    </text>
  </question>
EOF
	  if [ $exalogic_rack -eq 3 ] ; then
	    cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <text nls_id="orhc_exadata_n87_nlsid">Enter valid InfiniBand gateway switch IP addresses</text>
    <multipart-question>
      <question id="q${PROBE_QUES_CNT}o2q1q1" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n31_nlsid">
          Enter IP address for first InfiniBand gateway switch 
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q2" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n32_nlsid">
          Enter IP address for second InfiniBand gateway switch
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q3" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n33_nlsid">
          Enter IP address for third gateway infiniband switch
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q4" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n34_nlsid">
          Enter IP address for fourth InfiniBand gateway switch
        </text>
      </question>
    </multipart-question>
  </question>
EOF
	  else
	    cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <text nls_id="orhc_exadata_n87_nlsid">Enter valid InfiniBand gateway switch IP addresses</text>
    <multipart-question>
      <question id="q${PROBE_QUES_CNT}o2q1q1" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n31_nlsid">
          Enter IP address for first gateway infiniband switch
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q2" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n32_nlsid">
          Enter IP address for second gateway infiniband switch
        </text>
      </question>
    </multipart-question>
  </question>
</group>
EOF
	  fi

	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	  echo -e "Could not find infiniband gateway switch names from env or configuration file.Please enter the first gateway infiniband switch name : "
	elif [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  echo -e "Could not find infiniband gateway switch names from env or configuration file.Please enter the first gateway infiniband switch name : "

          read_probe_xml "Could not find InfiniBand gateway switch names from env or configuration file"
          if [[ $xml_rvalue = "Switch Name" ]] || [[ $xml_rvalue -eq 1 ]]
          then
            read_probe_xml "Enter the first InfiniBand gateway switch name"
          elif [[ $xml_rvalue = "Switch IP address" ]] || [[ $xml_rvalue -eq 2 ]]
          then
            read_probe_xml "Enter IP address for first InfiniBand gateway switch"
          fi
          n_prefix=$xml_rvalue

          test_node_reachability;
	else
          unset n_prefix
          el_done=0
          while [ $el_done -lt 3 ] 
          do
            el_done=$(expr $el_done + 1)
            exec 3<&2; exec 2<&0
            $READ -p "Could not find infiniband gateway switch names from env or configuration file.Please enter the first gateway infiniband switch name : " n_prefix
            exec 2<&3
            test_node_reachability;
            if [ $el_node_ping -eq "1" ] ; then 
              if [ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
	        echo -e "\n"
	        printf  "Enter the $USER password for the above gateway infiniband switch :- "
	        tty -s && stty -echo
	        $READ -r n_passwd
	        tty -s && stty echo
	        echo
	        echo

                isSwitch ${n_prefix} ${n_passwd}
                if [ $switch_version_valid -ge 1 ]
                then
                  echo "${n_prefix}" > $swlist_file
                  break
                else
                  echo "Entered IP is not a valid gateway switch"
                fi
	      else
	      	break;
              fi  
            fi
          done
	fi

        if [[ $el_node_ping -eq "0"  ]] || [[ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" && $switch_version_valid -lt 1 ]]
        then
          echo "Failed to get infiniband gateway switch names. Skipping infiniband gateway switches.";
          touch $swlist_file
        else
          if [ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
            # User entered IP address. ask second cell ip address too.

            if [ $exalogic_rack -eq 3 ] ; then # 4 switches
              get_ip_from_user "Enter IP address for second gateway infiniband switch : "
              add_to_swlist_file ${n_prefix}
              get_ip_from_user "Enter IP address for third gateway infiniband switch : "
              add_to_swlist_file ${n_prefix}
              get_ip_from_user "Enter IP address for fourth gateway infiniband switch : "
              add_to_swlist_file ${n_prefix}
            else # 2 switches
              get_ip_from_user "Enter IP address for second gateway infiniband switch : "
              add_to_swlist_file ${n_prefix}
            fi
            echo
          else
      	    n_prefix_sub=$(echo $n_prefix|sed s/.$//);  
      	    n_prefix_sub=$(echo $n_prefix_sub|sed s/.$//);  
      	    n_suffix=$(echo $n_prefix|sed 's/^.*\(..\)$/\1/');
      	    n_suffix_counter=0
      	    if [ $exalogic_rack -eq 3 ]
      	    then 
      	      while [ $n_suffix_counter -lt 4 ]
      	      do 
      	        if [ $n_suffix_counter -eq 0 ]
      	        then
      	          echo "${n_prefix_sub}${n_suffix}" >> $swlist_file
      	          n_suffix=$( expr $n_suffix + 1 ) 
      	          n_suffix_counter=$( expr $n_suffix_counter + 1 ) 
      	        else
      	          echo "${n_prefix_sub}0${n_suffix}" >> $swlist_file
      	          n_suffix=$( expr $n_suffix + 1 ) 
      	          n_suffix_counter=$( expr $n_suffix_counter + 1 ) 
      	        fi
      	      done
      	    else
      	      while [ $n_suffix_counter -lt 2 ]
      	      do 
      	        if [ $n_suffix_counter -eq 0 ]
      	        then
      	          echo "${n_prefix_sub}${n_suffix}" >> $swlist_file
      	          n_suffix=$( expr $n_suffix + 1 )
      	          n_suffix_counter=$( expr $n_suffix_counter + 1 )
      	        else
      	          echo "${n_prefix_sub}0${n_suffix}" >> $swlist_file
      	          n_suffix=$( expr $n_suffix + 1 )
      	        n_suffix_counter=$( expr $n_suffix_counter + 1 )
      	       fi 
      	      done
      	    fi
      	    n_suffix_counter=0
          fi
        fi
        #/usr/sbin/ibswitches|egrep -wi 'IB|GW'|cut -d'"' -f2|awk '{print $6}'|grep -vw localhost|cut -d' ' -f1>$swlist_file
      fi # -n IBSWITCHES close here

      if [[ -n $spineswitchname && `if [ -e $WRKDIR/o_ibswitches.out ]; then grep -wic "$spineswitchname" $WRKDIR/o_ibswitches.out; else echo '0'; fi` -eq "0" ]]; then echo "$spineswitchname"       >> $swlist_file; fi

      # To generate list of external nodes
      if [ -n "$RAT_EXT_ZFS_NODES" ]
      then
        for cellname in `echo $RAT_EXT_ZFS_NODES`
        do
          echo "$cellname">>$extsnlist_file
        done
      elif [ -r "$WRKDIR/o_external_storage.out" ]
      then # Use cached nodes list from previous run
        if [[ $from_exadiscover -eq "0" ]] ; then
          echo -e "Using cached file $WRKDIR/o_external_storage.out for external storage nodes list ....\n\n";
        fi
        cp -f $WRKDIR/o_external_storage.out $extsnlist_file
      elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
      then # Read the conf file
        rm -f  $extsnlist_file
        generate_exalogic_node_info_from_conf;
      fi # Don't ask the user

      #To generate list of storage nodes   
      if [ -n "$RAT_ZFS_NODES" ]
      then
        for cellname in `echo $RAT_ZFS_NODES`
        do
          echo "$cellname">>$snlist_file
        done
      elif [ -r "$WRKDIR/o_storage.out" ]
      then # Use cached nodes list from previous run
        if [[ $from_exadiscover -eq "0" ]] ; then
          echo -e "Using cached file $WRKDIR/o_storage.out for storage nodes list ....\n\n";
        fi
        cp -f $WRKDIR/o_storage.out $snlist_file
      elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
      then # Read the conf file
        rm -f  $snlist_file 
        generate_exalogic_node_info_from_conf;
      else # Ask user
	if [[ $EM_PROBE_MODE -eq 1 ]]
   	then
	  cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_CC}" groupHeader="${GID_CC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT"  defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n36_nlsid">
        Could not find storage node names from env or configuration file
      </text>
    </context>
    <text nls_id="orhc_exadata_n13_nlsid">
      Indicate your selection from one of these options 
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
        <text nls_id="orhc_exadata_n18_nlsid">Storage Node Name</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n37_nlsid">Storage IP address</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n55_nlsid">
      Enter the first storage cell
    </text>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <text nls_id="orhc_exadata_n88_nlsid">Enter Valid storage server IP addresses</text>
    <multipart-question>
      <question id="q${PROBE_QUES_CNT}o2q1q1" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n19_nlsid">
  	Enter IP address for first storage server
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q2" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n22_nlsid">
  	Enter IP address for second storage server
        </text>
      </question>
    </multipart-question>
  </question>
</group>
EOF

	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	  echo -e "Could not find storage node names from env or configuration file.Please enter the first storage server: "
	elif [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  echo -e "Could not find storage node names from env or configuration file.Please enter the first storage server: "

	  read_probe_xml "Could not find storage node names from env or configuration file"
	  if [[ $xml_rvalue = "Storage Node Name" ]] || [[ $xml_rvalue -eq 1 ]]
	  then
	    read_probe_xml "Enter the first storage cell"
	  elif [[ $xml_rvalue = "Storage IP address" ]] || [[ $xml_rvalue -eq 2 ]]
	  then
	    read_probe_xml "Enter IP address for first storage server"
	  fi
	  n_prefix=$xml_rvalue

          test_node_reachability;
	else
          # Cells
          unset n_prefix
          el_done=0
          while [ $el_done -lt 3 ] 
          do
            el_done=$(expr $el_done + 1)
            exec 3<&2; exec 2<&0
            $READ -p "Could not find storage node names from env or configuration file.Please enter the first storage server : " n_prefix
            exec 2<&3

            test_node_reachability;
            if [ $el_node_ping -eq "1" ] ; then break; fi;
          done
        fi

        if [ $el_node_ping -eq "0" ]
        then
          echo "Failed to get storage node info. Skipping storage node.";
          touch $snlist_file
        else
          if [ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
            # User enetered IP address. ask second cell ip address too.
            echo "${n_prefix}" > $snlist_file
            unset n_prefix
            el_done=0
            while [ $el_done -lt 3 ] 
            do
              el_done=$(expr $el_done + 1)
	      
	      if [[ $EM_XMLD_MODE -eq 1 ]]
	      then
		echo "Please enter the second storage server : "
		read_probe_xml "Enter IP address for second storage server"
	      else
                exec 3<&2; exec 2<&0
                $READ -p "Please enter the second storage server : " n_prefix
                exec 2<&3
	      fi
              
              test_node_reachability;
              if [ $el_node_ping -eq "1" ] ; then break; fi;
            done
            if [ $el_node_ping -eq "0" ]
            then
              echo "Failed to get storage node info. Skipping storage node.";
            else
              echo "${n_prefix}" >> $snlist_file
            fi
          else
            n_prefix=$(echo $n_prefix|sed s/.$//);  
            echo "${n_prefix}1" > $snlist_file
            echo "${n_prefix}2" >> $snlist_file
          fi
        fi
      fi
    fi #NO_QUESTION if closes here

    validate_exalogic_rack;

    echo "IS_EXALOGIC_MACHINE = $is_exalogic_machine" >> $MASTERFIL
    echo "IS_EXALOGIC_EC_MACHINE = $in_ec_exalogic" >> $MASTERFIL
    echo "EXALOGIC_VERSION = $exalogic_version" >> $MASTERFIL
    echo "EXALOGIC_ACTUAL_VERSION = $exalogic_version_actual" >> $MASTERFIL
    echo "EXALOGIC_RACK = $exalogic_rack" >> $MASTERFIL
    echo "EXALOGIC_RACK_IDENTIFIER = $RackIdentifier" >> $MASTERFIL
    #echo "COMPONENTS = $components" >>$MASTERFIL
    if [ -e $snlist_file ]; then cp -f $snlist_file  $WRKDIR >/dev/null 2>&1;fi
    if [ -e $extsnlist_file ]; then cp -f $extsnlist_file  $WRKDIR >/dev/null 2>&1;fi
    if [ -e $swlist_file ]; then cp -f $swlist_file  $WRKDIR >/dev/null 2>&1;fi
    #rm -f $WRKDIR/o_host_list.out $WRKDIR/o_storage.out $WRKDIR/o_ibswitches.out

    #-generate exalogic physical node list and update conf file.....
    echo "IS_EXALOGIC_HYBRID = $exalogic_hybrid" >> $MASTERFIL

    if [[ -n "$exalogic_hybrid" && "$exalogic_hybrid" -eq "1" ]]
    then
      if [ -z "$phy_nodes" ]
      then
        #For standard hybrid, there are only 4 configurations:
        #1) 1/8 - 2 virt + 2 physical nodes.
        #2) 1/4 - 4 virt + 4 physical.
        #3) 1/2 - 8 virt + 8 physical.
        #4) full - 16 virt + 14 physical.

        #EXAERROR=0
        #virtual_nodes=$(grep -c "c_nodes_.*_IPoIB-admin" $EAOUT) 
      	#case $exalogic_rack in
        #    3) 
        #	add_compute=15 
        #	if [[ $virtual_nodes != "16" ]] ; then EXAERROR=1; fi
        #    ;;
        #    2) 
        #	add_compute=8
        #	if [[ $virtual_nodes != "8" ]] ; then EXAERROR=1; fi
        #    ;;
        #    1) 
        #	add_compute=4
        #	if [[ $virtual_nodes != "4" ]] ; then EXAERROR=1; fi
        #    ;;
        #    0) 
        #	add_compute=2
        #	if [[ $virtual_nodes != "2" ]] ; then EXAERROR=1; fi
        #    ;;
        #  esac

        #  if [[ $EXAERROR = "1" ]]
        #  then
        #    echo -e ""
        #    echo -e "${RED}${program_name} could not determine physical nodes. please use -phy flag like ./${program_name} -hybrid -phy phy_node1,phy_node2.\n${NORM}"   
        #    echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
        #    rm -rf $HOSTLIST
        #    exit
        #  fi

        #  first_compute=$(grep "c_nodes_01_IPoIB-admin=" $EAOUT |cut -d= -f2)
        #  first_compute=$(echo "$first_compute" | sed 's/\.[0-9]*$/\.X/g')

        #  if [[ $exalogic_rack = "3" ]] ; then add_compute=$(expr $add_compute + 1); fi 

        #  comp_cnt=$(($add_compute * 2))
        #  while [[ $add_compute -lt $comp_cnt ]]
        #  do
        #    add_compute=$(expr $add_compute + 1)
        #    phy_compute=$(echo "$first_compute" | sed "s/.X$/\.$add_compute/g")
        #    phy_nodes=$phy_nodes","$phy_compute;
        #  done

        if [[ `grep -c "phy_nodes=" $EAOUT` -eq 0 ]]
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="${program_name} could not determine physical nodes. please use -phy flag like ./${program_name} -hybrid -phy phy_node1,phy_node2."
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e ""
          echo -e "${RED}${program_name} could not determine physical nodes. please use -phy flag like ./${program_name} -hybrid -phy phy_node1,phy_node2.\n${NORM}"   
          echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
          rm -rf $HOSTLIST
          exit 1
        else
          phy_nodes=$(grep "phy_nodes=" $EAOUT|sed 's/phy_nodes=//g'|sed 's/ //g')
        fi
      fi

      phy_nodes=$(echo $phy_nodes | sed 's/^,//g' | sed 's/,$//g')

      uniq_phy_nodes=""
      for exa_phy_node in `echo "$phy_nodes" | sed 's/,/ /g'`
      do
        if [ `echo "$uniq_phy_nodes"|grep -iwc "$exa_phy_node"` -eq 0 ]
        then
          uniq_phy_nodes="${uniq_phy_nodes},${exa_phy_node}," 

          echo "$exa_phy_node" >> $cnlist_file
        fi
      done
    
      uniq_phy_nodes=$(echo "$uniq_phy_nodes" | sed 's/,,/,/g' | sed 's/^,//g' | sed 's/,$//g');

      sed /phy_nodes/d $EAOUT > $EAOUT.new  
      echo "phy_nodes=$uniq_phy_nodes" >> $EAOUT.new
      mv -f $EAOUT.new $EAOUT

      phy_nodes=$uniq_phy_nodes;
    fi
  else
    is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $MASTERFIL | awk '{print $3}'`
    if [ ! -n "$is_exalogic_machine" ] ; then is_exalogic_machine=0; fi
    in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $MASTERFIL | awk '{print $3}'`
    exalogic_version=`grep EXALOGIC_VERSION $MASTERFIL | awk '{print $3}'`
    exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $MASTERFIL | awk '{print $3}'`
    exalogic_rack=`grep EXALOGIC_RACK $MASTERFIL | awk '{print $3}'`
    RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $MASTERFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`

    exalogic_hybrid=`grep IS_EXALOGIC_HYBRID $MASTERFIL | awk '{print $3}'`
    phy_nodes=`grep PHYSICAL_NODES $MASTERFIL | awk '{print $3}'`   
  fi

  case $exalogic_rack in
    3) #FULL
      EXALOGIC_RACK=FULL
      ;;
    2) #HALF
      EXALOGIC_RACK=HALF
      ;;
    1) #QUARTER
      EXALOGIC_RACK=QUARTER
      ;;
    0) #1/8 rack
      EXALOGIC_RACK="1/8"
      ;;
    *) #1/8 rack
      EXALOGIC_RACK="FULL"
      ;;
  esac

  if [[ -n $go_next && $go_next = "e" ]] ; then exit; fi
}

######################################################
# This script generates the info for Exalogic node info in each of these output files respectively:
# 1. o_host_list.out = contains hostname of compute nodes
# 2. o_storage.out = contains hostname of ZFS storage
# 3. o_ibswitches.out = contains hostname of switches for IB nodes
######################################################
generate_exalogic_node_info_from_conf()
{
  #db_machine_compute=1
  if [ $OFFLINE -eq "0" ]
  then
   if [ -n "$RAT_EXALOGIC_CONF" ]
   then
     conf_file="$RAT_EXALOGIC_CONF"
   elif [ $# -eq 0 ] ; then
     conf_file="exalogic_deploy.conf"
   elif [ $# -eq 1 ] ; then
     conf_file=$1
   fi
 
   #echo "Parsing $conf_file"
   if [ ! -f $conf_file ] ; then
     if [[ $EM_PROBE_MODE -eq 1 ]]
     then
       EMSG="The exalogic config file doesn't exist. Set conf file location in env variable RAT_EXALOGIC_CONF and run again"
       update_probe_xml "ERROR" "GENERIC" "$EMSG"
     fi
     echo "The exalogic config file doesn't exist. Set conf file location in env variable RAT_EXALOGIC_CONF and run again"
     exit 1
   fi
 
   if [ -e $cnlist_file -a -e $snlist_file -a -e $swlist_file -a -e $extsnlist_file ] ; then
     if [[ $EM_PROBE_MODE -eq 1 ]]
     then
       EMSG="Exalogic node info files already exist. Please refer to $cnlist_file, $swlist_file, $extsnlist_file, and $snlist_file for more information"
       update_probe_xml "ERROR" "GENERIC" "$EMSG"
     fi
     echo "Exalogic node info files already exist. Please refer to $cnlist_file, $swlist_file, $extsnlist_file, and $snlist_file for more information"
     exit 1
   else
     rm -rf $cnlist_file
     rm -rf $swlist_file
     rm -rf $snlist_file
     rm -rf $extsnlist_file
   fi
 
   ###########################
   # Retrieve the required info
   ##########################
   rackname=""
   sn_prefix=""
   cn_prefix=""
   extsn_prefix=""
   # Storage node name prefix
   #sn_prefix=`cat $conf_file | grep SNODE_PREFIX | cut -d ' ' -f 2`
   sn_prefix=`grep SNODE_PREFIX $conf_file | cut -d ' ' -f 2`
 
   # Rackname
   #rackname=`cat $conf_file | grep RACK_NAME | cut -d ' ' -f 2`
   rackname=`grep RACK_NAME $conf_file | cut -d ' ' -f 2`
 
   # Compute node name prefix
   #cn_prefix=`cat $conf_file | grep CNODE_PREFIX | cut -d ' ' -f 2`
   cn_prefix=`grep CNODE_PREFIX $conf_file | cut -d ' ' -f 2`
 
   # External storage node name prefix
   #sn_prefix=`cat $conf_file | grep SNODE_PREFIX | cut -d ' ' -f 2`
   extsn_prefix=`grep EXT_SNODE_PREFIX $conf_file | cut -d ' ' -f 2`

   ####################################################
   # Generate o_host_list.out
   #cat $conf_file | grep "$rackname$cn_prefix" | cut -f2 > $cnlist_file
   grep "$rackname$cn_prefix" $conf_file | cut -f2 > $cnlist_file
   #cat $conf_file | grep "$rackname$cn_prefix" | cut -f2 > $cnlist_file
 
   ######################################################
   # Generate o_storage.out
   #cat $conf_file | grep "$rackname$sn_prefix" | cut -f2 > $snlist_file
   grep "$rackname$sn_prefix" $conf_file | cut -f2 > $snlist_file
 
   ######################################################
   # Generate o_ibswitches.out
   #cat $conf_file | grep swnode | cut -d " " -f 2 | cut -f2 > $swlist_file
   grep swnode $conf_file | cut -d " " -f 2 | cut -f2 > $swlist_file
 
   ######################################################
   # Generate o_external_storage.out
   #cat $conf_file | grep swnode | cut -d " " -f 2 | cut -f2 > $swlist_file
   grep "$rackname$extsn_prefix" $conf_file | cut -f2 > $extsnlist_file

   components=$(echo ${user_components}:EXALOGIC)
 
   #echo "$cnlist_file, $snlist_file, and $swlist_file generated successfully"
   #echo "IS_EXALOGIC_MACHINE = $is_exalogic_machine" >> $MASTERFIL
   #echo "EXALOGIC_VERSION = $exalogic_version" >> $MASTERFIL
  else
   is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $MASTERFIL | awk '{print $3}'`
   if [ ! -n "$is_exalogic_machine" ] ; then is_exalogic_machine=0; fi
   in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $MASTERFIL | awk '{print $3}'`
   exalogic_version=`grep EXALOGIC_VERSION $MASTERFIL | awk '{print $3}'`
   exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $MASTERFIL | awk '{print $3}'`
   RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $MASTERFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`
   #echo "Offline mode"
  fi
}

validate_exalogic_rack()
{
  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then return; fi;

  no_of_switches=$(cat $swlist_file|wc -l)
  no_of_compute_nodes=$(cat $cnlist_file|wc -l)
  #if [[ $no_of_switches -gt 2 && $no_of_compute_nodes -lt 30 ]]
  if [[ $no_of_switches -gt 2 && $no_of_compute_nodes -lt 30 && -z "$RAT_CLUSTERNODES" && -z "$RAT_IBSWITCHES" && -z "$RAT_ELRACKTYPE" ]]
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="${program_name} could not determine rack type like full or half from environment. please set RAT_ELRACKTYPE to specify rack type as following.\nIf full rack then set RAT_ELRACKTYPE to 3\nIf half rack then set RAT_ELRACKTYPE to 2\nIf quarter rack then set RAT_ELRACKTYPE to 1\nIf 1/8 rack then set RAT_ELRACKTYPE to 0"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "${RED}${program_name} could not determine rack type like full or half from environment. please set RAT_ELRACKTYPE to specify rack type as following.\n${NORM}"
    echo -e "If full rack then set RAT_ELRACKTYPE to 3\nIf half rack then set RAT_ELRACKTYPE to 2\nif quarter rack then set RAT_ELRACKTYPE to 1\nif 1/8 rack then set RAT_ELRACKTYPE to 0"
    rm -f $HOSTLIST # gadiga avoid cleanup and ssh password prompts for each host
    exit 1
  fi  
}

function get_fmw_version ()
{
  i="$localnode"

  get_fmw_comps_running
 
  if [[ `echo "$fmw_comps_running" | grep -icw "OIM"` -gt 0 ]]; then
    IDM_VERSION=$($IAM_HOME/OPatch/opatch lsinventory | grep -i 'Oracle IDM Suite' | sed 's/Oracle IDM Suite//gi' | sed 's/ //g') 
    echo "IDM_VERSION = $IDM_VERSION" >> $MASTERFIL
  elif [[ `echo "$fmw_comps_running" | grep -icw "OAM"` -gt 0 ]]; then
    IDM_VERSION=$($IAM_HOME/OPatch/opatch lsinventory | grep -i 'Oracle IDM Suite' | sed 's/Oracle IDM Suite//gi' | sed 's/ //g') 
    echo "IDM_VERSION = $IDM_VERSION" >> $MASTERFIL
  elif [[ `echo "$fmw_comps_running" | grep -icw "OUD"` -gt 0 ]]; then
    OUD_HOME=$(grep -i "$i\.OUD\.HOME" $MASTERFIL | cut -d'=' -f2 | sed 's/ //g')
    IDM_VERSION=$($OUD_HOME/OPatch/opatch lsinventory | grep -i 'Oracle Unified Directory' | sed 's/Oracle Unified Directory//gi' | sed 's/ //g') 
    echo "IDM_VERSION = $IDM_VERSION" >> $MASTERFIL
  fi
  fmw_version="$IDM_VERSION"
  unset i
}

function read_fmw_comps_prerun ()
{
  fmw_comps_running=$(grep "$i.FMW_RUNNING_COMPS =" $MASTERFIL | cut -d'=' -f2 | sed 's/ //g');
}

function pickoimnode ()
{
  checknode=$1;
  fmw_machine_id=$2;
  if [ -z "$fmw_machine_id" ] ; then
    echo "ERROR: Failed to get machine id for $checknode in $OUTPUTDIR/topology_kv.out"
  fi
  if [ `grep "component.type = WLS_MANAGED_OIM" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
    oimnode="$checknode";
    echo "OIMNODE = $oimnode">>$MASTERFIL
  fi
}

function pickoamnode ()
{
  checknode=$1;
  fmw_machine_id=$2
  if [ -z "$fmw_machine_id" ] ; then
    echo "ERROR: Failed to get machine id for $checknode in $OUTPUTDIR/topology_kv.out"
  fi
  if [ `grep "component.type = WLS_MANAGED_OAM" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
    oamnode="$checknode";
    echo "OAMNODE = $oamnode">>$MASTERFIL
  fi
}

function pickoudnode ()
{
  checknode=$1;
  fmw_machine_id=$2
  if [ -z "$fmw_machine_id" ] ; then
    echo "ERROR: Failed to get machine id for $checknode in $OUTPUTDIR/topology_kv.out"
  fi
  if [ `grep "type = OUD" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
    oudnode="$checknode";
    echo "OUDNODE = $oudnode">>$MASTERFIL
  fi
}

# Check topology kv file for running components
# OIM, OAM, OUD, DB, OHS
# OIM : topology.machines.machine.id="f610cd22-1e71-4304-9793-d7cafe400049".instances.instance.id="77082311-bd9e-4b1e-9df9-b168690d2005".components.component.type = WLS_MANAGED_OIM
# OAM : topology.machines.machine.id="f610cd22-1e71-4304-9793-d7cafe400049".instances.instance.id="014f1e5b-0e52-4e74-b138-2065dec7c384".components.component.type = WLS_MANAGED_OAM
# OUD : topology.machines.machine.id="f610cd22-1e71-4304-9793-d7cafe400049".instances.instance.id="f5fe3fdc-a8da-4e76-863e-d40581045742".type = OUD
# DB  : topology.databases.database.id="8a023e25-c641-48b1-9a1b-28ba8fd4de4c".connectionString = jdbc:oracle:thin:@servicename
# OHS : topology.machines.machine.id="f610cd22-1e71-4304-9793-d7cafe400049".instances.instance.id="73ad08c6-107c-4bae-80f8-c7042123b2a8".type = OHS_HTTPD

function get_fmw_comps_running ()
{
  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ $fmw_runmode = "pre" ]]; then
    read_fmw_comps_prerun
  else 
    fmw_comps_running=""
    # get machine id : topology.machines.machine.id="f610cd22-1e71-4304-9793-d7cafe400049".name = host.domain.com
    fmw_machine_id=$(grep topology.machines.machine.id= $OUTPUTDIR/topology_kv.out |grep "\.name = $i" | cut -d\" -f2)
    if [ -z "$fmw_machine_id" ] ; then
      echo "ERROR: Failed to get machine id for $i in $OUTPUTDIR/topology_kv.out"
    else
      if [ `grep "component.type = WLS_MANAGED_OIM" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
        fmw_comps_running="$fmw_comps_running:OIM";
      fi
      if [ `grep "component.type = WLS_MANAGED_OAM" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
        fmw_comps_running="$fmw_comps_running:OAM";
      fi
      if [ `grep "type = OUD" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
        fmw_comps_running="$fmw_comps_running:OUD";
      fi
      if [ `grep "type = OHS_HTTPD" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
        fmw_comps_running="$fmw_comps_running:OHS";
      fi

      for mapping in ${VHNMAP[@]}
      do
        vhost=${mapping%%:*}
        ahost=${mapping#*:}
        if [[ "$i" = "$ahost" ]]; then
          fmw_machine_id=$(grep topology.machines.machine.id= $OUTPUTDIR/topology_kv.out |grep "\.name = $vhost" | cut -d\" -f2)
          if [ -n "$fmw_machine_id" ] ; then
            if [ `grep "component.type = WLS_MANAGED_OIM" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
              fmw_comps_running="$fmw_comps_running:OIM";
            fi
            if [ `grep "component.type = WLS_MANAGED_OAM" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
              fmw_comps_running="$fmw_comps_running:OAM";
            fi
            if [ `grep "type = OUD" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
              fmw_comps_running="$fmw_comps_running:OUD";
            fi
            if [ `grep "type = OHS_HTTPD" $OUTPUTDIR/topology_kv.out |grep -c $fmw_machine_id` -gt "0" ] ; then
              fmw_comps_running="$fmw_comps_running:OHS";
            fi
          fi 
        fi
      done
      unset mapping vhost ahost
      if [[ -n "$fmw_comps_running" ]]; then fmw_comps_running=$(echo "$fmw_comps_running"|tr ':' '\n'|sort -u | tr '\n' ':'|sed "s/:$//g"); fi

      if [[ `grep -ic "$i.FMW_RUNNING_COMPS =" $MASTERFIL` -eq "0" ]]; then echo "$i.FMW_RUNNING_COMPS = $fmw_comps_running" >> $MASTERFIL; fi
      get_fmw_homes
    fi
  fi
}

# Given component and hostname, get homes
function get_fmw_homes
{
  fmw_machine_id=$(grep topology.machines.machine.id= $OUTPUTDIR/topology_kv.out |grep "\.name = $i" | cut -d\" -f2)
  for hid in `grep $fmw_machine_id $OUTPUTDIR/topology_kv.out| grep "\.homeId = " | sed 's/.*\.homeId = //'`
  do
    hid_typ=$(grep "\.homes.home.id=.$hid.\.type = " $OUTPUTDIR/topology_kv.out | sed 's/.*\.type = //')
    hid_path=$(grep "\.homes.home.id=.$hid.\.path = " $OUTPUTDIR/topology_kv.out | sed 's/.*\.path = //')
    if [[ `grep -ic "$i.$hid_typ.HOME =" $MASTERFIL` -eq "0" ]]; then echo "$i.$hid_typ.HOME = $hid_path" >> $MASTERFIL; fi
  done

  for mapping in ${VHNMAP[@]}
  do
    vhost=${mapping%%:*}
    ahost=${mapping#*:}
    if [[ "$i" = "$ahost" ]]; then
      fmw_machine_id=$(grep topology.machines.machine.id= $OUTPUTDIR/topology_kv.out |grep "\.name = $vhost" | cut -d\" -f2)
    fi
    for hid in `grep $fmw_machine_id $OUTPUTDIR/topology_kv.out| grep "\.homeId = " | sed 's/.*\.homeId = //'`
    do
      hid_typ=$(grep "\.homes.home.id=.$hid.\.type = " $OUTPUTDIR/topology_kv.out | sed 's/.*\.type = //')
      hid_path=$(grep "\.homes.home.id=.$hid.\.path = " $OUTPUTDIR/topology_kv.out | sed 's/.*\.path = //')
      if [[ `grep -ic "$i.$hid_typ.HOME =" $MASTERFIL` -eq "0" ]]; then echo "$i.$hid_typ.HOME = $hid_path" >> $MASTERFIL; fi
    done
  done

  set_idm_healthcheck_env
}

function check_in_profiles ()
{
  if [[ -n "$exclude_profile" && $exclude_profile -eq 1 ]]
  then
    ex_profile=1
    if [ -z "$CHECK_ID" ]; then return; fi
    for aprofile in $profileids2exclude
    do
      if [[ `grep -ic "$CHECK_ID" "$SCRIPTPATH/.cgrep/profiles/$aprofile.prf"` -gt "0" ]] ; then
        ex_profile=0
        return;
      fi
    done
  else
    in_profile=0
    if [ -z "$CHECK_ID" ]; then return; fi
    for aprofile in $profileids2run
    do
      if [[ `grep -ic "$CHECK_ID" "$SCRIPTPATH/.cgrep/profiles/$aprofile.prf"` -gt "0" ]] ; then
        in_profile=1
        return;
      fi
    done
  fi
}

function check_in_targetversion ()
{
  in_profile=0
  if [[ `grep -ic "$CHECK_ID" "$targetVesionCheckFil"` -gt "0" ]] 
   then
     in_profile=1
     return;
  fi
}


assign_stack_status ()
{
  db_status_counter=0
  dbinst_up=0
  asminst_up=0

  if [ $OFFLINE -eq 0  ]
  then
    chk_fname=$MASTERFIL
  else
    chk_fname=$DUMPDIR/$CHKFIL
  fi

  #echo "========================================================================="
  #echo
  for db_name_to_check in "${mb_db_names[@]}"
  do
    if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
      stack_db_status[$db_status_counter]=`grep -i "${db_name_to_check}.INSTANCE_MODE"  $chk_fname |awk '{print $3}' |sort -n |tail -1`
    else
      stack_db_status[$db_status_counter]=`grep -i "$i.${db_name_to_check}.INSTANCE_MODE"  $chk_fname |awk '{print $3}'`
    fi
    if [ -z "${stack_db_status[$db_status_counter]}" ] ; then
      stack_db_status[$db_status_counter]=0
    fi
    if [[ $dbinst_up -eq "0" && ${stack_db_status[$db_status_counter]} -gt "0" ]] ; then
      dbinst_up=${stack_db_status[$db_status_counter]}
    fi
    #echo "db_status_counter=$db_status_counter, db_name_to_check=$db_name_to_check, stack_db_status=${stack_db_status[$db_status_counter]}, dbinst_up=$dbinst_up"
    db_status_counter=$(expr $db_status_counter + 1);
  done

  stack_dbinst_up[$stack_counter]=$dbinst_up

  if [ -z "${stack_db_status[0]}" ] ; then stack_db_status[0]=0; fi
  asminst_up=`grep -i "$i.ASM_STATUS"  $chk_fname |awk '{print $3}'`
  if [ -z "$asminst_up" ] ; then asminst_up=0; fi
  stack_asm_up[$stack_counter]=$asminst_up

  #echo "stack_dbinst_up= ${stack_dbinst_up[$stack_counter]}"
  #echo "========================================================================="
  #echo
}

copy_localonly ()
{
  function is_zip_unzip_available ()
  {
    is_zip_unzip_available=1
    ZIP_CMD=$(which zip 2>/dev/null)
    if [[ -z "$ZIP_CMD" || `echo $?` -ne 0 || `echo "$ZIP_CMD" | grep -ic "no zip"` -gt "0" ]]; then
      unset ZIP_CMD
      is_zip_unzip_available=0
    else
      UNZIP_CMD=$(which unzip 2>/dev/null)
      if [[ -z "$UNZIP_CMD" || `echo $?` -ne 0 || `echo "$UNZIP_CMD" | grep -ic "no unzip"` -gt "0" ]]; then
        unset UNZIP_CMD
	is_zip_unzip_available=0
      fi
    fi
  }

  is_zip_unzip_available 
  if [ -d $SCRIPTPATH/.cgrep ]; then
    cOLD_DIR=`pwd`
    cd $SCRIPTPATH/.cgrep/
    if [[ -n $is_zip_unzip_available && $is_zip_unzip_available -eq "1" ]]; then
      ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}'|xargs zip -qj ${RTEMPDIR}/${program_name}_utlscripts.zip >/dev/null 2>&1
    else
      ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}'|xargs tar -czf ${RTEMPDIR}/${program_name}_utlscripts.tar.gz >/dev/null 2>&1
    fi
    cd $cOLD_DIR
  fi
  if [[ -n $is_zip_unzip_available && $is_zip_unzip_available -eq "1" ]]; then
    #unzip -o $RTEMPDIR/${program_name}_utlscripts.zip -d $TMPDIR >/dev/null 2>&1
    unzip -o $RTEMPDIR/${program_name}_utlscripts.zip -d $RTEMPDIR >/dev/null 2>&1
    unzip -o $RTEMPDIR/${DBSAT} -d $RTEMPDIR >/dev/null 2>&1
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]] ; then
      if [[ -n "$1" && "$1" = "CHECK" ]]; then 
        if [[ -e $TMP_OUTPUT/utilscopied.txt ]]; then return; fi
      fi	    
      unzip -o $RTEMPDIR/${program_name}_utlscripts.zip -d $TMP_OUTPUT>/dev/null 2>&1
      unzip -o $RTEMPDIR/${DBSAT} -d $TMP_OUTPUT >/dev/null 2>&1
      if [[ -n "$1" && "$1" != "CHECK" ]]; then
        cOLD_DIR=`pwd`
        cd $TMP_OUTPUT
	unzip -Z -1 $RTEMPDIR/${program_name}_utlscripts.zip|xargs chown $1:$2 >/dev/null 2>&1;
	touch $TMP_OUTPUT/utilscopied.txt >/dev/null 2>&1;
        cd $cOLD_DIR
      fi
    fi
  else
    #tar -xzf $RTEMPDIR/${program_name}_utlscripts.tar.gz -C $TMPDIR >/dev/null 2>&1
    tar -xzf $RTEMPDIR/${program_name}_utlscripts.tar.gz -C $RTEMPDIR >/dev/null 2>&1
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]] ; then
      if [[ -n "$1" && "$1" = "CHECK" ]]; then 
        if [[ -e $TMP_OUTPUT/utilscopied.txt ]]; then return; fi
      fi	    
      tar -xzf $RTEMPDIR/${program_name}_utlscripts.tar.gz -C $TMP_OUTPUT>/dev/null 2>&1
      if [[ -n "$1" && "$1" != "CHECK" ]]; then
        cOLD_DIR=`pwd`
        cd $TMP_OUTPUT
        tar -tf $RTEMPDIR/${program_name}_utlscripts.tar.gz|xargs chown $1:$2 >/dev/null 2>&1;
	touch $TMP_OUTPUT/utilscopied.txt >/dev/null 2>&1;
        cd $cOLD_DIR
      fi
    fi
  fi
}


par_copy_utl_script_to_tmp ()
{
  function is_zip_unzip_available ()
  {
    is_zip_unzip_available=1
    ZIP_CMD=$(which zip 2>/dev/null)
    if [[ -z "$ZIP_CMD" || `echo $?` -ne 0 || `echo "$ZIP_CMD" | grep -ic "no zip"` -gt "0" ]]; then
      unset ZIP_CMD
      is_zip_unzip_available=0
    else
      UNZIP_CMD=$(which unzip 2>/dev/null)
      if [[ -z "$UNZIP_CMD" || `echo $?` -ne 0 || `echo "$UNZIP_CMD" | grep -ic "no unzip"` -gt "0" ]]; then
        unset UNZIP_CMD
	is_zip_unzip_available=0
      fi
    fi
  }
  is_zip_unzip_available 
  if [ -d $SCRIPTPATH/.cgrep ]; then
    cOLD_DIR=`pwd`
    cd $SCRIPTPATH/.cgrep/
    if [[ -n $is_zip_unzip_available && $is_zip_unzip_available -eq "1" ]]; then
      ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}'|xargs zip -qj ${RTEMPDIR}/${program_name}_utlscripts.zip >/dev/null 2>&1
    else
      ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}'|xargs tar -czf ${RTEMPDIR}/${program_name}_utlscripts.tar.gz >/dev/null 2>&1
    fi
    cd $cOLD_DIR
  fi

  function par_scp ()
  {
    if [[ -e ${RTEMPDIR}/${program_name}_utlscripts.zip || -e ${RTEMPDIR}/${program_name}_utlscripts.tar.gz ]]; then
      if [ $hname = $localnode ]; then
        if [[ -n $is_zip_unzip_available && $is_zip_unzip_available -eq "1" ]]; then
	  OLD_TMDPIR=$TMPDIR
	  TMPDIR=$RTEMPDIR
	  unzip -o $RTEMPDIR/${program_name}_utlscripts.zip -d $TMPDIR >/dev/null 2>&1
          unzip -o $RTEMPDIR/${DBSAT} -d $TMPDIR >/dev/null 2>&1
          chmod 540 $TMPDIR/$ASREXACHK $TMPDIR/checkDiskFGMapping.sh $TMPDIR/checkDiskScheduler.sh $TMPDIR/checkvg.sh $TMPDIR/checkLocalDisks.sh $TMPDIR/ofm_client.sh $TMPDIR/validatePassword.sh $TMPDIR/checkHiddenParams.sh >/dev/null 2>&1	  
	  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	    cOLD_DIR=`pwd`
	    cd $TMP_OUTPUT;
	    unzip -o $RTEMPDIR/${program_name}_utlscripts.zip >/dev/null 2>&1
            unzip -o $RTEMPDIR/${DBSAT} >/dev/null 2>&1
	    #unzip -Z -1 $RTEMPDIR/${program_name}_utlscripts.zip|xargs chmod 755 >/dev/null 2>&1
	    for pluginscript in `unzip -Z -1 $RTEMPDIR/${program_name}_utlscripts.zip`
  	    do
	      security_fix "fix_plugin_or_rtscript_attributes" "$pluginscript" "" "540"
	    done
            chmod 555 $TMP_OUTPUT/$ASREXACHK $TMP_OUTPUT/checkDiskFGMapping.sh $TMP_OUTPUT/checkDiskScheduler.sh $TMP_OUTPUT/checkvg.sh $TMP_OUTPUT/checkLocalDisks.sh $TMP_OUTPUT/ofm_client.sh $TMP_OUTPUT/validatePassword.sh $TMP_OUTPUT/checkHiddenParams.sh >/dev/null 2>&1	  
	    cd $cOLD_DIR
	  fi
	else
	  tar -xzf $RTEMPDIR/${program_name}_utlscripts.tar.gz -C $TMPDIR >/dev/null 2>&1
          chmod 540 $TMPDIR/$ASREXACHK $TMPDIR/checkDiskFGMapping.sh $TMPDIR/checkDiskScheduler.sh $TMPDIR/checkvg.sh $TMPDIR/checkLocalDisks.sh $TMPDIR/ofm_client.sh $TMPDIR/checkHiddenParams.sh $TMPDIR/validatePassword.sh >/dev/null 2>&1	  
	  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	    cOLD_DIR=`pwd`
	    cd $TMP_OUTPUT;
	    tar -xzf $RTEMPDIR/${program_name}_utlscripts.tar.gz >/dev/null 2>&1
	    #tar -tf $RTEMPDIR/${program_name}_utlscripts.tar.gz|xargs chmod 755 >/dev/null 2>&1
	    for pluginscript in `tar -tf $RTEMPDIR/${program_name}_utlscripts.tar.gz`
  	    do
	      security_fix "fix_plugin_or_rtscript_attributes" "$pluginscript" "" "540"
	    done
            chmod 555 $TMP_OUTPUT/$ASREXACHK $TMP_OUTPUT/checkDiskFGMapping.sh $TMP_OUTPUT/checkDiskScheduler.sh $TMP_OUTPUT/checkvg.sh $TMP_OUTPUT/checkLocalDisks.sh $TMP_OUTPUT/ofm_client.sh $TMP_OUTPUT/validatePassword.sh $TMP_OUTPUT/checkHiddenParams.sh >/dev/null 2>&1	  
	    cd $cOLD_DIR
	  fi
        fi
	TMPDIR=$OLD_TMPDIR
      else
        node_ssh_user=$usern
        if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
          if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
            node_ssh_user="${root_user}"
          else
            node_ssh_user="${foxtrot_dom0_user}"
          fi
          if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$hname "echo \"\$HOME\""); fi
          l_RTEMPDIR=${l_TMPDIR}/.${program_name}
        else
          l_TMPDIR=$TMPDIR
          l_RTEMPDIR=$RTEMPDIR
        fi
	l_OLD_TMPDIR=$l_TMPDIR
	l_TMPDIR=$l_RTEMPDIR

	if [[ -n $is_zip_unzip_available && $is_zip_unzip_available -eq "1" ]]; then
          $SCOPY ${RTEMPDIR}/${program_name}_utlscripts.zip $node_ssh_user@$hname:$l_RTEMPDIR/ >/dev/null 2>&1
 	  $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; if [ -e $l_RTEMPDIR/${program_name}_utlscripts.zip ]; then unzip -o $l_RTEMPDIR/${program_name}_utlscripts.zip -d $l_TMPDIR >/dev/null 2>&1; fi;\""
 	  $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; if [ -e $l_RTEMPDIR/${DBSAT} ]; then unzip -o $l_RTEMPDIR/${DBSAT} -d $l_TMPDIR >/dev/null 2>&1; fi;\""
          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; chmod 540 $l_TMPDIR/$ASREXACHK $l_TMPDIR/checkDiskFGMapping.sh $l_TMPDIR/checkDiskScheduler.sh $l_TMPDIR/checkvg.sh $l_TMPDIR/checkHiddenParams.sh $l_TMPDIR/checkLocalDisks.sh $l_TMPDIR/ofm_client.sh $TMPDIR/validatePassword.sh>/dev/null 2>&1\""
	  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	    $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; cd $TMP_OUTPUT; if [ -e $l_RTEMPDIR/${program_name}_utlscripts.zip ]; then unzip -o $l_RTEMPDIR/${program_name}_utlscripts.zip >/dev/null 2>&1; unzip -Z -1 $l_RTEMPDIR/${program_name}_utlscripts.zip|xargs chmod 540 >/dev/null 2>&1; fi;\""
	    $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; cd $TMP_OUTPUT; if [ -e $l_RTEMPDIR/${DBSAT} ]; then unzip -o $l_RTEMPDIR/${DBSAT} >/dev/null 2>&1; fi;\""
            $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; chmod 555 $TMP_OUTPUT/$ASREXACHK $TMP_OUTPUT/checkDiskFGMapping.sh $TMP_OUTPUT/checkDiskScheduler.sh $TMP_OUTPUT/checkvg.sh $TMP_OUTPUT/checkHiddenParams.sh $TMP_OUTPUT/checkLocalDisks.sh $TMP_OUTPUT/ofm_client.sh $TMPDIR/validatePassword.sh>/dev/null 2>&1\""
	  fi
        else
          $SCOPY ${RTEMPDIR}/${program_name}_utlscripts.tar.gz $node_ssh_user@$hname:$l_RTEMPDIR/ >/dev/null 2>&1
 	  $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; if [ -e $l_RTEMPDIR/${program_name}_utlscripts.tar.gz ]; then tar -xzf $l_RTEMPDIR/${program_name}_utlscripts.tar.gz -C $l_TMPDIR >/dev/null 2>&1; fi;\""
          $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; chmod 540 $l_TMPDIR/$ASREXACHK $l_TMPDIR/checkDiskFGMapping.sh $l_TMPDIR/checkDiskScheduler.sh $l_TMPDIR/checkvg.sh $l_TMPDIR/checkHiddenParams.sh $l_TMPDIR/checkLocalDisks.sh  $l_TMPDIR/ofm_client.sh $TMPDIR/validatePassword.sh>/dev/null 2>&1\""
	  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	    $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; cd $TMP_OUTPUT; if [ -e $l_RTEMPDIR/${program_name}_utlscripts.tar.gz ]; then tar -xzf $l_RTEMPDIR/${program_name}_utlscripts.tar.gz >/dev/null 2>&1; tar -tf $l_RTEMPDIR/${program_name}_utlscripts.tar.gz|xargs chmod 540>/dev/null 2>&1; fi;\""
            $SSHELL $node_ssh_user@$hname "$bash_scr -c \"$bash_source; chmod 555 $TMP_OUTPUT/$ASREXACHK $TMP_OUTPUT/checkDiskFGMapping.sh $TMP_OUTPUT/checkDiskScheduler.sh $TMP_OUTPUT/checkvg.sh $TMP_OUTPUT/checkHiddenParams.sh $TMP_OUTPUT/checkLocalDisks.sh $TMP_OUTPUT/ofm_client.sh $TMPDIR/validatePassword.sh>/dev/null 2>&1\""
	  fi
        fi
	l_TMPDIR=$l_OLD_TMPDIR
      fi
      printf ". "
    fi
  }
  
  printf "\n\nCopying plug-ins\n\n. . "

  is_zip_unzip_available 
  if [ -d $SCRIPTPATH/.cgrep ]; then
    cOLD_DIR=`pwd`
    cd $SCRIPTPATH/.cgrep/
    if [[ -n $is_zip_unzip_available && $is_zip_unzip_available -eq "1" ]]; then
      ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}'|xargs zip -qj ${RTEMPDIR}/${program_name}_utlscripts.zip >/dev/null 2>&1
    else
      ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}'|xargs tar -czf ${RTEMPDIR}/${program_name}_utlscripts.tar.gz >/dev/null 2>&1
    fi
    cd $cOLD_DIR
  fi
  
  scp_h_cnt=0
  for hname in `cat $HOSTLIST`
  do
    par_scp &
    scp_h_cnt=$(expr $scp_h_cnt + 1)
  done
}


copy_utl_script_to_tmp ()
{
  #We don't need copy as on remote, copying locally utlscripts from scped .cgrep directory.
  if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && -e $EXPECT ]] || [[ -z $RAT_COMPUTE_RUNMODE && -e $EXPECT ]]; then copy_localonly; return; fi

  if [[ -z $RAT_COPY_UTL_NO_PARALLEL ]]; then par_copy_utl_script_to_tmp; return; fi 

  #copy utility scripts to /tmp on all nodes so audit check can find it and execute it
  utlscrpcounter=0
  printf "\n\nCopying plug-ins\n\n. . " 
  for utlscrpt_full in `if [ -d $SCRIPTPATH/.cgrep ]; then ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}';fi`  
  do
    utlscrpt=$(basename $utlscrpt_full)
    for hname in `cat $HOSTLIST`
    do
      if  [ -e $SCRIPTPATH/.cgrep/${utlscrpt} ]
      then  
        if [ $hname = $localnode ]
        then
	  TMPDIR=$OLD_TMPDIR
	  TMPDIR=$RTEMPDIR
          cp -f $SCRIPTPATH/.cgrep/${utlscrpt} $TMPDIR  >/dev/null 2>&1  
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "$ASREXACHK" ]; then chmod 540 $TMPDIR/$ASREXACHK;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskFGMapping.sh" ]; then chmod 540 $TMPDIR/checkDiskFGMapping.sh;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskScheduler.sh" ]; then chmod 540 $TMPDIR/checkDiskScheduler.sh;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkLocalDisks.sh" ]; then chmod 540 $TMPDIR/checkLocalDisks.sh;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "validatePassword.sh" ]; then chmod 540 $TMPDIR/validatePassword.sh;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkHiddenParams.sh" ]; then chmod 540 $TMPDIR/checkHiddenParams.sh;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkvg.sh" ]; then chmod 540 $TMPDIR/checkvg.sh;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "ofm_client.sh" ]; then chmod 540 $TMPDIR/ofm_client.sh;fi
	
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            cp -f $SCRIPTPATH/.cgrep/${utlscrpt} $TMP_OUTPUT  >/dev/null 2>&1  
	    security_fix "fix_plugin_or_rtscript_attributes" "$TMP_OUTPUT/${utlscrpt}" "" "540"
            if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskFGMapping.sh" ]; then chmod 555 $TMPDIR/checkDiskFGMapping.sh;fi
	  fi 
	  TMPDIR=$OLD_TMPDIR
        else
	  node_ssh_user=$usern
          if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	    if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
              node_ssh_user="${root_user}"
            else
              node_ssh_user="${foxtrot_dom0_user}"
            fi
            if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$hname "echo \"\$HOME\""); fi
            l_RTEMPDIR=${l_TMPDIR}/.${program_name}
          else
            l_TMPDIR=$TMPDIR
            l_RTEMPDIR=$RTEMPDIR
          fi
	  l_OLD_TMPDIR=$l_TMPDIR
	  l_TMPDIR=$l_RTEMPDIR

          $SCOPY $SCRIPTPATH/.cgrep/${utlscrpt} $node_ssh_user@$hname:$l_TMPDIR/ >/dev/null 2>&1 
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "$ASREXACHK" ]; then $SSHELL $node_ssh_user@$hname "chmod 540 $l_TMPDIR/$ASREXACHK";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskFGMapping.sh" ]; then $SSHELL $node_ssh_user@$hname "chmod 540 $l_TMPDIR/checkDiskFGMapping.sh";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskScheduler.sh" ]; then $SSHELL $node_ssh_user@$hname "chmod 540 $l_TMPDIR/checkDiskScheduler.sh";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkLocalDisks.sh" ]; then $SSHELL $node_ssh_user@$hname "chmod 540 $l_TMPDIR/checkLocalDisks.sh";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "ofm_client.sh" ]; then $SSHELL $node_ssh_user@$hname "chmod 540 $l_TMPDIR/ofm_client.sh";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "validatePassword.sh" ]; then $SSHELL $node_ssh_user@$hname "chmod 540 $l_TMPDIR/validatePassword.sh";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkHiddenParams.sh" ]; then $SSHELL $node_ssh_user@$hname "chmod 540 $l_TMPDIR/checkHiddenParams.sh";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkvg.sh" ]; then $SSHELL $node_ssh_user@$hname "chmod 540 $l_TMPDIR/checkvg.sh";fi

	  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
            $SCOPY $SCRIPTPATH/.cgrep/${utlscrpt} $node_ssh_user@$hname:$TMP_OUTPUT/ >/dev/null 2>&1 
            $SSHELL $node_ssh_user@$hname "chmod 540 $TMP_OUTPUT/${utlscrpt}";
            if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskFGMapping.sh" ]; then $SSHELL $node_ssh_user@$hname "chmod 555 $l_TMPDIR/checkDiskFGMapping.sh";fi
	  fi 
	  $l_TMPDIR=$l_OLD_TMPDIR
        fi
      fi
      #$READ -p "stop for $SCRIPTPATH/.cgrep/$ASREXACHK"
    done
    a_utlscrpt[$utlscrpcounter]=$utlscrpt 
    utlscrpcounter=$(expr $utlscrpcounter + 1 )
    printf ". "
  done
  printf "\n\n" 
  utlscrpcounter=0 
}

add_maa_scorecard ()
{
  if [[ -n "$skip_maa_scorecard" && $skip_maa_scorecard -eq 1  ]]
  then 
    if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]]
    then
      components=$(echo ${components}|sed 's/:MAA//')
    elif [ $single_instance_run -eq 1 ]
    then
      components=$(echo ${components}|sed 's/:SIDBMAA//')   
    else
      components=$(echo ${components}:MAA)
    fi
    TYP=-a
  fi
  if [[ -n "$maa_scorecard" && $maa_scorecard -eq 0 ]]; then components=$(echo ${components}|sed 's/:MAA//');components=$(echo ${components}|sed 's/:SIDBMAA//'); fi
  if [[ $is_exadata_dom0_machine -eq "1" || $is_ssc_globalzone_machine -eq 1 ]] ; then components=$(echo ${components}|sed 's/:MAA//');fi
}

add_hacheck ()
{
  if [[ -n "$skip_hacheck" && $skip_hacheck -eq 1  ]] 
  then 
    #if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]]
    if [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]] || [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
    then
      components=$(echo ${components}:HACHECK)
      #components=$(echo ${components}|sed 's/:HACHECK//')
    elif [ $single_instance_run -eq 1 ]
    then
      components=$(echo ${components}:SIDBHACHECK)
      #components=$(echo ${components}|sed 's/:SIDBHACHECK//')
      #else
      #components=$(echo ${components}:HACHECK)
    fi
    TYP=-a
  fi
  if [[ -n "$include_hacheck" && $include_hacheck -eq 0 ]]
  then 
    if [ $single_instance_run -eq 1 ]
    then
      components=$(echo ${components}|sed 's/:SIDBHACHECK//')
    else
      components=$(echo ${components}|sed 's/:HACHECK//')
    fi
  fi
}

match_database_role ()
{
  dbrole_match_count=0
  dbrole_match_count=$(echo "$check_database_role"|grep -icw "$1")
}
match_database_type ()
{
  dbtype_match_count=0
  dbtype_match_count=$(echo "$check_database_type"|grep -icw "$1")
}

compare_collections ()
{
  res1=$1;
  res2=$2;

  if [ -n $3 ] ; then
    res3=$3;
  fi

  if [[ -z "$res1" || -z "$res2" ]] ; then
    echo -e "${RED}This command requires two arguments.${NORM}";
    display_usage;
  fi

  remove_res1=0
  remove_res2=0

  if [ `echo $res1 | grep -ic '\.zip$'` -gt "0" ] ; then
    zip_base=$(basename $res1 | sed 's/\.zip//');
    rm -rf $TMPDIR/$zip_base
    unzip -o $res1 -d $TMPDIR >/dev/null 2>&1
    if [ -e "$TMPDIR/$zip_base/$zip_base.html" ] ; then
      remove_res1=1
      res1_dir="$TMPDIR/$zip_base"
    else
      echo -e "${RED}Error while unzipping $res1.. exiting${NORM}";
      exit;
    fi
  else
    res1_dir=$res1
  fi

  if [ `echo $res2 | grep -ic '\.zip$'` -gt "0" ] ; then
    zip_base=$(basename $res2 | sed 's/\.zip//');
    rm -rf $TMPDIR/$zip_base 
    unzip -o $res2 -d $TMPDIR >/dev/null 2>&1
    if [ -e "$TMPDIR/$zip_base/$zip_base.html" ] ; then
      remove_res2=1
      res2_dir="$TMPDIR/$zip_base"
    else
      echo -e "${RED}Error while unzipping $res2.. exiting${NORM}";
      exit;
    fi
  else
    res2_dir=$res2
  fi

  if [ -e "$res1_dir/outfiles/check_env.out" ]
  then
    MASTERFIL1=$res1_dir/outfiles/check_env.out
  else
    MASTERFIL1=$res1_dir/outfiles/raccheck_env.out
  fi
 
  if [[ `grep -iwc "IT_IS_RAC = 1" $MASTERFIL1` -gt 0 || `grep -iwc 'EXADATA_COMPUTE = 1' $MASTERFIL1` -gt 0 ]]
  then
    $perl_exe $SCRIPTPATH/.cgrep/diff_collections.pl $WRKDIR $res1_dir $res2_dir $res3 
  fi

  if [[ $remove_res1 -eq "1" && -d "$res1_dir" ]] ; then
    rm -rf $res1_dir
  fi
  if [[ $remove_res2 -eq "1" && -d "$res2_dir" ]] ; then
    rm -rf $res2_dir
  fi
}

compare_reports ()
{
  perl_exe=$(which perl| tr -d '\r')
  if [ -z "$perl_exe" ] ; then
    echo -e "${RED}This feature requires Perl command. If its installed, please set PATH and try again, else please install perl and try again.${NORM}";
    display_usage; 
  fi

  ignore_profile_cmp=0
  if [[ `echo "$*"|grep -ic '\-force'` -gt "0" ]]; then
    args=$(echo $* | sed 's/-force//');
    ignore_profile_cmp=1
  fi

  args=$(echo $* | sed 's/.*-diff//' | sed 's/-force//');
  if [ -z "$args" ] ; then 
    echo -e "${RED}Missing arguments${NORM}";
    display_usage; 
  fi

  report1=$(echo $args | awk '{print $1}');

  if [[ $report1 = "-h" ]] ; then
    echo -e "   
        -diff <Old Report> <New Report> [-outfile <Output HTML>] [-force]
                Diff two ${program_name} reports. Pass directory name or zip file or html report file as <Old Report> & <New Report>
		-force : To compare different profiles collections or profile with non-profile collection.
    "
    exit 1;
  fi

  report2=$(echo $args | awk '{print $2}');
  if [ -z "$report3" ] ; then
    report3=$(echo $args | awk '{print $3}');
    if [[ -n "$report3" && $report3 = "-outfile" ]] ; then
      report3=$(echo $args | awk '{print $4}');
    else
      unset report3;
    fi
  fi

  if [[ -z "$report1" || -z "$report2" ]] ; then
    echo -e "${RED}This command requires two arguments.${NORM}";
    display_usage; 
  fi

  report1col=$report1;
  report2col=$report2;

  if [ -e "$res1_dir/outfiles/check_env.out" ]
  then
    MASTERFIL1=$res1_dir/outfiles/check_env.out
  else
    MASTERFIL1=$res1_dir/outfiles/raccheck_env.out
  fi

  if [[ `echo $report1 | grep -ic '\.html$'` -gt "0" || `echo $report2 | grep -ic '\.html$'` -gt "0" ]] ; then
    diffcoll=0;
  else
    diffcoll=1;
  fi

  remove_report1=0
  remove_report2=0
  if [ `echo $report1 | grep -ic '\.zip$'` -gt "0" ] ; then
    #zip_base=$(basename $report1 | sed 's/\.zip//');
    #unzip $report1 $zip_base/$zip_base.html -d /tmp >/dev/null 2>&1
    #if [ -e "/tmp/$zip_base/$zip_base.html" ] ; then
    #  report1=/tmp/$zip_base/$zip_base.html
    #  remove_report1=1
    #  report1_dir="/tmp/$zip_base/"

    zip_base=$(basename $report1 | sed 's/\.zip//');
    unzip -o $report1 -d $TMPDIR/report1_$$ >/dev/null 2>&1

    if [ -e "$TMPDIR/report1_$$/$zip_base/outfiles/check_env.out" ]
    then
      MASTERFIL1=$TMPDIR/report1_$$/$zip_base/outfiles/check_env.out
    else
      MASTERFIL1=$TMPDIR/report1_$$/$zip_base/outfiles/raccheck_env.out
    fi
    if [[ `grep -iwc "IT_IS_RAC = 1" $MASTERFIL1` -gt 0 || `grep -iwc 'EXADATA_COMPUTE = 1' $MASTERFIL1` -gt 0 ]]
    then
      diffcoll=1;
    else
      diffcoll=-1;
    fi

    if [ -e "$TMPDIR/report1_$$/$zip_base/$zip_base.html" ] ; then
      report1=$TMPDIR/report1_$$/$zip_base/$zip_base.html
      remove_report1=1
      report1_dir="$TMPDIR/report1_$$/"
      report1_file="$zip_base.html"
    else
      echo -e "${RED}Error while unzipping $report1.. exiting${NORM}";
    fi
  fi

  if [ `echo $report2 | grep -ic '\.zip$'` -gt "0" ] ; then
    #zip_base=$(echo $report2 | sed 's/\.zip//');
    #unzip $report2 $zip_base/$zip_base.html -d /tmp >/dev/null 2>&1
    #if [ -e "/tmp/$zip_base/$zip_base.html" ] ; then
    #  report2=/tmp/$zip_base/$zip_base.html
    #  remove_report2=1
    #  report2_dir="/tmp/$zip_base/"

    zip_base=$(basename $report2 | sed 's/\.zip//');
    unzip -o $report2 $zip_base/$zip_base.html -d $TMPDIR/report2_$$ >/dev/null 2>&1
    if [ -e "$TMPDIR/report2_$$/$zip_base/$zip_base.html" ] ; then
      report2=$TMPDIR/report2_$$/$zip_base/$zip_base.html
      remove_report2=1
      report2_dir="$TMPDIR/report2_$$/"
      report2_file="$zip_base.html"
    else
      echo -e "${RED}Error while unzipping $report2.. exiting${NORM}";
    fi
  fi
   
  $perl_exe $SCRIPTPATH/.cgrep/diff_checks.pl $diffcoll $WRKDIR "$report1" "$report2" "$report3" $ignore_profile_cmp
  diff_returncode=`echo $?`

  if [[ $ignore_profile_cmp -eq "0" ]] && [[ -n "$diff_returncode" && $diff_returncode -eq "2" ]]; then
     echo -e "${RED}Please use -force to compare different profiles collections or profile with non-profile collection.${NORM}";
     usage_granular "-diff"
     return
  fi

  if [[ $remove_report1 -eq "1" && -d "$report1_dir" ]] ; then
    rm -f $report1_dir/$report1_file
    #rmdir $report1_dir
    rm -rf $report1_dir
  fi
  if [[ $remove_report2 -eq "1" && -d "$report2_dir" ]] ; then
    rm -f $report2_dir/$report2_file
    #rmdir $report2_dir
    rm -rf $report2_dir
  fi

  if [[ $diffcoll -eq "1" ]] ; then
    compare_collections $report1col $report2col $report3 
  fi
}

compare_exalogic_rack ()
{
  python_exe=$(which python)
  if [ -z "$python_exe" ] ; then
    echo -e "${RED}This feature requires python command. If its installed, please set PATH and try again, else please install python and try again.${NORM}";
    display_usage;
  fi
  
  args=$(echo $* | sed 's/.*-exadiff//');
  if [ -z "$args" ] ; then
    echo -e "${RED}Missing arguments${NORM}";
    display_usage;
  fi
  
  report1=$(echo $args | awk '{print $1}');
  report2=$(echo $args | awk '{print $2}');
  report3=$(echo $args | awk '{print $3}');

  if [ "$report1" == "-h" ] ; then
    usage_granular -exadiff;exit 1;
  fi
  
  if [[ -n "$report3" ]] || [[ -z "$report1" || -z "$report2" ]] ; then 
    echo -e "${RED}This command requires two arguments.${NORM}";
    display_usage;
  fi

  if [[ `echo $report1 | grep -ic '\.zip$'` -eq "0" ]] ; then
    if [ -f "$report1" ]; then
      echo -e "${RED}This command requires two collections. First argument is a file.${NORM}";
      display_usage;
    fi
  fi
  if [[ `echo $report2 | grep -ic '\.zip$'` -eq "0" ]] ; then
    if [ -f "$report2" ] ; then
      echo -e "${RED}This command requires two collections. Second argument is a file.${NORM}";
      display_usage;
    fi
  fi
 
  $python_exe $SCRIPTPATH/.cgrep/rack_comparison.py $report1 $report2 
}

reset_crs ()
{
  perl_exe=$(which perl| tr -d '\r');
  if [ -z "$perl_exe" ] ; then
    echo -e "${RED}This feature requires Perl command. If its installed, please set PATH and try again, else please install perl and try again.${NORM}";
    display_usage; 
    return 
  fi

  args=$(echo $* | sed 's/.*-resetcrs//');
  if [ -z "$args" ] ; then
    echo -e "${RED}Missing arguments${NORM}";
    display_usage;
    return 
  fi

  if [ -e "$SCRIPTPATH/.cgrep/reset_crshome.pl" ]
  then
    security_fix "fix_plugin_or_rtscript_attributes" "$RTEMPDIR/reset_crshome.pl" "" "540"
    $perl_exe $RTEMPDIR/reset_crshome.pl $args 
  fi
}

check_if_bda ()
{
  is_bda_machine=0
  bda_machine=""
  bda_identifier="";
  bda_version="";
  if [ -e /opt/oracle/bda/ ];
  then
    bda_machine=$(rpm -q bda);
    if [ `echo "$bda_machine" |grep -ic bda` -gt 0 ]	
    then
      is_bda_machine=1
    fi
  fi
  localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
  if [ $is_bda_machine -eq 1 ];
  then
    if [ `uname -s` = "Linux" ]; then IPMITOOL="/usr/bin/ipmitool";elif [ `uname -s` = "SunOS" ]; then IPMITOOL="/opt/ipmitool/bin/ipmitool";fi
    if [ -e $IPMITOOL ]; then bda_identifier=$($IPMITOOL sunoem cli force "show /SP system_identifier" 2>/dev/null|grep "system_identifier "|awk '{print $NF}');fi
    set_bda_env
  fi
}

function set_bda_env()
{
  is_bda_dom0=0
  is_bda_domu=0
  bda_in_cluster=0
  if [ -n "$RAT_DB" ];
  then
    bda_version=$RAT_DB
  else
    bda_version=`imageinfo |grep IMAGE_VERSION | awk ' { print $3} '`
    if [[ -z "$bda_version" ]];
    then
      bda_version=`rpm -q bda|cut -d- -f2`
    fi
  fi
  bda_actual_version=$bda_version;
  if [[ -z "$bda_version" ]];
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="${program_name} did not find Big Data Appliance version from environment. Please set RAT_DB like export RAT_DB=2.2.0 and run $program_name again"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "${RED} ${program_name} did not find Big Data Appliance version from environment. Please set RAT_DB like export RAT_DB=2.2.0 and run $program_name again${NORM}"
    exit 1
  else
    if [[ ${#bda_version} -eq 5 ]];
    then
      bda_version=$bda_version'.0.0'
    elif [[ ${#bda_version} -eq 7 ]];
    then
      bda_version=$bda_version'.0'
    elif [[ ${#bda_version} -lt 5 || ${#bda_version} -gt 9 ]] 
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="Big Data Appliance version is not correct. Please set RAT_DB like RAT_DB=2.2.0 and run $program_name again"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "${RED} Big Data Appliance version is not correct. Please set RAT_DB like RAT_DB=2.2.0 and run $program_name again${NORM}"
      exit 1
    fi
    BDACLI=`which bdacli`
    bda_version_int=$(echo $bda_version|sed 's/\.//g')
    if [[ $bda_version_int -gt 44000 ]];then
      bda_version='4.4.0.0.0'
    fi
    if [[ $bda_version_int -ge 46300 ]];then
      bda_server_type=`$BDACLI getinfo server_type 2>/dev/null`
      is_server_in_cluster=`$BDACLI getinfo server_in_cluster 2>/dev/null`

      if [[ $bda_server_type == "BDCS_VM" ]];then
        is_bda_domu=1
      elif [[ $bda_server_type == "BDCS_HOST" ]];then
        is_bda_dom0=1
      fi

      if [[ $is_server_in_cluster == "yes" ]];then
        bda_in_cluster=1
      fi
    else
      if [[ -f "/opt/oracle/bda/network.json" ]];then
        bda_cmd_output=`/opt/oracle/bda/bin/json-select  --jpx="BDADEPLOY/HOSTENV" /opt/oracle/bda/network.json`
        if [[ $bda_cmd_output == "DOM0" ]];then
          is_bda_dom0=1
        elif [[ $bda_cmd_output == "DOMU" ]];then
          is_bda_domu=1
        elif [[ -z $bda_cmd_output ]];then
          bda_cmd_output=`/opt/oracle/bda/bin/json-select  --jpx="BDADEPLOY/IS_VM" /opt/oracle/bda/network.json`
          if [[ $? -eq 0 ]];then
            #Then its a BDA domU
            echo
          else
            #baremetal
            echo
          fi
        fi
      else
        echo
        #baremetal
      fi
    fi
    #B 
    if [[ $is_bda_dom0 == 1 ]];then
      localonly=1
      bda_in_cluster=0
    fi
    if [[ -f "/opt/oracle/bda/install/state/config.json" ]];then
      bda_in_cluster=1
    else
      bda_in_cluster=0
    fi
  fi
 #Since there are no version dependent checks, hard coding version to latest version so dont have to add new versions to checks
 short_bda_version=$(echo $bda_version|sed 's/[^0-9\.]//g'|sed 's/\.//g')  
 if [[ -n "$short_bda_version" && $short_bda_version -gt 44000 ]];then bda_version="4.4.0.0.0";fi
  if [ $upgrade_mode -gt 0 ]
  then
    echo -e "${RED}Checking upgrade best practices are not supported by ${program_name} for Big Data Appliance ${NORM}"
    exit 1
  fi

  if [ $TYP = "-p" ]
  then
    echo -e "${RED}Patch recommendations are not supported by ${program_name} for Big Data Appliance ${NORM}"
    exit 1
  fi

}

generate_zfssa_node_info ()
{
 cnlist_file="$OUTPUTDIR/o_host_list.out"
 hostname|cut -d. -f1>$cnlist_file
 zfssa_version="1.0.0.2.0"
 components=$(echo ${user_components}:ZFSSA)
  if [ -n "$RAT_ZFS_NODES" ]
  then  
    for zfsname in `echo $RAT_ZFS_NODES`
    do    
      echo "$zfsname">>$OUTPUTDIR/zfsip.ora
    done  
    ZFSIP=$OUTPUTDIR/zfsip.ora
  elif [[ $is_opc -eq 1 && -n $OPC_ZFS_CREDFILE && -r $OPC_ZFS_CREDFILE ]] ; then
    RAT_ZFS_NODES=`cat $OPC_ZFS_CREDFILE |awk -F"|" '{print $1}'`;
  fi
  if [[ -n "$is_opc" && $is_opc -eq 1 ]] ; then
    zfssa_version="14.1.15.0.0"
  fi
}

function generate_bda_node_info()
{
  if [ $OFFLINE -eq 0 ]
  then
    cnlist_file="$OUTPUTDIR/o_host_list.out"
    swlist_file="$OUTPUTDIR/o_ibswitches.out"
    HOSTLIST=$cnlist_file

    if [ -n "$RAT_CLUSTERNODES" ]
    then
      rm -f $HOSTLIST
      for nodename in `echo $RAT_CLUSTERNODES`
      do
        echo $nodename>>$HOSTLIST
      done
    else 
      if [ $is_bda_dom0 -eq 1 ]
      then
          bda_nodes=$(hostname -s)
      elif [[ -f /opt/oracle/bda/install/state/config.json ]];
      then
       bda_nodes=`/opt/oracle/bda/bin/bdacli getinfo cluster_node_names`
      elif [[ -f /opt/oracle/bda/install/state/mammoth-saved.params ]];
      then
        bda_nodes=`grep -m 1 "NODE_NAMES" /opt/oracle/bda/install/state/mammoth-saved.params | sed 's/.*=(//' | sed 's/)//'`
      else
        if [[ -f /opt/oracle/bda/BdaDeploy.json ]];
        then
          bda_nodes=`/opt/oracle/bda/bin/json-select --jpx=BONDETH0_NAMES /opt/oracle/bda/BdaDeploy.json`
        elif [[ -f /opt/oracle/bda/network.json ]];
        then
          bda_nodes=`/opt/oracle/bda/bin/json-select --jpx=BDADEPLOY/SERVERS/CLIENT_NETWORK/NAME /opt/oracle/bda/network.json`
        else
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="Network is not configured on this Big Data Appliance. Please configure the network and run $program_name again"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e "${RED}Network is not configured on this Big Data Appliance. Please configure the network and run $program_name again${NORM}"
          exit 1
        fi
      fi
      if [[ $bda_in_cluster -eq 1 ]];then
        bda_nodes=`$BDACLI getinfo cluster_node_names`
      fi
      if [[ -z "$bda_nodes" ]];
      then
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
	  EMSG="Unable to determine compute nodes in Big Data Appliance. Please set RAT_CLUSTERNODES like RAT_CLUSTERNODES=node1,node2 and run $program_name again"
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
        echo -e "${RED}Unable to determine compute nodes in Big Data Appliance. Please set RAT_CLUSTERNODES like RAT_CLUSTERNODES=node1,node2 and run $program_name again${NORM}"
        exit 1
      else
        rm -f $cnlist_file
        touch $cnlist_file
        for nodename in `echo $bda_nodes`
        do
          echo $nodename>>$cnlist_file
        done 
      fi
    fi

    if [ -n "$RAT_IBSWITCHES" ];
    then
      rm -f $swlist_file
      touch $swlist_file
      for switchname in `echo $RAT_IBSWITCHES`
      do
       	echo "$switchname">>$swlist_file
      done
    fi
    #else
    #    rm -f $swlist_file
    #    touch $swlist_file
    #    /usr/sbin/ibswitches|egrep -wi 'IB|GW'|cut -d'"' -f2|awk '{print $6}'|grep -vw localhost|cut -d' ' -f1>$swlist_file
    #    if [ -s $swlist_file ];
    #    	then
    #        	echo ""
    #    else
    #		echo "Failed to get infiniband gateway switch names. Please set RAT_IBSWITCHES like RAT_IBSWITCHES=switch1,switch2 and run $program_name. Skipping infiniband gateway switches for this run.";
    #        	touch $swlist_file		
    #    fi
    #fi

    echo "IS_BDA_MACHINE = $is_bda_machine" >> $MASTERFIL
    echo "BDA_VERSION = $bda_version" >> $MASTERFIL
    echo "BDA_ACTUAL_VERSION = $bda_actual_version" >> $MASTERFIL
    echo "BDA_IDENTIFIER = $bda_identifier" >> $MASTERFIL
  else
    is_bda_machine=`grep IS_BDA_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`
    bda_version=`grep BDA_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
    bda_actual_version=`grep BDA_ACTUAL_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
    bda_identifier=`grep BDA_IDENTIFIER $DUMPDIR/$CHKFIL | awk '{print $3}'`
  fi
}

function write_fmw_comps_prerun ()
{
  if [[ `echo "$single_node_idm" | grep -icw 'Y'` -eq 0 ]]; then
    for idmhname in `cat $IHOSTLIST`
    do
      for oud in "${OUD[@]}"
      do
        if [[ "$idmhname" = "$oud" ]]; then
          fmw_comps_running="$fmw_comps_running:OUD";
          break;
        fi
      done
      for oim in "${OIM[@]}"
      do
        if [[ "$idmhname" = "$oim" ]]; then
          fmw_comps_running="$fmw_comps_running:OIM";
          break;
        fi
      done
      for oam in "${OAM[@]}"
      do
        if [[ "$idmhname" = "$oam" ]]; then
          fmw_comps_running="$fmw_comps_running:OAM";
          break;
        fi
      done
      #for ohs in "${OHS[@]}"
      #do
      #  if [[ "$idmhname" = "$ohs" ]]; then
      #    fmw_comps_running="$fmw_comps_running:OHS";
      #    break;
      #  fi
      #done
      echo "$idmhname.FMW_RUNNING_COMPS = $fmw_comps_running" >> $MASTERFIL
      unset fmw_comps_running
    done
  else
    #echo "$localnode.FMW_RUNNING_COMPS = :OIM:OAM:OUD:OHS" >> $MASTERFIL
    echo "$localnode.FMW_RUNNING_COMPS = :OIM:OAM:OUD" >> $MASTERFIL
    unset fmw_comps_running
  fi
}

function read_opc_topology ()
{
  if [[ $EM_PROBE_MODE -eq 1 ]]; then return; fi
  echo "IS_OPC = 1" >> $MASTERFIL
  echo $localnode > $HOSTLIST
  is_this_db_machine $localnode
  # Reset values set by above function
  opc_machine_type="GUEST"
  xm info >/dev/null 2>&1
  if [ $? -ne 0 ] ; then
    opc_machine_type="ADMIN"
  fi
  echo "OPC_MACHINE_TYPE = $opc_machine_type" >> $MASTERFIL
  db_machine_compute=0
  if [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]] ; then
    components=OPCZFSSA
  else
    components=OPC$EXADATA_VERSION$opc_machine_type
  fi
  echo  
  echo "Running Oracle Public Compute healthchecks";
  echo  

  ZFSSAAKSHSCRIPT=$ZFSAKSHSCRIPT
  export IS_OPC=1
  export RAT_CREATE_CLOUD_JSON=1
  export RAT_SEND_TO_RSYSLOG=1
  #export RAT_NO_COMPONENTS_FILTER=1
  #cp -f $SCRIPTPATH/.cgrep/ipmitool $TMPDIR/
  #chmod +x $TMPDIR/ipmitool
  cp -f $SCRIPTPATH/.cgrep/ipmitool $RTEMPDIR/
  chmod +x $RTEMPDIR/ipmitool
  megacli_found=0
  if [ -x /opt/MegaRAID/MegaCli/MegaCli64 ] ; then megacli_found=1; fi
  if [ -x /opt/MegaRAID/storcli/storcli64 ] ; then megacli_found=1; fi
  if [ -z  "$RAT_NONEWRPMS_INTERNAL" ]
  then
      nvme_disks_to_install_rpm=$(/sbin/lspci -d 144d:a821 2>/dev/null|wc -l)
      oracle_hmp_tools_installed=$(/bin/rpm -q oracle-hmp-tools 2>&1 >/dev/null;echo $?)
      #oracle_hmp_tools_installed = 1 means not installed
      oracle_hmp_libs_installed=$(/bin/rpm -q oracle-hmp-libs 2>&1 >/dev/null;echo $?)
      #oracle_libs_tools_installed = 1 means not installed
      sas2ircu_rpm_installed=$(/bin/rpm -q sas2ircu 2>&1 >/dev/null;echo $?)
      sas_lsi_cards=$(/sbin/lspci|egrep -wq 'LSISAS2004|LSISAS2008|LSISAS2108|LSISAS2208|LSISAS2304|LSISAS2308';echo $?)
      if [[ $components = "OPCX4-GUEST" || $components = "OPCX4-ADMIN" ]]; then opc_x4_system=1;else opc_x4_system=0;fi
      if [ $megacli_found -eq 0 ] ; then
	echo "Installing storcli.." |tee -a $LOGFIL
	/bin/rpm -UvH $SCRIPTPATH/.cgrep/storcli-1.09.16-1.noarch.rpm
        if [ $? -eq "1" ]; then echo -e "Failed to install storcli-1.09.16-1.noarch.rpm"|tee -a $LOGFIL; fi   
      fi
      if [[ $opc_x4_system -eq 1 &&  $sas_lsi_cards -eq 0  &&  $sas2ircu_rpm_installed -eq 1 ]]
      then
	  echo "Installing sas2ircu rpm.." |tee -a $LOGFIL
          /bin/rpm -UvH $SCRIPTPATH/.cgrep/sas2ircu-15.0-1.el6.nux.x86_64.rpm
          if [ $? -eq "1" ]; then echo -e "Failed to install sas2ircu-15.0-1.el6.nux.x86_64.rpm"|tee -a $LOGFIL; fi   
      fi
      if [[ ! -f "/usr/sbin/nvmeadm" && $oracle_hmp_libs_installed -eq 1 &&  $nvme_disks_to_install_rpm -gt 0 ]]
      then
          echo "Installing  oracle-hmp-libs rpm.." |tee -a $LOGFIL
          /bin/rpm -UvH $SCRIPTPATH/.cgrep/oracle-hmp-libs-2.3.8.0-1.el6.x86_64.rpm
          if [ $? -eq "1" ]; then echo -e "Failed to install oracle-hmp-libs-2.3.8.0-1.el6.x86_64.rpm"|tee -a $LOGFIL; fi   
      fi
      if [[ ! -f "/usr/sbin/nvmeadm" && $oracle_hmp_tools_installed -eq 1 && $nvme_disks_to_install_rpm -gt 0 ]]
      then
          echo "Installing  oracle-hmp-tools rpm.." |tee -a $LOGFIL
          /bin/rpm -UvH $SCRIPTPATH/.cgrep/oracle-hmp-tools-2.3.8.0-1.el6.x86_64.rpm
          if [ $? -eq "1" ]; then echo -e "Failed to install oracle-hmp-tools-2.3.8.0-1.el6.x86_64.rpm"|tee -a $LOGFIL; fi   
      fi
      if [[ ! -f "/usr/bin/expect" && -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]]
      then
	/bin/rpm -q expect- >/dev/null 2>&1
	if [ $? -eq "1" ] ; then
	  echo "Installing expect.." |tee -a $LOGFIL
	  /bin/rpm -UvH $SCRIPTPATH/.cgrep/expect-5.45-3.fc15.x86_64.rpm 
          if [ $? -eq "1" ]; then echo -e "Failed to install expect-5.45-3.fc15.x86_64.rpm"|tee -a $LOGFIL; fi   
	fi
      fi
  fi
}

function read_fmw_topology ()
{
  if [[ $EM_PROBE_MODE -eq 1 ]]; then return; fi

  if [ $is_fmw_machine -eq 1 ] ; then
    echo 
    echo "Running Oracle Identity Management healthchecks..";
    echo 
    fmw_version=11.1.2.0.0
    echo "IS_FMW_MACHINE = $is_fmw_machine" >> $MASTERFIL
    echo "FMW_TOPOLOGY = $fmw_topology" >> $MASTERFIL
    echo "FMW_CREDCONFIG = $fmw_credconfig" >> $MASTERFIL
    echo "FMW_RUNMODE = $fmw_runmode" >> $MASTERFIL
    echo "FMW_RUN_COMPS = $fmw_run_comps" >> $MASTERFIL
    echo "FMW_EXCLUDE_COMPS = $fmw_exclude_comps" >> $MASTERFIL
    if [[ -n "$fmw_runmode" ]] ; then
      if [ $fmw_runmode = "pre" ] ; then components=IDMPREINSTALL; fi
      if [ $fmw_runmode = "post" ] ; then components=IDMPOSTINSTALL; fi
      if [ $fmw_runmode = "runtime" ] ; then components=IDM; fi
    else
      #components=IDMPOSTINSTALL
      components=IDM
    fi

    if [[ $fmw_runmode = "pre" ]]; then
      if [[ -n "$RAT_PREINSTALL_IDMVERSION" ]]; then
        fmw_version=$RAT_PREINSTALL_IDMVERSION 
      else
        fmw_version=11.1.2.3.0
      fi
      echo "IDM_VERSION = $fmw_version" >> $MASTERFIL
      write_fmw_comps_prerun
    else    
      echo "$localnode.COMPONENT = $components">>$MASTERFIL
      localnode=`hostname | tr "[A-Z]" "[a-z]"|cut -d. -f1|tr -d '\r'`
      cp -f $fmw_topology $OUTPUTDIR
      xml2kv $fmw_topology $OUTPUTDIR/topology_kv.out
      echo $localnode > $HOSTLIST
      #grep 'topology.machines.machine.id=".*".name = ' $OUTPUTDIR/topology_kv.out | grep -v instances | grep name |grep -v $localnode |sort -u | sed 's/.* = //' |cut -d. -f1 >> $HOSTLIST
      grep 'topology.machines.machine.id=".*".name = ' $OUTPUTDIR/topology_kv.out | grep -v instances | grep name |grep -v $localnode |sort -u | sed 's/.* = //' |cut -d. -f1 >> $HOSTLIST.itmp
      
      for tmp_host in `cat $HOSTLIST.itmp`
      do
        node_pingable "$tmp_host"
        if [[ -n "$pingable" && $pingable -eq "1" ]] ; then
	  echo "$tmp_host" >> $HOSTLIST
        fi
      done
      if [[ -e $HOSTLIST.itmp ]]; then rm -rf $HOSTLIST.itmp >/dev/null 2>&1; fi

      get_fmw_version
    fi
    fmw_components=$components;
  fi
}

function bda_machine_type()
{
  if [[ $is_bda_machine -ne "1" ]]; then return; fi
  if [ $OFFLINE -eq 0 ]
  then
    if [ -z "$platform" ]; then platform=$(uname -s);fi;
    sunfire_x4270m2=0
    sunfire_x4270m3=0
    
    if [ $platform = "Linux" ]
    then
      if [ "$1" = "$localnode" ]
      then
        #no_of_cores=$(cat /proc/cpuinfo | grep -w "processor"|wc -l)
        no_of_cores=$(grep -w "processor" /proc/cpuinfo | wc -l | tr -d ' ')
        bda_platform=$(uname -p)
      else
        no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 "cat /proc/cpuinfo | grep -w \"processor\"|wc -l|tr -d ' '")
        bda_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
      fi
    else
      if [ "$1" = "$localnode" ]
      then
        no_of_cores=$(/sbin/psrinfo|wc -l|tr -d ' ')
        bda_platform=$(uname -p)
      else
        no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 "/sbin/psrinfo|wc -l|tr -d ' '")
        bda_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
      fi
    fi
    
    if [[ $is_bda_dom0 -eq 1 || $is_bda_domu -eq 1 ]];then
      cpu_model=$(grep -wi "Intel(R)" /proc/cpuinfo|sort -u|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
      if [[ "$cpu_model" = "E5-2697v2" ]]
      then
        sunfire_x4270m2=1
        if [[ $is_bda_dom0 -eq 1 ]];then
          components=$(echo ${user_components}:VMBDAX2-2)
        fi
        if [[ $is_bda_domu -eq 1 ]];then
          components=$(echo ${user_components}:BDAVM)
        fi
      else 
        sunfire_x4270m3=1
        if [[ $is_bda_dom0 -eq 1 ]];then
          components=$(echo ${user_components}:VMBDAX3-2)
        fi
        if [[ $is_bda_domu -eq 1 ]];then
          components=$(echo ${user_components}:BDAVM)
        fi
      fi
    else
      if [[ $no_of_cores -eq 24 ]]
      then
        sunfire_x4270m2=1
        components=$(echo ${user_components}:BDAX2-2)
      
      elif [[ $no_of_cores -ge 32 ]]
      then
        sunfire_x4270m3=1
        components=$(echo ${user_components}:BDAX3-2)
      fi
    fi


    rdbms_installed[0]=0
    if [[ -f /opt/oracle/bda/install/state/mammoth-saved.params ]];
    then
      rdbms_installed[0]=1	
    fi
     
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
      echo "$1.RDBMS_INSTALLED = ${rdbms_installed[0]}">> $MASTERFIL;
    fi
  fi
}

check_if_exalytics()
{
  IMAGE_ID_FILE=/usr/lib/init-exalogic-node/.image_id
  IMAGE_HISTORY_FILE=/var/log/init-exalogic-node/.image_history
  IMAGEINFO=/opt/exalytics/bin/exalytics_imageinfo
  is_exalytics_machine=1
  RackIdentifier="";
  exalytic_version_actual="";
  exalytic_version_cn="";

  if [ -r /var/exalytics/info/em-context.info ]
  then
    #ipmi_system_identifier=$(cat /var/exalytics/info/em-context.info|grep -wi "system_identifier"|grep -iwc "exalytics")
    ipmi_system_identifier=$(grep -wi "system_identifier" /var/exalytics/info/em-context.info|grep -iwc "exalytics")
  else
    if [ -x /usr/bin/ipmitool ]
    then
        ipmi_system_identifier=$(/usr/bin/ipmitool sunoem cli force 2>/dev/null "show /SP system_identifier") 
    elif [ -x /usr/sbin/ipmitool ]
    then
       ipmi_system_identifier=$(/usr/sbin/ipmitool sunoem cli force 2>/dev/null "show /SP system_identifier") 
    #else
        #echo -e "${RED}${program_name} did not find ipmitool in /usr/bin or at /usr/sbin to discover type of engineered system.\n\n\n${program_name} is exiting ....${NORM}\n\n"
        #exit 1
    fi
    ipmi_system_identifier_exalytics=$(echo $ipmi_system_identifier|grep "system_identifier"|grep -cwi "exalytics")
  fi

  if [[ -n "$ipmi_system_identifier_exalytics" && "$ipmi_system_identifier_exalytics"  -eq 0 ]]; then is_exalytics_machine=0;fi
  dom0_node=0
  if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
  then
    dom0_node=1
  fi
  localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
  if [ $is_exalytics_machine -eq 1 ]
  then
    set_exalytics_env  
  fi
}

 
function set_exalytics_env ()
{
  html_rack_type="System"
  it_is_rac=0
  #checking for existance of binary to support solaris because ipmitool does not exists there
  if [ -e /usr/bin/ipmitool ]; then RackIdentifier=$(/usr/bin/ipmitool sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}');else RackIdentifier=$(/usr/sbin/ipmitool sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}');fi

  if [ -n "$RAT_DB" ]
  then
    exalytics_version_actual=$RAT_DB
  elif [ -e "$IMAGEINFO" ]
  then
    exalytics_version_actual=$($IMAGEINFO|grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
  elif [ -e "/usr/lib/init-exalogic-node/.emoc_version" ]
  then
    exalytics_version_actual=$(cat /usr/lib/init-exalogic-node/.emoc_version | cut -d= -f2 | sed "s/'//g")
  else
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="${program_name} did not find Exalytics version from environment. Please set RAT_DB like RAT_DB=1.0.0.5 and run $program_name again"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "${RED} ${program_name} did not find Exalytics version from environment. Please set RAT_DB like RAT_DB=1.0.0.5 and run $program_name again${NORM}"
    exit 1
  fi
  exalytics_version=$(echo $exalytics_version_actual |tr -d '.')
  #new command returns 4 digit version and all checks have five digit version so adding one more 0 to match system and check version
  if [[ `echo $exalytics_version|grep -ci 1005` -ge 1 ]]; then exalytics_version=10050;fi 
  if [[ `echo $exalytics_version|grep -ci 1006` -ge 1 ]]; then exalytics_version=10060;fi 
  if [[ `echo $exalytics_version|grep -ci 1007` -ge 1 ]]; then exalytics_version=10060;fi 
  if [[ `echo $exalytics_version|grep -ci 200` -ge 1 ]]; then exalytics_version=10060;fi 
  if [[ $exalytics_version -gt 1007 ]]; then exalytics_version=10060;fi

  components=$(echo ${components}:EXALYTICS)
  if [ $upgrade_mode -gt 0 ]
  then
    echo -e "${RED}Checking upgrade best practices are not supported by ${program_name} for Exalytics ${NORM}"
    exit 1
  fi

  if [ $TYP = "-p" ]
  then
    echo -e "${RED}Patch recommendations are not supported by ${program_name} for Exalytics ${NORM}"
    exit 1
  fi

  if [ $exalytics_version -lt 10050 ]
  then
    echo -e "${RED}\n\n${program_name} is not supported on Exalytics version $exalytics_version_actual ${NORM}\n\n"
    exit 1
  fi
}

function generate_exalytics_node_info ()
{
  echo $localnode>$OUTPUTDIR/o_host_list.out
  echo "$localnode.COMPONENT = $components">>$MASTERFIL 
  echo "EXALYTICS_VERSION = $exalytics_version" >>$MASTERFIL
  echo "EXALYTICS_VERSION_ACTUAL = $exalytics_version_actual" >>$MASTERFIL
  echo "IS_EXALYTICS_MACHINE = $is_exalytics_machine" >>$MASTERFIL
  echo "EXALYTICS_RACK_IDENTIFIER = $RackIdentifier" >> $MASTERFIL 
  rdbms_installed[0]=0
  ttx_installed[0]=0
  set_exalytics_bi_env
  read_exalytics_bi_env
  #-------------------TimesTen
  # added branch not to call timesten stuffs if profile is obiee
  if [ "$profiles2run" != "obiee" ]; then set_exalytics_tt_env;fi
  #---------------------------
}

#-------------------TimesTen
function set_exalytics_tt_env ()
{
  TTX_FILENAME="/etc/TimesTen/instance_info"

  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    MASTERFIL1=$OUTPUTDIR/check_env.out
  else
    MASTERFIL1=$OUTPUTDIR/raccheck_env.out
  fi

  TTX_TMPFILE=$MASTERFIL1

  if [[ -e $TTX_FILENAME && -s $TTX_FILENAME ]]
  then
    if [[ $OFFLINE -eq 0 ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]];
    then
      echo ""
      sed -e '/^#/d' -e '/./{H;$!d;}' -e 'x;/\[ [^ ]* \]/!d;/Product=/!d;/InstallDir=/!d' $TTX_FILENAME |
                        awk -v TMPFILE=$TTX_TMPFILE -v SILENT=$skip_in_silent 'BEGIN{
                                n=0;ret=1;
                        }
                        {
                                IGNORECASE=1;if($0~/^\[/) {n++;p=index($0," ]");inst[n]=substr($0,3,p-3)};
                                if($0~/^Product=/) {prod[n]=substr($0,17);if(prod[n]~/11.2.2/) prodOK[n]=1;}
                                if($0~/^InstallDir=/) instdir[n]=substr($0,12);
                                if($0~/^InstanceAdministrator=/) {admin[n]=substr($0,23);if(admin[n]=="oracle") adminOK[n]=1}
                                if($0~/^DaemonHome=/) dhome[n]=substr($0,12);
                                if($0~/^BitLevel=/) {bit[n]=substr($0,10);if(bit[n]=="64") bitOK[n]=1}
                                if($0~/^Component=/) {comp[n]=substr($0,11);if(comp[n]=="Client/Server and DataManager") compOK[n]=1;}
                        }
                        END{
				if (n>0) {
	                		printf "List of running TimesTen databases\n" > "/dev/stderr";
					printf "\n" > "/dev/stderr";
					printf "\n[BEGIN TIMESTEN BLOCK\n" >> TMPFILE;
				}
                                dbIdx=1;
                                printf "DBNAME=TTX_DBPATH | TTX_VERSION | TTX_INSTANCE_NAME | TTX_HOME | TTX_DAEMON_HOME\n" >> TMPFILE;
                                printf "--------------------------------------------------------------------------------\n" >> TMPFILE;
                                for(i=1;i<=n;i++) {
                                        m=0;
					cmd1="ls "dhome[i]"/DBI* 2>/dev/null"; while((cmd1 | getline dbif[m])>0) {m++}; close(cmd1);
					if (m>0) printf "\n+ installation [%s]:\t %s, %s\n",inst[i],prod[i],instdir[i];
                                        for(j=0;j<m;j++) {
						duplicateDB=0;dbiInst[j]="";
						s="";p=0;DBILINES=5;cmd2="/usr/bin/od -A n -S2 "dbif[j]" | head -n "DBILINES; cmd2 | getline dbiInst[j]; while(s!~/^\// && p<DBILINES) {p++;cmd2 | getline s}; if(s~/^\//) {dbiDBPath[dbIdx]=s} else {print "error parsing DBI file "dbif[j]}; close(cmd2);
						for(k=1;k<dbIdx;k++) { if (dbiDBPath[dbIdx] == dbiDBPath[k]) duplicateDB=1; }
						if (dbiDBPath[dbIdx]!="" && dbiInst[j]==inst[i] && duplicateDB!=1) {
							printf "[%d] database=%s\n",dbIdx,dbiDBPath[dbIdx];
       		                                        printf "%d. %s\n",dbIdx,dbiDBPath[dbIdx] > "/dev/stderr";
							printf "DBNAME%d=%s|%s|%s|%s|%s\n",dbIdx,dbiDBPath[dbIdx],prod[i],inst[i],instdir[i],dhome[i] >> TMPFILE;		
                        	                        dbIdx++;
						}
                                        }
                                }
				if (n>0) {
					aindex=dbIdx;
					printf "%d. %s\n",dbIdx,"All of Above" > "/dev/stderr";
					printf "%d. %s\n",dbIdx,"All of Above" >> TMPFILE; 
					dbIdx++;
					tindex=dbIdx;
					printf "%d. %s\n",dbIdx,"None of Above" > "/dev/stderr";
					printf "%d. %s\n",dbIdx,"None of Above" >> TMPFILE; 
					printf "\n" > "/dev/stderr";
					if (SILENT == 0) {
						printf "Select databases from list for checking best practices. For multiple databases, select %d for All or comma separated number like 1,2 etc [1-%d][%d].",aindex,tindex,aindex > "/dev/stderr";
					}
					printf "END TIMESTEN BLOCK]\n\n" >> TMPFILE;
				}
                        }' 2>&1 > /dev/null

      AINDEX=$(grep -i 'All of Above' $TTX_TMPFILE|awk -F"." '{print $1}');
      NINDEX=$(grep -i 'None of Above' $TTX_TMPFILE|awk -F"." '{print $1}');
      
      if [[ $skip_in_silent -eq 0 ]] && [[ $EM_PROBE_MODE -eq 0 ]] && [[ $EM_XMLD_MODE -eq 0 ]]
      then
      	exec 3<&2; exec 2<&0
      	$READ -p "" TTX_INPUT
	read_code=`echo $?`;
      	exec 2<&3
	write_in_env "TIMESTEN_CHECK_OPTION" "$TTX_INPUT"
	process_prompt "$read_code" "TTX_INPUT" "$AINDEX"
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
	read_probe_xml "List of running TimesTen databases"
 	TTX_INPUT=$xml_rvalue	
      else
      	TTX_INPUT=$AINDEX;
      fi
      echo ""
      
      case $TTX_INPUT in
      	[0-9]*)		
      	  SHOW_TTX=$TTX_INPUT		
      	  if [ "$TTX_INPUT" = "$AINDEX" ]; then SHOW_TTX='all'; write_in_env "TIMESTEN_CHECK_OPTION" "all"; fi 
      	  if [ "$TTX_INPUT" = "$NINDEX" ]; then SHOW_TTX='none'; write_in_env "TIMESTEN_CHECK_OPTION" "none"; fi 
      	  ;;
      	*)
      	  SHOW_TTX='all'		
	  write_in_env "TIMESTEN_CHECK_OPTION" "all"
      	  ;;
      esac
      echo "TTX_CHECKS = $SHOW_TTX">> $TTX_TMPFILE;
    fi
  
    bln=$(grep -n 'BEGIN TIMESTEN BLOCK' $TTX_TMPFILE|awk -F":" '{print $1}');
    eln=$(grep -n 'END TIMESTEN BLOCK' $TTX_TMPFILE|awk -F":" '{print $1}');
    
    if [[ $OFFLINE -eq 1 ]] || [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 && $RAT_RUNMODE_INTERNAL != "slave" ]]; then SHOW_TTX=`grep -i "TTX_CHECKS" $TTX_TMPFILE |awk '{print $3}'`; fi

    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      cat >> ${PROBE_XML}.tmp << EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="MULTI_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n38_nlsid">
        List of running TimesTen databases 
      </text>
    </context>
      <text nls_id="orhc_exadata_n8_nlsid">
        Select databases from list for checking best practices 
      </text>
    <options>
EOF
    fi
    
    if [ "$SHOW_TTX" != "none" ]; then
      O_IFS=$IFS
      IFS=$'\n'
      for LINE in `sed -n "$bln, $eln p" $TTX_TMPFILE`
      do
        i=`echo "$LINE" | awk '{t=-1;if(/^DBNAME[0-9]+=/) {p=index($0,"=");t=substr($0,7,p-7)};print t}'`
        if [ $i -ge 0 ]; then
      	  dbstr[$i]=`echo "$LINE" | awk '{p=index($0,"=");print substr($0,p+1);}'`
      	  ttx_dbpath[$i]=`echo "${dbstr[$i]}"| awk '{n=split($0,a,"|");print a[1]}'`
      	  ttx_version[$i]=`echo "${dbstr[$i]}" | awk '{n=split($0,a,"|");print a[2]}'`
      	  ttx_instance_name[$i]=`echo "${dbstr[$i]}" | awk '{n=split($0,a,"|");print a[3]}'`
      	  ttx_home[$i]=`echo "${dbstr[$i]}" | awk '{n=split($0,a,"|");print a[4]}'`
      	  ttx_daemon_home[$i]=`echo "${dbstr[$i]}" | awk '{n=split($0,a,"|");print a[5]}'`
      	  allDBIdxs="$allDBIdxs $i"

          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
            cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${i}">
        <text${ttx_dbpath[$i]}|${ttx_version[$i]}|${ttx_instance_name[$i]}|${ttx_home[$i]}|${ttx_daemon_home[$i]}</text>
      </option>
EOF
          fi
        fi
      done
      IFS=$O_IFS;

      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	i=$(expr ${i} + 1);
        cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${i}">
        <text nls_id="orhc_exadata_n4_nlsid">All</text>
      </option>
EOF
	i=$(expr ${i} + 1);
        cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${i}">
        <text nls_id="orhc_exadata_n3_nlsid">None</text>
      </option>
    </options>
  </question>
</group>
EOF
        PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
      fi

      if [ "$SHOW_TTX" == "all" ]; then
      	dbToCheck="$allDBIdxs"
      else
      	for j in $(echo $SHOW_TTX | sed 's/,/ /g'); do
      	  dbToCheck="$dbToCheck $j"
      	done
  	write_in_env "TIMESTEN_CHECK_OPTION" "$dbToCheck"	
      fi
    
      #--------------------------
      mb_ttx_db_counter=0
      if [ ${#mb_db_names[@]} -gt 0 ]; then mb_ttx_db_counter=${#mb_db_names[@]}; fi
      
      for d in $dbToCheck 
      do
      	ttx_installed[0]=1
      	mb_db_names[$mb_ttx_db_counter]=${ttx_dbpath[$d]}
      	echo ${ttx_home[$d]} >>$OUTPUTDIR/mb_db_homes_distinct.out
      	mb_ttx_db_counter=$(expr $mb_ttx_db_counter + 1)
      done
      #--------------------------
    
      #--------------------------
      mb_ttx_db_counter=0
      if [ ${#mb_oracle_homes_distinct[@]} -gt 0 ]; then mb_ttx_db_counter=${#mb_oracle_homes_distinct[@]}; fi
      
      for mb_db_home in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|sort -u;fi;`
      do
      	H_FOUND=0;
      	for homes in "${ttx_home[@]}"
      	do
      	  if [ $mb_db_home == $homes ]; then H_FOUND=1; fi
      	done
      
      	if [ $H_FOUND -eq 1 ]
      	then
      	  I_H_FOUND=0;
      	  for i_mb_db_home in ${mb_oracle_homes_distinct[@]}
      	  do
      	    if [ $i_mb_db_home == $mb_db_home ]
      	    then
      	      I_H_FOUND=1;
      	    fi
      	  done
      	  if [ $I_H_FOUND -eq 0 ]
      	  then
      	    mb_oracle_homes_distinct[$mb_ttx_db_counter]=$mb_db_home
      	    mb_ttx_db_counter=$(expr $mb_ttx_db_counter + 1)
      	  fi
      	fi
      done
      #-------------------------
      multiple_oracle_homes=$mb_ttx_db_counter
      mb_ttx_db_counter=0
    else
      dbToCheck=""
    fi
  fi
}

function set_exalytics_bi_env ()
{
  if [[ -e /etc/oraInst.loc || -e /u01/app/oracle/product/exalytics/config/domains.xml ]] && [ "$profiles2run" != "timesten" ] 
  then
    exalytics_reads_domains_xml  
    if [ -z "$RAT_BI_HOMES" ]
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="$program_name found OBIEE installation and RAT_BI_HOMES environment variable is not set.\nset RAT_BI_HOMES environment variable to comma separated list of BI homes installed on this system and re-run $program_name.\nlike export RAT_BI_HOMES=\"/u01/oracle/BIMachine,/u02/oracle/BIMachine\""
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "${RED}\n$program_name found OBIEE installation and RAT_BI_HOMES environment variable is not set.\n${NORM}"
      echo -e "${RED}\nset RAT_BI_HOMES environment variable to comma separated list of BI homes installed on this system and re-run $program_name.\n${NORM}"
      echo -e "${RED}\nlike export RAT_BI_HOMES=\"/u01/oracle/BIMachine,/u02/oracle/BIMachine\"\n${NORM}"
      exit 1
    else      
      log_env_varaibles "RAT_BI_HOMES" "$RAT_BI_HOMES" "1"
      for mb_db_home in $RAT_BI_HOMES
      do
        bi_home_all_instances=""
        if [ -e "$mb_db_home/instances" ] 
        then 
          if [ -e "$mb_db_home/Oracle_BI1/bifoundation/version.txt" ]
          then
            bi_home_version=$(grep -i 'Release Version: Oracle Business Intelligence' "$mb_db_home/Oracle_BI1/bifoundation/version.txt"|sed 's/Release Version: Oracle Business Intelligence//g'|sed 's/ //g')
            echo "OBIEE Release Version: $mb_db_home = $bi_home_version" >> $MASTERFIL 
          fi
          if [ -d "$mb_db_home/instances" ]
          then
            for bi_instance in $(ls -l "$mb_db_home/instances"|grep ^d|awk '{print $NF}')
            do
       	     bi_home_all_instances=$bi_instance","$bi_home_all_instances;
            done	
            bi_home_all_instances=$(echo $bi_home_all_instances|sed 's/,$//g');
            echo "OBIEE_INSTANCE_MAP: $mb_db_home = $bi_home_all_instances" >> $MASTERFIL
          fi
          echo $mb_db_home >>$OUTPUTDIR/mb_db_homes_distinct.out
        else
          echo -e "\n${RED} ${mb_db_home} is not valid path for OBIEE home so skipping for checking best practices\n${NORM}"|tee -a $LOGFIL 
        fi 
      done
    fi
  fi
}

function read_exalytics_bi_env ()
{
  mb_db_counter=0
  for mb_db_home in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|sort -u;fi;`
  do
    rdbms_installed[0]=1
    mb_oracle_homes_distinct[$mb_db_counter]=$mb_db_home
    mb_db_counter=$(expr $mb_db_counter + 1)
  done 
  if [[ $OFFLINE -eq 0 ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then echo "$localnode.RDBMS_INSTALLED = ${rdbms_installed[0]}">> $MASTERFIL;fi   
  multiple_oracle_homes=$mb_db_counter
  mb_db_counter=0
}

function discover_ssc_zfs_nodes ()
{
  if [ -n "$RAT_ZFS_NODES" ]
  then
    for zfsname in `echo $RAT_ZFS_NODES`
    do
      echo "$zfsname">>$OUTPUTDIR/zfsip.ora
    done
    ZFSIP=$OUTPUTDIR/zfsip.ora
  else
    is_ssc_zfsnodes_passed=0
    return
    #ssc_zfs_appliances=$(cat /etc/hosts|grep sn[1-2]|grep -v ilom|awk '{print $1}'|sed 's/#//g')
    ssc_zfs_appliances=$(grep -w storadm /etc/hosts|grep -v ilom|awk '{print $1}'|sed 's/#//g')
    if [ -z "$ssc_zfs_appliances" ]; then ssc_zfs_appliances=$(grep h[1-2] /etc/hosts|egrep -v ilom    |awk '{print $1}'|sed 's/#//g');fi
    for zfsname in `echo $ssc_zfs_appliances`
    do
      echo "$zfsname">>$OUTPUTDIR/zfsip.ora
    done
    ZFSIP=$OUTPUTDIR/zfsip.ora
  fi
  if [[ ! -s $ZFSIP && $profiles2exclude != "zfs" ]]
  then
    echo -e ${RED}"\n\n$program_name could not discover ZFS Storage Appliance.\n\nPlease use -zfsnodes command line option\n\n"${NORM}
    echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
    exit 1
  fi
}

function generate_zfs_checks_aksh()
{
    # List of check files
    aksh=""
    erroneous=false
    ZFSCHECKSDIRECTORY="$SCRIPTPATH/.cgrep/zfschecks"
 
     for checkname in chkCommonCode $ZFSCHECKSTORUN; do
         # Check if the check file exists (remove "chk" in checkname)        
         checkfile=$ZFSCHECKSDIRECTORY/${checkname#chk}
         if [[ -f $checkfile ]]; then
             # Append filename to aksh
             aksh="$aksh $checkfile"
         else
             echo "Error: The check file $checkfile does not exist. " >> $ERRFIL
             #erroneous=true
             #break       
         fi
     done
 
     if [[ $erroneous = false ]]; then
         # Print the aksh content
         echo "script" >> $1
         if [  -n "$aksh" ] ; then
           cat $aksh >> $1
         fi
         echo "." >> $1
     fi
}

function write_var
{
  TOR_SWITCH_VAR_FILE=$OUTPUTDIR/tor_switch_vars.out
  if [[ -f $TOR_SWITCH_VAR_FILE ]]; then
      rm $TOR_SWITCH_VAR_FILE
  fi
  while [ "$1" != "" ]; do
      var=$1
      echo "$var=${!var}" >> $TOR_SWITCH_VAR_FILE
      shift
  done
}

function generate_zfs_aksh
{            
  touch $OUTPUTDIR/zfsexcl.txt
  cat $OUTPUTDIR/cmdexfil.txt $EXCLUDEFIL 2>/dev/null |sort -u > $OUTPUTDIR/zfsexcl.txt 

  ZFSCHECKSTORUN=`$perl_exe $SCRIPTPATH/.cgrep/get_zfs_checks.pl $INPUTDIR/collections.dat -needs_running "$1" -excludefile $OUTPUTDIR/zfsexcl.txt 2>>$ERRFIL`
  if [[ $1 == "ZFS" ]]; then
    generate_zfs_checks_aksh $OUTPUTDIR/$ZFSGENERATEDAKSHFILE
    ZFSAKSHSCRIPT=$OUTPUTDIR/$ZFSGENERATEDAKSHFILE
    ZFSSAAKSHSCRIPT=$OUTPUTDIR/$ZFSGENERATEDAKSHFILE
  elif [[ $1 == "EXTERNAL_ZFS" ]]; then
    generate_zfs_checks_aksh $OUTPUTDIR/$EXTZFSGENERATEDAKSHFILE 
    EXTZFSAKSHSCRIPT=$OUTPUTDIR/$EXTZFSGENERATEDAKSHFILE
  fi
}        

function execute_zfs_collection ()
{
  if  [[ $OFFLINE -eq 0 && $zfs_password_status -ne 3 ]]
  then
    if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
    if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $1 ]]  
    then
      #cat $IBSWITCHSCRPT
      #$READ -p "good to run"
      if [ ! -e $CELLDIR ];then mkdir $CELLDIR >/dev/null 2>&1;fi
      cp -f $1 $CELLDIR 2>/dev/null 2>&1
      
      root_zfs_counter=0
      no_of_cells=$(wc -l $1 |awk '{print $1}'|tr -d ' ')
      no_of_cells=$(expr $no_of_cells - 1);
      in_last_cell=0
      last_cell_name=""
      if [[ ! -n "$RAT_ZFS_RUNMODE" ]] ; then RAT_ZFS_RUNMODE="parallel"; fi;
      for cellname in `cat $1|cut -d= -f2|sed 's/"//g'` 
      do
        test_node_reachability "$cellname" "$zfs_ssh_user";
	if [ $el_node_ping -eq "1" ] ; then
	  cellPingStatus=0;
	else
	  cellPingStatus=1;
	fi     
        
        if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq 0 && ! -n "${a_zfs_rootpassword[$root_zfs_counter]}" ]]
        then
          cellPingStatus=1;
        fi
        if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
        then
          noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $cellname)
          if [[ $no_of_cells -eq $root_zfs_counter ]] ; then last_cell_name=$cellname; in_last_cell=1; fi
          cell_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
          if [ $noPasswordAvailable -eq 0 ]
          then
            if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] ; then
              echo -e "\n${GREEN}Starting to run $zfs_ssh_user privileged commands in background on ${BLINK}ZFS Storage Appliance $cellname ${NORM}\n"
	      echo -e "\nStarting to run $zfs_ssh_user privileged commands in background on ${BLINK}ZFS Storage Appliance${NORM} $cellname\n" >> $LOGFIL
            else
              echo -e "\nPreparing to run $zfs_ssh_user privileged commands on ${BLINK}ZFS Storage Appliance${NORM} $cellname\n"
            fi
            if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq 0 ]]
            then 
              zfs_rootpassword=${a_zfs_rootpassword[$root_zfs_counter]}
            fi			      

            cell_type="zfscell"
            zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]] ; then
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$cellname" "$zfs_ssh_user" "$zfs_rootpassword" "1"  "$cell_type"
            else
              passwordCheckStatus=0
            fi
            if [[ $passwordCheckStatus -eq 0 ]]
            then
              rm -f $RTEMPDIR/zfscell.pid
              cr_name=$RTEMPDIR/${program_name}_${cellname}_cells.sh
  	      security_fix "check_and_fix_script_existence" "$cr_name"
              echo "#!/bin/env bash" > $cr_name
              echo "$RAT_DEBUG_FLG" >> $cr_name
              echo "echo \$\$ > $RTEMPDIR/zfscell.pid" >> $cr_name
              echo "$SSHELL $zfs_ssh_user@$cellname < $2 > $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out" >> $cr_name
              #chmod +x $cr_name
     	      security_fix "fix_plugin_or_rtscript_attributes" "$cr_name" "" "540"
      
	      local_cr_name=$RTEMPDIR/.${program_name}_${cellname}_conf.aksh
  	      security_fix "check_and_fix_script_existence" "$local_cr_name"
	      #echo "$SSHELL $zfs_ssh_user@$cellname configuration preferences set session_annotation=\"${program_name}_session\" <<EOF
#script printf('\\\\n'); printf('\\\\n%s\\\\n',run('configuration version get product'))
#EOF" > $local_cr_name
              echo "$SSHELL $zfs_ssh_user@$cellname <<CFSA
             script printf('\\\\n'); printf('\\\\n%s\\\\n',run('configuration version get product')); printf('%s', run('configuration preferences set session_annotation=\"${program_name}_session\"'));
              CFSA" > $local_cr_name 
	      #chmod +x $local_cr_name
     	      security_fix "fix_plugin_or_rtscript_attributes" "$cr_name" "" "540"

	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              fixRootPassword "$zfs_rootpassword"
              #code to verify that its ZFS storage
              zfs_node_config=$($EXPECT -f - << IBEOF
                            set timeout $passwordcheck_timeout
	      		    set le_zfs_password "$fixedRootPassword"
	      		    #log_user 0
                            if { "$RAT_EXPECT_DEBUG" == "-d" } {
                              exp_internal 1
                            } 
	                    spawn -noecho $bash_scr $local_cr_name
	      		    match_max 100000
	      	       	    expect {
	      		      -nocase "permission denied *" {
	      		      exit 4;
	      	            }
	      	      	      -nocase "no)?" {
	      		      send -- "yes\n"
	      	            }
	      	              -nocase "*?assword:*" {
	      		      send -- "\$le_zfs_password\n"
	      	            }
	      	      	      -nocase eof {
	      		      exit
	      	            }
	      	    	    }
	      	    	    # Look for passwd prompt
	      	    	    expect {
	      	    	      -nocase "*?assword:*" {
	      	    	        send -- "\$le_zfs_password\n"
	      	    	      }
	      	    	      # Stop the on logon tests and if asked to connect to master switch choose no
	      	    	      -nocase eof {
	      	    	        exit
	      	    	      } -nocase timeout {
	      	    	        send_error "Timed out while running collections on $cellname\n";
	      	    	        exit
	      	    	      }
	      	    	    }
	      	    	    expect -nocase eof
IBEOF
)
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              #zfs_node_config_valid=$(echo "$zfs_node_config"|grep -wc "ZFS Storage")   
              zfs_node_config_valid1=$(echo "$zfs_node_config"|grep -vwi 'session_annotation'|grep -wc "ZFS Storage")   
              zfs_node_config_valid2=$(echo "$zfs_node_config"|grep -vwi 'session_annotation'|grep -c "Sun Storage 7")   
   	      #code to verify that its zfs storage ends here
              if [[ $zfs_node_config_valid1 -ge 1 || $zfs_node_config_valid2 -ge 1 ]]
              then
	        if [ -z "$RAT_ZFS_ROOT_TIMEOUT" ]; then
	          #Default is 20mins
	          zfs_wakeup_root=1200
	        else
	          zfs_wakeup_root=$RAT_ZFS_ROOT_TIMEOUT
	        fi

		if [[ -n "$zfs_ssh_status" && $zfs_ssh_status -eq "0" && $passwordCheckStatus -eq 0 ]]
		then
		  zfs_aksh_timeout=$zfs_wakeup_root
		else
		  zfs_aksh_timeout=$passwordcheck_timeout
		fi

		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	        $EXPECT -f - << IBEOF &
	         #set timeout $passwordcheck_timeout
	         set timeout $zfs_aksh_timeout
	         set le_zfs_rootpassword "$fixedRootPassword"
	         log_user 0
	         if { "$RAT_EXPECT_DEBUG" == "-d" } {
	           exp_internal 1
	         }
	         spawn $cr_name
	         match_max 100000
	           expect {
	         -nocase "permission denied *" {
	           exit 4;
	         }
	         -nocase "no)?" {
	           send -- "yes\n"
	         }
	         -nocase "*?assword:*" {
	           send -- "\$le_zfs_rootpassword\n"
	         }
	         -nocase eof {
	           exit
	         }
	         }
	         # Look for passwd prompt
	         #expect -nocase "*?assword:*"
	         #send -- "\$le_zfs_rootpassword\n"
	         #set timeout $watchdog_wakeup_root
	         set timeout $zfs_wakeup_root
	         expect { 
	 	   -nocase "*?assword:*" {
		     send -- "\$le_zfs_rootpassword\n"
		   }
	           -nocase eof {
	              exit
	           } 
	           -nocase timeout {
	              send_error "\nTimed out while running collections on $cellname\n";
	              exit
	           }	
	         }
IBEOF
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	        sleep 2 # Wait till pid file gets created
	        zcell_pid=$(cat $RTEMPDIR/zfscell.pid)
	        if [ -n "$zcell_pid" ]
	        then # wait till we finish collection running on cell
	          #Not in control of watchdog.
	          touch $RTEMPDIR/nowatch.pid
	          echo "$zcell_pid" >>  $RTEMPDIR/nowatch.pid
	          if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] ; then
	            cell_pids[$zcell_pid]="$zcell_pid";
	            cell_pid_names[$zcell_pid]="$cellname"
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	            cell_root_password[$zcell_pid]="$cell_rootpassword"
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	          else
	            keep_looping=1
	            while [ $keep_looping -eq "1" ]
	            do
	              if [ `ps -ef | grep _cells.sh |grep -c $zcell_pid` -gt 0 ]
	              then
	                if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ;
	                then
	                  printf ". "
	                fi
	              else
	                break
	              fi
	              sleep 2
	            done
	          fi
	        fi 
              else
                echo -e "\n${RED}Skipping $zfs_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} because its not valid Sun ZFS Storage .${NORM}\n"|tee -a $LOGFIL
                add_to_skipped_nodes "${cellname}" "Not valid Sun ZFS Storage" 
                grep -vw "$cellname" $1 > $CELLDIR/cellip.ora.bk
                mv -f $CELLDIR/cellip.ora.bk $1
              fi # end of if [ $zfs_node_config_valid -ge 1 ]
	    fi   # end of if [[ $passwordCheckStatus -eq 0 ]] 
	  else
	    echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
	  fi #end of if [ $noPasswordAvailable -eq 0 ]
          if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
          then
            cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
            collect_duration "$CELLDIR/c_root_collect_timing.out" "$COLLECT_TIMING"
            rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
          elif [[ -e $CELLDIR_SHORT/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
          then
            cat $CELLDIR_SHORT/c_root_collect_timing.out >> $COLLECT_TIMING
            collect_duration "$CELLDIR_SHORT/c_root_collect_timing.out" "$COLLECT_TIMING"
            rm -f $CELLDIR_SHORT/c_root_collect_timing.out  >/dev/null 2>&1
          fi
        else 
	  if [[ $ssh_go_ahead = 0 ]]
	  then
	    echo -e "\n${RED}Skipping $zfs_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but ssh took too long.${NORM}\n"|tee -a $LOGFIL
	    add_to_skipped_nodes "${cellname}" "Network latency issue: Storage Server is pingable but ssh took too long"
	  else
	    echo -e "\n${RED}Skipping $zfs_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} because its not available.${NORM}\n"|tee -a $LOGFIL
	    add_to_skipped_nodes "${cellname}" "Storage Server is not available"
	  fi
        fi  #end of cellPingStatus
        root_zfs_counter=$(expr $root_zfs_counter + 1)
      done
      if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ; then 
        wait_for_cell_completion;
	copy_cellfiles_to_remotenodes;
      fi
    fi
    root_zfs_counter=0 
    echo -e "\n\n"
  fi 
}

#function to discover mixed hardware cells
mixed_hardware_cells_discovery ()
{
  #if [ $OFFLINE -eq 0 ]
  if [[ $OFFLINE -eq "0" ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]];
  then
      for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
      do
      	cellHardwareTypeV2=$(grep -wci "SUN FIRE X4275" $mixedCellFil)
	cellHardwareTypeX22=$(grep -wci "SUN FIRE X4[1-2]70 M2" $mixedCellFil)
	cellHardwareTypeX23=$(grep -wci "SUN FIRE X4[1-2]70 M3" $mixedCellFil)
	cellHardwareTypeX24=$(grep -ci "SUN SERVER X4-2" $mixedCellFil)	
	cellHardwareTypeX25=$(grep -ci "ORACLE SERVER X5-2" $mixedCellFil)	
	cellHardwareTypeX26=$(grep -ci "ORACLE SERVER X6-2" $mixedCellFil)	
	cellHardwareTypeX27=$(grep -ci "ORACLE SERVER X7-2" $mixedCellFil)	
        #Dom0 then get cell name from file name otherwise get ip address 
        if [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]]
        then
          hardwareTypecellName=$(basename $mixedCellFil|$AWK 'BEGIN { FS = "_" } {print $4}')
        else
          hardwareTypecellName=$(basename $mixedCellFil|$AWK 'BEGIN { FS = "_" } {printf $4}')
          if [[ `echo "$hardwareTypecellName"|grep -c '[A-Za-z]'` -eq 0 ]]; then
            hardwareTypecellName=$(basename $mixedCellFil|$AWK 'BEGIN { FS = "_" } {printf $4"."$5"."$6"."$7}')
          fi
        fi 
        if [ $cellHardwareTypeV2 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = V2">>$MASTERFIL;cellHardwareType="EXADATA";fi
        if [ $cellHardwareTypeX22 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X2-2">>$MASTERFIL;cellHardwareType="X2";fi
        if [ $cellHardwareTypeX23 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X3-2">>$MASTERFIL;cellHardwareType="X3";fi
        if [ $cellHardwareTypeX24 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X4-2">>$MASTERFIL;cellHardwareType="X4";fi
        if [ $cellHardwareTypeX25 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X5-2">>$MASTERFIL;cellHardwareType="X5";fi
        if [ $cellHardwareTypeX26 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X6-2">>$MASTERFIL;cellHardwareType="X6";fi
        if [ $cellHardwareTypeX27 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X7-2">>$MASTERFIL;cellHardwareType="X7";fi

        if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
	  components=`grep -iw COMPONENTS $MASTERFIL |grep -w $localnode|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
	fi
      done
  fi
  #$READ -p "change files in $CELLDIR" 
  mixed_hardware=0
  if [ -e $CELLDIR ]; then  mixed_hardware=$(find $CELLDIR -name '*CellMakeModel*report.out' -exec md5sum {} \;|awk '{print $1}'|sort -u|wc -l|sed 's/ //g');fi
  #If all cells are same type than checking local compute node type to make sure its same hardware and if not then making it mixed hardware type
  if [ $mixed_hardware -lt 2 ];then if [[ -n "$cellHardwareType" ]]; then cellComputeMatch=$(echo "$components" |grep -ic "$cellHardwareType"); fi; fi 
  #if [[ -n "$cellComputeMatch" && $cellComputeMatch -eq 0 ]]; then mixed_hardware=2;fi
  if [[ -n "$cellComputeMatch" && $cellComputeMatch -eq 0 && `echo "$components"|grep -icw "AVM"` -eq 0 ]]; then mixed_hardware=2;fi
  if [[ $mixed_hardware -gt 1 ]]
  then
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      mixed_hardware_v2=$(grep -wci "SUN FIRE X4275" $mixedCellFil)
      if [ $mixed_hardware_v2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      mixed_hardware_x2_2=$(grep -wci "SUN FIRE X4[1-2]70 M2" $mixedCellFil)
      if [ $mixed_hardware_x2_2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      mixed_hardware_x3_2=$(grep -wci "SUN FIRE X4[1-2]70 M3" $mixedCellFil)
      if [ $mixed_hardware_x3_2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      mixed_hardware_x4_2=$(grep -ci "SUN SERVER X4-2" $mixedCellFil)
      if [ $mixed_hardware_x4_2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      mixed_hardware_x5_2=$(grep -ci "ORACLE SERVER X5-2" $mixedCellFil)
      if [ $mixed_hardware_x5_2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      mixed_hardware_x6_2=$(grep -ci "ORACLE SERVER X6-2" $mixedCellFil)
      if [ $mixed_hardware_x6_2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      mixed_hardware_x7_2=$(grep -ci "ORACLE SERVER X7-2" $mixedCellFil)
      if [ $mixed_hardware_x7_2 -ge 1 ]; then break;fi
    done
  fi
  if [ $OFFLINE -eq 0 ];then
      echo -e "\nmixed hardware status = $mixed_hardware mixed_hardware_v2=$mixed_hardware_v2 mixed_hardware_x2_2=$mixed_hardware_x2_2 mixed_hardware_x3_2=$mixed_hardware_x3_2 mixed_hardware_x4_2=$mixed_hardware_x4_2 \n mixed_hardware_x5_2=$mixed_hardware_x5_2\n">>$LOGFIL
  fi
}

function set_root_all_prompt ()
{
  return
  if [ $userid -eq 0 ] ; then return; fi
  if [ -e "$EXPECT" ] ; then
    echo
    echo
    exec 3<&2; exec 2<&0
    $READ -p  "Is ${root_user} password same on all components?[y/n][y]" samerootpassword_YesNo
    exec 2<&3
    process_prompt "$read_code" "samerootpassword_YesNo" "y"

    if [ -z "$samerootpassword_YesNo" ] ; then samerootpassword_YesNo="y"; fi
    case $samerootpassword_YesNo in
    y|Y|Yes|YES|yes)
      echo -e "\n"
      printf  "Enter ${root_user} password for components :- "
      tty -s && stty -echo
      $READ -r global_root_password
      tty -s && stty echo
      echo
      echo
      root_hostname=$(cat $HOSTLIST|head -1)
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      checkUserPassword "$root_hostname" "${root_user}" "$global_root_password" "3"
      if [ $passwordCheckStatus -eq 0 ]
      then
        root_all_prompt=1
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        global_root_password="$passwordToCheck"
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
    esac
  fi
}

function submit_client_run ()
{
  # Set all RAT_ env in client run
  #rm -f $RTEMPDIR_D/setenv.sh
  security_fix "check_and_fix_script_existence" "${RTEMPDIR}/setenv.sh"
  env | grep RAT_ | grep -v RAT_EXPECT_DEBUG | grep -v RAT_EXPECT_STRACE_DEBUG  > $RTEMPDIR_D/rat_env.txt

  if [[ `grep -ic 'RAT_SKIP_MERGE_INTERNAL' $RTEMPDIR_D/rat_env.txt` -eq "0" ]]; then
    export RAT_SKIP_MERGE_INTERNAL=0;
    echo "RAT_SKIP_MERGE_INTERNAL=0" >> $RTEMPDIR_D/rat_env.txt
  fi

  while read envs
  do
    e_key=$(echo $envs| cut -d"=" -f1)
    e_val=$(echo $envs| sed 's/[^=]*=//')
    echo "export $e_key=\"$e_val\"" >> $RTEMPDIR_D/setenv.sh
  done < $RTEMPDIR_D/rat_env.txt

  echo $argsaved > $RTEMPDIR_D/commands
  touch $RTEMPDIR_D/run.log

  keep_looping=0
  while [ $keep_looping -eq "1" ] ; do
    if [ -e "$LOCKFIL" ] ; then
      epid=$(cat $LOCKFIL)
      keep_looping=0
    fi
    if [ ! -e "$RTEMPDIR_D/run.log" ] ; then keep_looping=0; fi;
    if [ $keep_looping -eq "1" ] ; then sleep 1; fi
  done

  #kill -INT $dpid
  #if [ -n "$epid" ] ; then
  #tail --pid=$epid -f $RTEMPDIR_D/run.log
  mypid=$$
  echo $mypid > $RTEMPDIR_D/client.pid
  tail -f $RTEMPDIR_D/run.log 2>/dev/null
  if [ -e "$RTEMPDIR_D/run_error.log" ] ; then
    cat $RTEMPDIR_D/run_error.log; rm -f $RTEMPDIR_D/run_error.log
  fi
  # | while read line; do
    #if [[ `echo "$line" | grep -c "UPLOAD.if required"` -eq "0" ]] ; then
    #  echo "$line"
    #else
    #  echo "$line"
    #  exit
    #fi
  #done
  #fi
  exit;
}

function stop_daemon_client ()
{
  if [ -e "$RTEMPDIR_D/client.pid" ] ; then
    #user run...
    cpid=$(cat $RTEMPDIR_D/client.pid)
  elif [ -e "$RTEMPDIR_D/run.pid" ] ; then
    #auto run...
    cpid=$(cat $RTEMPDIR_D/run.pid)
  fi

  if [ -n "$cpid" ] ; then 
    if [[ `ps -ef |grep -w "$cpid"| grep -v grep|wc -l` -gt "0" ]] ; then
      tpid=$(ps -ef |grep -w $cpid|grep tail |grep -v grep |awk '{print $2}')
      if [ -n "$tpid" ] ; then
        killsub $tpid >/dev/null 2>&1
      else
        killtree $cpid 9 >/dev/null 2>&1
      fi
    fi
 
    if [ -e "$RTEMPDIR_D/commands" ]; then rm -f $RTEMPDIR_D/commands >/dev/null 2>&1; fi;
    if [ -e $LOCKFIL ]; then rm -f $LOCKFIL >/dev/null 2>&1; fi;

    cleanup_client

    echo
    echo "client run on daemon is successfully stopped."
    echo
    log_daemon "client run on daemon is stopped on user request"
    exit 0;
  else
    echo -e "No daemon client is running."
  fi
}

function stop_daemon_actual ()
{
  dpid=$(cat $RTEMPDIR_D/daemon.pid)
  kill -15 $dpid 2>/dev/null
  stopped=0;
  while [[ $stopped -eq "0" ]] ; do
    if [[ `ps -ef | grep -w $dpid | grep -v grep | wc -l` -eq "0" ]] ; then
      stopped=1;
    else
      printf ". ";
      sleep 1;
    fi
  done

  rm -rf $RTEMPDIR_D
  rm -rf $DAEMONFIL

  echo
  echo
  echo "Stopped."
  echo
  log_daemon "Daemon is stopped on user request"
  exit;
}

function stop_daemon ()
{
  #log_daemon "Stopping daemon as the $1 password is changed on $2 after daemon was started"
  #send_email "${program_name} daemon was stopped" "Stopping daemon as the $1 password is changed on $2 after daemon was started. Please restart the daemon."

  log_daemon "Stopping daemon as the $1 password could not be authenticated on $2 after daemon was started"
  send_email "${program_name} daemon was stopped" "Stopping daemon as the $1 password could not be authenticated on $2 after daemon was started. Please restart the daemon." "0" "all"
  touch $RTEMPDIR_D/stop
}

function set_date_vars ()
{
  t_yr=$(echo $1 | cut -d":" -f1)
  t_yr=$(expr $t_yr + 0)

  t_mm=$(echo $1 | cut -d":" -f2)
  t_mm=$(expr $t_mm + 0)

  t_dd=$(echo $1 | cut -d":" -f3)
  t_dd=$(expr $t_dd + 0)

  t_hh=$(echo $1 | cut -d":" -f4)
  t_hh=$(expr $t_hh + 0)

  t_mi=$(echo $1 | cut -d":" -f5)
  t_mi=$(expr $t_mi + 0)

  t_ss=$(echo $1 | cut -d":" -f6)
  t_ss=$(expr $t_ss + 0)

  t_dn=$(echo $1 | cut -d":" -f7)
  t_dn=$(expr $t_dn + 0)

  set_t_day
}

function set_t_day ()
{
  case "$t_dn" in
    0) t_day="sun";;
    1) t_day="mon";;
    2) t_day="tue";;
    3) t_day="wed";;
    4) t_day="thu";;
    5) t_day="fri";;
    6) t_day="sat";;
  esac
}

function convert_in_epoch 
{
  autorun_type=$1
  autorun_value=$2
  
  d_start_time=$(cat $RTEMPDIR_D/daemon_start_time|sed 's/^\s*//g'|sed 's/\s*$//g')
  if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    echo "ID=>${autorun_ids} - $d_start_time" > $RTEMPDIR_D/last_autorun_time
  else
    if [[ `grep -c "^ID=>" "$RTEMPDIR_D/last_autorun_time"` -eq 0 ]]; then
      la_start_time=$(cat $RTEMPDIR_D/last_autorun_time|sed 's/^\s*//g'|sed 's/\s*$//g')
      rm -f $RTEMPDIR_D/last_autorun_time
      echo "ID=>${autorun_ids} - $la_start_time" > $RTEMPDIR_D/last_autorun_time
    else 
      if [[ `grep -c "^ID=>${autorun_ids} -" "$RTEMPDIR_D/last_autorun_time"` -eq 0 ]]; then
        echo "ID=>${autorun_ids} - $d_start_time" >> $RTEMPDIR_D/last_autorun_time
      fi
    fi
  fi

  dlast=$(grep "^ID=>${autorun_ids} -" $RTEMPDIR_D/last_autorun_time|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')

  set_date_vars $dlast
  epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')

  if [[ -n $autorun_type && $autorun_type = "AUTORUN_INTERVAL" ]]; then
    auto_interval_in_mins=$(expr $autorun_value \* 60)
    auto_interval_in_secs=$(expr $auto_interval_in_mins \* 60)
 
    next_epoch=$(expr $epoch_last + $auto_interval_in_secs)

  elif [[ -n $autorun_type && $autorun_type = "AUTORUN_SCHEDULE" ]]; then
    autorun_hrs=`echo "$p_conf_value"| awk '{print $1}'`;
    if [[ "$autorun_hrs" = "*" ]]; then autorun_hrs="0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"; fi

    autorun_dte=`echo "$p_conf_value"| awk '{print $2}'`;
    if [[ "$autorun_dte" = "*" ]]; then autorun_dte="1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"; fi

    autorun_mon=`echo "$p_conf_value"| awk '{print $3}'`;
    if [[ "$autorun_mon" = "*" ]]; then autorun_mon="1,2,3,4,5,6,7,8,9,10,11,12"; fi

    autorun_day=`echo "$p_conf_value"| awk '{print $4}'`;
    if [[ "$autorun_day" = "*" ]]; then autorun_day="0,1,2,3,4,5,6"; fi

    old_ifs=$IFS
    IFS=","

    year=$t_yr
    year_limit=$(expr $year + 10)
    br_out_loop=0

    while [[ $year -le $year_limit ]]
    do
      sameYear=0; if [[ $curDateYear -eq $year ]]; then sameYear=1; fi

      leap_year=0
      if [ `expr $year % 4` -eq 0 ]; then leap_year=1; fi

      for t_months in $(echo "$autorun_mon")
      do
	sameMonth=0; if [[ $curDateMonth -eq $t_months ]]; then sameMonth=1; fi
	if [[ $sameYear -eq "1" && $t_months -lt $curDateMonth ]]; then continue; fi

        t_autorun_dte=$autorun_dte
        if [[ $t_months -eq 2 ]]; then
          t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g'|sed 's/,*30//g'|sed 's/,*29//g')
          if [[ $leap_year -eq 1 ]]; then
            t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g'|sed 's/,*30//g');
          fi
	else
	  if [[ $t_months -eq 4 || $t_months -eq 6 || $t_months -eq 9 || $t_months -eq 11 ]]; then	
	    t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g');
	  fi
        fi

        br_out_loop=0;
        month=$t_months;

        for t_days in $(echo "$t_autorun_dte")
        do
	  sameDay=0; if [[ $curDateDay -eq $t_days ]]; then sameDay=1; fi
	  if [[ $sameYear -eq "1" && $sameMonth -eq "1" && $t_days -lt $curDateDay ]]; then continue; fi

          day=$t_days;

          for t_hours in $(echo "$autorun_hrs")
          do
	    sameHour=0; if [[ $curDateHour -eq $t_hours ]]; then sameHour=1; fi
	    if [[ $sameYear -eq "1" && $sameMonth -eq "1" && $sameDay -eq "1" && $t_hours -lt $curDateHour ]]; then continue; fi

            hour=$t_hours;
            next_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,'$hour','$day','$month'-1,'$year');')

            pos_diff=$(expr $next_epoch - $epoch_last)

            compare_values=1
            if [[ $hour -eq $t_hh ]]; then
              if [[ $day -ne $t_dd ]]; then
                compare_values=1
              else
                if [[ $month -ne $t_mm ]]; then
                  compare_values=1
                else
                  if [[ $year -ne $t_yr ]]; then
                    compare_values=1
                  else
                    compare_values=0
                  fi
                fi
              fi
            fi

            if [[ $pos_diff -ge 0 ]] && [[ $compare_values -eq "1" ]]; then
              week_day=$(perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my($wday)=(localtime('$next_epoch'))[6];print $wday;');
              for week_day_list in $(echo "$autorun_day")
              do
                if [[ $week_day_list = $week_day ]]; then
                  br_out_loop=1
                  break;
                fi
              done
            fi
            if [[ $br_out_loop = 1 ]]; then break; fi
          done
          if [[ $br_out_loop = 1 ]]; then break; fi
        done
        if [[ $br_out_loop = 1 ]]; then break; fi
      done
      year=$(expr $year + 1)
      if [[ $br_out_loop = 1 ]]; then break; fi
    done
    IFS="$old_ifs"
  fi

  ar_epoch_value=$next_epoch
}

function check_multiple_autoruns
{
  display_nar="$1"

  if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "1" ]] && [[ -n $display_nar && $display_nar -eq "1" ]]; then	  
    if [[ -f "$p_conf_file" ]]; then
      is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')
      if [[ $is_id_exist -eq "0" ]]; then
        echo
        echo -e "${RED}Specified ID[${autorun_id}] doesn't exist.${NORM}"
        echo
        exit 1
      fi
    fi
  fi

  if [[ -f "$p_conf_file" ]]; then
    store_p_conf_file="$p_conf_file"

    get_dnow
    numids=$(grep -c "^\s*@.*_START\s*$" "$p_conf_file" | sed 's/ //g')
    
    if [[ $numids -gt 0 ]]; then
      id_counter=0
  	
      for autorun_ids in `grep "^\s*@.*_START\s*$" "$p_conf_file" | sed 's/_START//g' | sed 's/^\s*@//g'`
      do
        if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "1" ]] && [[ -n $display_nar && $display_nar -eq "1" ]]; then
          if [[ $autorun_ids != $autorun_id ]]; then
	    continue;
	  fi
        fi
        
        sed -n "/^@${autorun_ids}_START$/,/^@${autorun_ids}_END$/p" "$p_conf_file" > "$p_conf_file.tmp"
      
        swap_p_conf_file "$p_conf_file.tmp"
        if [[ `grep -ic "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
          read_conf "AUTORUN_INTERVAL"
      	
          if [[ $p_conf_value -eq "0" ]] ; then continue; fi
      	
          convert_in_epoch "AUTORUN_INTERVAL" "$p_conf_value"
        elif [[ -f "$p_conf_file" && `grep -ic "AUTORUN_SCHEDULE" $p_conf_file` -gt "0" ]] ; then
          read_conf "AUTORUN_SCHEDULE"
          convert_in_epoch "AUTORUN_SCHEDULE" "$p_conf_value"
        fi	   
        schedules_values[$id_counter]="$ar_epoch_value"
        schedules_ids[$id_counter]="$autorun_ids"
      
        id_counter=$(expr $id_counter + 1)
  
	rm -f $p_conf_file >/dev/null 2>&1;
        swap_p_conf_file "$store_p_conf_file"
      done

      id_counter=0
      r_id_counter=0
      smallest_epoch=${schedules_values[0]}
      for schedules in "${schedules_values[@]}"
      do
        if [[ $schedules -lt $smallest_epoch ]]; then
	  smallest_epoch=$schedules
   	  r_id_counter=$id_counter
        fi
	id_counter=$(expr $id_counter + 1)
      done

      if [[ -n $display_nar && $display_nar -eq "1" ]] ; then
        echo 
        echo "ID: ${schedules_ids[$r_id_counter]} "

        echo
        sed -n "/^@${schedules_ids[$r_id_counter]}_START$/,/^@${schedules_ids[$r_id_counter]}_END$/p" $p_conf_file|grep 'AUTORUN_SCHEDULE='

        perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$smallest_epoch'))[0,1,2,3,4,5];print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900);printf(" %02d:%02d:%02d\n", $hour,$min,$sec);'; 
        echo

        swap_p_conf_file "$store_p_conf_file"
        exit 0;
      elif [[ -n $display_nar && $display_nar -eq "0" ]]; then
	sed -n "/^@${schedules_ids[$r_id_counter]}_START$/,/^@${schedules_ids[$r_id_counter]}_END$/p" $p_conf_file > $cur_p_conf_file
        autorun_id=${schedules_ids[$r_id_counter]}      
	swap_p_conf_file "$cur_p_conf_file"
	return 
      fi
    fi
  fi
}

function next_autorun_on ()
{
  curDateYear=$(date '+%Y')
  curDateMonth=$(date '+%m'|sed 's/^0//')
  curDateDay=$(date '+%d'|sed 's/^0//')
  curDateHour=$(date '+%H'|sed 's/^0//')
  curDateMin=$(date '+%H'|sed 's/^0//')

  #Multiple schedules
  check_multiple_autoruns "1" 

  if [[ -f "$p_conf_file" && `grep -ic "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_INTERVAL"
    if [[ $p_conf_value -eq "0" ]] ; then 
      echo
      echo -e "${RED}Auto run is not configured. Please use ${program_name} -set AUTORUN_INTERVAL=<n[h|d]> to enable auto run.${NORM}"
      echo
      return;
    fi
    auto_interval_in_mins=$(expr $p_conf_value \* 60)
    auto_interval_in_secs=$(expr $auto_interval_in_mins \* 60)
  elif [[ -f "$p_conf_file" && `grep -ic "AUTORUN_SCHEDULE" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_SCHEDULE"
    if [[ -z "$p_conf_value" ]] ; then
      echo
      echo -e "${RED}Auto run is not configured. Please use ${program_name} -set AUTORUN_INTERVAL=<n[h|d]> to enable auto run.${NORM}"
      echo
      return;
    fi
    echo "AUTORUN_SCHEDULE = $p_conf_value"

    get_dnow
    if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
      d_start_time=$(cat $RTEMPDIR_D/daemon_start_time|sed 's/^\s*//g'|sed 's/\s*$//g')
      echo "ID=>${autorun_id} - $d_start_time" > $RTEMPDIR_D/last_autorun_time
    else
      la_start_time=$(cat $RTEMPDIR_D/last_autorun_time|sed 's/^\s*//g'|sed 's/\s*$//g')      
      rm -f $RTEMPDIR_D/last_autorun_time
      echo "ID=>${autorun_id} - $la_start_time" > $RTEMPDIR_D/last_autorun_time
    fi

    dlast=$(cat $RTEMPDIR_D/last_autorun_time|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')

    set_date_vars $dlast
    epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')

    autorun_hrs=`echo "$p_conf_value"| awk '{print $1}'`;
    if [[ "$autorun_hrs" = "*" ]]; then autorun_hrs="0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"; fi
    
    autorun_dte=`echo "$p_conf_value"| awk '{print $2}'`;
    if [[ "$autorun_dte" = "*" ]]; then autorun_dte="1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"; fi
    
    autorun_mon=`echo "$p_conf_value"| awk '{print $3}'`;
    if [[ "$autorun_mon" = "*" ]]; then autorun_mon="1,2,3,4,5,6,7,8,9,10,11,12"; fi
    
    autorun_day=`echo "$p_conf_value"| awk '{print $4}'`;
    if [[ "$autorun_day" = "*" ]]; then autorun_day="0,1,2,3,4,5,6"; fi
    
    old_ifs=$IFS
    IFS=","
    
    year=$t_yr
    year_limit=$(expr $year + 10)
    br_out_loop=0

    while [[ $year -le $year_limit ]]
    do
      sameYear=0; if [[ $curDateYear -eq $year ]]; then sameYear=1; fi

      leap_year=0
      if [ `expr $year % 4` -eq 0 ]; then leap_year=1; fi
    
      for t_months in $(echo "$autorun_mon")
      do
	sameMonth=0; if [[ $curDateMonth -eq $t_months ]]; then sameMonth=1; fi
	if [[ $sameYear -eq "1" && $t_months -lt $curDateMonth ]]; then continue; fi

        t_autorun_dte=$autorun_dte
        if [[ $t_months -eq 2 ]]; then
          t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g'|sed 's/,*30//g'|sed 's/,*29//g')
          if [[ $leap_year -eq 1 ]]; then
            t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g'|sed 's/,*30//g');
          fi
	else
	  if [[ $t_months -eq 4 || $t_months -eq 6 || $t_months -eq 9 || $t_months -eq 11 ]]; then	
	    t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g');
	  fi
        fi
    
        br_out_loop=0;
        month=$t_months;
    
        for t_days in $(echo "$t_autorun_dte")
        do
          sameDay=0; if [[ $curDateDay -eq $t_days ]]; then sameDay=1; fi
	  if [[ $sameYear -eq "1" && $sameMonth -eq "1" && $t_days -lt $curDateDay ]]; then continue; fi

          day=$t_days;
    
          for t_hours in $(echo "$autorun_hrs")
          do
	    sameHour=0; if [[ $curDateHour -eq $t_hours ]]; then sameHour=1; fi
	    if [[ $sameYear -eq "1" && $sameMonth -eq "1" && $sameDay -eq "1" && $t_hours -lt $curDateHour ]]; then continue; fi

            hour=$t_hours;
            next_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,'$hour','$day','$month'-1,'$year');')
    
            pos_diff=$(expr $next_epoch - $epoch_last)

            compare_values=1
            if [[ $hour -eq $t_hh ]]; then
              if [[ $day -ne $t_dd ]]; then
                compare_values=1
              else
                if [[ $month -ne $t_mm ]]; then
                  compare_values=1
                else
                  if [[ $year -ne $t_yr ]]; then
                    compare_values=1
                  else
                    compare_values=0
                  fi
                fi
              fi
            fi

            if [[ $pos_diff -ge 0 ]] && [[ $compare_values -eq "1" ]]; then
   	      week_day=$(perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my($wday)=(localtime('$next_epoch'))[6];print $wday;');
 
              for week_day_list in $(echo "$autorun_day")
              do
                if [[ $week_day_list = $week_day ]]; then
		  echo -e ""
                  perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$next_epoch'))[0,1,2,3,4,5];print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900);printf(" %02d:%02d:%02d\n", $hour,$min,$sec);';  
                  br_out_loop=1
                  break;
                fi
              done
            fi
            if [[ $br_out_loop = 1 ]]; then break; fi
          done
          if [[ $br_out_loop = 1 ]]; then break; fi
        done
        if [[ $br_out_loop = 1 ]]; then break; fi
      done
      year=$(expr $year + 1)
      if [[ $br_out_loop = 1 ]]; then break; fi
    done
    IFS="$old_ifs"
    
    if [[ $br_out_loop = "0" ]]; then
      echo -e ""
      echo -e "${RED}AUTORUN_SCHEDULE is not configured properly.${NORM}"
    fi
    echo -e ""
    return
  else
    echo
    echo -e "${RED}Auto run is not configured. Please use ${program_name} -set AUTORUN_INTERVAL=<n[h|d]> to enable auto run.${NORM}"
    echo
    return
  fi

  if [ -z "$auto_interval_in_secs" ] ; then
    auto_interval_in_secs=86400 # Once every day
  fi

  get_dnow

  if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    d_start_time=$(cat $RTEMPDIR_D/daemon_start_time|sed 's/^\s*//g'|sed 's/\s*$//g')
    echo "ID=>${autorun_id} - $d_start_time" > $RTEMPDIR_D/last_autorun_time

    #cp -f $RTEMPDIR_D/daemon_start_time $RTEMPDIR_D/last_autorun_time
  else
    la_start_time=$(cat $RTEMPDIR_D/last_autorun_time|sed 's/^\s*//g'|sed 's/\s*$//g')      
    rm -f $RTEMPDIR_D/last_autorun_time
    echo "ID=>${autorun_id} - $l_start_time" > $RTEMPDIR_D/last_autorun_time
  fi

  dlast=$(cat $RTEMPDIR_D/last_autorun_time|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')
  #dlast=$(cat $RTEMPDIR_D/last_autorun_time)

  set_date_vars $dnow
  epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
  set_date_vars $dlast
  epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
  next_epoch=$(expr $epoch_last + $auto_interval_in_secs)

  echo
  perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$next_epoch'))[0,1,2,3,4,5]; print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900);printf(" %02d:%02d:%02d\n", $hour,$min,$sec);';
 
  echo
}

function check_val_in_array ()
{
  val2check="$1"
  arr_values="$2"

  val_in_array=0
  if [ ! -n "$arr_values" ] ; then return; fi;

  if [ "$arr_values" = "*" ] ; then
    val_in_array=1;
    return;
  fi

  old_ifs=$IFS
  IFS=","
  for a_val in $arr_values
  do
    if [ -n "$a_val" ] ; then
      a_val_num=$(expr $a_val + 0)
      if [[ "$a_val_num" -eq "$val2check" ]] ; then 
        val_in_array=1
      fi
    fi
  done
  IFS="$old_ifs"

  if [ $val_in_array -eq "0" ] ; then
    if [ -e $cur_p_conf_file ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;
  fi
}

#log_daemon "run_client_now=$run_client_now"

function start_auto_run ()
{
  if [ -e "$RTEMPDIR_D/commands" ] ; then return; fi

  curDateYear=$(date '+%Y')
  curDateMonth=$(date '+%m'|sed 's/^0//')
  curDateDay=$(date '+%d'|sed 's/^0//')
  curDateHour=$(date '+%H'|sed 's/^0//')
  curDateMin=$(date '+%H'|sed 's/^0//')

  check_multiple_autoruns "0"

  autorun_mode="none"
  autorun_time="" #mon,tue,wed:0130,1130
  if [[ -f "$p_conf_file" && `grep -ic "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_INTERVAL"
    if [[ $p_conf_value -eq "0" ]] ; then return; fi
    auto_interval_in_mins=$(expr $p_conf_value \* 60)
    auto_interval_in_secs=$(expr $auto_interval_in_mins \* 60)
    autorun_mode="interval"
  elif [[ -f "$p_conf_file" && `grep -ic "AUTORUN_SCHEDULE" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_SCHEDULE"
    if [[ -z "$p_conf_value" ]] ; then return; fi
    autorun_hrs=`echo "$p_conf_value"| awk '{print $1}'`
    autorun_dte=`echo "$p_conf_value"| awk '{print $2}'`
    autorun_mon=`echo "$p_conf_value"| awk '{print $3}'`
    autorun_day=`echo "$p_conf_value"| awk '{print $4}'`
    autorun_mode="time"
  else
    if [ -e $cur_p_conf_file ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;
    return
  fi

  if [ -z "$auto_interval_in_secs" ] ; then
    auto_interval_in_secs=86400 # Once every day
  fi

  d_start_time=$(cat $RTEMPDIR_D/daemon_start_time|sed 's/^\s*//g'|sed 's/\s*$//g')
  if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    echo "ID=>${autorun_id} - $d_start_time" > $RTEMPDIR_D/last_autorun_time
  else
    #if [[ `cat "$RTEMPDIR_D/last_autorun_time"|grep -c "^ID=>"` -eq 0 ]]; then
    if [[ `grep -c "^ID=>" "$RTEMPDIR_D/last_autorun_time"` -eq 0 ]]; then
      la_start_time=$(cat $RTEMPDIR_D/last_autorun_time|sed 's/^\s*//g'|sed 's/\s*$//g')
      rm -f $RTEMPDIR_D/last_autorun_time
      echo "ID=>${autorun_id} - $la_start_time" > $RTEMPDIR_D/last_autorun_time
    else
      #if [[ `cat "$RTEMPDIR_D/last_autorun_time"|grep -c "^ID=>${autorun_ids} -"` -eq 0 ]]; then
      if [[ `grep -c "^ID=>${autorun_ids} -" "$RTEMPDIR_D/last_autorun_time"` -eq 0 ]]; then
        echo "ID=>${autorun_id} - $d_start_time" >> $RTEMPDIR_D/last_autorun_time
      fi
    fi
  fi

  get_dnow
  if [ -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    dlast=$(grep "^ID=>${autorun_id} -" $RTEMPDIR_D/last_autorun_time|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')
    dlast_hr=0
    epoch_last=0
    if [ -n "$dlast" ] ; then
      set_date_vars $dlast
      epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
      dlast_mm=$t_mm
      dlast_dd=$t_dd
      dlast_hr=$t_hh
    fi
    set_date_vars $dnow
    epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    diff_epoch=`expr $epoch_now - $epoch_last`

    if [[ -n "$RAT_DEBUG" && $RAT_DEBUG -eq "1" ]] ; then
      log_daemon "ID=$autorun_id diff_epoch=$diff_epoch auto_interval_in_secs=$auto_interval_in_secs dnow=$dnow dlast=$dlast dlast_hr=$dlast_hr t_hh=$t_hh"
      log_daemon "ID=$autorun_id autorun_mode=$autorun_mode autorun_days=$autorun_day, autorun_time=$autorun_time diff_epoch=$diff_epoch, t_day = $t_day"
    fi

    if [[ $autorun_mode = "interval" ]] ; then
      if [ -z "$diff_epoch" ] ; then swap_p_conf_file "$store_p_conf_file"; return; fi
      if [ $diff_epoch -lt $auto_interval_in_secs ] ; then
   	swap_p_conf_file "$store_p_conf_file"
        return
      fi
    elif [[ $autorun_mode = "time" ]] ; then
      if [[ $t_hh -ne $dlast_hr ]] || [[ $t_hh -eq $dlast_hr && $dlast_dd -ne $t_dd ]] || [[ $t_hh -eq $dlast_hr && $dlast_dd -eq $t_dd && $t_mm -ne $dlast_mm ]] ; then
        run_client_now=0
        check_val_in_array "$t_hh" "$autorun_hrs"
        if [ $val_in_array -eq "0" ] ; then return; fi

        check_val_in_array "$t_dd" "$autorun_dte"
        if [ $val_in_array -eq "0" ] ; then return; fi
         
        check_val_in_array "$t_mm" "$autorun_mon"
        if [ $val_in_array -eq "0" ] ; then return; fi

        check_val_in_array "$t_dn" "$autorun_day"
        if [ $val_in_array -eq "0" ] ; then return; fi

        run_client_now=1
      else
        if [ -e $cur_p_conf_file ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;
        return
      fi    
    else
      if [ -e $cur_p_conf_file ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;
      return
    fi
  fi

  sed "/^ID=>${autorun_id} - /d" $RTEMPDIR_D/last_autorun_time > $RTEMPDIR_D/last_autorun_time.tmp
  echo "ID=>${autorun_id} - $dnow" >> $RTEMPDIR_D/last_autorun_time.tmp
  mv -f $RTEMPDIR_D/last_autorun_time.tmp $RTEMPDIR_D/last_autorun_time

  started_autorun=1
  read_conf "AUTORUN_FLAGS"
  if [ -n "$p_conf_value" ] ; then
    OLD_SHELL=$SSHELL
    SSHELL="$SSHELL -o NumberOfPasswordPrompts=0"
    for hname in `cat $RTEMPDIR_D/.hosts.txt`
    do
      if [ $hname = $localnode ]
      then
        if [ -e $LOCKFIL ]
        then
          lockfile_pid_status=$(ps -ef |grep $(cat $LOCKFIL)|grep -v grep|wc -l)
          if [[ -n "$lockfile_pid_status" && $lockfile_pid_status -gt 0 ]]
          then
            log_daemon "Another instance of $program_name is running on $hname. Auto run instance is exiting." 
            return
          fi
        fi
      else
        remote_lock_file=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then cat $LOCKFIL|wc -l;fi\"")
        remote_lockfile_pid=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then cat $LOCKFIL|head -1;fi\"")
        remote_lockfile_pid_status=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then ps -ef |grep $remote_lockfile_pid|grep -v grep|wc -l;fi\"")
        if [[ -n "$remote_lock_file" && $remote_lock_file -eq 1 && -n "$remote_lockfile_pid_status" && $remote_lockfile_pid_status -gt 0 ]]
        then
          log_daemon "Another instance of $program_name is running on $hname.Auto run instance is exiting on $localnode.\n" 
          return
        fi
      fi
    done
    SSHELL=$OLD_SHELL

    #log_daemon "Started auto run $p_conf_value"
    echo "$p_conf_value" > $RTEMPDIR_D/commands
  else
    touch $RTEMPDIR_D/commands
  fi
  touch $RTEMPDIR_D/autorun
}

function ping_a_host ()
{
  hname=$1
    
  test_node_reachability "$hname";
  if [ $el_node_ping -eq "1" ] ; then
    ping_exitcode=0;
  else
    ping_exitcode=1;
  fi
}

function get_dnow ()
{
  dnow=$(date '+%Y:%m:%d:%H:%M:%S:%w')
}

function write_dnow_init ()
{
  get_dnow
  echo "$dnow" > $RTEMPDIR_D/daemon_start_time
  echo "$dnow" > $RTEMPDIR_D/last_pchk_time
}

function check_daemon_passwords ()
{
  if [ -f "$p_conf_file" ]; then
    cnt=0
    for pchk in `grep -w "PASSWORD_CHECK_INTERVAL" $p_conf_file`
    do
      p_conf_value=$(echo "$pchk"| cut -d"=" -f2 | sed 's/ //g')

      if [[ $cnt -eq "0" ]]; then password_interval=$p_conf_value; fi
      if [[ $p_conf_value -lt $password_interval ]]; then password_interval=$p_conf_value;  fi

      cnt=`expr $cnt + 1`  
    done
    
    if [[ $cnt -gt 0 ]]
    then
      p_conf_value=$password_interval

      if [[ $p_conf_value -eq "0" ]] ; then return; fi
      pchk_interval_in_mins=$(expr $p_conf_value \* 60)
      pchk_interval_in_secs=$(expr $pchk_interval_in_mins \* 60)
    fi
  fi

  if [ -z "$pchk_interval_in_secs" ] ; then
    pchk_interval_in_secs=86400 # Once every day
  fi

  get_dnow
  if [ -e "$RTEMPDIR_D/last_pchk_time" ] ; then
    dlast=$(cat $RTEMPDIR_D/last_pchk_time)
    set_date_vars $dnow
    epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    set_date_vars $dlast
    epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    diff_epoch=`expr $epoch_now - $epoch_last`
    if [ -z "$diff_epoch" ] ; then return; fi
    #log_daemon "diff_epoch=$diff_epoch interval=$pchk_interval_in_secs dnow=$dnow dlast=$dlast"
    if [ $diff_epoch -lt $pchk_interval_in_secs ] ; then
      return
    fi
  fi
  echo $dnow > $RTEMPDIR_D/last_pchk_time

  log_daemon "Started checking passwords...."

  touch $RTEMPDIR_D/password_check.running

  if [[ -n "$rootYesNoint" && $rootYesNoint -ne 3 && $rootYesNoint -ne 2 ]] || [[ -z $rootYesNoint ]] ; then
    root_hostname_counter=0
    for root_hostname in `cat $RTEMPDIR_D/.hosts.txt 2>/dev/null`
    do
      ping_a_host $root_hostname
      if [[ -n "$ping_exitcode" && $ping_exitcode -eq "0" ]] ; then
	daemon_compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "${root_user}" "$root_hostname" ls >/dev/null 2>&1;echo $?);
        if [[ -n "$daemon_compute_ssh_status" && $daemon_compute_ssh_status -ne 0 ]]
	then
          if [[ -n "$samerootpassword" && $samerootpassword -eq "0" ]] ; then
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$root_hostname" "${root_user}" "${a_compute_rootpassword[$root_hostname_counter]}" 1
          else
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" 1
          fi
          if [ $passwordCheckStatus -ne "0" ] ; then
            stop_daemon "${root_user}" "$root_hostname"
          fi
	fi
      fi
      root_hostname_counter=$(expr $root_hostname_counter + 1)
    done
  fi

  if [[ -n "$cell_password_status" && $cell_password_status -ne 3  ]] || [[ -z $cell_password_status ]] ; then   
    root_cell_counter=0
    cell_type="normal"
    if [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
    then
      cell_type="zfscell"
    fi

    for cellname in `cat $RTEMPDIR_D/.cells.txt 2>/dev/null |cut -d\" -f2`
    do
      test_node_reachability "$cellname" "$cell_ssh_user";
      if [ $el_node_ping -eq "1" ] ; then
        cellPingStatus=0;
      else
        cellPingStatus=1;
      fi

      if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]] ; then 
	daemon_cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "$cell_ssh_user" "$cellname" ls >/dev/null 2>&1;echo $?);
	if [[ -n "$daemon_cell_ssh_status" && $daemon_cell_ssh_status -ne 0 ]]
	then
          if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$cellname" "$cell_ssh_user" "${a_cell_rootpassword[$root_cell_counter]}" "1" $cell_type
          else
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "1" $cell_type
          fi
          if [ $passwordCheckStatus -ne "0" ] ; then
            stop_daemon "$cell_ssh_user" "$cellname"
          fi
	fi
      fi
      root_cell_counter=$(expr $root_cell_counter + 1)
    done
  fi

  if [[ -n "$zfs_password_status" && $zfs_password_status -ne 3  ]] || [[ -z $zfs_password_status ]] ; then
    root_zfs_counter=0
    for zfsname in `cat $RTEMPDIR_D/.zfs.txt 2>/dev/null|cut -d= -f2|sed 's/"//g'`
    do
      test_node_reachability "$zfsname" "$zfs_ssh_user";
      if [ $el_node_ping -eq "1" ] ; then
        zfsPingStatus=0;
      else
        zfsPingStatus=1;
      fi

      if [[ -n "$zfsPingStatus" && $zfsPingStatus -eq 0 ]] ; then
	daemon_zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "$zfs_ssh_user" "$zfsname" ls >/dev/null 2>&1;echo $?);
	if [[ -n "$daemon_zfs_ssh_status" && $daemon_zfs_ssh_status -ne 0 ]]
	then
          if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq "0" ]] ; then
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$zfsname" "$zfs_ssh_user" "${a_zfs_rootpassword[$root_zfs_counter]}" "1" "zfscell"
          else
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "1" "zfscell"
          fi
          if [ $passwordCheckStatus -ne "0" ] ; then
            stop_daemon "$zfs_ssh_user" "$zfsname"
          fi
        fi
      fi
      root_zfs_counter=$(expr $root_zfs_counter + 1)
    done
  fi

  if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3  ]] || [[ -z $ibswitch_password_status ]] ; then
    ib_root_counter=0
    for switchname in `cat $RTEMPDIR_D/.ibs.txt 2>/dev/null`
    do
      test_node_reachability "$switchname" "$ibswitch_user";
      if [ $el_node_ping -eq "1" ] ; then
        switchping_status=0;
      else
        switchping_status=1;
      fi

      if [ $switchping_status -eq 0 ] ; then
	daemon_ibs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "$ibswitch_user" "$switchname" ls >/dev/null 2>&1;echo $?);
        if [[ -n "$daemon_ibs_ssh_status" && $daemon_ibs_ssh_status -ne 0 ]]
	then
          if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq "0" ]] ; then
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$switchname" "$ibswitch_user" "${a_ib_switch_root_password[$ib_root_counter]}" "1" "ibswitch"
          else
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "1" "ibswitch"
          fi
          if [ $passwordCheckStatus -ne "0" ] ; then
            stop_daemon "$ibswitch_user" "$switchname"
          fi
        fi
      fi
      ib_root_counter=$(expr $ib_root_counter + 1)
    done
  fi

  node_index=0 
  for hname in "${a_node_names[@]}"
  do
    ping_a_host $hname
    if [[ -n "$ping_exitcode" && $ping_exitcode -eq "0" ]] ; then
      daemon_node_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "$usern" "$hname" ls >/dev/null 2>&1;echo $?)	
      if [[ -n "$daemon_node_ssh_status" && $daemon_node_ssh_status -ne 0 ]]
      then 
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        checkUserPassword "$hname" "$usern" "${a_node_passwords[$node_index]}" "1"
        if [ $passwordCheckStatus -ne "0" ] ; then
          stop_daemon "$usern" "$hname"
        fi
      fi
    fi
    node_index=$(expr $node_index + 1)
  done
  log_daemon "Finished checking passwords...."
  rm -f $RTEMPDIR_D/password_check.running
}

function upgrade_program_daemon ()
{
  if [ -e "$RTEMPDIR_D/commands" ] ; then return; fi
  
  log_daemon "Started checking ${program_name} version...."
  
  check_upgrade_ret_val="";
  check_upgrade
  
  if [[ "$check_upgrade_ret_val" != "0" && "$check_upgrade_ret_val" != "-1" ]]; then
    log_daemon "Running older ${program_name} version....."
	
    PRERDIR=`pwd`;
    if [ `touch $PRERDIR/testfile 2> /dev/null; echo "$?"` -eq 0 ]; then
      upgrade_orachk
	  
      LATEST_AVAILABLE_VERSION=`$SCRIPTPATH/${program_name} -v`
      LATEST_AVAILABLE_VERSION=$(echo "$LATEST_AVAILABLE_VERSION"|grep 'VERSION')
      log_daemon "Upgraded to Latest available version(${LATEST_AVAILABLE_VERSION}). Stopping ${program_name} daemon."

      send_email "${program_name} daemon has been upgraded" "${program_name} daemon has been upgraded to latest available version(${LATEST_AVAILABLE_VERSION})." "0" "all"
      stop_daemon_actual
    else
      log_daemon "$PREDIR is not writable. Please upgrade ${program_name} manually."
    fi
  fi
}

function send_mail_using_cell ()
{
  root_cell_counter=0
  if [[ -n $test_email_config && $test_email_config -eq 1 ]];then
    mail_sent_from_cell=1;
    matter="This is test mail sent by $program_name from storage cell" 
  else
    log_daemon "Sending email using cell"
  fi

  if [[ -n "$attachment" && "$attachment" -eq "1" ]]
  then
    bname_prev_report=$(basename "$prev_report")
    bname_html_report=$(basename "$html_report")
    bname_diff_report=$(basename "$diff_report")
    bname_mail_program=$(basename "$MAIL_PROGRAM")
        		
cat > $MAIL_PROGRAM <<EOF
#!/bin/env bash

mail_server_running=0
function check_if_mail_exists ()
{
  mail_cmd=$(which mailx)
  if [ -z "\$mail_cmd" ] ; then mail_cmd=\$(which mail); fi
  if [ -z "\$mail_cmd" ] ; then mail_cmd=\$(which sendmail); fi
  if [ -n "\$mail_cmd" ] ; then mail_server_running=1; fi
}

function send_email_with_attachment ()
{
  which mailx >/dev/null 2>&1

  if [ \$(echo \$?) -eq 0 ]
  then
    echo "$matter" > mail.out

    if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
    then
      mailx -s "$subject" -a "$bname_html_report" $remail < mail.out >/dev/null 2>&1;
    else
      mailx -s "$subject" -a "$bname_prev_report" -a "$bname_html_report" -a "$bname_diff_report" $remail < mail.out >/dev/null 2>&1; 
    fi 
    rm -rf mail.out >/dev/null 2>&1;
  else
    which mutt >/dev/null 2>&1
    if [ \$(echo \$?) -eq 0 ]
    then
      echo "$matter" > mail.out

      if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
      then
        mutt -s "$subject" -a "$bname_html_report" -- $remail < mail.out >/dev/null 2>&1;
      else
        mutt -s "$subject" -a "$bname_prev_report" -a "$bname_html_report" -a "$bname_diff_report" -- $remail < mail.out >/dev/null 2>&1; 
      fi 
      rm -rf mail.out >/dev/null 2>&1;
    else
      which sendmail >/dev/null 2>&1
      if [ \$(echo \$?) -eq 0 ]
      then
        from=""
        to="$remail"
        subject="$subject"
        boundary="ZZ_/afg6432dfgkl.94531q"
        body="$matter"
        declare -a attachments
        if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
        then
          attachments=( "$bname_html_report" )
        else
	  attachments=( "$bname_prev_report" "$bname_html_report" "$bname_diff_report" )
        fi
{
        printf '%s\n' "From: $from
To: \$to
Subject: \$subject
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary=\"\$boundary\"

--\${boundary}

\$body
"
        for file in "\${attachments[@]}"; do
          [ ! -f "\$file" ] && echo "Warning: attachment \$file not found, skipping" >&2 && continue
          mimetype=\$(file --mime "\$file"|cut -d: -f2|cut -d\; -f2|sed 's/ //g')

          printf '%s\n' "--\${boundary}
Content-Type: \$mimetype
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=\"\$file\"
"
          base64 "\$file"
          echo
        done
        printf '%s\n' "--\${boundary}--"
} | sendmail -t -oi
      else
        echo "$matter" | \$mail_cmd -s "$subject" $remail
      fi
    fi
  fi
}

check_if_mail_exists 
if [[ -n "\$mail_server_running" && \$mail_server_running -eq "1" ]] ; then
  send_email_with_attachment
  exit 1
else
  exit 2    
fi	
EOF
  fi

  for cellname in `cat $RTEMPDIR_D/.cells.txt |sed '/^\s*$/d'|cut -d\" -f2|cut -d\; -f2`
  do
    if [[  -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      cell_rootpassword=${a_cell_rootpassword[$root_cell_counter]}
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    fi
    root_cell_counter=$(expr $root_cell_counter + 1 )
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    fixRootPassword "$cell_rootpassword"
    lle_cell_rootpassword=$fixedRootPassword
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi

    test_node_reachability "$cellname" "$cell_ssh_user";
    if [ $el_node_ping -eq "1" ] ; then
      cellPingStatus=0;
    else
      cellPingStatus=1;
    fi

    if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
    then
      log_daemon "cellname : $cellname"
      if [[ $test_email_config -eq 1 ]];then
        echo -e "\nSending test mail to $remail from cell $cellname\n\n"
      fi

      if [[ -n "$attachment" && "$attachment" -eq "1" ]];then
        if [[ -n $test_email_config && $test_email_config -eq "1" ]];then
          if [ -z "$RAT_CELL_SSH_USER" ];then cell_ssh_user="root"; else cell_ssh_user=$RAT_CELL_SSH_USER;fi
        else
          if [ -z "$RAT_CELL_SSH_USER" ];then cell_ssh_user="root"; else cell_ssh_user=$RAT_CELL_SSH_USER;fi
        fi
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	$EXPECT -f - << IBEOF
	set timeout $passwordcheck_timeout
	set le_cell_rootpassword "$lle_cell_rootpassword"
	log_user 0
	if { "$RAT_EXPECT_DEBUG" == "-d" } {
	  exp_internal 1
	}
        spawn $SCOPY $MAIL_PROGRAM $prev_report $html_report $diff_report $cell_ssh_user@$cellname:$CELLTMPDIR
        match_max 100000
        expect {
          -nocase "permission denied *" {
	   exit 4;
          }
          -nocase "no)?" {
           send -- "yes\n"
          }
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
        }
        expect {
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          } 
	  -nocase timeout {
           send_error "Timed out while copying files to $cellname\n";
           exit
         }
       }
       expect -nocase eof
IBEOF

        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_cell_rootpassword "$lle_cell_rootpassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn $SSHELL $cell_ssh_user@$cellname "chmod 540 $CELLTMPDIR/$bname_mail_program;"
        match_max 100000
        expect {
          -nocase "permission denied *" {
	   exit 4;
          }
          -nocase "no)?" {
           send -- "yes\n"
          }
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
        }
        expect {
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
          -nocase timeout {
           send_error "Timed out while modifiying permissions on $cellname\n";
           exit
         }
       }
       expect -nocase eof
IBEOF
        		
        $EXPECT -f - >/dev/null 2>&1 << IBEOF
        log_user 1
	spawn -noecho $SSHELL $cell_ssh_user@$cellname $CELLTMPDIR/$bname_mail_program
        exp_internal 1
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }    
        set timeout 60
        set le_cell_rootpassword "$lle_cell_rootpassword"
        set i 0
        log_user 1
        while {\$i < 1000000} {
          match_max 100000
          expect {
            -nocase "permission denied *" {
	      exit 4;
            }
            -nocase "no)?" {
              send -- "yes\r"
             }
             -nocase "*?assword:*" {
               send -- "\$le_cell_rootpassword\n"
             }
             -nocase eof {
               exit 0
             }
          }
          sleep 1
        }
        set timeout 7200
        expect -nocase eof
        exit
IBEOF

        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_cell_rootpassword "$lle_cell_rootpassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn $SSHELL $cell_ssh_user@$cellname "rm -f $CELLTMPDIR/$bname_prev_report $CELLTMPDIR/$bname_html_report $CELLTMPDIR/$bname_diff_report $CELLTMPDIR/$bname_mail_program >/dev/null 2>&1"
        match_max 100000
        expect {
          -nocase "permission denied *" {
	   exit 4;
          }
          -nocase "no)?" {
           send -- "yes\n"
          }
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
        }
        expect {
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
          -nocase timeout {
           send_error "Timed out while removing files from $cellname\n";
           exit
         }
       }
       expect -nocase eof
IBEOF
      else
        $EXPECT -f - >/dev/null 2>&1 << IBEOF
        log_user 1
        spawn -noecho $SSHELL $cell_ssh_user@$cellname "echo \"$matter\" | $mail_cmd -s '$subject' $remail"
        exp_internal 1
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }    
        set timeout 60
        set le_cell_rootpassword "$lle_cell_rootpassword"
        set i 0
        log_user 1
        while {\$i < 1000000} {
          match_max 100000
          expect {
             -nocase "permission denied *" {
	      exit 4;
             }
            -nocase "no)?" {
              send -- "yes\r"
             }
             -nocase "*?assword:*" {
               send -- "\$le_cell_rootpassword\n"
             }
             -nocase eof {
               exit 0
             }
          }
          sleep 1
        }
        set timeout 7200
        expect -nocase eof
        exit
IBEOF
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
      break;
    fi
  done
  rm -f $MAIL_PROGRAM >/dev/null 2>&1
}

function run_client_script ()
{
  global_pass_prompt_ans="n"
  if [[ $root_all_prompt -eq "1" ]] ; then
    global_pass_prompt_ans="y"
  fi

  same_password_cell_ans="y"
  same_password_zfs_ans="y"
  same_password_node_ans="y"
  same_password_switch_ans="y"
  node_password_prompts=""
  if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then 
    same_password_cell_ans="n"; 
    root_cell_counter=0
    for cellname in `cat $RTEMPDIR_D/.cells.txt |cut -d\" -f2`
    do
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
      then
        cellname_full=$cellname
      else
        #cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)
        cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)
      fi
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      cell_password_prompts="$cell_password_prompts
     \"Enter * password for STORAGE SERVER* $cellname_full :\" {
        send -- \"${a_cell_rootpassword[$root_cell_counter]}\\r\"
      }"
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      root_cell_counter=$(expr $root_cell_counter + 1 )
    done
  fi

  if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq "0" ]] ; then 
    same_password_zfs_ans="n"; 
    root_zfs_counter=0
    for zfsname in `cat $RTEMPDIR_D/.zfs.txt|cut -d= -f2|sed 's/"//g'`
    do
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      zfs_password_prompts="$zfs_password_prompts
     \"Enter * password for*ZFS Storage Appliance* $zfsname :\" {
        send -- \"${a_zfs_rootpassword[$root_zfs_counter]}\\r\"
      }"
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      root_zfs_counter=$(expr $root_zfs_counter + 1 )
    done
  fi

  if [[ -n "$samerootpassword" && $samerootpassword -eq "0" ]] ; then 
    same_password_node_ans="n"; 
    root_hostname_counter=0
    for root_hostname in `cat $RTEMPDIR_D/.hosts.txt`
    do
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      node_password_prompts="$node_password_prompts
     \"Enter root password *$root_hostname :\" {
        send -- \"${a_compute_rootpassword[$root_hostname_counter]}\\r\"
      }"
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      root_hostname_counter=$(expr $root_hostname_counter + 1)
    done
  fi

  if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq "0" ]] ; then 
    same_password_switch_ans="n"; 
    ib_root_counter=0
    for switchname in `cat $RTEMPDIR_D/.ibs.txt`
    do
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      switch_password_prompts="$switch_password_prompts
     \"Enter * password for*INFINIBAND SWITCH* $switchname :\" {
        send -- \"${a_ib_switch_root_password[$ib_root_counter]}\\r\"
      }
     \"Enter * password for* $switchname :\" {
        send -- \"${a_ib_switch_root_password[$ib_root_counter]}\\r\"
      }"
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      ib_root_counter=$(expr $ib_root_counter + 1 )
    done
  fi


  db_os_auth_prompts=""
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    if [[ -n "${mb_sysdba_user[$mb_db_counter]}" ]] ; then
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      db_os_auth_prompts="$db_os_auth_prompts
      \"OS authentication is not enabled so please enter sysdba privileged user name for $db_name_to_check:\" {
        send -- \"${mb_sysdba_user[$mb_db_counter]}\\r\"
      }
      \"Enter password for ${mb_sysdba_user[$mb_db_counter]}@$db_name_to_check:\" {
        send -- \"${mb_sysdba_pswd[$mb_db_counter]}\\r\"
      }"
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  db_os_auth_prompts="$db_os_auth_prompts
     \"OS authentication is not enabled so please enter sysdba privileged user name for *\" {
        send -- \"\\r\"
      }
      \"Enter user name again for *:*\" {
        send -- \"\\r\"
      }
      \"Enter password for *@*\" {
        send -- \"\\r\"
      }"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  pdb_password_prompts=""
  mb_pdb_counter=0
  for pdb_name in "${mb_pdb_names[@]}"
  do
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    pdb_password_prompts="$pdb_password_prompts
    \"Enter * user password for $pdb_name pluggable database\" {
      send -- \"${mb_pdb_sys_password[$mb_pdb_counter]}\\r\"
    }"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    mb_pdb_counter=$(expr $mb_pdb_counter + 1)
  done
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  pdb_password_prompts="$pdb_password_prompts
    \"Enter * user password for * pluggable database\" {
      send -- \"\\r\"
    }"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  ssh_password_prompts=""
  node_index=0
  for hname in "${a_node_names[@]}"
  do
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    ssh_password_prompts="$ssh_password_prompts
    \"Enter ${usern} *password on $hname * :\" {
      send -- \"${a_node_passwords[$node_index]}\\r\"
    }"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    node_index=$(expr $node_index + 1)
  done
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  ssh_password_prompts="$ssh_password_prompts
    \"Enter ${usern} *password on * :\" {
      send -- \"\\r\"
    }"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  
  #exacli daemon
  exacli_user=$exacli_user
  exacli_password_yesno=$exacli_password_yesno
  #if [[ -n $unlocked_storage_cell && $unlocked_storage_cell -eq 1 ]];then
  for (( exacli_ip_index = 0; exacli_ip_index < $all_cell_ip_max_index; exacli_ip_index++ ))
  do
    cell_ip="${exacli_all_ip[exacli_ip_index]}"
    exacli_ip_index=`expr $exacli_ip_index + 1`
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    exacli_password="${exacli_all_ip[exacli_ip_index]}"
    exacli_prompts="$exacli_prompts
      \"Enter password for EXACLI user * to unlock Storage Server ${cell_ip}*:\" {
      send -- \"$exacli_password\\r\"
    }"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  done
  #fi

  #echo "$cell_password_prompts"
  #echo "$zfs_password_prompts"
  #echo "$node_password_prompts"
  #echo "$switch_password_prompts"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  fixRootPassword "$cell_rootpassword"
    lle_cell_rootpassword=$fixedRootPassword	
  fixRootPassword "$switch_rootpassword"
    lle_switch_rootpassword=$fixedRootPassword
  fixRootPassword "$zfs_rootpassword"
    lle_zfs_rootpassword=$fixedRootPassword
  fixRootPassword "$global_root_password"
    lle_global_root_password=$fixedRootPassword
  fixRootPassword "$compute_rootpassword"
    lle_compute_rootpassword=$fixedRootPassword
  fixRootPassword "$OMS_SYSMAN_PASSWORD"
    lle_OMS_SYSMAN_PASSWORD=$fixedRootPassword	
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  export RAT_CLIENT_RUN_LOG_INTERNAL=$RTEMPDIR_D/run.log

  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi

  if [ -z "$RAT_CLIENTDISCOVERY_TIMEOUT" ]
  then
    #Default: 10mins
    client_disc_timeout=600
  else
    client_disc_timeout=$RAT_CLIENTDISCOVERY_TIMEOUT
  fi 

  if [ -z "$RAT_CLIENTRUN_TIMEOUT" ]
  then
    #Default: 4hrs
    clientrun_timeout=14400
  else
    clientrun_timeout=$RAT_CLIENTRUN_TIMEOUT
  fi 

  $EXPECT -f - >> $RTEMPDIR_D/run.log 2>&1 << IBEOF
    log_user 1
    spawn -noecho $RTEMPDIR_D/run.sh
    if { "$RAT_EXPECT_DEBUG" == "-d" } {
      exp_internal 1
    }    
    set timeout $client_disc_timeout
    set le_cell_rootpassword "$lle_cell_rootpassword"
    set le_switch_rootpassword "$lle_switch_rootpassword"
    set le_zfs_rootpassword "$lle_zfs_rootpassword"
    set le_global_root_password "$lle_global_root_password"
    set le_compute_rootpassword "$lle_compute_rootpassword"
    set i 0
    log_user 1
    while {\$i < 1000000} {
      match_max 100000
      expect {
        -nocase eof {
           exit
         }
        -nocase "permission denied *" {
	   exit 4;
         }
        -nocase "no)?" {
          send -- "yes\r"
         }
	 "Enter path for clusterware home*" {
	   send -- "$cHome\r"
	 }
	"Enter upgrade target version*" {
           send -- "$targetversion\r"
         } 
         "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME*" {
           send -- "y\r"
         }
         "RDBMS binaries found at * and ORACLE_HOME not set. Do you want to set ORACLE_HOME to *" {
	   send -- "$setOHHome\r"
	 } 
	 "Enter password for OMS sysman user*" {
	   send -- "$lle_OMS_SYSMAN_PASSWORD\r"
	 }
         "Select databases from list for checking best practices.*" {
           send -- "$db_to_check\r"
         }
         "Please indicate your selection from one of the above options for STORAGE SERVER*" {
           send -- "$cellssh_YesNo\r"
         }
	 "This computer is for*" {
	   send -- "$uip\r"
	 }
	 "*have Oracle software installed*" {
	   send -- "$ask_inv_loc\r"
	 }
         "Please indicate your selection from one of the above options for ZFS Storage Appliance*" {
           send -- "$zfsssh_YesNo\r"
         }
         "Please indicate your selection from one of the above options for root*" {
           send -- "$rootYesNo\r"
         }
         "Please indicate your selection from one of the above options for INFINIBAND SWITCH*" {
           send -- "$ibswitch_YesNo\r"
         }
         "Do you want to configure SSH for user*" {
           send -- "n\r"
         }
         "We can configure ssh only for this run and reverse the changes back. Do you want to continue?*" {
           send -- "y\r"
         }
         "Is root password same on all components? *" {
           send -- "$global_pass_prompt_ans\r"
         }
         "Enter exacli user name:" {
           send -- "$exacli_user\r"
         }
         "Is EXACLI password same on all Storage Servers*" {
           send -- "$exacli_password_yesno\r"
         }
         "Is * password same on all STORAGE SERVER" {
           send -- "$same_password_cell_ans\r"
         }
         "Is * password same on all ZFS Storage Appliance" {
           send -- "$same_password_zfs_ans\r"
         }
         "Is * password same on all*nodes" {
           send -- "$same_password_node_ans\r"
         }
         "Is * password same on all INFINIBAND SWITCH" {
           send -- "$same_password_switch_ans\r"
         }
         $ssh_password_prompts
         $exacli_prompts 
         $cell_password_prompts
         $zfs_password_prompts
         $node_password_prompts
         $switch_password_prompts
         "Unable to determine nodes in cluster.  Do you want to enter manually.*" {
           send -- "$readNodeNames\r"
         }
         "Enter cluster node names *," {
           send -- "$nodeList\r"
         }
         "CRS binaries found at * Do you want to set CRS_HOME to *" {
           send -- "$setCRSHome\r"
         }
         "Enter value for ORA_CRS_HOME environment variable*" {
           send -- "$setCRSHome\r"
         }
         "Do you want to download latest version from my oracle support*" {
           send -- "$dlYesNo\r"
         }
         "Enter * password for STORAGE SERVER*" {
           send -- "\$le_cell_rootpassword\r"
         }
         "Enter * password for INFINIBAND SWITCH*" {
           send -- "\$le_switch_rootpassword\r"
         }
	"Enter * password for ${nodeNameToCheck}" {
	   send -- "\$le_switch_rootpassword\r"
	}
         "Enter * password for ZFS Storage Appliance*" {
           send -- "\$le_zfs_rootpassword\r"
         }
         "Enter root password*components*" {
           send -- "\$le_global_root_password\r"
         }
         "Enter root password*" {
           send -- "\$le_compute_rootpassword\r"
         }
         "Enter root  password*" {
           send -- "\$le_compute_rootpassword\r"
         }
         $db_os_auth_prompts
         $pdb_password_prompts
         "Do you want to continue*" {
           send -- "\r"
         }
         "Output directory to read for offline use is*" {
           send -- "\r"
         }
         "Press enter to  continue..*" {
           send -- "\r"
         }
         "*           Node name -*" {
           set timeout $clientrun_timeout
           expect eof
           exit
         }
         "*Checking Best Practice Recommendations*" {
           set timeout $clientrun_timeout
           expect eof
           exit
         }
      }
      sleep 1
    }
    set timeout $clientrun_timeout
    expect -nocase eof
    exit
IBEOF
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
}

function cleanup_client ()
{
  if [ -e "${RTEMPDIR}/${program_name}.pid" ] ; then 
    program_pid=$(cat ${RTEMPDIR}/${program_name}.pid)
  fi
  if [ -e "$RTEMPDIR_D/run.pid" ] ; then
    run_pid=$(cat $RTEMPDIR_D/run.pid)
  fi
  if [[ -n "$program_pid" && `ps -ef| grep -w "$program_pid" | grep -v grep| wc -l` -gt "0" ]] ; then
    kill -15  $program_pid
  fi
  if [[ -n "$run_pid" && `ps -ef| grep -w "$run_pid" | grep -v grep| wc -l` -gt "0" ]] ; then
    kill -15  $run_pid
  fi

  if [ -e "$RTEMPDIR_D/client.pid" ] ; then
    rm -f $RTEMPDIR_D/client.pid
  fi
}

function log_daemon ()
{
  if [[ $autorun -eq "1" ]] ; then
    echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $1\n" >> $WRKDIR/${program_name}_daemon.log
  else
    temp_arg_flag=$(echo $command_arguments|grep -ic "NOTIFICATION_EMAIL")
    if [[ -n "$temp_arg_flag" && $temp_arg_flag -gt "0" ]]; then
      if [[ -e $LOGFIL ]];then 
        echo -e "\n\n$1" >> $LOGFIL
      else
        echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $1\n" >> $WRKDIR/${program_name}_daemon.log >/dev/null 2>&1
      fi
    else
        echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $1\n" >> $WRKDIR/${program_name}_daemon.log >/dev/null 2>&1
    fi
  fi
}

function get_program_key ()
{
  PDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
  program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')

  md5sum_program=$(which md5sum 2>/dev/null| grep -v "no md5sum in")
  if [ -n "$md5sum_program" ] ; then
    #program_key=$(md5sum $0 | awk '{print $1}')
    program_key=$(md5sum $PDIR/${program_name} | awk '{print $1}')
  else
    #program_key=$(ls -l $0 | awk '{print $5$6$7$8}')
    program_key=$(ls -l $PDIR/${program_name} | awk '{print $5$6$7$8}')
  fi
}

function killsub() 
{
  kill ${1} >/dev/null 2>/dev/null
  #wait ${1} 2>/dev/null
}
# TODO
# Check if request is from same user - done
# md5sum use full path instead of one in PATH
# when user process is killed, kill client also - done.. not allowing stop when active client exists

function handle_client_request ()
{
  #send_email "Started ${program_name} run" "Started exachk run"
  args=$(cat $RTEMPDIR_D/commands)

  autorun=0
  if [ -f "$RTEMPDIR_D/autorun" ] ; then
    autorun=1
  fi

  rm -f $RTEMPDIR_D/autorun

  if [[ $autorun -eq "1" ]] ; then
    log_daemon "Started ${program_name} execution : ID = $autorun_id args = $args"
  else
    log_daemon "Started ${program_name} execution : args = $args"
  fi

  #echo "starting to run $0 args = $args"

  export RAT_DAEMON_CLIENT=1

  get_program_key

  if [[ $program_key = $RAT_PROGRAM_KEY ]] ; then
    security_fix "check_and_fix_script_existence" "$RTEMPDIR_D/run.sh"
    echo "#!$bash_scr" > $RTEMPDIR_D/run.sh

    #if [[ -n "$RAT_DAEMON_DEBUG" && $RAT_DAEMON_DEBUG -eq "1" ]] ; then echo "set -x" >> $RTEMPDIR_D/run.sh; export RAT_CLIENT_DEBUG=1; fi

    echo "$RAT_DEBUG_FLG" >> $RTEMPDIR_D/run.sh
    echo "echo \$\$ > $RTEMPDIR_D/run.pid" >> $RTEMPDIR_D/run.sh
    if [ -e "$RTEMPDIR_D/setenv.sh" ] ; then
      echo ". $RTEMPDIR_D/setenv.sh" >> $RTEMPDIR_D/run.sh
    fi

    #PDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
    PDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
    program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
    if [[ -n "$RAT_DAEMON_DEBUG" && $RAT_DAEMON_DEBUG -eq "1" ]]
    then
      export RAT_CLIENT_DEBUG=1
      export RAT_REMOTE_MODE=1
      #export RAT_EXPECT_DEBUG="-d"

      PS4='$(date "+ $LINENO: + ")'

      timestamp=$(date '+%Y%m%d_%H%M%S')
      debugFileName=$(echo ${program_name}_debug_${timestamp}.log)
      if [[ -n $RAT_OUTPUT ]]; then
	debugFileName=${RAT_OUTPUT}/${debugFileName}
      fi

      export RAT_CLIENT_DEB_FIL=$debugFileName
      export RAT_DEBUG_FILENAME_INTERNAL=$debugFileName

      echo -e ""
      echo -e ""
      echo -e "Debug output file is $debugFileName";
      echo -e ""
      echo -e ""

      echo "$bash_scr -x ${PDIR}/${program_name} $args 2>$debugFileName" >> $RTEMPDIR_D/run.sh
    else
      echo "$bash_scr ${PDIR}/${program_name} $args" >> $RTEMPDIR_D/run.sh
    fi

    #chmod +x $RTEMPDIR_D/run.sh
    security_fix "fix_plugin_or_rtscript_attributes" "$RTEMPDIR_D/run.sh" "" "540"
    run_client_script
    rm -f $RTEMPDIR_D/run.pid
  else
    echo > $RTEMPDIR_D/run_error.log
    echo -e "${RED}$0 is changed since daemon started. Restart(stop & start) daemon using new ${program_name}. You could also use -nodaemon option to ignore daemon. ex: ${program_name} -nodaemon <other options>.${NORM}" >> $RTEMPDIR_D/run_error.log
    echo >> $RTEMPDIR_D/run_error.log
    log_daemon "Failed to run ${program_name} as $0 is changed since daemon started. Restart(stop & start) daemon using new ${program_name}"
  fi

  if [ -f "$RTEMPDIR_D/client.pid" ] ; then
    cpid=$(cat $RTEMPDIR_D/client.pid)
    if [[ -n "$cpid" && `ps -ef |grep -w "$cpid"| grep -v grep|wc -l` -gt "0" ]] ; then
      log_daemon "Client pid : $cpid"
      tpid=$(ps -ef |grep -w $cpid|grep tail |grep -v grep |awk '{print $2}')
      if [ -n "$tpid" ] ; then
        #echo "killing using kill"
        killsub $tpid >/dev/null 2>&1
      else
        killtree $cpid 9 >/dev/null 2>&1
      fi
    fi
  fi
  if [ -e "$RTEMPDIR_D/commands" ]; then mv -f $RTEMPDIR_D/commands $RTEMPDIR_D/commands.done; fi;

  if [ -e "$RTEMPDIR_D/run.log" ]; then mv -f $RTEMPDIR_D/run.log $RTEMPDIR_D/run.log.done; fi;
  if [[ $autorun -eq "1" ]] ; then
    DIFF_RUN_REPORT=$RTEMPDIR_D/diff_run_report.txt
    html_report=$(grep "Detailed report (html)" $RTEMPDIR_D/run.log.done | awk '{print $NF}' | sed 's/\.html.*/.html/'|head -1)
    if [[ -n "$html_report" && -f "$html_report" ]] ; then
      if [[ -f $RTEMPDIR_D/last_autorun_report && `grep -c "^@ID:${autorun_id} - " $RTEMPDIR_D/last_autorun_report` -gt 0 ]] ; then
        prev_report=$(grep "^@ID:$autorun_id - " $RTEMPDIR_D/last_autorun_report|tail -1|sed 's/^@ID.* - //g'|sed 's/^\s*//g'|sed 's/\s*$//g')
 
        b_prev_report=$(basename "$prev_report")
        b_html_report=$(basename "$html_report")

	p_total_checks=$(grep '<td>Total checks</td>' $prev_report|sed 's/[^0-9]//g')
	p_passed_checks=$(grep '<td>Passed checks</td>' $prev_report|sed 's/[^0-9]//g')
	p_failed_checks=$(grep '<td>Failed(fail/warn/info/skip) checks</td>' $prev_report|sed 's/[^0-9]//g')
        p_shc_header=$(perl -e 'open(INPUT,"'$prev_report'"); while(<INPUT>){ if ($_ =~ m/(System Health Score is [0-9]* out of [0-9]*)/g) { print $1; break;}}') 

	c_total_checks=$(grep '<td>Total checks</td>' $html_report|sed 's/[^0-9]//g')
	c_passed_checks=$(grep '<td>Passed checks</td>' $html_report|sed 's/[^0-9]//g')
	c_failed_checks=$(grep '<td>Failed(fail/warn/info/skip) checks</td>' $html_report|sed 's/[^0-9]//g')
        c_shc_header=$(perl -e 'open(INPUT,"'$html_report'"); while(<INPUT>){ if ($_ =~ m/(System Health Score is [0-9]* out of [0-9]*)/g) { print $1; break;}}') 

	echo ""								> $DIFF_RUN_REPORT
        echo "$b_prev_report System Health Score"			>>$DIFF_RUN_REPORT
	echo "-----------------------------------------"		>>$DIFF_RUN_REPORT
	echo "$p_shc_header"						>>$DIFF_RUN_REPORT
	echo "Total checks                 	:  $p_total_checks"	>>$DIFF_RUN_REPORT
	echo "Passed checks                	:  $p_passed_checks" 	>>$DIFF_RUN_REPORT
	echo "Failed(fail/warn/info/skip) checks:  $p_failed_checks" 	>>$DIFF_RUN_REPORT
	echo ""								>>$DIFF_RUN_REPORT
	echo ""								>>$DIFF_RUN_REPORT
	echo ""								>>$DIFF_RUN_REPORT
        echo "$b_html_report System Health Score"			>>$DIFF_RUN_REPORT		
	echo "-----------------------------------------"		>>$DIFF_RUN_REPORT
	echo "$c_shc_header"						>>$DIFF_RUN_REPORT
	echo "Total checks                	:  $c_total_checks"	>>$DIFF_RUN_REPORT
	echo "Passed checks                	:  $c_passed_checks"	>>$DIFF_RUN_REPORT
	echo "Failed(fail/warn/info/skip) checks:  $c_failed_checks"	>>$DIFF_RUN_REPORT
        echo ""								>>$DIFF_RUN_REPORT
        echo ""								>>$DIFF_RUN_REPORT
        $PDIR/${program_name} -diff $prev_report $html_report 		>>$DIFF_RUN_REPORT

        tchks=$(grep '^Total' $DIFF_RUN_REPORT | grep -v 'checks' | awk '{print $NF}')
        schks=$(grep '^Same' $DIFF_RUN_REPORT | awk '{print $NF}')
        if [ ! -n "$tchks" ] ; then tchks=0; fi
        if [ ! -n "$schks" ] ; then schks=0; fi
        if [[ $RAT_DEBUG -eq "1" ]] ; then log_daemon "tchks=$tchks schks=$schks"; fi
        if [[ $tchks -ne $schks ]] ; then
          subj="ID:${autorun_id} : Differences found in $program_name run."
        else
          subj="ID:${autorun_id} : No differences found in $program_name run."
        fi
        matter=$(cat $DIFF_RUN_REPORT)
        diff_report=$(echo "$matter"|grep 'Check comparison is complete'|sed 's/Check comparison is complete. The comparison report can be viewed in: //g'|sed 's/^\s//g'|sed 's/\s$//g')
        send_email "$subj" "$matter" "1"
      else
        b_html_report=$(basename "$html_report")

        c_total_checks=$(grep '<td>Total checks</td>' $html_report|sed 's/[^0-9]//g')
        c_passed_checks=$(grep '<td>Passed checks</td>' $html_report|sed 's/[^0-9]//g')
        c_failed_checks=$(grep '<td>Failed(fail/warn/info/skip) checks</td>' $html_report|sed 's/[^0-9]//g')
   	c_shc_header=$(perl -e 'open(INPUT,"'$html_report'"); while(<INPUT>){ if ($_ =~ m/(System Health Score is [0-9]* out of [0-9]*)/g) { print $1; break;}}')
	
	echo ""								> $DIFF_RUN_REPORT
	echo "First run results"					>>$DIFF_RUN_REPORT
        echo ""                                                 	>>$DIFF_RUN_REPORT
        echo ""                                                 	>>$DIFF_RUN_REPORT
        echo "$b_html_report System Health Score"               	>>$DIFF_RUN_REPORT
        echo "-----------------------------------------"        	>>$DIFF_RUN_REPORT
        echo "$c_shc_header"                                    	>>$DIFF_RUN_REPORT
        echo "Total checks                 	:  $c_total_checks"  	>>$DIFF_RUN_REPORT
        echo "Passed checks               	:  $c_passed_checks" 	>>$DIFF_RUN_REPORT
        echo "Failed(fail/warn/info/skip) checks:  $c_failed_checks" 	>>$DIFF_RUN_REPORT
        echo ""                                                 	>>$DIFF_RUN_REPORT
        echo ""                                                 	>>$DIFF_RUN_REPORT
        matter=$(cat $DIFF_RUN_REPORT)

        send_email "ID:${autorun_id} : First $program_name run." "$matter" "1"
      fi
      purge_collections
    fi

    if [[ -n "$html_report" && -f "$html_report" ]] ; then
      echo "@ID:${autorun_id} - $html_report" >> $RTEMPDIR_D/last_autorun_report

      ar_collection=$(dirname "$html_report") 
      ar_collection=$(basename "$ar_collection")
      echo "@ID:${autorun_id} - $ar_collection" >> $autorun_list
    fi
  fi

  if [ -e "$RTEMPDIR_D/run.log.done" ]; 
  then 
    current_html_report=$(grep "Detailed report (html)" $RTEMPDIR_D/run.log.done | awk '{print $NF}' | sed 's/\.html.*/.html/'|head -1)
    current_html_report=$(basename "$current_html_report"|sed 's/.html//g')
    if [[ -n "$current_html_report" ]]; then 
      mv -f $RTEMPDIR_D/run.log.done $WRKDIR/$current_html_report.log; 
    fi
  fi

  rm -f $RTEMPDIR_D/client.pid

  if [ -e "$cur_p_conf_file" ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;

  log_daemon "Finished ${program_name} execution"
}

#function to map ip address to switch name and find switch type for each(leaf or spine)
switch_ip_type_name_mapping ()
{
  o_ibnetdiscover_fil=$OUTPUTDIR/o_ibnetdiscover_${localnode}.out
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then o_ibnetdiscover_fil=$OUTPUTDIR/o_ibnetdiscover_exalogic_${localnode}.out; fi 

  if [[ -e $OUTPUTDIR/o_ibswitches_${localnode}.out && -e $o_ibnetdiscover_fil ]]
  then
    if [ -e $SWITCH_TYPE_FIL ]; then rm -rf $SWITCH_TYPE_FIL >/dev/null 2>&1;fi
    for switchip in `cat $OUTPUTDIR/o_ibswitches_${localnode}.out`
    do
      is_ibswitch_ip=$(echo $switchip|grep -c '[A-Za-z]')
      if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
      then
          ib_switch_name=$(nslookup $switchip|grep -iw name|awk '{print $NF}'|sed 's/\.$//')
      else
          ib_switch_name=$switchip
      fi
      short_ib_switch_name=$(echo $ib_switch_name|cut -d. -f1)
      ib_switch_type=$(grep -w "$short_ib_switch_name" $o_ibnetdiscover_fil|cut -d'|' -f2|sort -u|head -1)
      if [ -z "$ib_switch_type" ]; then ib_switch_type=$(grep -w "$ib_switch_name" $o_ibnetdiscover_fil|cut -d'|' -f2|sort -u|head -1);fi
      if [ -z "$ib_switch_type" ]; then ib_switch_type=$(grep -w "$switchip" $o_ibnetdiscover_fil|cut -d'|' -f2|sort -u|head -1);fi
      if [ -z "$ib_switch_type" ]; then ib_switch_type="unknown";fi
      echo "$switchip|$ib_switch_type|$ib_switch_name">>$SWITCH_TYPE_FIL
    done
    #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
      cp -f $SWITCH_TYPE_FIL $TMP_OUTPUT; 
      chmod 640 $SWITCH_TYPE_FIL; 
    else
      cp -f $SWITCH_TYPE_FIL $RTEMPDIR;
    fi
  fi
  if [[ -n "$RAT_TORSWITCHES" ]]
  then
    for switchip in `echo -e "$RAT_TORSWITCHES" | tr ',' ' '`
    do
      is_switch_ip=$(echo $switchip | grep -c '[A-Za-z]')
      if [[ -n $is_switch_ip && $is_switch_ip -eq 0 ]]
      then
        switch_name=$(nslookup $switchip | grep -iw name|awk '{print $ NF}' | sed 's/\.$//')
      else
        switch_name=$switchip
      fi
      short_switch_name=$(echo $switch_name |cut -d. -f1)
      switch_type="tor"
      echo "$switchip|$switch_type|$switch_name" >> $SWITCH_TYPE_FIL
    done
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
      cp -f $SWITCH_TYPE_FIL $TMP_OUTPUT; 
      chmod 640 $SWITCH_TYPE_FIL; 
    else
      cp -f $SWITCH_TYPE_FIL $RTEMPDIR;
    fi

  fi
  unset is_ibswitch_ip
  unset is_switch_ip
}

#function to download new exachk from MOS
function download_from_mos()
{
  return 1;
  PROCEED=1
  MOVE_CURRENT_VER=1
  DAYS_LIMIT=100		
  AUTOUPDATE=0
  
  if [[ $UPDATE_RUN -eq 1 ]]
  then
    if [[ "$TYP" != "-f" && "$TYP_S" != "-S" && "$TYP_S" != "-s" ]]
    then
      if [[ $daemon_running -ne "1" ]]
      then
      	if  [ -e $SCRIPTPATH/.cgrep/auto_downloader.pl ]
      	then
      	  if  [ -w $SCRIPTPATH ]
      	  then
      	    SUPPORT_HOST='support.oracle.com'
      	    platform=`uname -s`
            test_node_reachability "$SUPPORT_HOST";
            if [ $el_node_ping -eq "1" ] ; then
              exitcode=0;
            else
              exitcode=1;
            fi

      	    if [ $exitcode = 0 ]
      	    then
      	      AUTOUPDATE=1
      	    else
      	      echo ""
      	      echo -e $RED"MOS($SUPPORT_HOST) is not reachable.${NORM}";
      	      echo ""
      	      PROCEED=2
      	    fi
      	  else
      	    echo ""
      	    echo -e ${RED}"$SCRIPTPATH is read-only directory.$SCRIPTPATH must be writable to update $program_name.${NORM}";
      	    echo ""
      	    PROCEED=2
      	  fi
      	else
      	  echo ""
      	  echo -e ${RED}"Auto-update Component is missing.Please try to update $program_name manually.${NORM}";
      	  echo ""
      	  PROCEED=2
      	fi
      else
        echo ""
        echo -e ${RED}"Daemon is running in background.Please stop the daemon using $program_name -d start' and then try to update $program_name.${NORM}";
        echo ""
      	PROCEED=2
      fi
    else
      echo ""
      echo -e ${RED}"$program_name cannot be updated in offline/silent mode.${NORM}";
      echo ""
      PROCEED=2
    fi
  fi
  
  if [[ $AUTOUPDATE -eq 1 ]]
  then
    MOS_ATTEMPT=3
    if [[ ${program_name} = "raccheck" ]]
    then
      MOS_URL="https://support.oracle.com/epmos/faces/DocumentDisplay?id=1070954.1"
    elif [[ ${program_name} = "odacheck" ]]
    then
      MOS_URL="https://support.oracle.com/epmos/faces/DocumentDisplay?id=1070954.1"
    elif [[ ${program_name} = "exachk" ]]
    then
      MOS_URL="https://support.oracle.com/epmos/faces/DocumentDisplay?id=1070954.1"
    fi
    perl_exe=$(which perl);
    
    while [ $MOS_ATTEMPT -ge 1 ]
    do
      echo ""
      if [ $MOS_ATTEMPT -eq 3 ]
      then
        echo "Credentials required to login to My Oracle Support:"
      else
        echo "Please re-enter credentials correctly, $MOS_ATTEMPT tries remaining"
      fi
      
      exec 3<&2; exec 2<&0
      $READ -p "Enter Username:" MOS_USERNAME
      exec 2<&3

      tty -s && stty -echo
      exec 3<&2; exec 2<&0
      $READ -p "Enter Password:" MOS_PASSWORD
      exec 2<&3
      tty -s && stty echo

      echo ""
      security_fix "fix_plugin_or_rtscript_attributes" "$RTEMPDIR/auto_downloader.pl" "" "540"
      ade_status=`$perl_exe $RTEMPDIR/auto_downloader.pl -u "$MOS_USERNAME" -p "$MOS_PASSWORD" -l "$MOS_URL" -b "$SCRIPTPATH/${program_name}_bundle.zip" -v "$show_version_envfile" 2>&1`;
      
      if [[ `echo "$ade_status"| grep -ci 'Error Code:2'` -eq 1 ]]
      then
        ade_status=`echo "$ade_status"|sed 's/\[Error Code:[0-9]*\]\s*//g'`;
        echo ""
        echo -e ${RED}"$ade_status ${NORM}";
        MOS_ATTEMPT=0
        PROCEED=2
      elif [[ `echo "$ade_status"| grep -ci 'Error Code:3'` -eq 1 ]]
      then
        echo -e ${RED}"Incorrect username or password. ${NORM}"
        MOS_ATTEMPT=$(expr $MOS_ATTEMPT - 1)		
        if [ $MOS_ATTEMPT -eq 0 ]
        then
          ade_status=`echo "$ade_status"|sed 's/\[Error Code:[0-9]*\]\s*//g'`;
          echo ""
          echo -e ${RED}"$ade_status ${NORM}";
          echo -e ${RED}"${program_name} update failed. ${NORM}"
          PROCEED=2
        fi
      elif [[ `echo "$ade_status"| grep -ci 'Info Code:4'` -eq 1 ]]
      then 
        ade_status=`echo "$ade_status"|sed 's/\[Info Code:[0-9]*\]\s*//g'`;
        echo ""
        echo -e $ade_status Proceeding with existing ${program_name}.
        echo ""
        MOS_ATTEMPT=0
        PROCEED=1		
      elif [[ `echo "$ade_status"| grep -ci 'Info Code:1'` -eq 1 ]]
      then
        ade_status=`echo "$ade_status"|sed 's/\[Info Code:[0-9]*\]\s*//g'`;
        echo ""
        echo -e "$ade_status. Restarting updated ${program_name}...."
        echo ""
        MOS_ATTEMPT=0
        PROCEED=3		
      else
        echo ""
        echo -e "Unexpected error occurred while updating ${program_name}."
        echo ""
        MOS_ATTEMPT=0
        PROCEED=2		
      fi
    done
    
    if [[ $PROCEED -eq 3 ]]
    then
      if [ `echo $argsaved | grep -cw 'update'` -gt "0" ] ; then
        argsaved=$(echo $argsaved | sed 's/-update//')
      fi
    
      c_pro_pid=$$;
      for _child in $(ps -o pid --no-headers --ppid ${c_pro_pid})
      do
        kill -9 ${_child} >/dev/null 2>&1
      done
    
      ./${SCRIPTPATH}/${program_name} ${argsaved}
      exit 1
    fi
  fi
  
  if [[ $PROCEED -eq 2 ]]
  then
    exec 3<&2; exec 2<&0
    $READ -p "Do you want to proceed with existing ${program_name}?[y/n][y]" E_PRO
    read_code=`echo $?`;
    exec 2<&3
    process_prompt "$read_code" "E_PRO" "y"
    echo ""
    case $E_PRO in
      y|Y|yes|YES|Yes)
      	MOVE_CURRENT_VER=1
        ;;
      n|N|No|NO)
      	MOVE_CURRENT_VER=0
        ;;
      *)
      	MOVE_CURRENT_VER=1
        ;;
    esac	
  fi
  
  if [[ $MOVE_CURRENT_VER -ne 1 ]]
  then
    exit 1;
  fi
}

remove_passwords_in_debug_called=0
# Cleanup the debug o/p to remove cell, switch, root, osuser, db passwords
function remove_passwords_in_debug()
{
  if [ $remove_passwords_in_debug_called -eq "1" ] ; then return; fi

  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" ]]; then set +x; fi
  # Remove the passwords
  for a_password in $RAT_UPLOAD_PASSWORD $cell_rootpassword $switch_rootpassword $zfs_rootpassword $global_root_password $compute_rootpassword $node_rootpassword $global_cell_rootpassword $global_zfscell_rootpassword $global_switch_rootpassword ${a_cell_rootpassword[@]} ${a_zfs_rootpassword[@]} ${a_compute_rootpassword[@]} ${a_ib_switch_root_password[@]} ${mb_sysdba_pswd[@]} ${mb_pdb_sys_password[@]} ${a_node_passwords[@]} $SSO_PASSWORD $OMS_SYSMAN_PASSWORD $exacli_password $global_exacli_passwd ${exacli_passwdonly_list[@]}
  do
    if [ `echo "$a_password" | grep -c '[a-zA-Z]'` -gt "0" ] ; then
      a_password2=$(echo "$a_password"| $perl_exe -p -e 's/(.)/$1./g' |sed 's/.$//' |$perl_exe -p -e 's/([^A-Za-z0-9\\\.\n])/\\$1/g')
      a_password=$(echo "$a_password"| $perl_exe -p -e 's/([^A-Za-z0-9\n])/\\$1/g')

      if [ -e $RAT_DEBUG_FILENAME_INTERNAL ]; then remove_passwords_in_file $RAT_DEBUG_FILENAME_INTERNAL; fi
      if [ -e $OUTPUTDIR/log/watchdog.log ]; then remove_passwords_in_file $OUTPUTDIR/log/watchdog.log; fi

      for s_file in `ls $OUTPUTDIR/log/*.slave.log 2>/dev/null`
      do
        remove_passwords_in_file $s_file
      done
      if [[ -n "$RAT_DAEMONDEB_INTERNAL" && -f "$RAT_DAEMONDEB_INTERNAL" ]] ; then
        remove_passwords_in_file $RAT_DAEMONDEB_INTERNAL
      fi
      if [ -n "$RAT_CLIENT_RUN_LOG_INTERNAL" ] ; then
        remove_passwords_in_file $RAT_CLIENT_RUN_LOG_INTERNAL
      fi
    fi
  done
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" ]]; then set -x; fi

  remove_passwords_in_debug_called=1
}

function remove_passwords_in_file
{
  filen=$1
  $perl_exe -p -i -e "s/$a_password/${program_name}_password/g" $filen
  $perl_exe -p -i -e "s/$a_password2/${program_name}_password_slash/g" $filen
}

exit_status ()
{
  if [[ -n "$RAT_OUTPUT" && -n "$RAT_COPY_EM_XML_FILES" && $RAT_COPY_EM_XML_FILES -ge 1 ]];
  then
    let failed_checks=$G_FAIL_CHECKS+$G_WARN_CHECKS+$G_INFO_CHECKS
    let passed_checks=$G_TOTAL_CHECKS-$failed_checks
    if [[ $G_FAIL_CHECKS -gt 0 ]];
    then
      exit 3;	
    elif [[ $G_WARN_CHECKS -gt 0 && $G_INFO_CHECKS -gt 0 ]];
    then
      exit 2;
    elif [[ $G_WARN_CHECKS -le 0 && $G_INFO_CHECKS -gt 0 ]];
    then
      exit 1;
    elif [[ $passed_checks -eq $G_TOTAL_CHECKS ]];
    then
      exit 0;
    fi
  fi
}

function move_failed_to_skipped ()
{
  icode=$1
  imsg=$2
  idetail=$3
  ipchecks=$4

  iFILVAL=$5
  iFILVAL=$(echo "$iFILVAL"|sed "s/^\s*//g"|sed "s/\s*$//g")

  if [[ `echo "$iFILVAL"|grep -ic "^[0-9][0-9]*$"` -eq 0 || `echo "$iFILVAL"|wc -l|sed 's/ //g'` -gt "1" ]]; then unset iFILVAL; fi

  if [[ -n "$icode" && $icode = "OS_OUT_CHECK" ]]; then
    if [[ -n "$iFILVAL" && "$iFILVAL" = "9196" ]]; then
      call_get_log_result=0;			
      skip_this_version=1;
      SKIP_CHECK=1
      rskip_os_out_check=1

      reason_failed="exit code is $iFILVAL";

      echo "skipping $audit_check_name(checkid:-$CHECK_ID) on $idetail because $reason_failed and check does not apply to this system." >>$RSKIPFIL
    fi
  else
    #if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ -n $ipchecks && $ipchecks -eq "1" ]] && [[ -n $ipchecks && $ipchecks -eq "2" ]]; then
    if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ -n $ipchecks && $ipchecks -eq "1" ]]; then
      #Format:CheckId:Host:DBname:Returncode
     
      if [[ -n $PRET_STATUS && $PRET_STATUS -eq "0" ]]; then
        if [ -f "$t_PSQL_STAT" ]; then
          #if [[ `grep -ic "^$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"` -gt "0" ]]; then      
          if [[ `grep -ic "^$CHECK_ID:.*:$db_name_to_check:" "$t_PSQL_STAT"` -gt "0" ]]; then      
          #if [[ `grep -ic "$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"` -gt "0" ]]; then      
            #if [[ $ipchecks -eq "2" ]] ; then
            #  status_line=$(grep "^Report:$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"); 
            #else
            #  status_line=$(grep "^Execute:$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"); 
            #fi
            unset status_line
            status_line=$(grep "^$CHECK_ID:$i:$db_name_to_check:" "$t_PSQL_STAT"|head -1); 
            if [[ -z $status_line || $status_line = "" ]]; then status_line=$(grep "^$CHECK_ID:.*:$db_name_to_check:" "$t_PSQL_STAT"|head -1); fi

            #icode=$(echo "$status_line" | cut -d':' -f5)
            icode=$(echo "$status_line" | cut -d':' -f4)
            alvl=$(echo "$status_line" | cut -d':' -f5)

            if [[ -n "$alvl" ]]; then ALVL=$alvl; fi
          
            if [[ -n $icode ]] ; then
              #if [[ $COMTYPE = "OS" || $COMTYPE = "SQL" || $COMTYPE = "SQL_COLLECT" ]] ; then
              if [[ $COMTYPE = "OS" || $COMTYPE = "SQL" ]]; then
                if [[ -n "$iFILVAL" && "$iFILVAL" = "9196" ]]; then
                  call_get_log_result=0;			
                  skip_this_version=1;
          	  SKIP_CHECK=1

  		  rskip_os_sql=1
                  reason_failed="exit code is $iFILVAL";

                  echo "skipping $audit_check_name(checkid:-$CHECK_ID) on $idetail because $reason_failed and check does not apply to this system." >>$RSKIPFIL
          	  return;
                elif [[ $icode -ne 0 ]]; then
                  call_get_log_result=0;
                  skip_this_version=1;

                  let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                  let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
          	  validate_needs_running;
                fi
              fi
            fi
          fi
        fi
        return 
      else
        icode=$PRET_STATUS
      fi
    fi

    if [[ $icode -gt "100" ]] ; then
      reason_failed="was killed.";
    else
      reason_failed="failed with exit code $icode.";
    fi
 
    if [[ -n "$iFILVAL" && "$iFILVAL" = "9196" ]]; then
      call_get_log_result=0;			
      skip_this_version=1;
      SKIP_CHECK=1
 
      rskip_os_sql=1
      reason_failed="exit code is $iFILVAL";

      echo "skipping $audit_check_name(checkid:-$CHECK_ID) on $idetail because $reason_failed and check does not apply to this system." >>$RSKIPFIL
    elif [[ $icode -ne 0 ]];
    then
      call_get_log_result=0;			
      skip_this_version=1;
      if [[ -z "$3" ]];
      then
        if [[ -z "$2" ]];
        then
          echo "skipping $audit_check_name(checkid:-$CHECK_ID) because audit check execution $reason_failed" >>$SKIPFIL
          errm="skipping $audit_check_name(checkid:-$CHECK_ID) because audit check execution $reason_failed"
          update_errm_in_syslog
        else
          echo "skipping $2 because audit check execution $reason_failed" >>$SKIPFIL
          errm="skipping $2 because audit check execution $reason_failed"
          update_errm_in_syslog
        fi
      else
        echo "[$idetail] skipping $audit_check_name(checkid:-$CHECK_ID) because audit check execution $reason_failed" >>$SKIPFIL
        errm="[$idetail] skipping $audit_check_name(checkid:-$CHECK_ID) because audit check execution $reason_failed"
        update_errm_in_syslog
      fi
      let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
      validate_needs_running;
    fi
  fi
}

check_cascade_prompt ()
{
  echo -e "\n\nChecking for prompts in $PROFILE on $prompt_host for $usern user...\n\n"
  if [ "$prompt_host" = "$localnode" ]
  then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then 
      security_fix "fix_plugin_or_rtscript_attributes" "$PRMPTORCLENVFIL" "" "540"
    else
      security_fix "fix_plugin_or_rtscript_attributes" "$PRMPTORCLENVFIL" "" "740"
    fi
    returncode=`. $PRMPTORCLENVFIL`
    returncode=$(echo $?)
  else
    $SCOPY $PRMPTORCLENVFIL $prompt_host:$RTEMPDIR >/dev/null 2>&1
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then 
      $SSHELL $prompt_host "chmod 540 $RTEMPDIR/prmpt_set_orcl_env_file.sh" >/dev/null 2>&1
    else
      $SSHELL $prompt_host "chmod 740 $RTEMPDIR/prmpt_set_orcl_env_file.sh" >/dev/null 2>&1
    fi
    returncode=`$SSHELL $prompt_host "$RTEMPDIR/prmpt_set_orcl_env_file.sh"`
    returncode=$(echo $?)
  fi
    
  #rm -f $PRMPTORCLENVFIL >/dev/null 2>&1;

  if [ $returncode -ne 0 ]
  then
    echo -e "${RED}There are prompts in $PROFILE on $prompt_host which will cause issues in $program_name successful execution. Please remove or comment all prompts in $PROFILE and run again\n\n"$NORM   
    exit 1 
  fi
}

check_hostname_mismatch ()
{
  #actual_hostname=$(hostname -s)
  actual_hostname=$(hostname|cut -d"." -f1)
  eth0_exists=$(/sbin/ifconfig eth0 >/dev/null 2>&1;echo $?) 
  if  [ $eth0_exists -eq 0 ]
  then
      mgmt_interface=eth0
  else
      eth1_exists=$(/sbin/ifconfig eth1 >/dev/null 2>&1;echo $?)
      if [ $eth1_exists -eq 0 ] 
      then
           mgmt_interface=eth1
       fi
  fi
  if [ -n "$mgmt_interface" ]
  then 
      ipv6_check=$(/sbin/ifconfig $mgmt_interface|grep -wc "inet")
      if [[ -n "$ipv6_check" && $ipv6_check -gt 0 ]];
      then
	  mgmt_hostname=$(grep -w `/sbin/ifconfig $mgmt_interface|grep -w "inet"|awk '{print $2}'|cut -d: -f2` /etc/hosts|grep -v ^#|awk '{print $NF}'|cut -d. -f1|head -1)
	  dns_hostname=$(/sbin/ifconfig $mgmt_interface|grep -w "inet"|awk '{print $2}'|cut -d: -f2|nslookup 2>/dev/null|grep -w name|awk '{print $NF}'|cut -d. -f1)
      else
	  mgmt_ipv6_address=$(/sbin/ifconfig $mgmt_interface|grep -w "inet6"|awk '{print $3}'|head -1|cut -d'/' -f1)
	  if [ -n "$mgmt_ipv6_address" ]
	  then
	      mgmt_hostname=$(grep -w  "$mgmt_ipv6_address" /etc/hosts|grep -v ^#|awk '{print $NF}'|cut -d. -f1|head -1)
	      dns_hostname=$(nslookup $"$mgmt_ipv6_address"|grep -w name|awk '{print $NF}'|cut -d. -f1)
	  fi   
      fi
  fi
  if [[ -n "$actual_hostname" && -n "$mgmt_hostname" && -n "$dns_hostname" && "$dns_hostname" = "$mgmt_hostname" && "$actual_hostname" != "$mgmt_hostname" ]]
  then
    actual_hostname_ssh_status=1
    for clienthname in `cat $HOSTLIST`
    do
      is_cell_locked "$clienthname" "$usern"
      if [[ -n "$cell_locked" && $cell_locked -eq 1 ]]
      then
          actual_hostname_ssh_status=0
          break
      fi
    done    
    if [[ -n "$actual_hostname_ssh_status" && $actual_hostname_ssh_status -eq 0 ]]
    then 
        echo -e "${RED}\n\nDefault hostname is not mapped to management network rather its mapped to client network and ssh is not enabled on client network.\n\nManagement network hostname = $mgmt_hostname\n\nDefault/client network hostnanme = $actual_hostname\n\n${program_name} is exiting.${NORM}\n\nrun ${program_name} with -clusternodes command line argument and specify comma separated management network hostnames.\n\neg ./${program_name} -clusternodes $mgmt_hostname,\n\n"
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
            EMSG="Default hostname is not mapped to management network rather its mapped to client network and ssh is not enabled on client network. Management network hostname = $mgmt_hostname and Default/client network hostnanme = $actual_hostname. Please set RAT_CLUSTERNODES to management network hosts and re-run"     
            update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
        exit 1
    fi
  else
    echo "value for check_hostname_mismatch actual_hostname=$actual_hostname mgmt_hostname=$mgmt_hostname dns_hostname=$dns_hostname management interface=$mgmt_interface">>$LOGFIL
  fi
}

update_location_file ()
{
  if [ ! -z "$MERGEFILES" ]; then return; fi;
  old_IFS=$IFS
  unset IFS
  locVersion=$(echo $modelVersion|tr -d ' ')
  for hname in `cat $HOSTLIST`
  do
    if [ $hname = $localnode ]
    then
      echo -e "#####${program_name} metadata#####" 2>>$ERRFIL  		> $SIGNFIL
      echo -e "\ninstall node = ${localnode}" 2>>$ERRFIL  		>>$SIGNFIL
      echo -e "\n${program_name} version = $locVersion" 2>>$ERRFIL 	>>$SIGNFIL
      echo -e "\nInstall location = $(dirname $ABSTPATH)" 2>>$ERRFIL 	>>$SIGNFIL
      echo -e "\nOutput location = ${WRKDIR}" 2>>$ERRFIL 		>>$SIGNFIL
      echo -e "\nCommandline Arguments = ${argsaved}" 2>>$ERRFIL 	>>$SIGNFIL
      echo -e "\nLast run at = ${collection_date}" 2>>$ERRFIL 		>>$SIGNFIL
      #if [[ -e $SIGNFIL && -e /tmp ]]; then mv -f $SIGNFIL /tmp/ >/dev/null 2>&1;fi
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
        dirlist=$(echo "$USR_DIRS"|sed "s/^\s*//g"|sed "s/\s*$//g")
        for utildir in `echo "$dirlist"`
        do
           dir_utildir=$(dirname $utildir)
           if [[ -e $SIGNFIL && -e $dir_utildir ]]; then cp -f $SIGNFIL $dir_utildir >/dev/null 2>&1; fi
        done
      fi
      if [[ -e $SIGNFIL && -e '/tmp' ]]; then cp -f $SIGNFIL /tmp >/dev/null 2>&1; fi
    else
      node_ssh_user=$usern
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
          node_ssh_user="${root_user}"
        else
          node_ssh_user="${foxtrot_dom0_user}"
        fi
      fi
      #if [[ -e $SIGNFIL && -e /tmp ]]; then $SCOPY $SIGNFIL $node_ssh_user@$hname:/tmp/ >/dev/null 2>&1;fi 
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
        dirlist=$(echo "$USR_DIRS"|sed "s/^\s*//g"|sed "s/\s*$//g")
        for utildir in `echo "$dirlist"`
        do
           dir_utildir=$(dirname $utildir)
           if [[ -e $SIGNFIL && -e $dir_utildir ]]; then $SCOPY $SIGNFIL $node_ssh_user@$hname:$dir_utildir >/dev/null 2>&1;fi 
        done
      fi
      if [[ -e $SIGNFIL && -e '/tmp' ]]; then $SCOPY $SIGNFIL $node_ssh_user@$hname:/tmp >/dev/null 2>&1;fi 
    fi 
  done
  IFS=$old_IFS
}

update_daemon_file ()
{
  old_IFS=$IFS
  unset IFS
  locVersion=$(echo $modelVersion|tr -d ' ')

  echo -e "">$DAEMONFIL
  echo -e "----------------------------------------------------------">>$DAEMONFIL
  echo -e "${program_name} daemon information">>$DAEMONFIL
  echo -e "----------------------------------------------------------">>$DAEMONFIL
  echo -e " \ninstall node = ${localnode}">>$DAEMONFIL
  echo -e " \n${program_name} daemon version = $locVersion">>$DAEMONFIL
  echo -e " \nInstall location = $(dirname $ABSTPATH)">>$DAEMONFIL
  echo -e " \nStarted at = $(date)">>$DAEMONFIL
}

function remove_preinitsetup ()
{
  if [ -e "$INITDMP" ]
  then
    assign_usern	
    for initentry in `cat $INITDMP`
    do
      rusern=$(echo "$initentry"|cut -d: -f2)
      rhostn=$(echo "$initentry"|cut -d: -f3)
  	
      if [ `echo "$initentry"|grep -ic "S:"` -gt 0 ]
      then
        dhostn=$localnode	
        $SSHELL -o StrictHostKeyChecking=no -x -l $rusern $rhostn "/bin/sh -c \"sed /$usern@$dhostn/d ~/.ssh/authorized_keys > ~/.ssh/authorized_keys.new; cp -f ~/.ssh/authorized_keys ~/.ssh/authorized_keys.initsetup.tmp; mv -f ~/.ssh/authorized_keys.new ~/.ssh/authorized_keys;\" >/dev/null 2>&1"
      elif [ `echo "$initentry"|grep -ic "P:"` -gt 0 ]
      then
        dhostn=$rhostn
        $SSHELL -o StrictHostKeyChecking=no -x -l $usern $rhostn "/usr/bin/ssh -o StrictHostKeyChecking=no -x -l $rusern $rhostn \"sed /$usern@$dhostn/d ~/.ssh/authorized_keys > ~/.ssh/authorized_keys.new; cp -f ~/.ssh/authorized_keys ~/.ssh/authorized_keys.initsetup.tmp; mv -f ~/.ssh/authorized_keys.new ~/.ssh/authorized_keys;\" >/dev/null 2>&1"
      fi
    done
  fi
}

function prepare_initsetup ()
{
  setup_status=1
  if [[ $OFFLINE -eq 0 ]]; then

  use_expect_for_ssh=0
  unset node_rootpassword
  unset passwordToCheck

  assign_usern
  
  usern2="$usern"
  usern="${root_user}"
  
  if [ `cat $HOSTLIST|wc -l` -gt 0 ] ; then echo -e "\n"; echo -e "Checking ssh user equivalency between $usern2 and $usern user on COMPUTE Nodes\n"; fi;

  if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "serial" ]]; then
  for hname in `cat $HOSTLIST`
  do
    platform=`uname -s`
    
    if [ $hname != $localnode ]
    then
      test_node_reachability "$hname" "$usern";
      if [ $el_node_ping -eq "1" ] ; then
        exitcode=0;
      else
        exitcode=1;
      fi
    else
      exitcode=0
    fi

    if [[ $exitcode = 0 ]]
    then
      /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $hname ls 2>/dev/null 1>/dev/null
      ssh_setup_status=$?
      if [ $ssh_setup_status -ne 0 ]
      then
        if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq 1 ]] || [[ -n "$is_ssc_machine" && $is_ssc_machine -eq 1 ]] || [ $is_ssc_localzone_machine -eq 1 ] || [ $is_ssc_globalzone_machine -eq 1 ] || [ $is_ssc_globalzone_dbmachine -eq 1 ];
        then
          rsh_setup_status=1
        else
          rsh -l $usern $hname ls 2>/dev/null 1>/dev/null
          rsh_setup_status=$?
          if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
        fi
      fi

      if [[ $ssh_setup_status -eq 0 || $rsh_setup_status -eq 0 ]]
      then
	echo -e $GREEN"$usern user equivalence is configured between $localnode and $hname." $NORM
      else
	if [[ $use_expect_for_ssh -eq 0 ]]
	then
	  echo -e ${RED}"\n$usern user equivalence is not setup between $localnode and $hname."${NORM}
	  exec 3<&2; exec 2<&0
	  $READ -p "Do you want to configure $usern user equivalence between $localnode and $hname [y/n][y]" AutoLoginCheck
	  read_code=`echo $?`;
	  exec 2<&3
	  process_prompt "$read_code" "AutoLoginCheck" "n"
	fi

        case $AutoLoginCheck in
	y|Y|YES|yes|Yes)
          if [[ -z "$compute_samerootpassword_YesNo" ]]
          then
            compute_samerootpassword_YesNo="y"
            echo -e "\n"
	    exec 3<&2; exec 2<&0
            $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"
          fi

          case $compute_samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            compute_samerootpassword_YesNo="y"
            if [[ -z "$global_compute_rootpassword" ]]
            then
              printf  "Enter ${usern} password :- "
              tty -s && stty -echo
              $READ -r global_compute_rootpassword
              tty -s && stty echo
            fi

            printf "\n\nVerifying ${usern} password.\n\n. .\n";
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1"  && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
	      	
  	    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                global_compute_rootpassword=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
	  ;;
          n|N|No|NO|no)
            compute_samerootpassword_YesNo="n"
            printf  "Enter ${hname} ${usern} password :- "
            tty -s && stty -echo
            $READ -r compute_rootpassword
            tty -s && stty echo
            printf "\n\nVerifying ${usern} password.\n\n. .\n";
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$hname" "$usern" "$compute_rootpassword" "3"

            if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
            then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                global_compute_rootpassword=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
          ;;
          *)
            compute_samerootpassword_YesNo="y"
            if [[ -z "$global_compute_rootpassword" ]]
            then
              printf  "Enter ${usern} password :- "
              tty -s && stty -echo
              $READ -r global_compute_rootpassword
              tty -s && stty echo
            fi

            printf "\n\nVerifying ${usern} password.\n\n. .\n";
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
	      	
  	    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                global_compute_rootpassword=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
	  ;;
	esac
	;;
	n|N|NO|No|no)
          compute_samerootpassword_YesNo="n"
          echo -e $RED"\nWithout $usern user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
          setup_status=0
          return
	;;
	*)
          if [[ -z "$compute_samerootpassword_YesNo" ]]
          then
            compute_samerootpassword_YesNo="y"
            echo -e "\n"
	    exec 3<&2; exec 2<&0
            $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"
          fi

          case $compute_samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            compute_samerootpassword_YesNo="y"
            if [[ -z "$global_compute_rootpassword" ]]
            then
              printf  "Enter ${usern} password :- "
              tty -s && stty -echo
              $READ -r global_compute_rootpassword
              tty -s && stty echo
            fi

            printf "\n\nVerifying ${usern} password.\n\n. .\n";
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
	      	
  	    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                global_compute_rootpassword=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
	  ;;
          n|N|No|NO|no)
            compute_samerootpassword_YesNo="n"
            printf  "Enter ${hname} ${usern} password :- "
            tty -s && stty -echo
            $READ -r compute_rootpassword
            tty -s && stty echo
            printf "\n\nVerifying ${usern} password.\n\n. .\n";
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$hname" "$usern" "$compute_rootpassword" "3"

            if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
            then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                global_compute_rootpassword=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
          ;;
          *)
            compute_samerootpassword_YesNo="y"
            if [[ -z "$global_compute_rootpassword" ]]
            then
              printf  "Enter ${usern} password :- "
              tty -s && stty -echo
              $READ -r global_compute_rootpassword
              tty -s && stty echo
            fi

            printf "\n\nVerifying ${usern} password.\n\n. .\n";
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
	      	
  	    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                global_compute_rootpassword=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
	  ;;
	esac
	;;
	esac
      fi
    else
      echo ${RED}"Node $hname is not pingable so, no audit checks will be executed on $hname"${NORM}
    fi
  done
  else
  #parallel setup
  
  if [[ "$usern2" = "${root_user}" ]] 
  then
  for hname in `cat $HOSTLIST`
  do
    echo -e $GREEN"Node $hname is configured for ssh user equivalency between $usern2 and $usern user\n" $NORM
    echo -e ""
  done
  else
  for hname in `cat $HOSTLIST`
  do
    platform=`uname -s`
  
    PubkeyAuthentication="no"
    if [ $hname != $localnode ]
    then
      test_node_reachability "$hname" "$usern";
      if [ $el_node_ping -eq "1" ] ; then
        exitcode=0;
      else
        exitcode=1;
      fi

      if [[ $exitcode = 0 ]]
      then
  	$SSHELL $usern2@$hname "/usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $hname ls 2>/dev/null 1>/dev/null"
	ssh_setup_status=$?
        if [ $ssh_setup_status -ne 0 ]
        then
          if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq 1 ]];
          then
            rsh_setup_status=1
          else
            $SSHELL $usern2@$hname "rsh -l $usern $hname ls 2>/dev/null 1>/dev/null"
            rsh_setup_status=$?
            if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
          fi
        fi		
        if [[ $ssh_setup_status -eq 0 || $rsh_setup_status -eq 0 ]]
        then
          echo -e $GREEN"Node $hname is configured for ssh user equivalency between $usern2 and $usern user\n" $NORM
        else
          if [[ $use_expect_for_ssh -eq 0 ]]
          then
            echo -e $RED"$hname is not configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
	    exec 3<&2; exec 2<&0
            $READ -p "Do you want to configure SSH for between $usern2 and $usern user on $hname [y/n][y]" AutoLoginCheck
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "AutoLoginCheck" "n"
          fi

          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
            AutoLoginCheckYes=1 
	    use_expect_for_ssh=1

	    if [[ -z "$compute_samerootpassword_YesNo" ]]
            then
              compute_samerootpassword_YesNo="y"
    	      echo -e "\n"
	      exec 3<&2; exec 2<&0
	      $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"
            fi

	    case $compute_samerootpassword_YesNo in
	    y|Y|Yes|YES|yes)
	      compute_samerootpassword_YesNo="y"
	      if [[ -z "$global_compute_rootpassword" ]]
              then
	        printf  "Enter ${usern} password :- "
	        tty -s && stty -echo
	        $READ -r global_compute_rootpassword
	        tty -s && stty echo
	      fi

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
    	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 540 ${RTEMPDIR}/$program_name;"

		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    n|N|No|NO|no)
	      compute_samerootpassword_YesNo="n"
	      printf  "Enter ${hname} ${usern} password :- "
	      tty -s && stty -echo
	      $READ -r compute_rootpassword
	      tty -s && stty echo

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      checkUserPassword "$hname" "$usern" "$compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 540 ${RTEMPDIR}/$program_name;"

		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    *)
	      compute_samerootpassword_YesNo="y"
	      if [[ -z "$global_compute_rootpassword" ]]
              then
	        printf  "Enter ${usern} password :- "
	        tty -s && stty -echo
	        $READ -r global_compute_rootpassword
	        tty -s && stty echo
	      fi

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 540 ${RTEMPDIR}/$program_name;"

		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    esac
          ;;
          n|N|NO|No|no)
            echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	    setup_status=0
	    return
          ;;
          *)
            AutoLoginCheckYes=1 
	    use_expect_for_ssh=1

	    if [[ -z "$compute_samerootpassword_YesNo" ]]
            then
              compute_samerootpassword_YesNo="y"
    	      echo -e "\n"
	      exec 3<&2; exec 2<&0
	      $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"
            fi

	    case $compute_samerootpassword_YesNo in
	    y|Y|Yes|YES|yes)
	      compute_samerootpassword_YesNo="y"
	      if [[ -z "$global_compute_rootpassword" ]]
              then
	        printf  "Enter ${usern} password :- "
	        tty -s && stty -echo
	        $READ -r global_compute_rootpassword
	        tty -s && stty echo
	      fi

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 540 ${RTEMPDIR}/$program_name;"

		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    n|N|No|NO|no)
	      compute_samerootpassword_YesNo="n"
	      printf  "Enter ${hname} ${usern} password :- "
	      tty -s && stty -echo
	      $READ -r compute_rootpassword
	      tty -s && stty echo

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      checkUserPassword "$hname" "$usern" "$compute_rootpassword" "3"
              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 540 ${RTEMPDIR}/$program_name;"

		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    *)
	      compute_samerootpassword_YesNo="y"
	      if [[ -z "$global_compute_rootpassword" ]]
              then
	        printf  "Enter ${usern} password :- "
	        tty -s && stty -echo
	        $READ -r global_compute_rootpassword
	        tty -s && stty echo
	      fi

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 540 ${RTEMPDIR}/$program_name;"

		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    esac
          ;;
          esac
	fi
      else
        echo ${RED}"Node $hname is not pingable so, no audit checks will be executed on $hname"${NORM}
      fi
    else
      /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $hname ls 2>/dev/null 1>/dev/null
      ssh_setup_status=$?
      if [ $ssh_setup_status -ne 0 ]
      then
        if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq 1 ]];
        then
          rsh_setup_status=1
        else
          rsh -l $usern $hname ls 2>/dev/null 1>/dev/null
          rsh_setup_status=$?
          if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
        fi
      fi
    
      if [[ $ssh_setup_status -eq 0 || $rsh_setup_status -eq 0 ]]
      then
        echo -e $GREEN"Node $hname is configured for ssh user equivalency between $usern2 and $usern user\n" $NORM
      else
        if [[ $use_expect_for_ssh -eq 0 ]]
        then
          echo -e $RED"$hname is not configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
	  exec 3<&2; exec 2<&0
          $READ -p "Do you want to configure SSH between $usern and $usern2 user on $hname [y/n][y]" AutoLoginCheck
	  read_code=`echo $?`;
	  exec 2<&3
	  process_prompt "$read_code" "AutoLoginCheck" "n"
        fi
  
	compute_samerootpassword_YesNo="y"
        case $AutoLoginCheck in
        y|Y|YES|yes|Yes)
          AutoLoginCheckYes=1 

    	  echo -e "\n"
	  exec 3<&2; exec 2<&0
	  $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	  read_code=`echo $?`;
	  exec 2<&3
	  process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"

	  if [[ -z "$compute_samerootpassword_YesNo" ]]
          then
	    compute_samerootpassword_YesNo="y"
	  fi

          func_setup_ssh -user $usern -hosts "$hname" 
          if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
          then
            echo -e $RED"$hname: Failed to setup ssh user equivalency."$NORM;
            echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	    setup_status=0
	    return
	  else
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	    global_compute_rootpassword=$passwordToCheck
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	    echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
 	    echo "S:$usern:$hname" >> $INITDMP
          fi
        ;;
        n|N|NO|No|no)
          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	  setup_status=0
	  return
        ;;
        *)
          AutoLoginCheckYes=1 

    	  echo -e "\n"
	  exec 3<&2; exec 2<&0
	  $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	  read_code=`echo $?`;
	  exec 2<&3
	  process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"

	  if [[ -z "$compute_samerootpassword_YesNo" ]]
          then
	    compute_samerootpassword_YesNo="y"
	  fi

          func_setup_ssh -user $usern -hosts "$hname" 
          if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
          then
            echo -e $RED"$hname: Failed to setup ssh user equivalency."$NORM;
            echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	    setup_status=0
	    return
	  else
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	    global_compute_rootpassword=$passwordToCheck
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	    echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
 	    echo "S:$usern:$hname" >> $INITDMP
          fi
        ;;
        esac
      fi
    fi
  done
  fi
  fi
  
  use_expect_for_ssh=0
  unset node_rootpassword
  unset passwordToCheck
  if [[ -z "$RAT_CELLS" && -n $snlist_file && -e "$snlist_file" ]]
  then
      for cellname in `cat $snlist_file`
      do
         echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
      done
      CELLIP=$INPUTDIR/cellip.ora
  elif [ -z "$RAT_CELLS" ]
  then
      #CELLIP=/etc/oracle/cell/network-config/cellip.ora
      #cp -f /etc/oracle/cell/network-config/cellip.ora $INPUTDIR
      if [ -e /etc/oracle/cell/network-config/cellip.ora ]; then cat /etc/oracle/cell/network-config/cellip.ora|cut -d: -f1>$INPUTDIR/cellip.ora;fi
      CELLIP=$INPUTDIR/cellip.ora
  else
      for cellname in `echo $RAT_CELLS`
      do
         echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
      done
      CELLIP=$INPUTDIR/cellip.ora
  fi
  if [[ -z "$RAT_CELLS" && -n $extsnlist_file && -e "$extsnlist_file" ]]
  then
    for cellname in `cat $extsnlist_file`
    do
      echo "cell=\"$cellname\"">>$INPUTDIR/extcellip.ora
    done
    EXTCELLIP=$INPUTDIR/extcellip.ora
  fi
  is_this_db_machine $localnode

  ask_cell_password=1 
  PubkeyAuthentication=""
  if [[ $db_machine_compute -eq 1  || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1  || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]] && [ $TYP != "-p" ] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ "$upgrade_mode" -ne "3" ] && [ $only_hacheck_run -eq 0 ] && [ $ask_cell_password -eq "1" ] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] && [ -e "$CELLIP" ]
  then
    if [ -z "$RAT_CELL_SSH_USER" ];then cell_ssh_user="root"; else cell_ssh_user=$RAT_CELL_SSH_USER;fi
    usern=$cell_ssh_user
    cell_type="normal"
    
    if [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
    then
      cell_type="zfscell"
    fi
  
    #sed '/^\s*$/d' $CELLIP > $CELLIP.new
    #mv -f $CELLIP.new $CELLIP
    if [ `cat $CELLIP|wc -l` -gt 0 ] ; then echo -e "\n\nChecking ssh user equivalency between $usern2 and $cell_ssh_user user on STORAGE Servers\n"; fi;
  
    for hname in `cat $CELLIP|sed '/^\s*$/d'|cut -d\" -f2|cut -d\; -f2`
    do
      #cellPingStatus=$($PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1;echo $?)
      test_node_reachability "$hname" "$cell_ssh_user";
      if [ $el_node_ping -eq "1" ] ; then
        cellPingStatus=0;
      else
        cellPingStatus=1;
      fi
    
      if [ $cellPingStatus -eq 0 ]
      then 
        cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $hname ls >/dev/null 2>&1;echo $?);
	cell_password_status=0
        
        if [[ $cell_ssh_status -eq 0 ]]
        then
          echo -e $GREEN"$hname is configured for ssh user equivalency for $cell_ssh_user user\n" $NORM;
        else
          if [[ $use_expect_for_ssh -eq 0 ]]
          then
            echo -e $RED"$hname is not configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
	    exec 3<&2; exec 2<&0
            $READ -p "Do you want to configure SSH for user $cell_ssh_user on $hname [y/n][y]" AutoLoginCheck
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "AutoLoginCheck" "n"
          fi
          
          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
	    AutoLoginCheckYes=1
            if [[ -z "$cell_samerootpassword_YesNo" ]]
            then
              cell_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all STORAGE Servers?[y/n][y]" cell_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "cell_samerootpassword_YesNo" "y"
            fi

            case $cell_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_cell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_cell_rootpassword
		read_code=`echo $?`;
                tty -s && stty echo
		process_prompt "$read_code" "global_cell_rootpassword" "y"
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_cell_rootpassword=$passwordToCheck
                  #cell_password_status=1
                  cell_password_status=0
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
            n|N|No|NO|no)
              cell_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r cell_rootpassword
              tty -s && stty echo

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  #cell_password_status=1
                  cell_password_status=0
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_cell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_cell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  #cell_password_status=1
                  cell_password_status=0
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    esac
          ;;
          n|N|NO|No|no)
            echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
	    setup_status=0
	    return
          ;;
          *)
	    AutoLoginCheckYes=1
            if [[ -z "$cell_samerootpassword_YesNo" ]]
            then
              cell_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all STORAGE Servers?[y/n][y]" cell_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "cell_samerootpassword_YesNo" "y"
            fi

            case $cell_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_cell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_cell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  #cell_password_status=1
                  cell_password_status=0
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
            n|N|No|NO|no)
              cell_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r cell_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  #cell_password_status=1
                  cell_password_status=0
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_cell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_cell_rootpassword
		read_code=`echo $?`;
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  #cell_password_status=1
                  cell_password_status=0
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    esac
          ;;
          esac
        fi
      else
        echo -e $RED"\nSTORAGE Server $hname is not pingable, no audit checks will be executed on $hname\n"$NORM;
      fi
    done
    
    if [[ -n "$cell_password_status" && $cell_password_status -eq 0 && "$cell_ssh_user" = "root" && -z "$RAT_IBSWITCHES" ]]
    then
      first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)
      $SSHELL $cell_ssh_user@$first_cell_ip "rm -rf ${CELLRTEMPDIR} >/dev/null 2>&1"
      $SSHELL $cell_ssh_user@$first_cell_ip "mkdir ${CELLRTEMPDIR} >/dev/null 2>&1"
      $SSHELL $cell_ssh_user@$first_cell_ip "ibswitches 2>/dev/null >${CELLRTEMPDIR}/o_ibswitches_full.out"
      $SSHELL $cell_ssh_user@$first_cell_ip "cellcli -e \"list cell attributes makeModel,eighthrack\" 2>/dev/null>${SYSTEM_DESC_FIL}"
      $SCOPY $cell_ssh_user@$first_cell_ip:${CELLRTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
      $SCOPY $cell_ssh_user@$first_cell_ip:${SYSTEM_DESC_FIL} ${RTEMPDIR} >/dev/null 2>&1
      $SSHELL $cell_ssh_user@$first_cell_ip rm -f ${CELLRTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL} >/dev/null 2>&1
      $SSHELL $cell_ssh_user@$first_cell_ip "rmdir ${CELLRTEMPDIR}"
    elif [ -n  "$RAT_IBSWITCHES" ]
    then
      for switchname in `echo $RAT_IBSWITCHES`
      do
        echo $switchname >>${RTEMPDIR}/o_ibswitches_full.out
      done
    fi
  else
    cell_ssh_status=0
  fi
  
  use_expect_for_ssh=0 
  unset node_rootpassword
  unset passwordToCheck
  if [[ $is_ssc_machine -eq 1 || $is_exalogic_machine -eq 1 || $is_exalogic_foxtrot -eq "1" ]] && [[  $TYP != "-p"  && -n "$skip_in_silent" && $skip_in_silent -eq 0  && "$upgrade_mode" -ne "3" && $only_hacheck_run -eq 0 && $ask_zfs_password -eq "1" ]] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] && [ -e "$CELLIP" ]
  then
    zfs_ssh_user="root"
    usern="$zfs_ssh_user"
    cell_type="zfscell"
  
    if [ $is_ssc_machine -eq 1 ];then discover_ssc_zfs_nodes;elif [[ $is_exalogic_machine -eq 1 || -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ||  $is_zfssa_machine -eq 1 ]];then ZFSIP=$CELLIP;fi
  
    sed '/^\s*$/d' $CELLIP > $CELLIP.new
    mv -f $CELLIP.new $CELLIP
    if [ `cat $CELLIP|wc -l` -gt 0 ] ; then echo -e "\n\nChecking ssh user equivalency between $usern2 and $zfs_ssh_user user on STORAGE Servers\n"; fi;
  
    for hname in `cat $ZFSIP|cut -d\" -f2|cut -d\; -f2`
    do
      #zfsPingStatus=$($PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1;echo $?)
      test_node_reachability "$hname" "$zfs_ssh_user";
      if [ $el_node_ping -eq "1" ] ; then
        zfsPingStatus=0;
      else
        zfsPingStatus=1;
      fi

      if [ $zfsPingStatus -eq 0 ]
      then 
        zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $hname ls >/dev/null 2>&1;echo $?);
        
        if [[ $zfs_ssh_status -eq 0 ]]
        then
          echo -e $GREEN"$hname is configured for ssh user equivalency for $zfs_ssh_user user\n" $NORM;
        else
          if [[ $use_expect_for_ssh -eq 0 ]]
          then
            echo -e $RED"$hname is not configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
	    exec 3<&2; exec 2<&0
            $READ -p "Do you want to configure SSH for user $zfs_ssh_user on $hname [y/n][y]" AutoLoginCheck
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "AutoLoginCheck" "n"
          fi

          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
	    AutoLoginCheckYes=1
            if [[ -z "$zfscell_samerootpassword_YesNo" ]]
            then
              zfscell_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all STORAGE Servers?[y/n][y]" zfscell_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "zfscell_samerootpassword_YesNo" "y"
            fi

            case $zfscell_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              zfscell_samerootpassword_YesNo="y"
              if [[ -z "$global_zfscell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_zfscell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_zfscell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
            n|N|No|NO|no)
              zfscell_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r zfscell_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$zfscell_rootpassword" "3"
              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_zfscell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_zfscell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_zfscell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_zfscell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
		  setup_status=0
		  return
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    esac
          ;;
          n|N|NO|No|no)
            echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
            setup_status=0
 	    return
          ;;
          *)
	    AutoLoginCheckYes=1
            if [[ -z "$zfscell_samerootpassword_YesNo" ]]
            then
              zfscell_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all STORAGE Servers?[y/n][y]" zfscell_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "zfscell_samerootpassword_YesNo" "y"
            fi

            case $zfscell_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              zfscell_samerootpassword_YesNo="y"
              if [[ -z "$global_zfscell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_zfscell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_zfscell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
            n|N|No|NO|no)
              zfscell_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r zfscell_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
	  	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_zfscell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_zfscell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_zfscell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_zfscell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    esac
          ;;
          esac
        fi
      else
        echo -e $RED"\nSTORAGE Server $hname is not pingable, no audit checks will be executed on $hname\n"$NORM;
      fi
    done
  else
    zfs_ssh_status=0
  fi
  
  use_expect_for_ssh=0 
  unset node_rootpassword
  unset passwordToCheck
  if [[ $is_exalogic_machine -eq 1 || $is_bda_machine -eq 1 || $is_exalogic_foxtrot -eq 1 ]] && [[ -n "$swlist_file" && -e "$swlist_file" ]]
  then
    sed '/^\s*$/d' $swlist_file > $swlist_file.new
    mv -f $swlist_file.new $swlist_file
    if [[ -e "$swlist_file" && `cat $swlist_file|wc -l` -ne 0 ]]
    then
      for switchname in `cat $swlist_file`
      do
        test_node_reachability "$switchname" "" "" "Infiniband switch";
        if [ $el_node_ping -eq "1" ] ; then
          switchping_status=0;
          echo $switchname>>${RTEMPDIR}/o_ibswitches.out
        else
          switchping_status=1;
          echo -e ${RED}"InfiniBand switch $switchname is not reachable so its being skipped from checking best practicing"${NORM}
	  add_to_skipped_nodes "$switchname" "$tnr_note"
        fi
      done
      rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
      cp -f ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
    fi
  fi
  
  if [[ -e "${RTEMPDIR}/o_ibswitches_full.out" ]]
  then
    sed '/^\s*$/d' ${RTEMPDIR}/o_ibswitches_full.out > ${RTEMPDIR}/o_ibswitches_full.out.new
    mv -f ${RTEMPDIR}/o_ibswitches_full.out.new ${RTEMPDIR}/o_ibswitches_full.out 
  fi

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]]; then
    if [[ -e "${RTEMPDIR}/o_ibswitches_full.out" && `cat ${RTEMPDIR}/o_ibswitches_full.out |wc -l` -eq 0 ]] || [[ ! -e "${RTEMPDIR}/o_ibswitches_full.out" ]]
    then
      first_compute_ip=$(cat $HOSTLIST|head -1);
      $SSHELL $usern@$first_compute_ip "mkdir ${RTEMPDIR} >/dev/null 2>&1"
      $SSHELL $usern@$first_compute_ip "ibswitches 2>/dev/null >${RTEMPDIR}/o_ibswitches_full.out 2>/dev/null"
      $SCOPY $usern@$first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1

      if [[ -e "${RTEMPDIR}/o_ibswitches_full.out" && `cat ${RTEMPDIR}/o_ibswitches_full.out |wc -l` -eq 0 ]]
      then
        rm -rf "${RTEMPDIR}/o_ibswitches_full.out"  >/dev/null 2>&1
      fi
    fi  
  fi

  if [[ -e "${RTEMPDIR}/o_ibswitches_full.out" ]]
  then
    sed '/^\s*$/d' ${RTEMPDIR}/o_ibswitches_full.out > ${RTEMPDIR}/o_ibswitches_full.out.new
    mv -f ${RTEMPDIR}/o_ibswitches_full.out.new ${RTEMPDIR}/o_ibswitches_full.out 
  fi

  if [[ -e ${RTEMPDIR}/o_ibswitches_full.out && `cat ${RTEMPDIR}/o_ibswitches_full.out |wc -l|sed 's/ //g'` -ne 0 ]]
  then
    OIFS="${IFS}";
    NIFS=$'\n';
    IFS="${NIFS}";
    for switch_line in `cat ${RTEMPDIR}/o_ibswitches_full.out`
    do
      printf ". "
      switchname=$(echo "$switch_line"|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $1}'|sed 's/"$//g')
      is_ibswitch_ip=$(echo $switchname|grep -c '[A-Za-z]')
  
      if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
      then
        switchname_ip=$switchname   
        switchname=$(echo "$switch_line"|grep -vwi gw|cut -d'"' -f2|awk {'print $(NF-1)}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1)
      fi   
      if [ -n "$switchname" ]
      then 
        test_node_reachability "$switchname" "root" $switchname_ip "Infiniband switch";
        if [ $el_node_ping -eq "1" ] ; then
          switchping_status=0;
	  echo $switchname>>${RTEMPDIR}/o_ibswitches.out
        else
          switchping_status=1;
	  add_to_skipped_nodes "$switchname" "$tnr_note"
        fi
      fi
    done
 
    IFS="${OIFS}";
    mv -f ${RTEMPDIR}/o_ibswitches_full.out $OUTPUTDIR>/dev/null 2>&1
    cp -f ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  fi

  if [ -e "${RTEMPDIR}/o_ibswitches.out" ]
  then
    cell_type="ibswitch"
    sed '/^\s*$/d' ${RTEMPDIR}/o_ibswitches.out > ${RTEMPDIR}/o_ibswitches.out.new
    mv -f ${RTEMPDIR}/o_ibswitches.out.new ${RTEMPDIR}/o_ibswitches.out 

    assign_usern

    if [ `cat ${RTEMPDIR}/o_ibswitches.out|wc -l` -gt 0 ]
    then 
      if [ -z "$RAT_IBSWITCH_USER" ]
      then
	if [[ $is_exalogic_machine -eq 1 || $is_bda_machine -eq 1 || $is_exalogic_foxtrot -eq 1 ]]
	then
	  ibswitch_user="root"
	  ibswitch_user_noformat="root"
	else
         # If running is root then user to execute check on switch is set to root because mostly there will be passwordless ssh and one less prompt to answer
          if [ $usern = "${root_user}" ]
          then
	    ibswitch_user="root"
	    ibswitch_user_noformat=$ibswitch_user
          else
	    ibswitch_user="nm2user"
	    ibswitch_user_noformat=$ibswitch_user
          fi
           
	fi
      else
	ibswitch_user=$RAT_IBSWITCH_USER
      fi
      usern="$ibswitch_user"
      echo -e "\n\nChecking ssh user equivalency between $usern2 and $ibswitch_user user on INFINIBAND SWITCH\n"
      
      for hname in `cat ${RTEMPDIR}/o_ibswitches.out`
      do
	node_ssh_user=$ibswitch_user
        ibs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $hname ls >/dev/null 2>&1;echo $?);
        
        if [[ $ibs_ssh_status -eq 0 ]]
        then
          echo -e $GREEN"$hname is configured for ssh user equivalency for $ibswitch_user user\n" $NORM;
        else
          if [[ $use_expect_for_ssh -eq 0 ]]
          then
            echo -e $RED"$hname is not configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
	    exec 3<&2; exec 2<&0
            $READ -p "Do you want to configure SSH for user $ibswitch_user on $hname [y/n][y]" AutoLoginCheck
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "AutoLoginCheck" "n"
          fi
          
          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
            AutoLoginCheckYes=1
            if [[ -z "$switch_samerootpassword_YesNo" ]]
            then
              switch_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all IBSWITCHES?[y/n][y]" switch_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "switch_samerootpassword_YesNo" "y"
            fi

            case $switch_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              switch_samerootpassword_YesNo="y"
              if [[ -z "$global_switch_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_switch_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_switch_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
	    ;;
            n|N|No|NO|no)
              switch_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_switch_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              switch_samerootpassword_YesNo="y"
              if [[ -z "$global_switch_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
		read_code=`echo $?`;
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_switch_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
	    ;;
	    esac
          ;;
          n|N|NO|No|no)
            echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
            setup_status=0
	    return
          ;;
          *)
            AutoLoginCheckYes=1
            if [[ -z "$switch_samerootpassword_YesNo" ]]
            then
              switch_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all IBSWITCHES?[y/n][y]" switch_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "switch_samerootpassword_YesNo" "y"
            fi

            case $switch_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              switch_samerootpassword_YesNo="y"
              if [[ -z "$global_switch_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_switch_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_switch_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
	    ;;
            n|N|No|NO|no)
              switch_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_switch_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              switch_samerootpassword_YesNo="y"
              if [[ -z "$global_switch_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_switch_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$hname" "$usern" "$global_switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  global_switch_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
	    ;;
	    esac
          ;;
          esac
        fi
      done
    fi
  fi
  fi
  echo -e "\n"
  setup_status=1
  usern="$usern2"

  unset cell_type
  unset node_rootpassword
  unset passwordToCheck
}


func_remote_setup_ssh ()
{
  args=$(echo $* | sed 's/.*-setupssh//');
  usern=$(echo $args | awk '{print $1}');
  hname=$(echo $args | awk '{print $2}');

  func_setup_ssh -user $usern -hosts "$hname"

  if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
  then
    echo -e "SSH setup failed"	
  else
    echo -e "Successfully setup SSH"
  fi
}  

validate_user_home ()
{
  if [ -n "$RAT_TMPDIR" ]; then return; fi

  homedir=$($SSHELL $usern@$hname "echo \$HOME")
  if [[ -n "$homedir" && "$HOME" != "$homedir" ]]; then
    echo -e ${RED}"'$usern' user home directory is not same on $hname and $localnode. Please make sure that '$usern' user home directory is same on all nodes in cluster and then re-run ${program_name}."${NORM}      
    echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
    exit
  fi
}

check_tmp_status ()
{
  remote_hostname=$($SSHELL ${node_ssh_user}@$1 hostname|tr "[A-Z]" "[a-z]"|cut -d'.' -f1);
  if [[ "$localnode" = "$remote_hostname" ]]; then return; fi;
  
  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -ne "1" ]] || [[ -z "$is_exalogic_foxtrot" ]]; then validate_user_home; fi

  cat > $TMPSTFILE <<EOF
#!$bash_scr
$bash_source
$RAT_DEBUG_FLG  
 
if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
  if [ -n "$RAT_TMPDIR" ];then TMPDIR=$RAT_TMPDIR;else TMPDIR=\$HOME;fi
  RTEMPDIR=\$TMPDIR/.${program_name}
  LOCKFIL=\${RTEMPDIR}/${program_name}.pid
else
  TMPDIR=$TMPDIR
  RTEMPDIR=$RTEMPDIR
  LOCKFIL=$LOCKFIL
fi

mount_check=1
if [ -e "\$RTEMPDIR" ]; then
  del_rtempdir=0
  if [ -e \$LOCKFIL ]; then
    lockfile_pid_status=\$(ps -ef |grep \$(cat \$LOCKFIL)|grep -v grep|wc -l)
    if [[ -n "\$lockfile_pid_status" && \$lockfile_pid_status -gt 0 ]]; then
      del_rtempdir=0
    else
      del_rtempdir=1
    fi
  elif [ -f "\$RTEMPDIR" ]; then
    del_rtempdir=1
  elif [ -d "\$RTEMPDIR" ]; then
    del_rtempdir=2
  fi

  if [[ "\$del_rtempdir" -eq "1" ]]; then
    rm -rf \$RTEMPDIR >/dev/null 2>&1;
    if [ \$(echo \$?) -ne 0 ]; then
      echo -e "\nTemporary files/directories of previous run exist on $1 at \$RTEMPDIR. Delete them and re-run ${program_name}.\n\n${program_name} is exiting..\n"
      mount_check=0
    fi
  elif [[ "\$del_rtempdir" -eq "2" ]]; then
    rm -rf \$RTEMPDIR/* \$RTEMPDIR/.input_* >/dev/null 2>&1;
    if [ \$(echo \$?) -ne 0 ]; then
      echo -e "\nTemporary files/directories of previous run exist on $1 at \$RTEMPDIR. Delete them and re-run ${program_name}.\n\n${program_name} is exiting..\n"
      mount_check=0
    fi
  fi
fi

if [[ "\$mount_check" -eq "1" ]]; then
  \$(mount >/dev/null 2>&1)
  if [ \$(echo \$?) -eq 0 ]; then
    if [ \$(mount|grep -w "\$TMPDIR"|grep -icw "noexec") -gt 0 ]; then
      echo -e "\nPlease change the entry for \$TMPDIR in /etc/fstab file from 'noexec' to 'exec' on $1 and then re-run ${program_name}.\n\n${program_name} is exiting..\n"
    fi
  fi
fi
EOF

  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$1 "echo \"\$HOME\""); fi
    l_RTEMPDIR=${l_TMPDIR}/.${program_name}
  else
    l_TMPDIR=$TMPDIR
    l_RTEMPDIR=$RTEMPDIR
  fi
 
  tmp_status=$($SSHELL ${node_ssh_user}@$1 "$bash_scr -c \"if [ ! -w '$l_TMPDIR' ]; then echo -e 'FAIL'; fi;\"");  

  if [[ -n "$tmp_status" && $tmp_status = "FAIL" ]]; then
    echo -e ${RED}"$l_TMPDIR directory is not writable on $1.Please make sure that $l_TMPDIR is writable and then re-run ${program_name}"{NORM}
    echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
    exit 1
  else 
    b_TMPSTFILE=$(basename $TMPSTFILE)
    $SCOPY $TMPSTFILE ${node_ssh_user}@$1:$l_TMPDIR >/dev/null 2>&1
    $($SSHELL -o NumberOfPasswordPrompts=0 ${node_ssh_user}@$1 "chmod 540 $l_TMPDIR/$b_TMPSTFILE >/dev/null");
    tmp_mount_status=$($SSHELL -o NumberOfPasswordPrompts=0 ${node_ssh_user}@$1 $l_TMPDIR/$b_TMPSTFILE);
    $($SSHELL -o NumberOfPasswordPrompts=0 ${node_ssh_user}@$1 "rm -f $l_TMPDIR/$b_TMPSTFILE >/dev/null");

    if [ `echo "$tmp_mount_status"|grep -ic "exiting"` -gt 0 ]; then
      echo -e ${RED}"$tmp_mount_status"${NORM}
      exit 1
    fi
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then 
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
     #l_RAT_TMP_OUTPUT=$($SSHELL ${node_ssh_user}@$1 "$bash_scr -c \"if [[ -d '$RAT_TMP_OUTPUT' && -w '$RAT_TMP_OUTPUT' ]]; then echo $RAT_TMP_OUTPUT; else \"/tmp\"; fi;\"");
     l_RAT_TMP_OUTPUT=$($SSHELL ${node_ssh_user}@$1 "$bash_scr -c \"if [[ -d '$RAT_TMP_OUTPUT' && -w '$RAT_TMP_OUTPUT' ]]; then echo $RAT_TMP_OUTPUT; else 'USR_HOMEDIR'; fi;\"");
    else 
     l_RAT_TMP_OUTPUT=$RAT_TMP_OUTPUT
    fi

    if [[ `echo "$l_RAT_TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
      unset tmp_status
      tmp_status=$($SSHELL ${node_ssh_user}@$1 "$bash_scr -c \"if [ ! -e '$l_RAT_TMP_OUTPUT' ]; then echo -e 'FAIL'; fi;\"");

      if [[ -n "$tmp_status" && $tmp_status = "FAIL" ]]; then
        echo -e ${RED}"$l_RAT_TMP_OUTPUT directory does not exists.Please set the RAT_TMP_OUTPUT and then re-run ${program_name}"${NORM}
        echo "ex: export RAT_TMP_OUTPUT=/tmp"
        echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
        exit 1
      else
        unset tmp_status
        tmp_status=$($SSHELL ${node_ssh_user}@$1 "$bash_scr -c \"if [ ! -w '$l_RAT_TMP_OUTPUT' ]; then echo -e 'FAIL'; fi;\"");
        if [[ -n "$tmp_status" && $tmp_status = "FAIL" ]]; then
          echo -e ${RED}"$l_RAT_TMP_OUTPUT directory must be writable by all users for creating runtime files.Please set the RAT_TMP_OUTPUT and then re-run ${program_name}"${NORM}
          echo "ex: export RAT_TMP_OUTPUT=/tmp"
          echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
          exit 1 
        else
          l_TMP_OUTPUT=$l_RAT_TMP_OUTPUT/.${program_name}
          #$SSHELL ${node_ssh_user}@$1 "rm -f $l_TMP_OUTPUT >/dev/null 2>&1; mkdir $l_TMP_OUTPUT >/dev/null 2>&1; chmod 777 $l_TMP_OUTPUT;"
          $SSHELL ${node_ssh_user}@$1 "rm -f $l_TMP_OUTPUT >/dev/null 2>&1; mkdir $l_TMP_OUTPUT >/dev/null 2>&1;"
        fi
      fi
    fi
  fi
}

function rotate_daemon_logs ()
{
  if [[ -e $DLOG_CONFFILE ]]; then
    log_daemon "Started checking daemon logs size...."

    show_daemonlog_policy "getvalue"

    RAT_DAEMON_LOGMAXSIZE=$(echo "$RAT_DAEMON_LOGMAXSIZE"|sed 's/B/b/g'|sed 's/KB/k/gi'|sed 's/mb/M/gi')
    ARCHIVE_FIL=$WRKDIR/${program_name}_daemon_arch

    ltimestamp=$(date '+%Y%m%d_%H%M%S')
    for file in `find $WRKDIR -name "${program_name}_daemon*.log" -type f -size +${RAT_DAEMON_LOGMAXSIZE}`
    do
      if [[ $RAT_DAEMON_LOGRETPOLICY = 'ARCHIVE' ]]; then
	bfile=$(basename "$file"|sed 's/.log//g')
	cp -f $file $WRKDIR/${bfile}_${ltimestamp}.log

        ZIP_CMD=$(which zip 2>/dev/null)
        if [[ -z "$ZIP_CMD" || `echo $?` -ne 0 || `echo "$ZIP_CMD" | grep -ic "no zip"` -gt "0" ]]; then
	  TAR_CMD=$(which tar 2>/dev/null)
	  TAR_CMD_RC=$(echo $?)
	  GUNZIP_CMD=$(which gunzip 2>/dev/null)
	  GUNZIP_CMD_RC=$(echo $?)
	  GZIP_CMD=$(which gzip 2>/dev/null)
	  GZIP_CMD_RC=$(echo $?)

          if [[ -z "$TAR_CMD" || `echo "$TAR_CMD_RC"` -ne 0 || `echo "$TAR_CMD" | grep -ic "no tar"` -gt "0" ]] || [[ -z "$GUNZIP_CMD" || `echo "$GUNZIP_CMD_RC"` -ne 0 || `echo "$GUNZIP_CMD" | grep -ic "no gunzip"` -gt "0" ]] || [[ -z "$GZIP_CMD" || `echo "$GZIP_CMD_RC"` -ne 0 || `echo "$GZIP_CMD" | grep -ic "no zip"` -gt "0" ]]; then
    	    log_daemon "Unable to archive: zip and tar/gunzip/gzip missing...."
    	    log_daemon "Finished checking daemon logs size...."
	    return
	  else
	   if [[ -e ${ARCHIVE_FIL}.tar.gz ]]; then $GUNZIP_CMD ${ARCHIVE_FIL}.tar.gz >/dev/null 2>&1; fi
	   $TAR_CMD -rf ${ARCHIVE_FIL}.tar --directory $WRKDIR ${bfile}_${ltimestamp}.log >/dev/null 2>&1
	   $GZIP_CMD ${ARCHIVE_FIL}.tar >/dev/null 2>&1
  	  fi	
	else
	  $ZIP_CMD ${ARCHIVE_FIL}.zip $WRKDIR/${bfile}_${ltimestamp}.log >/dev/null 2>&1
	fi
	rm -f $WRKDIR/${bfile}_${ltimestamp}.log >/dev/null 2>&1
      fi
      echo "" > $file
    done
    log_daemon "Finished checking daemon logs size...."
  fi
}

function purge_collections ()
{
  if [ -e $autorun_list ]; then
    if [[ `grep -c "^@ID:" $autorun_list` -eq 0 ]]; then
        sed -e "s/^/@ID:${program_name}.default - /" $autorun_list > $autorun_list.bak && mv -f $autorun_list.bak $autorun_list
    fi
  fi

  swap_p_conf_file "$cur_p_conf_file"

  if [[ -f "$p_conf_file" && `grep -ic "COLLECTION_RETENTION" $p_conf_file` -gt "0" ]] ; then
    read_conf "COLLECTION_RETENTION"
    purge_days=$p_conf_value

    if [[ -f "$autorun_list" ]] ; then
      log_daemon "Checking collections older than ${purge_days} days for purging"

      for pfile in $(find $WRKDIR -name "${program_name}_${localnode}*" -type d -mtime +${purge_days};find $WRKDIR -name "${program_name}_${localnode}*.zip" -type f -mtime +${purge_days};find $WRKDIR -name "${program_name}_${localnode}*.log" -type f -mtime +${purge_days};)
      do
	bpfile=$(basename "$pfile"|sed 's/.zip//g'|sed 's/.log//g')
	 
        #if [[ `grep -icw "$bpfile" "$autorun_list"` -gt 0 && -e "$pfile" ]] ; then 
 	if [[ `grep "^@ID:${autorun_id} - " "$autorun_list"|grep -icw "$bpfile"` -gt 0 && -e "$pfile" ]] ; then
	  rm -rf "$pfile" >/dev/null 2>&1 
	  deleted_list="${pfile}\n${deleted_list}"
        fi
      done
      if [ ! -z "$deleted_list" ] ; then
        log_daemon "Following collections has been purged-"
	log_daemon "\n$deleted_list"
      else
        log_daemon "Collections purged - none"
      fi
    fi
  fi
}

function is_SSH_blocked ()
{
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  #Calling Format: is_SSH_blocked "nodename" "user" [password] [host type(compute/cell/switch)] 
  SSH_host="$1"
  SSH_user="$2"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  SSH_password="$3"
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  SSH_host_type="$4"

  SSH_blocked=0
 
  if [[ -z $SSH_host_type ]] ; then
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$SSH_host"` -le 0 ]]; then
        node_ssh_user="${root_user}"
      else
        node_ssh_user="${foxtrot_dom0_user}"
      fi
      if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$SSH_host "echo \"\$HOME\""); fi
      l_RTEMPDIR=${l_TMPDIR}/.${program_name}
    else
      l_TMPDIR=$TMPDIR
      l_RTEMPDIR=$RTEMPDIR
    fi
    SSH_dir=$l_RTEMPDIR
  elif [[ $SSH_host_type = 'CELL' ]]; then
    SSH_dir=$CELLRTEMPDIR
  elif [[ $SSH_host_type = 'SWITCH' ]]; then
    SSH_dir=$IBRTEMPDIR
  fi

  SSH_chk_file="$RTEMPDIR/SSH_chk_file.sh"

  if [[ ! -e $SSH_chk_file ]]; 
  then
    echo "#!$bash_scr" > $SSH_chk_file 
    echo "$bash_source" >> $SSH_chk_file
    echo "echo 'Script Executed Successfully'" >> $SSH_chk_file
  fi

  /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l "$SSH_user" "$SSH_host" ls 2>/dev/null 1>/dev/null
  if [[ $? -eq 0 ]]; then
    SSH_remote_dir=$($SSHELL -t $SSH_user@$SSH_host "if [[ -d $SSH_dir ]]; then echo '1'; else if [[ -f $SSH_dir ]]; then echo '2'; else echo '0'; fi; fi" 2>/dev/null)
    SSH_remote_dir=$(echo "$SSH_remote_dir" | grep -vi 'OpenSSH_' | tr -d '\r' | sed 's/ //g' | grep "^[0-9]$");

    if [[ -n $SSH_remote_dir && $SSH_remote_dir -eq "0" ]] || [[ -z "$SSH_remote_dir" ]]; then  
      $SSHELL $SSH_user@$SSH_host "$bash_scr -c \"mkdir ${SSH_dir} >/dev/null 2>&1;\""    
    elif [[ -n $SSH_remote_dir && $SSH_remote_dir -eq "2" ]]; then
      $SSHELL $SSH_user@$SSH_host "$bash_scr -c \"rm -f ${SSH_dir} >/dev/null 2>&1;\""    
      $SSHELL $SSH_user@$SSH_host "$bash_scr -c \"mkdir ${SSH_dir} >/dev/null 2>&1;\""    
    fi
 
    $SCOPY $SSH_chk_file $SSH_user@$SSH_host:$SSH_dir >/dev/null 2>&1    

    /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l "$SSH_user" "$SSH_host" "chmod 540 $SSH_dir/SSH_chk_file.sh" 2>/dev/null 1>/dev/null
    SSH_return=$(/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -t $SSH_user@$SSH_host $SSH_dir/SSH_chk_file.sh 2>&1)

    if [[ `echo "$SSH_return" | grep -ic "Script Executed Successfully"` -eq 0 ]]; then SSH_blocked=1; fi
  else
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    if [[ -n $SSH_password ]]; then
      fixRootPassword "$SSH_password"

      SSH_remote_dir=$($EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        #log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
	spawn -noecho $SSHELL $SSH_user@$SSH_host "if test -d $SSH_dir; then echo '1'; else if test -f $SSH_dir; then echo '2'; else echo '0'; fi; fi"
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to determine temp directory on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to determine temp directory on $SSH_host\n";
             exit
           }
         }
IBEOF
)
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      SSH_remote_dir=$(echo "$SSH_remote_dir" | grep -vi 'OpenSSH_' | grep -vi "password:" | tr -d '\r' | sed 's/ //g' | grep "^[0-9]$");      

      if [[ -n "$SSH_remote_dir" && $SSH_remote_dir -eq "0" ]] || [[ -z "$SSH_remote_dir" ]]; then  
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
	spawn -noecho $SSHELL $SSH_user@$SSH_host mkdir $SSH_dir
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to create temp directory on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to create temp directory on $SSH_host\n";
             exit
           }
         }
IBEOF
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      elif [[ -n $SSH_remote_dir && $SSH_remote_dir -eq "2" ]]; then
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
	spawn -noecho $SSHELL $SSH_user@$SSH_host rm -f $SSH_dir
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to delete file on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to delete file on $SSH_host\n";
             exit
           }
         }
IBEOF

        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
	spawn -noecho $SSHELL $SSH_user@$SSH_host mkdir $SSH_dir
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to create temp directory on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to create temp directory on $SSH_host\n";
             exit
           }
         }
IBEOF
      fi
      sleep 2;

      $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn $SCOPY $SSH_chk_file $SSH_user@$SSH_host:$SSH_dir
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Timed out while copying $SSH_dir/SSH_chk_file.sh on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Timed out while copying $SSH_dir/SSH_chk_file.sh on $SSH_host\n";
             exit
           }
         }
IBEOF

      $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn $SSHELL $SSH_user@$SSH_host chmod 540 $SSH_dir/SSH_chk_file.sh
        match_max 100000
          expect {
            -nocase "permission denied *" {
              exit 4;
            }
            -nocase "no)?" {
              send -- "yes\n"
            }
            -nocase "*?assword:*" {
              send -- "\$le_extract_password\n"
            }
            -nocase eof {
              exit
            }
          }
          # Look for passwd prompt
          expect {
            -nocase "*?assword:*" {
              send -- "\$le_extract_password\n"
            }
            -nocase eof {
              exit
            }
            -nocase timeout {
              send_error "Timed out while modifying permissions on $SSH_host\n";
              exit
            }
          }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Timed out while modifying permissions on $SSH_host\n";
             exit
           }
         }
IBEOF

      t_SSHELL=$(echo "$SSHELL" | sed 's/-q//g')

      SSH_return=$($EXPECT -f - 2>&1 << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        log_user 1
        spawn -noecho $t_SSHELL -t $SSH_user@$SSH_host $SSH_dir/SSH_chk_file.sh
        match_max 100000
          expect {
            -nocase "permission denied *" {
              exit 4;
            }
            -nocase "no)?" {
              send -- "yes\n"
            }
            -nocase "*?assword:*" {
              send -- "\$le_extract_password\n"
            }
            -nocase eof {
              exit
            }
          }
          #Look for passwd prompt
          log_user 1
          set timeout $watchdog_wakeup_root
          expect {
            -nocase "*?assword:*" {
              send -- "\$le_extract_password\n"
            }
            -nocase eof {
              exit
            }
            -nocase timeout {
              send_error "Timed out while running $SSH_dir/SSH_chk_file.sh on $SSH_host\n";
              exit
            }
          }
          log_user 1
          expect {
            -nocase eof {
             exit
            }
            -nocase timeout {
              send_error "Timed out while running $SSH_dir/SSH_chk_file.sh on $SSH_host\n";
              exit
            }
          }
IBEOF
)
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      if [[ `echo "$SSH_return" | grep -ic "Script Executed Successfully"` -eq 0 ]]; then SSH_blocked=1; fi
    fi
  fi 
}

function isDNSconfigured ()
{
  DNSconfigured=1
  
  is_IP "$1"
  if [[ $is_IPADDRESS -eq "1" ]]; then return; fi

  ssh_output=$(/usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l "$2" "$1" ls 2>&1 | tr -d '\r')
  if [[ `echo "$ssh_output"|grep -ic 'failure in name resolution'` -gt 0 || `echo "$ssh_output"|grep -ic 'Name or service not known'` -gt 0 ]]
  then
    DNSconfigured=0
  fi
}

function check_ssh_speed () 
{
  ssh_go_ahead=1
  if [[ -n "$RAT_PASSWORDCHECK_TIMEOUT" && $RAT_PASSWORDCHECK_TIMEOUT -gt 1 ]]
  then
    passwordcheck_timeout=$RAT_PASSWORDCHECK_TIMEOUT
  else
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] || [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]]
    then
      passwordcheck_timeout=20
    else
      passwordcheck_timeout=10
    fi
  fi
  
  ssh_speed=$(/usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -o ConnectTimeout=$passwordcheck_timeout -l "$2" "$1" ls 2>&1 | tr -d '\r')
  if [[ `echo "$ssh_speed"|grep -ic 'Connection timed out'` -gt 0 || `echo "$ssh_speed"|grep -ic 'Name or service not known'` -gt 0 || `echo "$ssh_speed"|grep -ic 'No route to host'` -gt 0 ]]
  then
    ssh_go_ahead=0
  fi
}

function format_cell_switch_files ()
{
  #$READ -p "$1 $2 $3"
  if [ "$3" = "cell" ]
  then   
    for shortFileName in $(ls $2/c_*out 2>/dev/null) 
    do
      SHORTFNAME=$(echo $shortFileName |$AWK 'BEGIN { FS = "/" } {printf $NF}')
      SHORTFNAME=$(echo $SHORTFNAME|sed 's/\.out//g')   
      SHORTFNAME1=$(echo $SHORTFNAME|cut -d _ -f1)
      SHORTFNAME2=$(echo $SHORTFNAME|cut -d _ -f2)
      SHORTFNAME3=$(echo $SHORTFNAME|sed s'/c_cbc_//g'|sed s'/c_cwc_//g'|sed s'/_report//g')
      if [ `echo $shortFileName|grep -c report` -gt 0 ]
      then
        cp -f $shortFileName $CELLDIR/${SHORTFNAME1}_${SHORTFNAME2}_${SHORTFNAME3}_${1}_report.out
      else
        cp -f $shortFileName $CELLDIR/${SHORTFNAME1}_${SHORTFNAME2}_${SHORTFNAME3}_${1}.out
      fi
      #$READ -p "$1 $2 $3"
    done
    mv -f $2 $CELLDIR >/dev/null 2>&1
  else
    for shortFileName in $(ls $2/s_*out 2>/dev/null) 
    do
      SHORTFNAME=$(echo $shortFileName |$AWK 'BEGIN { FS = "/" } {printf $NF}')
      SHORTFNAME=$(echo $SHORTFNAME|sed 's/\.out//g')   
      SHORTFNAME1=$(echo $SHORTFNAME|cut -d _ -f1)
      SHORTFNAME2=$(echo $SHORTFNAME|sed s'/^s_//g'|sed s'/_report//g')
      if [ `echo $shortFileName|grep -c report` -gt 0 ]
      then
	#if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then cp -f $shortFileName $TMP_OUTPUT/${SHORTFNAME1}_${SHORTFNAME2}_${1}_report.out;fi
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	  cp -f $shortFileName $TMP_OUTPUT/${SHORTFNAME1}_${SHORTFNAME2}_${1}_report.out
	fi
        cp -f $shortFileName $OUTPUTDIR/${SHORTFNAME1}_${SHORTFNAME2}_${1}_report.out
      else
	#if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then cp -f $shortFileName $TMP_OUTPUT/${SHORTFNAME1}_${SHORTFNAME2}_${1}.out; fi
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	  cp -f $shortFileName $TMP_OUTPUT/${SHORTFNAME1}_${SHORTFNAME2}_${1}.out
	fi
        cp -f $shortFileName $OUTPUTDIR/${SHORTFNAME1}_${SHORTFNAME2}_${1}.out
      fi
    done
    #deleting temporary directory created for each cell after format cell file names
    mv -f $2 $CELLDIR >/dev/null 2>&1
  fi
}

function parallel_sql () 
{
  perl_exe=$(which perl|tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi
 
  if [[ $OFFLINE -eq "0" ]]
  then
    ENVFIL="$MASTERFIL"
  else
    ENVFIL="$DUMPDIR/$CHKFIL"
  fi

  if [[ -n "$RAT_DB_PAR_LIMIT" && `echo "$RAT_DB_PAR_LIMIT"|grep -c "^[0-9][0-9]*$"` -gt 0 ]] || [[ -n "$RAT_DB_PAR_LIMIT" && `echo "$RAT_DB_PAR_LIMIT"|grep -c "max"` -gt 0 ]]; then num_sql_queries=$RAT_DB_PAR_LIMIT; fi

  if [[ -z "$RAT_ROOT_RUN" ]]; then TMP_OUTPUT=$RTEMPDIR; fi

  no_of_sel_dbs=${#mb_db_names[@]}
  if [[ -z $no_of_sel_dbs ]]; then no_of_sel_dbs=1; fi
  #Remove Duplicates
  if [ -e $t_PSQL_INFIL ]; then cat $t_PSQL_INFIL|sort|uniq > $t_PSQL_INFIL.new; mv -f $t_PSQL_INFIL.new $t_PSQL_INFIL; fi

  PRET_STATUS=0;
  
  perl_cmd="
	$perl_exe $SCRIPTPATH/.cgrep/psqlplus 
	-c "$t_PSQL_METAFIL" 
	-d "$t_PSQL_INFIL" 
	-g "$t_PSQL_STAT"
	-o "$OUTPUTDIR" 
	-w "$OUTPUTDIR_NEW" 
	-i "$INPUTDIR" 
	-t "$RTEMPDIR" 
	-e "$ERRFIL"
        -p "$ENVFIL"	
	-u "$num_sql_queries"
	-m 1 
	-v "$CHECKS_TIMING"
        -f "$CHK_TIMINGS"
	-a "$ORCLENVFIL"
	-s $OFFLINE 
	-n "$localnode" 
	-r "$i" 
	-k 1
	-b 1
	-z "$SKIPFIL"
	-j "$TMP_OUTPUT"
	-k "$APPTYPE"
	-y $no_of_sel_dbs
	-l $no_of_child_proc
"

  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]] || [[ -n "$RAT_PERL_DEBUG"  ]]
  then
    echo $perl_cmd 
  fi
  if [[ $RAT_DEBUG -eq "1" ]]; then
    $perl_cmd
  else
    $perl_cmd 2>>$ERRFIL
  fi
  PRET_STATUS=`echo $?`;  

  if [[ -z "$RAT_ROOT_RUN" ]]; then unset TMP_OUTPUT; fi
}


function is_IP() {
  is_IPADDRESS=1
  if [[ `perl -e 'my $count=0; my @count = ("'$1'" =~ m/\./g); $count=@count; print $count;'` -ne 3 ]]; then
  #if [ `echo $1 | grep -o '\.' | wc -l` -ne 3 ]; then
    is_IPADDRESS=0
  elif [ `echo $1 | tr '.' ' ' | wc -w` -ne 4 ]; then
    is_IPADDRESS=0
  else
    for OCTET in `echo $1 | tr '.' ' '`; do
      if [[ `echo "$OCTET" | grep -ic "^[0-9][0-9]*$"` -le 0 ]]; then
        is_IPADDRESS=0
	break;
      elif [[ $OCTET -lt 0 || $OCTET -gt 255 ]]; then
        is_IPADDRESS=0
	break;		
      fi
    done
  fi
}

generate_recommendations_xml () {
  echo "    <Check id=\"$1\">"						>> $XMLRECFIL
  echo "        <Recommendation><![CDATA[$2]]></Recommendation>"	>> $XMLRECFIL
  echo "        <Links><![CDATA[$3]]></Links>"				>> $XMLRECFIL
  echo "    </Check>"							>> $XMLRECFIL
}

top_consumers () 
{
  perl_exe=$(which perl|tr -d '\r');
  $perl_exe - -f $CHK_TIMINGS -t 10 -r $OUTPUTDIR/${program_name}_consumers.html <<PERLEOF
    use strict;
    use warnings;
    use Getopt::Long;
    use Data::Dumper;
    
    my (\$CHKFILE);
    my (\$CHECKS);
    my (\$THTML) = "topconsumers.html";
    my (\$TLIMIT)= 10;
    my (\$UNIT)	 = "ms";
    
    sub usage {
      print "Usage: \$0 -f CHECK TIMINGS FILE -t NUMBER(Top n Checks) -r TIMING HTML\n";
      exit;
    }
    
    if ( \@ARGV == 0 ) {
      usage();
    }
    
    GetOptions( "f=s" => \\\$CHKFILE, "t=n" => \\\$TLIMIT, "r=s" => \\\$THTML ) or usage();
    
    sub process_line {
      my (\$line) = shift;
      my (\$process) = 1;    
    
      \$process = 0 if ( \$line =~ m/^\s*#/ );
      \$process = 0 if ( \$line =~ m/^\s*\$/ );
    
      return \$process;
    }
    
    sub get_checkid {
      my (\$line) = shift;
      \$line =~ s/^\[CHECK://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_time {
      my (\$line) = shift;
      \$line =~ s/^.*Time: //g;
      return \$line;
    }
    
    sub get_host {
      my (\$line) = shift;
      \$line =~ s/^.*\[HOST://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_type {
      my (\$line) = shift;
      \$line =~ s/^.*\[TYPE://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_tag1 {
      my (\$line) = shift;
    
      return "" if ( \$line !~ m/TAG1/ );
    
      \$line =~ s/^.*\[TAG1://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_tag2 {
      my (\$line) = shift;
    
      return "" if ( \$line !~ m/TAG2/ );
    
      \$line =~ s/^.*\[TAG2://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_tag3 {
      my (\$line) = shift;
    
      return "" if ( \$line !~ m/TAG3/ );
    
      \$line =~ s/^.*\[TAG3://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }

    sub get_cn {
      my (\$line) = shift;
      \$line =~ s/^.*\[COLLECTION_NAME://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/^\s*//g;
      \$line =~ s/\s*$//g;
      return \$line;
    }

    sub get_chkname {
      my (\$line) = shift;
      \$line =~ s/^.*\[AUDIT_CHECK_NAME://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/^\s*//g;
      \$line =~ s/\s*$//g;
      return \$line;
    }

    sub timings {
      my \$CHECKID 	= shift; 
      my \$HOST		= shift;
      my \$TYPE		= shift;
      my \$END_TIME	= shift;
      my \$START_TIME	= shift;
      my \$SECTION	= shift;
      my \$COL_NAME	= shift || "";
      my \$CHK_NAME     = shift || "";
      my \$TAG1		= shift || "";
      my \$TAG2		= shift || "";
      my \$TAG3		= shift || 0;
    
      my \$DIFF = \$END_TIME - \$START_TIME;
    
      \$CHECKS->{"\$CHECKID:\$HOST:\$TYPE:\$START_TIME:\$END_TIME:\$COL_NAME:\$CHK_NAME:\$TAG1:\$TAG2:\$TAG3"} = \$DIFF;
    }
    
    sub convert_format {
      my (\$duration);
      if ( \$UNIT eq 'ms' ) {
        my (\$Milliseconds) = shift;
    
        my (\$Hours)   = (\$Milliseconds/(1000*60*60))%24;
        my (\$Minutes) = (\$Milliseconds/(1000*60))%60;
        my (\$Seconds) = (\$Milliseconds/1000)%60;
    
        \$duration = \$Hours . " hrs, " . \$Minutes . " mins" . " and " . \$Seconds . " secs";
        if ( \$Hours == 0 ) {
          \$duration =~ s/^.*hrs, //g;
        }
        if ( \$Minutes == 0 && \$Hours == 0 ) {
          \$duration =~ s/^.*mins and //g;
        }
        if ( \$Seconds == 0 && \$Minutes == 0 && \$Hours == 0 ) {
          \$duration =~ s/^.*secs //g;
          \$duration = \$Milliseconds . " ms";
        }
      }
      elsif ( \$UNIT eq 'secs' ) {
        my (\$Seconds) = shift;
    
        my (\$Hours)   = (\$Seconds/(60*60))%24;
        my (\$Minutes) = (\$Seconds/60)%60;
        \$Seconds      = \$Seconds%60;
    
        \$duration = \$Hours . " hrs, " . \$Minutes . " mins" . " and " . \$Seconds . " secs";
        if ( \$Hours == 0 ) {
          \$duration =~ s/^.*hrs, //g;
        }
        if ( \$Minutes == 0 && \$Hours == 0 ) {
          \$duration =~ s/^.*mins and //g;
        }
      }
      return \$duration;
    }

    sub print_info {
      my (\$count) = 0;
      
      open ( my \$TCF, ">" , \$THTML ) || die \$!;
      print \$TCF "<div id=\"tcbody\"><a href=\"\#\" class=\"a_bgw\">Top</a>\n";
      print \$TCF "<a name=\"top_consumers\"></a>\n";
      print \$TCF "<h2>Top 10 Time Consuming Checks</h2>\n";
      print \$TCF "<p><b>NOTE:</b> This information is primarily used for helping Oracle optimize the run time of ${program_name}.<br></br>These timings are not necessarily indicative of any problem and may vary widely from one system to another.</p>\n";
      print \$TCF "<table summary=\"Top Time Consuming Checks\">\n";
      print \$TCF "<tr>\n";
      print \$TCF "<th style=\"DISPLAY: none;\" name=\"checkid\" scope=\"col\">Check Id</th>\n";
      print \$TCF "<th scope=\"col\">Name</th>\n";
      print \$TCF "<th scope=\"col\">Type</th>\n";
      print \$TCF "<th scope=\"col\">Target</th>\n";
      print \$TCF "<th scope=\"col\">Execution Duration</th>\n";
      print \$TCF "</tr>\n";
    
      foreach my \$data (sort { \$CHECKS->{\$b} <=> \$CHECKS->{\$a} } keys %\$CHECKS) {
      if ( \$TLIMIT <= \$count ) { last; }
          
      my (@data) = split(':',\$data);
      my (\$checkid)	= \$data[0];
    
      my (\$name)	= \$data[5];
      if (!defined \$data[5] || \$data[5] =~ m/^\s*\$/ ) { \$name = \$data[6]; }
      
      my (\$target)	= \$data[1];
      if (defined \$data[7] && \$data[7] !~ m/^\s*\$/ ) { \$target .= ':'.\$data[7]; }
      if (defined \$data[8] && \$data[8] !~ m/^\s*\$/ ) { \$target .= ':'.\$data[8]; }
    
      my (\$duration)  = convert_format(\$CHECKS->{\$data});
    
      print \$TCF "<tr>\n";

      my (\$type)      = \$data[2];
      if (( \$type =~ m/SQL_COLLECT/ || \$type =~ m/OS_COLLECT/ ) || (defined \$data[9] && \$data[9] =~ m/[0-9]/ && \$data[9] == 0 )) {
	print \$TCF "<td align=\"center\" class=\"check-id\" style=\"DISPLAY: none;\" name=\"checkid\">-</td>\n";
        print \$TCF "<td scope=\"row\">\$name</td>\n";
      }
      else {
	print \$TCF "<td align=\"center\" class=\"check-id\" style=\"DISPLAY: none;\" name=\"checkid\">\$checkid</td>\n";
        print \$TCF "<td scope=\"row\"><a class=\"a_bgw\" href=\"\#".\$checkid."_summary\">\$name</a></td>\n";
      }

      if ( \$type =~ m/SQL_COLLECT/ ) {
        print \$TCF "<td scope=\"row\" align=\"center\"> SQL Collection </td>\n";
      }
      elsif ( \$type =~ m/OS_COLLECT/ ) {
        print \$TCF "<td scope=\"row\" align=\"center\"> OS Collection </td>\n";
      }
      else {
        print \$TCF "<td scope=\"row\" align=\"center\"> \$type Check </td>\n";

      }
      print \$TCF "<td scope=\"row\" align=\"center\"> \$target </td>\n";
      print \$TCF "<td scope=\"row\" align=\"center\">".\$duration."</td>\n";
      print \$TCF "</tr>\n";
    
      \$count++;
      }
    
      print \$TCF "</table></div>";
    }
    
    my (\$EPOCH_TIME) = '`date +%s%3N`';
    if ( \$EPOCH_TIME =~ m/%3N$/ || \$EPOCH_TIME !~ m/^[0-9]*$/) { \$UNIT = "secs"; }

    if (-e \$CHKFILE) {
      open( my \$CTIME, "<", \$CHKFILE ) || die \$!;
      while ( my \$line = <\$CTIME> ) {
        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
        
        if ( \$line =~ m/Check Start Time/ ) {
          my \$CHECKID	= get_checkid(\$line);
          next if ( \$CHECKID eq "" );
          
          my \$TIME_st 	= get_time(\$line);
          my \$HOST	= get_host(\$line);
          my \$TYPE	= get_type(\$line);
          my \$COL_NAME   = get_cn(\$line);
          my \$CHK_NAME   = get_chkname(\$line);
      
          while ( my \$line = <\$CTIME> ) {
            if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
            if ( \$line =~ m/Execution Start Time:/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
              my \$TIME_est 	= get_time(\$line);
      	      my \$TAG1 	= get_tag1(\$line);
      	      my \$TAG2 	= get_tag2(\$line);
      	      my \$TAG3 	= get_tag3(\$line);
      
              while ( my \$line = <\$CTIME> ) {
                if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }
      
                if ( \$line =~ m/Check:get_log_result.*Start Time/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	            my \$TIME_gst    = get_time(\$line);
      
                    while ( my \$line = <\$CTIME> ) {
                    if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }
      
                    if ( \$line =~ m/Check:log_pass.*Start Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	              my \$TIME_lpst = get_time(\$line);
      
                      while ( my \$line = <\$CTIME> ) {
                        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }
      
                        if ( \$line =~ m/Check:log_pass.*End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		          my \$TIME_lpet = get_time(\$line);
                          last;
                        }
                      }
                    }
                    if ( \$line =~ m/Check:log_fail.*Start Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	              my \$TIME_lfst = get_time(\$line);
      
                      while ( my \$line = <\$CTIME> ) {
                        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }
      
                        if ( \$line =~ m/Check:fail.*End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		          my \$TIME_lfet = get_time(\$line);
                          last;
                        }
                      }
                    }
                    if ( \$line =~ m/Check:get_log_result.*End Time/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	              my \$TIME_get = get_time(\$line);
                      last;
                    }
                  }
                }
                if ( \$line =~ m/Execution End Time:/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	          my \$TIME_eet = get_time(\$line);
      	          timings(\$CHECKID, \$HOST, \$TYPE, \$TIME_eet, \$TIME_est, 'execution', "\$COL_NAME", "\$CHK_NAME", "\$TAG1", "\$TAG2", "\$TAG3");
      
                  last;
                }
              }
            }
            elsif ( \$line =~ m/Check:get_log_result.*Start Time/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
              my \$TIME_gst 	= get_time(\$line);
      	      my \$TAG1 	= get_tag1(\$line);
      	      my \$TAG2 	= get_tag2(\$line);
      	      my \$TAG3 	= get_tag3(\$line);
      
              while ( my \$line = <\$CTIME> ) {	        
                if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
                if ( \$line =~ m/Execution Start Time:/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	            my \$TIME_est = get_time(\$line);
      
                    while ( my \$line = <\$CTIME> ) {
                    if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
                    if ( \$line =~ m/Check:log_pass.*Start Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		        my \$TIME_lpst = get_time(\$line);
      
                        while ( my \$line = <\$CTIME> ) {
                        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
                        if ( \$line =~ m/Check:log_pass.*End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		          my \$TIME_lpet = get_time(\$line);
                          last;
                	  }	
                      }
                    }
                    if ( \$line =~ m/Check:log_fail.*Start Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		      my \$TIME_lfst = get_time(\$line);
      
                      while ( my \$line = <\$CTIME> ) {
                        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
                        if ( \$line =~ m/Check:fail.*End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		          my \$TIME_lfet = get_time(\$line);
                          last;
                	}	
                      }
                    }
                    if ( \$line =~ m/Execution End Time:/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		      my \$TIME_eet = get_time(\$line);
      		
      	              timings(\$CHECKID, \$HOST, \$TYPE, \$TIME_eet, \$TIME_est, 'execution', "\$COL_NAME", "\$CHK_NAME", "\$TAG1", "\$TAG2", "\$TAG3");
                      last;
                    }  
                  }
                }
                if ( \$line =~ m/Check:get_log_result.*End Time/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	          my \$TIME_get = get_time(\$line);
                  last;
                }
              }
            }
      
            if ( \$line =~ m/Check End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$TYPE/ ) {
              my \$TIME_et = get_time(\$line);
              last;
            }	
          }
        }
      }
      close(\$CTIME);
      print_info ();
    }
PERLEOF
}

#usage: get_current_epoch [1] 
get_current_epoch ()
{
  in_secs=$1

  t_epoch_time=$(date +%3N)
  epoch_time=$(date +%s)
  if [[ ${#t_epoch_time} -gt 3 ]];
  then
    t_epoch_time=$(echo "$t_epoch_time" | sed 's/^.*\(.\{3\}\)$/\1/')
    epoch_time=${epoch_time}${t_epoch_time}
  else
    epoch_time=$(date +%s%3N)
  fi

  #if [[ `echo "$epoch_time"|grep -c '%3N'` -gt 0 ]] || [[ -n $in_secs && $in_secs -eq "1" ]]
  if [[ `echo "$epoch_time"|grep -c '^[0-9]*$'` -eq "0" ]] || [[ -n $in_secs && $in_secs -eq "1" ]]
  then
    epoch_time=$(date +%s)
    #if [[ `echo "$epoch_time"|grep -c '%s'` -gt 0 ]]
    if [[ `echo "$epoch_time"|grep -c '^[0-9]*$'` -eq "0" ]] 
    then
      sysDateYear=$(date '+%Y')
      sysDateMonth=$(date '+%m'|sed 's/^0//')
      sysDateDay=$(date '+%d'|sed 's/^0//')
      sysDateHour=$(date '+%H'|sed 's/^0//')      
      #sysDateMin=$(date '+%H'|sed 's/^0//')      
      sysDateMin=$(date '+%M'|sed 's/^0//')      
      sysDateSec=$(date '+%S'|sed 's/^0//')      
      epoch_time=$(perl -e 'use Time::Local;print timelocal("'$sysDateSec'","'$sysDateMin'","'$sysDateHour'",'$sysDateDay','$sysDateMonth'-1,'$sysDateYear');') 
    fi  
  fi	
}

function swap_p_conf_file
{
  if [ -e "$1" ]
  then
    p_conf_file="$1"
  fi	
}

function extract_ibswitches
{
  if [[ $OFFLINE -eq "0" ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 ]]; then return; fi
  
  if [[ $EM_PROBE_MODE -eq 1 && $em_probe_sudo_mode -eq 0 ]]
  then
    find_switch_root_password=$probe_root_password
  fi  

  first_compute_ip=$(cat $HOSTLIST|head -1)  
  if [[ -n "$compute_ssh_status" && $compute_ssh_status -ne 0 ]] || [[ $EM_PROBE_MODE -eq 1 && $em_probe_sudo_mode -eq 0 ]]
  then
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    fixRootPassword "$find_switch_root_password"
    $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1   
			   }
			   spawn -noecho $SSHELL ${root_user}@$first_compute_ip "ibswitches 2>/dev/null >${RTEMPDIR}/o_ibswitches_full.out"
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
				 exit 4;
				 }
			   -nocase "no)?" {
				 send -- "yes\n"
				 }
    			   -nocase "*?assword:*" {
                                 send -- "\$le_find_switch_root_password\n"
                                  }
			   -nocase eof {
				 exit
				 }
			   }
 			   expect {
                           -nocase "*?assword:*" {
                        	send -- "\$le_find_switch_root_password\n"
                           }
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while running ibswitches command \n";
                                exit
                           }
			   }
 			   expect {
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while running ibswitches command \n";
                                exit
                           }
			   }
IBEOF
  printf ". ";
  if [[ $first_compute_ip != $localnode ]]; then
    $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1
			   }  
			   spawn $SCOPY ${root_user}@$first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR}
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
				 exit 4;
				 }
			   -nocase "no)?" {
				 send -- "yes\n"
				 }
    			   -nocase "*?assword:*" {
                                 send -- "\$le_find_switch_root_password\n"
                                  }
			   -nocase eof {
				 exit
				 }
			   }
 			   expect {
                           -nocase "*?assword:*" {
                        	send -- "\$le_find_switch_root_password\n"
                           }
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while copying ${RTEMPDIR}/o_ibswitches_full.out from $first_compute_ip\n";
                                exit
                           }
			   }
 			   expect {
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while copying ${RTEMPDIR}/o_ibswitches_full.out from $first_compute_ip\n";
                                exit
                           }
			   }
IBEOF
  printf ". ";
  $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1
			   }   
			   spawn $SSHELL ${root_user}@$first_compute_ip rm -f o_ibswitches_full.out
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
				 exit 4;
				 }
			   -nocase "no)?" {
				 send -- "yes\n"
				 }
    			   -nocase "*?assword:*" {
                                 send -- "\$le_find_switch_root_password\n"
                                  }
			   -nocase eof {
				 exit
				 }
			   }
 			   expect {
                           -nocase "*?assword:*" {
                        	send -- "\$le_find_switch_root_password\n"
                           }
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while removing o_ibswitches_full.out\n";
                                exit
                           }
			   }
 			   expect {
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while removing o_ibswitches_full.out\n";
                                exit
                           }
			   }
IBEOF
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      printf ". ";
    fi
  else
    if [[ $EM_PROBE_MODE -eq 1 && $em_probe_sudo_mode -eq 1 ]]
    then
      $SSHELL $first_compute_ip "sudo ibswitches 2>/dev/null >${RTEMPDIR}/o_ibswitches_full.out 2>/dev/null 2>&1"

      if [[ $first_compute_ip != $localnode ]]; then
        $SCOPY $first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
        $SSHELL $first_compute_ip "sudo rm -f ${RTEMPDIR}/o_ibswitches_full.out>/dev/null 2>&1"
      fi
    else
      if [[ -n $db_root_ssh && $db_root_ssh -eq 0 ]]; then 
 	echo -e "No ${root_user} passsword and ssh to first compute node" >> $LOGFIL
	return; 
      fi

      $SSHELL ${root_user}@$first_compute_ip "ibswitches 2>/dev/null >${RTEMPDIR}/o_ibswitches_full.out 2>/dev/null 2>&1"
      if [[ $first_compute_ip != $localnode ]]; then
        $SCOPY ${root_user}@$first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
        $SSHELL ${root_user}@$first_compute_ip "rm -f ${RTEMPDIR}/o_ibswitches_full.out>/dev/null 2>&1"
      fi
    fi
    printf ". ";
  fi
}

function get_agentOwner ()
{
  if [[ -z "$mb_emagent_home" ]]; then
    mb_emagent_home=$emhome
  fi

  if [[ -n "$1" ]]; then
    stack=$1
    if [ `uname -s` = "Linux" ]
    then
      agentOwner=`$SSHELL $stack "stat -L -c \"%U\" $mb_emagent_home/bin/emctl 2>/dev/null"`
      if [ -z "$agentOwner" ]; then
        agentOwner=`$SSHELL $stack "ls -l $mb_emagent_home/bin/emctl 2>/dev/null >&1|awk '{print $3}'"`
    	agentOwner=`echo $agentOwner|awk '{print $3}'`
      fi
    else
      agentOwner=`$SSHELL $stack "ls -l $mb_emagent_home/bin/emctl 2>/dev/null >&1|awk '{print $3}'"`
      agentOwner=`echo $agentOwner|awk '{print $3}'`
    fi
    if [ -n "$agentOwner" ]; then
      agentGroup=`$SSHELL $t_flag $stack "$bash_scr -c \"groups "$agentOwner"|cut -d: -f2|awk '{print \\\\\\$1}'|sed 's/ //g'\""`
      agenthome_dir=`$SSHELL $t_flag $stack "$bash_scr -c \"grep "^${agentOwner}:" /etc/passwd|cut -d":" -f6\""`

      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_prompts "$agentOwner" "$agenthome_dir"; fi
      if [[ -z $agenthome_dir ]]; then
        agenthome_dir=`$SSHELL $t_flag $stack "$bash_scr -c \"su - $agentOwner -c \\\"echo \\\\\\\$HOME\\\"\" 2>/dev/null" 2>/dev/null`
      fi
    fi
  else
    if [ `uname -s` = "Linux" ]
    then
      agentOwner=$(stat -L -c "%U" $mb_emagent_home/bin/emctl 2>/dev/null >&1)
      if [ -z "$agentOwner" ]; then
        agentOwner=$(ls -l $mb_emagent_home/bin/emctl 2>/dev/null >&1|awk '{print $3}')
      fi
    else
      agentOwner=$(ls -l $mb_emagent_home/bin/emctl 2>/dev/null >&1|awk '{print $3}')
    fi
    if [ -n "$agentOwner" ]; then 
      agentGroup=$(groups "$agentOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
      agenthome_dir=$(grep "^${agentOwner}:" /etc/passwd|cut -d":" -f6);

      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_prompts "$agentOwner" "$agenthome_dir"; fi

      if [[ -z $agenthome_dir ]]; then
        agenthome_dir=`$SSHELL -o NumberOfPasswordPrompts=0 $t_flag $localnode "$bash_scr -c \"su - $agentOwner -c \\\"echo \\\\\\\$HOME\\\"\" 2>/dev/null" 2>/dev/null`
      fi
      if [[ -z $agenthome_dir ]]; then agenthome_dir=`$bash_scr -c "su - $agentOwner -c \"echo \\\\\\\$HOME\""`; fi
    fi
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    if [[ -n "$agentOwner" ]]; then
      check_usr_prompts "$agentOwner" "$agenthome_dir"

      if [[ ! -d "$OUTPUTDIR/$agentOwner" ]]; then
        mkdir $OUTPUTDIR/$agentOwner >/dev/null 2>&1
        usr_dirs[$usr_dir_cnt]=$agentOwner
        usr_dir_cnt=$(expr $usr_dir_cnt + 1)
      fi
      if [[ ! -d "$INPUTDIR/$agentOwner" ]]; then mkdir $INPUTDIR/$agentOwner >/dev/null 2>&1; fi

      if [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -gt "0" ]]; then 
        OLD_TMP_OUTPUT=$TMP_OUTPUT; 
        TMP_OUTPUT=$(echo "$TMP_OUTPUT"|sed "s|USR_HOMEDIR|$agenthome_dir|g"); 
	if [[ -n $USR_DIRS && `echo "$USR_DIRS" | grep -ic "$TMP_OUTPUT"` -eq "0" ]]; then
	  USR_DIRS="$USR_DIRS $TMP_OUTPUT"
    	  call_func_check_space "RUNTIME_DIR" "$agenthome_dir"
          if [[ ! -d "$TMP_OUTPUT/$agentOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$agentOwner" "$agentGroup"; mkdir -p $TMP_OUTPUT/$agentOwner >/dev/null 2>&1; fi
    	  copy_localonly "$agentOwner" "$agentGroup"
 	elif [[ -z $USR_DIRS ]]; then
	  USR_DIRS="$TMP_OUTPUT"
          if [[ ! -d "$TMP_OUTPUT/$agentOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$agentOwner" "$agentGroup"; mkdir -p $TMP_OUTPUT/$agentOwner >/dev/null 2>&1; fi
    	  call_func_check_space "RUNTIME_DIR" "$agenthome_dir"
    	  copy_localonly "$agentOwner" "$agentGroup"
	fi
      else
	if [[ -n $USR_DIRS && `echo "$USR_DIRS" | grep -ic "$TMP_OUTPUT/$agentOwner"` -eq "0" ]] || [[ -z $USR_DIRS ]]; then
	  USR_DIRS="$USR_DIRS $TMP_OUTPUT/$agentOwner"
          if [[ ! -d "$TMP_OUTPUT/$agentOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$agentOwner" "$agentGroup"; mkdir -p $TMP_OUTPUT/$agentOwner >/dev/null 2>&1; fi
	fi
      fi
      if [[ ! -e $TMP_OUTPUT/o_host_list.out ]]; then cp -f ${HOSTLIST} $TMP_OUTPUT >/dev/null 2>&1; fi

      if [[ ! -d "$RTEMPDIR/$agentOwner" ]]; then mkdir $RTEMPDIR/$agentOwner >/dev/null 2>&1; fi
              
      chown $agentOwner:$agentGroup $OUTPUTDIR/$agentOwner $INPUTDIR/$agentOwner $TMP_OUTPUT $TMP_OUTPUT/$agentOwner $RTEMPDIR/$agentOwner
    fi
  fi
}

function get_omsOwner ()
{
  localrun=1 
  if [[ -n $1 ]]; then
    if [[ $1 != $localnode ]]; then
      if [ -z $mb_oms_home ]; then
	localrun=1
      else
        localrun=0
        omsssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 $1 ls >/dev/null 2>&1;echo $?);
        if [[ -n "$omsssh_status" && $omsssh_status -eq 0 ]]; then 
	  t_flag="-T"
	  if [ `uname -s` = "Linux" ]
	  then
	    omsOwner=`$SSHELL $t_flag $1 "$bash_scr -c \"stat -L -c "%U" $mb_oms_home/bin/emctl$BAT 2>/dev/null >&1\""`
	    if [ -z $omsOwner ]; then
	      omsOwner=`$SSHELL $t_flag $1 "$bash_scr -c \"ls -l $mb_oms_home/bin/emctl$BAT 2>/dev/null >&1|awk '{print \\\\\\$3}'\""`
	    fi
	  else
	    omsOwner=`$SSHELL $t_flag $1 "$bash_scr -c \"ls -l $mb_oms_home/bin/emctl$BAT 2>/dev/null >&1|awk '{print \\\\\\$3}'\""`
	  fi

	  if [ -n "$omsOwner" ]; then
	    omsGroup=`$SSHELL $t_flag $1 "$bash_scr -c \"groups "$omsOwner"|cut -d: -f2|awk '{print \\\\\\$1}'|sed 's/ //g'\""`
	    omshome_dir=`$SSHELL $t_flag $1 "$bash_scr -c \"grep "^${omsOwner}:" /etc/passwd|cut -d":" -f6\""`
  	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_prompts "$omsOwner" "$omshome_dir"; fi
	    if [[ -z $omshome_dir ]]; then
	      omshome_dir=`$SSHELL $t_flag $1 "$bash_scr -c \"su - $omsOwner -c \\\"echo \\\\\\\$HOME\\\"\" 2>/dev/null" 2>/dev/null`
	    fi
	  fi
	else
	  localrun=1
	fi
      fi
    fi	
  fi

  if [[ $localrun -eq 1 ]]; then 
    if [ -z $mb_oms_home ]; then
      omsOwner=$usern
      omsGroup=$(groups "$omsOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
      omshome_dir=$(grep "^${omsOwner}:" /etc/passwd|cut -d":" -f6);
    else
      if [ `uname -s` = "Linux" ]
      then
        omsOwner=$(stat -L -c "%U" $mb_oms_home/bin/emctl$BAT 2>/dev/null >&1)
        if [ -z "$omsOwner" ]; then
          omsOwner=$(ls -l $mb_oms_home/bin/emctl$BAT 2>/dev/null >&1|awk '{print $3}')
        fi
      else
        omsOwner=$(ls -l $mb_oms_home/bin/emctl$BAT 2>/dev/null >&1|awk '{print $3}')
      fi
      if [ -n "$omsOwner" ]; then 
        omsGroup=$(groups "$omsOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
        omshome_dir=$(grep "^${omsOwner}:" /etc/passwd|cut -d":" -f6);
  	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_prompts "$omsOwner" "$omshome_dir"; fi
	if [[ -z $omshome_dir ]]; then
	  omshome_dir=`$SSHELL -o NumberOfPasswordPrompts=0 $t_flag $localnode "$bash_scr -c \"su - $omsOwner -c \\\"echo \\\\\\\$HOME\\\"\" 2>/dev/null" 2>/dev/null`
	fi
	if [[ -z $omshome_dir ]]; then omshome_dir=`$bash_scr -c "su - $omsOwner -c \"echo \\\\\\\$HOME\""`; fi
      fi
    fi
  fi

  if [[ -e $omshome_dir && -z $2 ]]; then 
    OLD_DIR=`pwd`
    cd "$omshome_dir";
  else
    #Keep it as location of a script
    OLD_DIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    if [[ -n "$omsOwner" ]]; then
      check_usr_prompts "$omsOwner" "$omshome_dir"

      if [[ ! -d "$OUTPUTDIR/$omsOwner" ]]; then 
        mkdir $OUTPUTDIR/$omsOwner >/dev/null 2>&1
        usr_dirs[$usr_dir_cnt]=$omsOwner 
        usr_dir_cnt=$(expr $usr_dir_cnt + 1)
      fi
      if [[ ! -d "$INPUTDIR/$omsOwner" ]]; then mkdir $INPUTDIR/$omsOwner >/dev/null 2>&1; fi

      if [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -gt "0" ]]; then 
        OLD_TMP_OUTPUT=$TMP_OUTPUT; 
        TMP_OUTPUT=$(echo "$TMP_OUTPUT"|sed "s|USR_HOMEDIR|$omshome_dir|g"); 
	if [[ -n $USR_DIRS && `echo "$USR_DIRS" | grep -ic "$TMP_OUTPUT"` -eq "0" ]]; then
	  USR_DIRS="$USR_DIRS $TMP_OUTPUT"
          if [[ ! -d "$TMP_OUTPUT/$omsOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$omsOwner" "$omsGroup"; mkdir -p $TMP_OUTPUT/$omsOwner >/dev/null 2>&1; fi
    	  call_func_check_space "RUNTIME_DIR" "$omshome_dir"
    	  copy_localonly "$omsOwner" "$omsGroup"
 	elif [[ -z $USR_DIRS ]]; then
	  USR_DIRS="$TMP_OUTPUT"
          if [[ ! -d "$TMP_OUTPUT/$omsOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$omsOwner" "$omsGroup"; mkdir -p $TMP_OUTPUT/$omsOwner >/dev/null 2>&1; fi
    	  call_func_check_space "RUNTIME_DIR" "$omshome_dir"
    	  copy_localonly "$omsOwner" "$omsGroup"
	fi
      else
	if [[ -n $USR_DIRS && `echo "$USR_DIRS" | grep -ic "$TMP_OUTPUT/$omsOwner"` -eq "0" ]] || [[ -z $USR_DIRS ]]; then
	  USR_DIRS="$USR_DIRS $TMP_OUTPUT/$omsOwner"
          if [[ ! -d "$TMP_OUTPUT/$omsOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$omsOwner" "$omsGroup"; mkdir -p $TMP_OUTPUT/$omsOwner >/dev/null 2>&1; fi
	fi
      fi
      if [[ ! -e $TMP_OUTPUT/o_host_list.out ]]; then cp -f ${HOSTLIST} $TMP_OUTPUT >/dev/null 2>&1; fi

      if [[ ! -d "$RTEMPDIR/$omsOwner" ]]; then mkdir $RTEMPDIR/$omsOwner >/dev/null 2>&1; fi

      chown $omsOwner:$omsGroup $OUTPUTDIR/$omsOwner $INPUTDIR/$omsOwner $TMP_OUTPUT $TMP_OUTPUT/$omsOwner $RTEMPDIR/$omsOwner
    fi
  fi
}

function check_usr_dirs_existence ()
{
  USR_TAG=$1
  GRP_TAG=$2

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_prompts "$USR_TAG" "$dbhome_dir"; fi

  if [[ -n "$USR_TAG" ]]; then
    if [[ ! -d "$OUTPUTDIR/$USR_TAG" ]]; then 
      mkdir $OUTPUTDIR/$USR_TAG >/dev/null 2>&1
      usr_dirs[$usr_dir_cnt]=$USR_TAG
      usr_dir_cnt=$(expr $usr_dir_cnt + 1)
    fi
    if [[ ! -d "$INPUTDIR/$USR_TAG" ]]; then mkdir $INPUTDIR/$USR_TAG >/dev/null 2>&1; fi

    if [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -gt "0" ]]; then 
      OLD_TMP_OUTPUT=$TMP_OUTPUT; 
      TMP_OUTPUT=$(echo "$TMP_OUTPUT"|sed "s|USR_HOMEDIR|$dbhome_dir|g"); 
      if [[ -n $USR_DIRS && `echo "$USR_DIRS" | grep -ic "$TMP_OUTPUT"` -eq "0" ]]; then
        USR_DIRS="$USR_DIRS $TMP_OUTPUT"
        if [[ ! -d "$TMP_OUTPUT/$USR_TAG" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$USR_TAG" "$GRP_TAG"; mkdir -p $TMP_OUTPUT/$USR_TAG >/dev/null 2>&1; fi
    	call_func_check_space "RUNTIME_DIR" "$dbhome_dir"
    	copy_localonly "$USR_TAG" "$GRP_TAG"
      elif [[ -z $USR_DIRS ]]; then
        USR_DIRS="$TMP_OUTPUT"
        if [[ ! -d "$TMP_OUTPUT/$USR_TAG" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$USR_TAG" "$GRP_TAG"; mkdir -p $TMP_OUTPUT/$USR_TAG >/dev/null 2>&1; fi
    	call_func_check_space "RUNTIME_DIR" "$dbhome_dir"
    	copy_localonly "$USR_TAG" "$GRP_TAG"
      fi
    else
      if [[ -n $USR_DIRS && `echo "$USR_DIRS" | grep -ic "$TMP_OUTPUT/$USR_TAG"` -eq "0" ]] || [[ -z $USR_DIRS ]]; then
        USR_DIRS="$USR_DIRS $TMP_OUTPUT/$USR_TAG"
        if [[ ! -d "$TMP_OUTPUT/$USR_TAG" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$USR_TAG" "$GRP_TAG"; mkdir -p $TMP_OUTPUT/$USR_TAG >/dev/null 2>&1; fi
      fi
    fi
    if [[ ! -e $TMP_OUTPUT/o_host_list.out ]]; then cp -f ${HOSTLIST} $TMP_OUTPUT >/dev/null 2>&1; fi

    if [[ ! -d "$RTEMPDIR/$USR_TAG" ]]; then mkdir -p $RTEMPDIR/$USR_TAG >/dev/null 2>&1; fi

    chown $USR_TAG:$GRP_TAG $OUTPUTDIR/$USR_TAG $INPUTDIR/$USR_TAG $TMP_OUTPUT $TMP_OUTPUT/$USR_TAG $RTEMPDIR/$USR_TAG
  fi
}

function get_dbOwner ()
{
  localrun=1 
  if [[ -n $1 ]]; then
    if [[ $1 != $localnode ]]; then
      if [ -z $ORACLE_HOME ]; then
	localrun=1
      else
        localrun=0
        dbssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 $1 ls >/dev/null 2>&1;echo $?);
        if [[ -n "$dbssh_status" && $dbssh_status -eq 0 ]]; then 
	  t_flag="-T"
	  if [ `uname -s` = "Linux" ]
	  then
	    dbOwner=`$SSHELL $t_flag $1 "$bash_scr -c \"stat -L -c "%U" $ORACLE_HOME/bin/oracle 2>/dev/null >&1\""`
	    if [ -z $dbOwner ]; then
	      dbOwner=`$SSHELL $t_flag $1 "$bash_scr -c \"ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print \\\\\\$3}'\""`
	    fi
	  else
	    dbOwner=`$SSHELL $t_flag $1 "$bash_scr -c \"ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print \\\\\\$3}'\""`
	  fi

	  if [ -n "$dbOwner" ]; then
	    dbGroup=`$SSHELL $t_flag $1 "$bash_scr -c \"groups "$dbOwner"|cut -d: -f2|awk '{print \\\\\\$1}'|sed 's/ //g'\""`
	    dbhome_dir=`$SSHELL $t_flag $1 "$bash_scr -c \"grep "^${dbOwner}:" /etc/passwd 2>/dev/null|cut -d":" -f6\""`
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_prompts "$dbOwner" "$dbhome_dir"; fi
	    if [[ -z $dbhome_dir ]]; then
	      dbhome_dir=`$SSHELL $t_flag $1 "$bash_scr -c \"su - $dbOwner -c \\\"echo \\\\\\\$HOME\\\"\" 2>/dev/null" 2>/dev/null`
	    fi
	  fi
	else
	  localrun=1
	fi
      fi
    fi	
  fi

  if [[ $localrun -eq 1 ]]; then 
    if [ -z $ORACLE_HOME ]; then
      dbOwner=$usern
      dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
      dbhome_dir=$(grep "^${dbOwner}:" /etc/passwd 2>/dev/null|cut -d":" -f6);
    else
      if [ `uname -s` = "Linux" ]
      then
        dbOwner=$(stat -L -c "%U" $ORACLE_HOME/bin/oracle 2>/dev/null >&1)
        if [ -z "$dbOwner" ]; then
          dbOwner=$(ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print $3}')
        fi
      else
        dbOwner=$(ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print $3}')
      fi
      if [ -n "$dbOwner" ]; then 
        dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
        dbhome_dir=$(grep "^${dbOwner}:" /etc/passwd 2>/dev/null|cut -d":" -f6);
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_prompts "$dbOwner" "$dbhome_dir"; fi
	if [[ -z $dbhome_dir ]]; then
	  dbhome_dir=`$SSHELL -o NumberOfPasswordPrompts=0 $t_flag $localnode "$bash_scr -c \"su - $dbOwner -c \\\"echo \\\\\\\$HOME\\\"\" 2>/dev/null" 2>/dev/null`
	fi
	if [[ -z $dbhome_dir ]]; then dbhome_dir=`$bash_scr -c "su - $dbOwner -c \"echo \\\\\\\$HOME\" 2>/dev/null" 2>/dev/null`; fi
      fi
    fi
  fi

  if [[ -e $dbhome_dir && -z $2 ]]; then 
    OLD_DIR=`pwd`
    cd "$dbhome_dir";
  else
    #Keep it as location of a script
    OLD_DIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    if [[ -n "$dbOwner" ]]; then
      check_usr_prompts "$dbOwner" "$dbhome_dir"

      if [[ ! -d "$OUTPUTDIR/$dbOwner" ]]; then 
        mkdir $OUTPUTDIR/$dbOwner >/dev/null 2>&1
        usr_dirs[$usr_dir_cnt]=$dbOwner
        usr_dir_cnt=$(expr $usr_dir_cnt + 1)
      fi
      if [[ ! -d "$INPUTDIR/$dbOwner" ]]; then mkdir $INPUTDIR/$dbOwner >/dev/null 2>&1; fi

      if [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -gt "0" ]]; then 
        OLD_TMP_OUTPUT=$TMP_OUTPUT; 
        TMP_OUTPUT=$(echo "$TMP_OUTPUT"|sed "s|USR_HOMEDIR|$dbhome_dir|g"); 
        if [[ -n $USR_DIRS && `echo "$USR_DIRS" | grep -ic "$TMP_OUTPUT"` -eq "0" ]]; then
          USR_DIRS="$USR_DIRS $TMP_OUTPUT"
      	  if [[ ! -d "$TMP_OUTPUT/$dbOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$dbOwner" "$dbGroup"; mkdir -p $TMP_OUTPUT/$dbOwner >/dev/null 2>&1; fi
    	  call_func_check_space "RUNTIME_DIR" "$dbhome_dir"
    	  copy_localonly "$dbOwner" "$dbGroup"
        elif [[ -z $USR_DIRS ]]; then
          USR_DIRS="$TMP_OUTPUT"
      	  if [[ ! -d "$TMP_OUTPUT/$dbOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$dbOwner" "$dbGroup"; mkdir -p $TMP_OUTPUT/$dbOwner >/dev/null 2>&1; fi
    	  call_func_check_space "RUNTIME_DIR" "$dbhome_dir"
    	  copy_localonly "$dbOwner" "$dbGroup"
        fi
      else 
        if [[ -n $USR_DIRS && `echo "$USR_DIRS" | grep -ic "$TMP_OUTPUT/$dbOwner"` -eq "0" ]] || [[ -z $USR_DIRS ]]; then
          USR_DIRS="$USR_DIRS $TMP_OUTPUT/$dbOwner"
      	  if [[ ! -d "$TMP_OUTPUT/$dbOwner" ]]; then create_usr_dirs_on_remote "$TMP_OUTPUT" "$dbOwner" "$dbGroup"; mkdir -p $TMP_OUTPUT/$dbOwner >/dev/null 2>&1; fi
        fi 
      fi
      if [[ ! -e $TMP_OUTPUT/o_host_list.out ]]; then cp -f ${HOSTLIST} $TMP_OUTPUT >/dev/null 2>&1; fi

      if [[ ! -d "$RTEMPDIR/$dbOwner" ]]; then mkdir $RTEMPDIR/$dbOwner >/dev/null 2>&1; fi

      chown $dbOwner:$dbGroup $OUTPUTDIR/$dbOwner $INPUTDIR/$dbOwner $TMP_OUTPUT $TMP_OUTPUT/$dbOwner $RTEMPDIR/$dbOwner >/dev/null 2>&1;
    fi
  fi
}

function finish_em_xml 
{
  update_probe_xml
  cat ${PROBE_XML};
  exit 0;
}

function save_crs ()
{
  if [ $is_windows -eq "0" ] ; then return; fi
  saved_CRS=$CRS
  unset CRS
  CRS=$saved_CRS
}

function ret_crs ()
{
  if [ $is_windows -eq "0" ] ; then return; fi
  export CRS
}


function update_probe_xml ()
{
  XMODE="$1"
  XETYPE="$2"
  XEMSG="$3" 

  if [[ -z $XMODE ]]
  then
    echo "<questionnaire>" > ${PROBE_XML}.tmp.2
    
    if [[ -e ${PROBE_XML}.tmp ]]
    then
      if [[ `grep -c "id=\"${GID_EC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_EC}\" groupHeader=\"${GID_EC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_EC}\" groupHeader=\"${GID_EC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_EC}\" groupHeader=\"${GID_EC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi
      
      if [[ `grep -c "id=\"${GID_DC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_DC}\" groupHeader=\"${GID_DC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_DC}\" groupHeader=\"${GID_DC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_DC}\" groupHeader=\"${GID_DC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi

      if [[ `grep -c "id=\"${GID_CC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_CC}\" groupHeader=\"${GID_CC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_CC}\" groupHeader=\"${GID_CC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_CC}\" groupHeader=\"${GID_CC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi
      
      if [[ `grep -c "id=\"${GID_SC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_SC}\" groupHeader=\"${GID_SC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_SC}\" groupHeader=\"${GID_SC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_SC}\" groupHeader=\"${GID_SC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi

      if [[ `grep -c "id=\"${GID_ZC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_ZC}\" groupHeader=\"${GID_ZC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_ZC}\" groupHeader=\"${GID_ZC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_ZC}\" groupHeader=\"${GID_ZC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi

    fi
    
    echo "</questionnaire>" >> ${PROBE_XML}.tmp.2
    mv -f ${PROBE_XML}.tmp.2 ${PROBE_XML}.tmp

    esmodel=""
    estype=""

    if [[ -e $MASTERFIL ]]; then
      esmodel=`grep -iw COMPONENTS $MASTERFIL |grep -i "$localnode"|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
      if [[ "$esmodel" = "NONE" ]]; then esmodel=`grep -iw COMPONENTS $MASTERFIL |grep -i "$localnode"|cut -d: -f2|sed 's/ //g'`; fi
      if [[ "$esmodel" = "EXADATA" ]]; then esmodel="V2"; fi

      if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]; then
	if [[ -n "$is_ssc_machine" && $is_ssc_machine -eq 1 ]]; then
          estype="SUPERCLUSTER"
	elif [[ "$is_avm_machine" &&  $is_avm_machine -eq 1 ]]; then
	  estype="RecoveryAppliance" 
	else
          estype="EXADATA"
	fi
      elif [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	assign_exalogic_module "$localnode"
	esmodel=`grep -iw COMPONENT $MASTERFIL |grep -i "$localnode"|cut -d= -f2|sed 's/NONE//g'|sed 's/ //g'|sed 's/^://g'|sed 's/:$//g'`
        estype="EXALOGIC"
      elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]; then
        estype="EXALYTICS"
      elif [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]; then
        estype="BDA"
      elif [[ -n "$oda_machine" && $oda_machine -eq 1 ]]; then
        estype="OracleDatabaseAppliance"
      elif [[ "$is_avm_machine" && $is_avm_machine -eq 1 ]]; then
        estype="RecoveryAppliance"
      elif [[ $single_instance_run -eq 1 ]]; then
        estype="SingleInstance"
      elif [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]]; then
  	estype="RACCHECK" 
      fi
    fi

    locVersion=$(echo $modelVersion|tr -d ' ')
    sed "s/PROGRAM_VERSION/$locVersion/g" $PROBE_XML > ${PROBE_XML}.tmp2
    mv -f ${PROBE_XML}.tmp2 $PROBE_XML
    sed "s/MACHINEMODEL/$esmodel/g" $PROBE_XML > ${PROBE_XML}.tmp2
    mv -f ${PROBE_XML}.tmp2 $PROBE_XML
    sed "s/MACHINETYPE/$estype/g" $PROBE_XML > ${PROBE_XML}.tmp2
    mv -f ${PROBE_XML}.tmp2 $PROBE_XML

    cat $PROBE_XML.tmp >> $PROBE_XML
  elif [[ $XMODE = "ERROR" ]]
  then
    if [[ $XETYPE = "GENERIC" ]]
    then
      cat >> $PROBE_XML << EOF
  <error id="$XETYPE">
    <message>
      $XEMSG
    </message>
  </error>
EOF
    elif [[ $XETYPE = "DAEMON" ]]
    then
      cat >> $PROBE_XML << EOF
  <error id="$XETYPE">
    <message>
      $XEMSG
    </message>
    <args>
      <arg id="location">$dloc</arg>	
      <arg id="version">$dversion</arg>	
    </args>
  </error>
EOF
    elif [[ $XETYPE = "ONEOFF_RUN" ]]
    then
      cat >> $PROBE_XML << EOF
  <error id="$XETYPE">
    <message>
      $XEMSG
    </message>
  </error>
EOF
    fi
    finish_em_xml 
  fi 

  cat >> $PROBE_XML <<EOF
</probeoutput>
EOF
  
  echo -e "\n\n"
  echo -e $GREEN"Probe Completed. Printing Probe Report"$NORM
  echo -e "\n\n"

  rm -f $PROBE_XML.tmp $PROBE_XML.tmp2 >/dev/null 2>&1;
}

function read_probe_xml
{
  op_search=$2
  op_translation=$3
  qtype=0
  sline=$(echo "$EMXML" | grep -ni "$1" | awk -F: '{print $1}' | sed 's/ //g')

  for (( i=$sline; i>=1; i-- ))
  do
    line=$(echo "$EMXML" | sed -n ${i}p)

    if [[ `echo "$line" | grep -c '<question '` -gt 0 ]];
    then
      xml_rvalue=$(echo "$line" | sed 's/^.*outcome="\(.*\)".*$/\1/')
      qtype=$(echo "$line" | grep -ic 'questionType="SECRET"')
      break
    fi
  done

  if [[ -n $op_search && $op_search -eq 1 ]]
  then
    sline=$(echo "$EMXML" | grep -n ">$xml_rvalue<" | awk -F: '{print $1}' | sed 's/ //g')
    for (( i=$sline; i>=1; i-- ))
    do
      line=$(echo "$EMXML" | sed -n ${i}p)

      if [[ `echo "$line" | grep -c '<option '` -gt 0 ]];
      then
        xml_rvalue=$(echo "$line" | sed 's/^.*id="\(.*\)".*$/\1/')
        break
      fi
    done
  fi

  unset tmp_xml_rvalue
  old_ifs=$IFS
  IFS=","
  for xvalue in $xml_rvalue
  do
    if [[ `echo "$EMXML" | grep -c "id=\"${xvalue}\""` -gt 0 ]]
    then
      tmp_xml_rvalue="${xvalue: -1}","${tmp_xml_rvalue}"
    fi
  done
  IFS=${old_ifs}

  if [[ -n $tmp_xml_rvalue ]]; then xml_rvalue=$(echo "$tmp_xml_rvalue" | sed 's/,$//g'); fi

  if [[ "$xml_rvalue" = 'True' ]] 
  then 
    xml_rvalue='Yes'; 
  elif [[ "$xml_rvalue" = 'False' ]] 
  then
    xml_rvalue='No'; 
  fi

  if [[ -n $op_translation && $op_translation -eq 1 ]]; then
    if [[ $xml_rvalue -eq "1" ]]; then 
      xml_rvalue="Y"
    elif [[ $xml_rvalue -eq "2" ]]; then
      xml_rvalue="N"
    fi
  fi

  if [[ $qtype -eq 0 ]]
  then
    echo -e "$xml_rvalue\n";
  fi
}

move_files ()
{
  source_file="$1"
  target_file="$2"
  mode="$3"
   
  if [ -e "$source_file" ]; then
    #source_file_path=$(dirname $source_file)
    #source_file_base=$(basename $source_file)
    if [[ -z $mode ]]; then
      cp -f "$source_file" "$target_file" >/dev/null 2>&1; 
      if [[ $source_file_path != $TMP_OUTPUT && -e $TMP_OUTPUT ]]; then cp -f "$source_file" "$TMP_OUTPUT" >/dev/null 2>&1; fi
    elif [[ "$mode" = "append" ]]; then
      cat "$source_file" >> "$target_file"
      #if [[ $source_file_path != $TMP_OUTPUT && -e $TMP_OUTPUT ]]; then cat "$source_file" >> "$TMP_OUTPUT/$source_file_base"; fi
    fi
  fi
}

validate_tod ()
{
  if [ -e "$1" ]; then
    if [ ! -w "$1" ]; then
      echo -e ${RED}"$1 directory must be writable by all users for creating runtime files.Please set the RAT_TMP_OUTPUT and then re-run ${program_name}"${NORM}
      echo "ex: export RAT_TMP_OUTPUT=/tmp"
      echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
      exit 1 
    fi
  else
    echo -e ${RED}"$1 directory does not exists.Please set the RAT_TMP_OUTPUT and then re-run ${program_name}"${NORM}
    echo "ex: export RAT_TMP_OUTPUT=/tmp" 
    echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
    exit 1 
  fi

  #rm -f $TMP_OUTPUT >/dev/null 2>&1; mkdir $TMP_OUTPUT >/dev/null 2>&1; chmod 777 $TMP_OUTPUT
  rm -f $TMP_OUTPUT >/dev/null 2>&1; mkdir $TMP_OUTPUT >/dev/null 2>&1;
}

set_rat_output ()
{
  if [ -z $RAT_OUTPUT ]; then
    #if [[ `echo "$WRKDIR"|grep -c "/suptools$"` -gt 0 ]]; then
      #oracle_home=$(echo "$WRKDIR"|sed "s/\/suptools$//g");
    if [[ `echo "$RPDIR"|grep -c "/suptools$"` -gt 0 ]]; then
      oracle_home=$(echo "$RPDIR"|sed "s/\/suptools$//g");
      orabasecmd=$oracle_home/bin/orabase
      if [[ -e $orabasecmd ]]; then
        export ORACLE_HOME=$oracle_home 
        ORACLE_BASE=`$orabasecmd`
        if [[ -e $ORACLE_BASE ]]; then
          if [ `uname -s` = "Linux" ]
          then
            orabaseOwner=$(stat -L -c "%U" $ORACLE_BASE 2>/dev/null >&1)
            if [ -z "$orabaseOwner" ]; then orabaseOwner=$(ls -ld $ORACLE_BASE 2>/dev/null >&1|tail -1|awk '{print $3}'); fi
          else
            orabaseOwner=$(ls -ld $ORACLE_BASE 2>/dev/null >&1|tail -1|awk '{print $3}')
          fi
          if [ -n "$orabaseOwner" ]; then orabaseGroup=$(groups "$orabaseOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g'); fi

          if [[ ! -d $ORACLE_BASE/suptools/${program_name} ]]; then mkdir -p $ORACLE_BASE/suptools/${program_name}; fi 
	  if [ -n "$orabaseOwner" ]; then 
	    chown $orabaseOwner:$orabaseGroup $ORACLE_BASE/suptools >/dev/null 2>&1;
	    chown $orabaseOwner:$orabaseGroup $ORACLE_BASE/suptools/${program_name} >/dev/null 2>&1; 
	  fi
          export RAT_OUTPUT=$ORACLE_BASE/suptools/${program_name}      
        fi
	unset ORACLE_HOME 
      fi
    fi
  fi
}

initialize ()
{
  #export RAT_NO_COMPONENTS_FILTER=1;

  if [[ -z $RAT_NOLOAD_CHECK_ATTRIBUTES ]]; then export RAT_LOAD_CHECK_ATTRIBUTES=1; fi

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN = 1 && "$RAT_RUNMODE_INTERNAL" != "slave" ]]; then
    CACHE_DIR=$WRKDIR
    if [[ -n $RAT_CACHE_LOC ]]; then CACHE_DIR=$RAT_CACHE_LOC; fi
    CACHE_FIL=$CACHE_DIR/.${program_name}_cache.cfg
  
    if [[ ! -r $CACHE_FIL ]]; then export RAT_CACHE_RUN=0; fi
    for file in `grep '\--cfs:' $CACHE_FIL|sed 's/--//g'|sed 's/cfs://g'`
    do
      LOC=$(echo "$file"|awk -F: '{print $1}')
      ifile=$(echo "$file"|awk -F: '{print $2}')

      if [[ `echo "$ifile"|grep -ic "rat_env.txt"` -gt 0 ]]; then 
        CONTENT=$(sed "/--cfs:${LOC}:${ifile}--/, /--cfe:${LOC}:${ifile}--/!d" $CACHE_FIL|sed "s/--cfs:${LOC}:${ifile}--//g"|sed "s/--cfe:${LOC}:${ifile}--//g"|grep -v "^\s*$"|grep -vw 'RAT_CACHE_RUN') 
	break
      fi
    done
    RAT_UPLOAD_CONNECT_STRING=$(echo "$CONTENT" |grep "RAT_UPLOAD_CONNECT_STRING")
    if [[ -n $RAT_UPLOAD_CONNECT_STRING || $RAT_UPLOAD_CONNECT_STRING != "" ]]; then  
      export RAT_UPLOAD_CONNECT_STRING="$RAT_UPLOAD_CONNECT_STRING";
    fi

    RATENVVAR=$(echo "$CONTENT"|grep -v "RAT_UPLOAD_CONNECT_STRING"|sed 's/^/export /')
    $RATENVVAR
  fi

  assign_usern

  if [ -n "$RAT_TOPOLOGY_XML" ] ; then fmw_topology=$RAT_TOPOLOGY_XML; fi
  if [ -n "$RAT_CREDCONFIG" ] ; then fmw_credconfig=$RAT_CREDCONFIG; fi
  if [ -z "$RAT_ROOT_USER" ];then root_user="root"; else root_user=$RAT_ROOT_USER; fi
  user_uid=$(id $usern|awk '{print $1}'|sed 's/[^0-9]//g') 
  if [[ $usern = ${root_user} || $user_uid = "0" ]] ; then export RAT_ROOT_RUN=1; fi
  
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    #if [ -z $RAT_TMP_OUTPUT ]; then export RAT_TMP_OUTPUT='/tmp'; else export RAT_TMP_OUTPUT=$RAT_TMP_OUTPUT; fi; 
    if [ -z $RAT_TMP_OUTPUT ]; then export RAT_TMP_OUTPUT='USR_HOMEDIR'; else export RAT_TMP_OUTPUT=$RAT_TMP_OUTPUT; fi; 
    TMP_OUTPUT=$RAT_TMP_OUTPUT/.${program_name}
  fi    

  RPDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
  if [[ -z $RAT_DB_PARALLEL ]] ; 
  then 
    export RAT_DB_PARALLEL=1; 
    SCRIPTPATH=$RPDIR
    security_fix "fix_plugin_or_rtscript_attributes" "$RTEMPDIR/psqlplus" "" "540"
  fi
  
  export RAT_SCRIPT_DEBUG="$RAT_SCRIPT_DEBUG"
  set_pdebug
  if [[ ! -z $RAT_CLIENT_DEBUG ]] 
  then
    RAT_DEBUG_FLG="set -x";
    set -x
    PS4='$(date "+ $LINENO: + ")'
  fi
  
  explicit_expect_debug=0
  if [[ -n $RAT_EXPECT_DEBUG && $RAT_EXPECT_DEBUG = "-d" ]]; then explicit_expect_debug=1; fi

  if [[ ! -z $RAT_SCRIPT_DEBUG ]]
  then
    RAT_EXPECT_DEBUG="-d"
    if [[ -z "$RAT_PASSWORD_CLEANUP" && $explicit_expect_debug -eq "0" ]]
    then
	RAT_EXPECT_DEBUG=""
    fi
    RAT_DEBUG_FLG="set -x";
    set -x
    PS4='$(date "+ $LINENO: + ")'
    if [[ -z $RAT_REMOTE_MODE ]]; then
      timestamp=$(date '+%Y%m%d_%H%M%S')
  
      program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
      debugFileName=$(echo ${program_name}_debug_${timestamp}.log)
      if [[ -n $RAT_OUTPUT ]]; then
  	debugFileName=${RAT_OUTPUT}/${debugFileName}
      fi
      export RAT_REMOTE_MODE=1 
      export RAT_DEBUG_FILENAME_INTERNAL=${debugFileName}
      
      ${RPDIR}/${program_name} $@ 2>&1| tee $debugFileName

      set +x
      echo -e ""
      echo -e ""
      echo -e "Debug output file is $debugFileName";
      echo -e ""
      echo -e ""
  
      exit 0
    fi
  else
    RAT_DEBUG_FLG="";
  fi
  
  program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
  bash_found=$(which bash >/dev/null 2>&1;echo $?)
  SSH_PASS_STATUS=0
  
  #to disable strict bash settings
  set +u
  
  if [ $bash_found -ne 0 ]
  then
    echo -e "\n${RED}${program_name} requires the BASH shell. Please install bash and try again.${NORM}\n"
    exit 1;
  fi
 #display a deprecate message is somebody runs raccheck
  raccheck_deprecate_msg="RACcheck has been deprecated.  ORAchk provides the same functionality.  Please switch to using ORAchk from same directory.\n\nRACcheck will not be available after this (12.1.0.2.3) release.\n\nSee MOS Note \"RACcheck Configuration Audit Tool Statement of Direction - name change to ORAchk (Doc ID 1591208.1)\".\n"
  if [ "$program_name" = "raccheck" ]
  then 
      echo -e "\n${RED}$raccheck_deprecate_msg${NORM}\n"
  fi
  #if [ `uname -s` = "HP-UX" ]
  #then
  #   echo -e "\n${RED}The ${program_name} is not supported on `uname -s` platform yet.${NORM}\n"
  #fi
  
  export LC_ALL=C;
  NO_WRITE_PASS=0;
  ECHO=:
  DEBUG=:
  AUDITTAB=db_audit
  supported_modules="PREUPGR              
  POSTUPGR             
  NONE
  PREUPGRX3-8          
  POSTUPGRX3-2         
  EXALOGIC_DB          
  EXALOGIC_OVMM        
  EXALOGIC_EC          
  EXALOGIC_PC          
  EXALYTICS
  ODA                  
  PREUPGRX2-8          
  PREUPGRDBM           
  POSTUPGRX2-2         
  POSTUPGRX2-8         
  POSTUPGRDBM          
  EXALOGIC_VM          
  X3-8                 
  SIDB                 
  SIDBMAA              
  DBM                  
  MAA                  
  OVM                  
  OVS                  
  X2-2                 
  X2-8                 
  PREUPGRX2-2          
  POSTUPGRX3-8         
  X3-2                 
  EXALOGIC             
  RACCHECK             
  PREUPGRX3-2          
  SUPERCLUSTER         
  PREUPGRSUPERCLUSTER  
  POSTUPGRSUPERCLUSTER
  AVM
  BDAX2-2
  BDAX3-2
  X4-2
  X5-2
  X6-2
  X4-8
  X5-8
  EIGHTHX4-2
  PREUPGREIGHTHX4-2
  POSTUPGREIGHTHX4-2
  PREUPGRSIDB
  POSTUPGRSIDB
  ZFSSA
  OPCZFSSA
  OPCX2-2ADMIN
  OPCX2-2GUEST
  OPCX3-2ADMIN
  OPCX3-2GUEST
  OPCX4-2ADMIN
  OPCX4-2GUEST
  OPCX5-2ADMIN
  OPCX5-2GUEST
  OPCX6-2ADMIN
  OPCX6-2GUEST
  VMX7-2
  OPCX7-2ADMIN
  OPCX7-2GUEST
  VMEIGHTHX7-2
  EIGHTHX7-2
  PREUPGREIGHTHX7-2
  POSTUPGREIGHTHX7-2
  X7-2
  PREUPGRX7-2
  "
  
  # Changes made by jrmullan 03/22/10
  if [ -n "$SUDOCMD" ]
  then
    # A valid sudo command was set up, this is specifically set for the Dell environment where they allow DBA's to
    # use sudo for specific files.  In this case /tmp/root_raccheck.sh
    echo ""
  else
    export SUDOCMD="/usr/bin/sudo"
  fi
  
  if [[ -n "$RAT_LOCALONLY" && $RAT_LOCALONLY -eq 1 ]]; then localonly=1;else localonly=0;fi
  
  trim="sed 's/^ *\(.*\) *$/\1/'"
  trim1="sed 's/^[[:space:]]*//g' | sed 's/[[:space:]]*$//g'"
  ltrim="sed 's/^[[:space:]]*//g'"
  rtrim="sed 's/[[:space:]]*$//g'"
  #AUDITTAB=bp_audit
  #location where raccheck.sh staged
  #CHECKHOME=$HOME/giri/stage
  #if [ ! -f $CHECKHOME/collections.dat ]
  #then
  #if [ `uname -s` = "Linux" ]
  #then
  #  CHECKHOME=$(readlink -f $0)
  #  CHECKHOME=$(dirname $CHECKHOME)
  #  CHECKHOME=$PWD
  #else
  #  CHECKHOME=$(dirname $0)
  #fi
  #$READ -p "CHECKHOME=$CHECKHOME"
  #fi
  #To fix bug reported by Srini to ignore ORACLE_SID when run in offline and create zip file at current working dir.
  
  #CHECKHOME=$PWD
  #PDIR=$PWD
  #V_PWD=$PWD

  V_PWD=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
  if [ $is_windows -eq "1" ] ; then
    V_PWD=$(cygpath -w $PWD | sed 's/\\/\//g' )
  fi

  CHECKHOME=$V_PWD
  PDIR=$V_PWD

  if [ `echo $V_PWD|grep -iwc "suptools/${program_name}"` -ge 1 ]
  then
    if [ -f "$V_PWD/../../bin/orabase" ]; then
      nulstr="";
      result_string="${PDIR/suptools\/${program_name}/$nulstr}"
      PDIR=$result_string;
      export ORACLE_HOME="$PDIR";
      ADR_BASE=`$V_PWD/../../bin/orabase`;
      if [[ -e $ADR_BASE ]]; then
        if [ `uname -s` = "Linux" ]
        then  
          orabaseOwner=$(stat -L -c "%U" $ADR_BASE 2>/dev/null >&1)
          if [ -z "$orabaseOwner" ]; then orabaseOwner=$(ls -ld $ADR_BASE 2>/dev/null >&1|tail -1|awk '{print $3}'); fi
        else  
          orabaseOwner=$(ls -ld $ADR_BASE 2>/dev/null >&1|tail -1|awk '{print $3}')
        fi    
        if [ -n "$orabaseOwner" ]; then orabaseGroup=$(groups "$orabaseOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g'); fi
      fi

      if [ ! -d "$ADR_BASE/${program_name}" ]; then
        mkdir $ADR_BASE/${program_name};
      fi
      if [ -d "$ADR_BASE/${program_name}" ]; then
        if [ -n "$orabaseOwner" ]; then chown $orabaseOwner:$orabaseGroup $ADR_BASE/${program_name} >/dev/null 2>&1; fi
        if [ -z "$RAT_OUTPUT" ]; then
          RAT_OUTPUT="$ADR_BASE/${program_name}";
          #echo "Output directory is $RAT_OUTPUT";
        fi
      fi
    fi
  fi
  
  #CHECKHOME_RELATIVE=$(dirname $0)
  
  if [[ -n "$ORACLE_SID" && $OFFLINE -eq 1 ]]
  #if [ -n "$ORACLE_SID" ]
  then
    WRKDIR=$CHECKHOME/$ORACLE_SID
  else
    WRKDIR=$CHECKHOME
  fi

  #Function to change old environment variable names to new standard environment names
  change_old_env_variables 

  set_rat_output
  
  #following check is to have output directory created at some diffrent local other than where we run raccheck from.
  if [ -z $RAT_OUTPUT ]; then WRKDIR=$WRKDIR; else WRKDIR=$RAT_OUTPUT; fi; 
  
  assign_usern
  
  SCRIPTPATH=$RPDIR
  #SCRIPTPATH=$(dirname $0)
  SCRIPTFIL=$SCRIPTPATH/$program_name
  REFFIL=$SCRIPTPATH/collections.dat
  REFFIL1=$SCRIPTPATH/rules.dat
  XSD_FILE=$SCRIPTPATH/user_defined_checks.xsd
  
  if [[ -n "$RAT_FDS_INTERNAL" ]] ; then # In slave mode, its set
    FDS=$RAT_FDS_INTERNAL
  else
    FDS=`date '+%m%d%y_%H%M%S'`
  fi

  if [[ -n "$RAT_IDMPATH" ]]; then IDMPATH=$RAT_IDMPATH; else IDMPATH=$WRKDIR/idm; fi
  
  SKIP_CRS_VAL=0
  PROBE_XML=${WRKDIR}/${program_name}_em_probe.xml
  INPUTDIR=${WRKDIR}/.input_${FDS}
  SQLFIL=$INPUTDIR/d_check.sql
  UPLOADFIL_VAR=$program_name
  UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_$FDS
  OUTPUTDIR_VAR=$program_name
  OUTPUTDIR=$WRKDIR/${OUTPUTDIR_VAR}_$FDS
  SPOOLFIL=$OUTPUTDIR/d_check.out
  OSOUTFIL=$OUTPUTDIR/o_check
  UPDATEFIL=$OUTPUTDIR/db_update_$FDS.sql
  SQLLOGFIL=$OUTPUTDIR/sql.log
  LOGFIL=$OUTPUTDIR/${program_name}.log
  SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
  RSKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks_runtime.log
  REPFIL=$OUTPUTDIR/${program_name}.rep
  XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
  XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
  JSONREPFIL=$OUTPUTDIR/${program_name}_results.json
  CLOUDLOG=$OUTPUTDIR/${program_name}_opc.json
  JSONSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.json
  XMLRECFIL=$OUTPUTDIR/${program_name}_recommendations.xml
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then  
    #ERRFIL=$TMP_OUTPUT/${program_name}_error.log
    OLD_ERRFIL=$OUTPUTDIR/${program_name}_error.log
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
    PSEUDOERRFIL=$TMP_OUTPUT/${program_name}_error.log
  else
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
  fi
  HOSTLIST=$OUTPUTDIR/o_host_list.out
  MASTERFIL=$OUTPUTDIR/raccheck_env.out
  ORCLENVFIL=$INPUTDIR/set_orcl_env.sh
  SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
  WRNDBPWD=0
  WATCHDOG=$INPUTDIR/watchdog.sh
  WATCHLOG=$OUTPUTDIR/watchdog.log
  EXESQL=$INPUTDIR/exec_raccheck_sqls.sh
  napply_missing_list=$OUTPUTDIR/o_napply_missing_list.out
  upload_raccheck_result_fil_base=$OUTPUTDIR/upload_${program_name}_result_base.sql
  upload_raccheck_result_fil=$OUTPUTDIR/upload_${program_name}_result.sql
  upload_raccheck_patch_result_fil=$OUTPUTDIR/upload_${program_name}_patch_result.sql
  REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
  REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
  SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
  SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
  CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
  SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
  CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
  SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
  PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
  PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
  CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
  CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
  CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
  CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
  CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
  CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
  CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
  CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
  IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
  IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
  IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
  IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
  CELLIBNTFILE=$OUTPUTDIR/cell_ib_count.out
  EL_GVM_FILE=$WRKDIR/el_guest_vms.out
  MANIFEST_XML=$OUTPUTDIR/FMW_Checks.xml
  
  OPC_ZFS_CREDFILE=$WRKDIR/exachk_zfs_credential.txt
  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
  #  PSQL_INFIL=$TMP_OUTPUT/.db_data.out
  #  PSQL_METAFIL=$TMP_OUTPUT/.chk_metadata.out
  #  PSQL_STAT=$TMP_OUTPUT/.chk_stat.out
  #else
    PSQL_INFIL=$INPUTDIR/.db_data.out
    PSQL_METAFIL=$INPUTDIR/.chk_metadata.out
    PSQL_STAT=$INPUTDIR/.chk_stat.out
  #fi
  #PROFILEONLY=$SCRIPTPATH/.cgrep/profile_only.dat
  
  #COLLDIFFFIL=$WRKDIR/collection_diff_candidate.log
  #CHECKSFILE=$WRKDIR/total_checks_summary.out

  if [ -z "$RAT_EXCLUDEFILE" ]
  then 
    if [ -r $WRKDIR/exclude_checks.txt ]
    then 
      EXCLUDEFIL=$WRKDIR/exclude_checks.txt
    else 
      EXCLUDEFIL=$WRKDIR/excluded_check_ids.txt
    fi
  else
    EXCLUDEFIL=$RAT_EXCLUDEFILE 
  fi
  #Setting TMPDIR to /tmp for ODA as requested in 20212859 RAT_KEEP_SUDO_TMP=1 to have root script in /tmp
  #if [[ -e /opt/oracle/oak/install/inittab && -w /tmp ]]; then RAT_TMPDIR=/tmp;RAT_KEEP_SUDO_TMP=1;fi
  if [ -n "$RAT_TMPDIR" ];then TMPDIR=$RAT_TMPDIR;else TMPDIR=$HOME;fi
  if [ -n "$RAT_CELL_TMPDIR" ];then CELLTMPDIR=$RAT_CELL_TMPDIR;else CELLTMPDIR="~";fi
  if [ -n "$RAT_IB_TMPDIR" ];then IBTMPDIR=$RAT_IB_TMPDIR;else IBTMPDIR="~";fi
  
  export TMPDIR

  EXCLUDELOG=$OUTPUTDIR/excluded_check_ids.log
  RTEMPDIR=$TMPDIR/.${program_name}
  CELLRTEMPDIR=$CELLTMPDIR/.${program_name}
  IBRTEMPDIR=$IBTMPDIR/.${program_name}
  RTEMPDIR_D=$TMPDIR/.${program_name}_${usern}_d
  SYSTEM_DESC_FIL=${CELLRTEMPDIR}/cell_system_description.out 
  SerialNumberFil=/var/log/cellos/SerialNumbers
  LOCKFIL=${RTEMPDIR}/${program_name}.pid
  AVMIDFIL=/opt/oracle.SupportTools/onecommand/databasemachine.xml
  SWITCH_TYPE_FIL=$OUTPUTDIR/switch_ip_type_name_mapping_detail.out
  SWITCH_TYPE_FIL_SHORT=switch_ip_type_name_mapping_detail.out
  #TMPSTFILE=$TMPDIR/tmp_status.sh
  TMPSTFILE=$RTEMPDIR/tmp_status.sh
  MAIL_PROGRAM=${RTEMPDIR_D}/mail_script.sh
  ROOTSCRPT="$INPUTDIR/root_${program_name}".sh
  ZFSAKSHSCRIPT="$SCRIPTPATH/.cgrep/exalogic_zfs_checks.aksh" 
  EXTZFSAKSHSCRIPT="$SCRIPTPATH/.cgrep/exalogic_external_zfs_checks.aksh"
  ZFSSAAKSHSCRIPT="$SCRIPTPATH/.cgrep/zfssa_checks.aksh" 
  ZFSGENERATEDAKSHFILE="zfs_generated_checks.aksh"
  EXTZFSGENERATEDAKSHFILE="ext_zfs_generated_checks.aksh"
  delete_lock_file=0
  no_patches=0
  num_sql_queries=0
  CRS12=0

  COLLDIFFFIL=$RTEMPDIR/collection_diff_candidate.log
  CHECKSFILE=$RTEMPDIR/total_checks_summary.out

  
  TMP_EXCLUDEFIL=$RTEMPDIR/np_exclude_checks.txt

  if [ -z "$RAT_SSHELL" ]
  then
    SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet -q"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] ; then
      SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet -v -q"
    fi
    #SSHELL_EL=$(echo ${SSHELL}t)
  else
    SSHELL=$RAT_SSHELL   
  fi
  SSHELL_EL=$(echo ${SSHELL} -t)

  if [ -z "$RAT_SCOPY" ]
  then
    SCOPY="/usr/bin/scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -q"
  else
    SCOPY=$RAT_SCOPY
  fi
  
  if [ -z "$RAT_EXPECT" ]
  then
    U_EXPECT=/usr/bin/expect
  else
    U_EXPECT=$RAT_EXPECT
  fi
  if [[ -n "$RAT_EXPECT_STRACE_DEBUG" && "$RAT_EXPECT_STRACE_DEBUG" = "strace" && `uname -s` = "Linux" ]]; 
  then 
    EXPECT="strace $U_EXPECT"
  else
    EXPECT=$U_EXPECT
  fi
  
  write_report_on_fail=1
  write_switchname_in_report=1
  write_cellname_in_report=1 
  noRootScriptNodeCount=0
  cgrep_platform=$(uname -s)
  if [ $cgrep_platform = "CYGWIN_NT-6.0" ]
  then
    cgrep_platform="CYGWIN_NT-6.3"
  fi
  acchk_out=$WRKDIR/${program_name}_acchk.out
  COLLECT_TIMING=$OUTPUTDIR/${program_name}_collection_timings.out
  ROOT_COLLECT_TIMING=${RTEMPDIR}/o_root_collect_timing.out
  CHECKS_TIMING=$OUTPUTDIR/${program_name}_checks_timings.out
  RACCHECK_TIMING=$OUTPUTDIR/${program_name}_timings.out
  MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
  CHK_TIMINGS=$OUTPUTDIR/${program_name}_epoch_checks_timings.out
  #EXADATA_CELL_COLLECTIONS=$TMPDIR/o_exadata_disk.out 
  EXADATA_CELL_COLLECTIONS=$RTEMPDIR/o_exadata_disk.out 
  CELLDIR="$OUTPUTDIR/.CELLDIR"
  fmt_line_header="---------------------------------------------------------------------------------"
  ROOT_LCKFIL=$RTEMPDIR/root_collection_running.dmp
  SIGNFIL=$TMPDIR/.${program_name}.loc
  DAEMONFIL=${RTEMPDIR_D}/.${program_name}_daemon.loc
  DAEMONDEB=$WRKDIR/${program_name}_daemon_debug.log
  DLOG_CONFFILE=$WRKDIR/.${program_name}_daemon_rotation.dmp
  ABSTPATH=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)/$(basename -- "$0")")
  
  #this was unset because tr command does not work if LANG is set to on Solaris.reported by e-dialog
  unset LANG NLS_LANG
  
  # Defaults
  INITDMP="$WRKDIR/.${program_name}_initsetup.dmp"
  ASREXACHK=asrexacheck #variable to store the name of asreaxchk script
  DBSAT=dbsat.zip
  checkFlashCache=checkFlashCache.sh
  validatePassword=validatePassword.sh
  p_conf_file="$WRKDIR/.${program_name}_conf.dmp"
  cur_p_conf_file="$RTEMPDIR_D/.${program_name}_cur_conf.dmp"
  autorun_list="$WRKDIR/.${program_name}_list.dmp"
  autorun_id=${program_name}.default
  IBHOSTS=/usr/sbin/ibhosts
  ZONENAME=/usr/bin/zonename
  SVCS=/usr/bin/svcs
  EM_PROBE_MODE=0
  EM_XMLD_MODE=0
  em_probe_sudo_mode=1

  is_exadata_dom0_machine=0
  is_ssc_localzone_machine=0
  is_ssc_globalzone_machine=0
  is_ssc_globalzone_dbmachine=0
  is_ssc_machine=0
  is_ext_ssc_machine=0
  is_exalogic_machine=0
  is_zfssa_machine=0
  is_bda_machine=0
  single_instance_run=0
  
  opc_credfile="";

  components=NONE
  print_pass_on_screen=0
  TYP_S=""
  TYP="-a"
  cross_node_checkids_counter=0 #variable to store index couter for cross_node_checkid
  process_cross_node_checks=0
  skip_maa_scorecard=0
  skip_hacheck=0
  REFRESH_CACHE=0
  CREATE_CACHE=0
  is_ssc_zfsnodes_passed=1
  MCLEANUP=0
  usr_dir_cnt=0
  RUNNING_ONCELL=0

  if [[ -z $RAT_OUTPUT_INTERNAL || -z $RAT_CACHE_RUN ]]; then
    if [[ -z $RAT_CACHE_RUN ]]; then export RAT_CACHE_RUN=0; fi

    upgrade_mode=0
    run_profile=0;
    internal_profile_set=0;
    profiles2run=""
    exclude_profile=0;
    profiles2exclude=""
    print_pass_in_report=1
    print_score_in_report=1
    
    read_p2r=0
    p2r_org=""
    
    long_args=0
    
    daemon_mode=0
    daemon_command="";
    daemon_only=0
    setup_inittab=0
    remote_setup_ssh=0
    prepare_init=0
    
    argnew="$*"
    argsaved="$*"
    UPDATE_RUN=0
    run_args=""
    
    setting_conf=0
    options2set=""
    unset_conf=0
    options2unset=""
    daemon_init_mode=0
    daemon_init_mode_sudo=0
    ebs32bit=0
    exalogic_hybrid=0
    phy_nodes=""
    set_db_par_limit=0
    setting_autorun_id=0
    if [[ -z $is_exalogic_foxtrot ]]; then
      is_exalogic_foxtrot=0
      foxtrot_dom0_user="oracleadmin"
    fi

    download_ARU=0
    
    if [[ -z $RAT_LT_VERCHECK && $program_name = "orachk" ]]; then
      lt_ver_check=1;
    elif [[ -n $RAT_LT_VERCHECK && $RAT_LT_VERCHECK = 0 ]]; then
      lt_ver_check=0;
    fi

    prompt_timeout=0
    #if [ `echo "$argsaved" | grep -cw 'd *start'` -gt "0" ] ; then
    #  argsaved=$(echo "$argsaved" | sed 's/-d *start//')
    #  daemon_start="-d start"
    #  set " $daemon_start"
    #fi
    is_fmw_machine=0
    fmw_dbrunonly=0
  fi
}

re_initialize ()
{
  `echo "$EMXML" | grep '<export>' | sed 's/<export>/export /g' | sed 's/<\/export>//g'`
  initialize "$@"
}

unset_root_run ()
{
  unset RAT_ROOT_RUN
  ERRFIL=$OUTPUTDIR/${program_name}_error.log
  PSQL_INFIL=$INPUTDIR/.db_data.out
  PSQL_METAFIL=$INPUTDIR/.chk_metadata.out
  PSQL_STAT=$INPUTDIR/.chk_stat.out
}

update_ld_lib_path () 
{
  REPLACE_HOME=${ORACLE_HOME} 
  if [[ -n "$1" && "$1" = "CRS" ]]; then 
    REPLACE_HOME=${stack_asm_home[$stack_counter]}
    if [[ -n "$crs112" && $crs112 -ge 1 ]]; then REPLACE_HOME=$CRS; fi
  fi

  LD_LIBRARY_PATH=$(grep "^LD_LIBRARY_PATH=" $ORCLENVFIL | cut -d"=" -f2 |sed 's/ //g')
  sed  "/LD_LIBRARY_PATH/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
  
  echo "if [[ \"\${LD_LIBRARY_PATH:-unset}\"  = \"unset\" ]] ; then LD_LIBRARY_PATH=\"\"; fi">>$INPUTDIR/tmp_env_file.out
  if [[ `echo "$LD_LIBRARY_PATH" | grep -c "^${REPLACE_HOME}/lib:"` -eq 0 ]]; then
    echo "LD_LIBRARY_PATH=$REPLACE_HOME/lib:${LD_LIBRARY_PATH}" >>$INPUTDIR/tmp_env_file.out
    echo "export LD_LIBRARY_PATH=$REPLACE_HOME/lib:${LD_LIBRARY_PATH}">>$INPUTDIR/tmp_env_file.out
  else
    echo "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}" >>$INPUTDIR/tmp_env_file.out
    echo "export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}">>$INPUTDIR/tmp_env_file.out
  fi
  
  cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
  rm -f $INPUTDIR/tmp_env_file.out
}

search_latest_version ()
{
  skip_search_latest_version=1
  running_from_home=0
  PROGDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

  if [[ -n "$RAT_ORATAB_LOC" ]]
  then
   ORATAB=$RAT_ORATAB_LOC;
  else
   case `/bin/uname` in
     Linux) 
       ORATAB="/etc/oratab"
     ;;
     SunOS) 
       ORATAB="/var/opt/oracle/oratab" 
     ;;
     HP-UX) 
       ORATAB="/etc/oratab"
     ;;
     AIX)   
       ORATAB="/etc/oratab"
     ;;
     CYGWIN_NT-[0-9].[0-9])
       ORATAB="win_oratab.out"
     ;;
     *)
       /bin/echo "ERROR: Unknown Operating System"
     ;;
   esac
  fi
 
  if [ -f "$ORATAB" ]; then
    for spath in `grep ":/" $ORATAB |grep -v "^#"|cut -d: -f2`
    do
      program_dir=""
      if [ -d ${spath}/suptools ]; then 
	program_dir="${spath}/suptools"
	if [[ `echo "$RAT_SEARCH_LOC" | grep -c ",${program_dir}"` -eq 0 ]]; then RAT_SEARCH_LOC="${RAT_SEARCH_LOC},${program_dir}"; fi
      fi

      if [ -d ${spath}/suptools/${program_name} ]; then 
	program_dir="${spath}/suptools/${program_name}"; 
	if [[ `echo "$RAT_SEARCH_LOC" | grep -c ",${program_dir}"` -eq 0 ]]; then RAT_SEARCH_LOC="${RAT_SEARCH_LOC},${program_dir}"; fi
      fi
    done
    RAT_SEARCH_LOC="${RAT_SEARCH_LOC},${ORACLE_BASE}/DB_TOOLS/${program_name}"
    RAT_SEARCH_LOC=$(echo "$RAT_SEARCH_LOC"| sed 's/,,/,/g' | sed 's/^,//' | sed 's/,$//g') 

    old_ifs=$IFS
    IFS=","    
    for path in `echo "$RAT_SEARCH_LOC"` 
    do
      if [[ "$PROGDIR" = "$path" ]]; then running_from_home=1; break; fi
    done 
    IFS=$old_ifs

    if [[ -n $running_from_home && $running_from_home -eq "1" ]]; then skip_search_latest_version=0; else return; fi

    RAT_SEARCH_LOC=$(echo "$RAT_SEARCH_LOC"| sed "s|$RPDIR||g")
    RAT_SEARCH_LOC=$(echo "$RAT_SEARCH_LOC"| sed 's/,,/,/g' | sed 's/^,//' | sed 's/,$//g') 

    old_ifs=$IFS
    IFS=","    
    for path in `echo "$RAT_SEARCH_LOC"`
    do
      files_present=0
      if [[ -f ${path}/${program_name} && -f ${path}/collections.dat ]]; then
        files_present=1
      elif [ -f ${path}/${program_name}.zip ]; then
        cd ${path}
 	zip -o "$program_name.zip" >/dev/null 2>&1;
        if [[ $? -eq 0 && -f ${path}/${program_name} && -f ${path}/collections.dat ]]; then
	  files_present=1
        fi
        cd $PWD
      fi
      if [[ $files_present -eq 1 ]] ; then
	VERSION=`${path}/${program_name} -v`
        VERSION=$(echo "$VERSION" | grep -i ${program_name}| grep "VERSION" | cut -d':' -f2 | sed 's/ //g')
        versionmap=("${versionmap[@]}" $VERSION:$path);
      fi
    done 
    IFS=$old_ifs 

    LATEST_VERSION=`${RPDIR}/${program_name} -v`
    LATEST_VERSION=$(echo "$LATEST_VERSION" | grep -i ${program_name}| grep "VERSION" | cut -d':' -f2 | sed 's/ //g')
    LATEST_KIT_PATH="${RPDIR}"
    for mapping in ${versionmap[@]}
    do
      KIT_VERSION=${mapping%%:*}
      KIT_PATH=${mapping#*:} 

      t_LATEST_VERSION=$(echo "$LATEST_VERSION" | cut -d"_" -f2)
      t_KIT_VERSION=$(echo "$KIT_VERSION" | cut -d"_" -f2)

      if [[ $t_LATEST_VERSION -lt $t_KIT_VERSION ]]; then 
	LATEST_VERSION=${KIT_VERSION};
	LATEST_KIT_PATH=${KIT_PATH}; 
      fi
    done
    #if [[ "$LATEST_KIT_PATH" = "$PDIR" ]]; then unset LATEST_KIT_PATH; fi
  else
    #LATEST_VERSION=`${RPDIR}/${program_name} -v`
    LATEST_VERSION=`echo -e "\n$program_name  version: ${program_version}_${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[a-z]" "[A-Z]"`
    LATEST_VERSION=$(echo "$LATEST_VERSION" | grep -i ${program_name}| grep "VERSION" | cut -d':' -f2 | sed 's/ //g')
    LATEST_KIT_PATH="${RPDIR}"
  fi
}

write_in_env ()
{
  if [[ ! -d $OUTPUTDIR ]]; then
    WRITE_PENDING=${WRITE_PENDING}"$1 = $2\n"
  else
    if [[ ! -e $MASTERFIL ]]; then
      touch $MASTERFIL;
    fi
  fi

  if [[ -e $MASTERFIL ]]; then
    if [[ -n $WRITE_PENDING ]]; then
      echo -e "$WRITE_PENDING" > $MASTERFIL;
      unset WRITE_PENDING
    fi
    echo "$1 = $2" >> $MASTERFIL;
  fi
}

process_prompt ()
{
  prompt_code=$1
  var_name=$2
  var_value=$3
  if [[ $prompt_timeout -eq 1 ]]; then
    if [[ $prompt_code -ne 0 ]]; then
      eval "$var_name=\"$var_value\""
    fi
  fi
}

exalytics_reads_domains_xml ()
{
  if [[ -e /u01/app/oracle/product/exalytics/config/domains.xml && -z "$RAT_BI_HOMES" ]]
  then 
      exalytics_domains=$(grep -iw "oraclehome=" /u01/app/oracle/product/exalytics/config/domains.xml|gawk 'BEGIN{FS="oracleHome="}{print $2}'|cut -d\" -f2) 
      for exalytics_domain in $exalytics_domains
      do
          domain_short_path=$(dirname $(dirname $exalytics_domain))
          RAT_BI_HOMES=$(echo $RAT_BI_HOMES $domain_short_path) 
      done
  fi
}

check_CURL ()
{
  is_curl_available=1
  if [[ -z $RAT_CURL_CMD ]]; then
    CURL_CMD=$(which curl 2>/dev/null)
    if [[ -z "$CURL_CMD" || `echo $?` -ne 0 || `echo "$CURL_CMD" | grep -ic "no curl"` -gt "0" ]]; then
      unset CURL_CMD
      is_curl_available=0
    fi 
  else
    CURL_CMD=$RAT_CURL_CMD
  fi
}

check_WGET ()
{
  is_wget_available=1
  if [[ -z $RAT_WGET_CMD ]]; then
    WGET_CMD=$(which wget 2>/dev/null)
    if [[ -z "$WGET_CMD" || `echo $?` -ne 0 || `echo "$WGET_CMD" | grep -ic "no wget"` -gt "0" ]]; then
      unset WGET_CMD
      is_wget_available=0	
    fi
  else
    WGET_CMD=$RAT_WGET_CMD
  fi	
}

#Format: download_using_CURL host_url username password cookies_file logfile downloaded_zipname(absolute)
download_using_CURL ()
{
  echo ""
  
  $CURL_CMD --user $2:$3 --cookie-jar $4 --location-trusted "$1" -o $6 --verbose 2>>$5
  if [[ `grep -ic 'HTTP/1.1 401 Unauthorized' $LOGFIL` -gt 0 ]]; then
    curl_return_code=0 
  elif [[ `grep -ic 'SSL certificate problem' $LOGFIL` -gt 0 ]]; then
    curl_return_code=2 
  else 
    curl_return_code=1
  fi
}

#Format: download_using_WGET host_url username password cookies_file sso_auth_file logfile downloaded_zipname(absolute)
download_using_WGET ()
{
  SSO_RESPONSE=`$WGET_CMD --user-agent="Mozilla/5.0" https://$8/Orion/Services/download 2>&1|grep Location`
  # Extract request parameters for SSO
  if [[ `echo "$SSO_RESPONSE"|grep -ic "Location"` -gt "0" ]]; then
    SSO_TOKEN=`echo "$SSO_RESPONSE"| cut -d '=' -f 2|cut -d ' ' -f 1`
    SSO_SERVER=`echo "$SSO_RESPONSE"| cut -d ' ' -f 2|cut -d 'p' -f 1,2`
    SSO_AUTH_URL=sso/auth
    AUTH_DATA="ssousername=$2&password=$3&site2pstoretoken=${SSO_TOKEN}"
    
    # The following command to authenticate uses HTTPS. This will work only if the wget in the environment
    # where this script will be executed was compiled with OpenSSL. Remove the --secure-protocol option
    # if wget was not compiled with OpenSSL
    # Depending on the preference, the other options are --secure-protocol= auto|SSLv2|SSLv3|TLSv1

    # Contact updates site so that we can get SSO Params for logging in
    $WGET_CMD --user-agent="Mozilla/5.0" --secure-protocol=auto --post-data $AUTH_DATA --save-cookies=$4 --keep-session-cookies ${SSO_SERVER}${SSO_AUTH_URL} -O $5 >> $6 2>&1

    if [[ -e $4 ]]; then
      if [[ `grep -ic "$8" "$4"` -gt 0 ]]; then
        echo ""
        $WGET_CMD --user-agent="Mozilla/5.0" --load-cookies=$4 --save-cookies=$4 --keep-session-cookies "$1" -O $7 >>$6 2>&1
        wget_return_code=1
      else
        wget_return_code=0 
      fi
    else
      wget_return_code=2
    fi
  else
    wget_return_code=2
    $WGET_CMD --user-agent="Mozilla/5.0" https://$8/Orion/Services/download 2>>$6
  fi
}

download_from_ARU ()
{
  trap 'cleanup;exit $USER_INTERRUPT' INT TERM EXIT

  LANG=C
  export LANG
  
  DOWNLOAD_STATUS=1

  #Validation1: URL host reachable or not
  URL_HOST="updates.oracle.com"

  platform=`uname -s`
  if [ $is_windows -eq "1" ] ; then
    PING=$(which ping| tr -d '\r')
    if [[ -z $PING ]]; then PING="/bin/ping"; fi
  else
    if [ $platform = "Linux" ]
    then
      PING="/bin/ping"
      PING_W_FLAG="-w 5"
    else
      PING="/usr/sbin/ping"
    fi
  fi
  if [ $platform = "SunOS" ]; then
    $PING -s $URL_HOST 5 5 >/dev/null 2>&1
  elif [ $platform = "HP-UX" ]; then
    $PING $URL_HOST -n 5 -m 5 >/dev/null 2>&1
  elif  [ $is_windows -eq "1" ] ; then
    $PING -n 5 $URL_HOST >/dev/null 2>&1
  else
    $PING -c 1 $PING_W_FLAG $URL_HOST >/dev/null 2>&1
  fi
  if [ $? -ne "0" ]; then
    echo -e "${RED}${URL_HOST} is not reachable. Please establish connectivity to ${URL_HOST} and try again.${NORM}"
    echo ""
    echo ""
    DOWNLOAD_STATUS=0
    return;
  fi
  
  #Validation2: curl/wget utility is available or not
  if [[ -z $RAT_USE_WGET ]]; then
    check_CURL    
    if [[ -n $is_curl_available && $is_curl_available -eq "0" ]]; then
      check_WGET
      if [[ -n $is_wget_available && $is_wget_available -eq "0" ]]; then
        echo -e "${RED}This feature requires curl/wget command. If curl/wget is installed, please set PATH and try again, else please install curl/wget and try again.${NORM}";
        echo ""
        echo ""
        DOWNLOAD_STATUS=0
	download_ARU=0
        return;
      fi
    fi
  else
    check_WGET
    if [[ -n $is_wget_available && $is_wget_available -eq "0" ]]; then
      check_CURL
      if [[ -n $is_curl_available && $is_curl_available -eq "0" ]]; then
        echo -e "${RED}This feature requires curl/wget command. If curl/wget is installed, please set PATH and try again, else please install curl/wget and try again.${NORM}";
        echo ""
        echo ""
        DOWNLOAD_STATUS=0
	download_ARU=0
        return;
      fi
    fi
  fi

 if [[ -z "$RAT_DOWNLOAD_BUGNO" ]]; then

  if [[ ${program_name} = "exachk" ]]; then
     #DOWNLOAD_LINK="https://$URL_HOST/Orion/Services/search?bug=18622611"
     RAT_DOWNLOAD_BUGNO="18622611"
  else
     #DOWNLOAD_LINK="https://$URL_HOST/Orion/Services/search?bug=17302090"
     RAT_DOWNLOAD_BUGNO="17302090"	
  fi
 fi

  DOWNLOAD_LINK="https://$URL_HOST/Orion/Services/search?bug=$RAT_DOWNLOAD_BUGNO"

  #Validation3: Required arugumnets passed or not
  SAVED_ARGS=$*
  while [[ $# > 1 ]]
  do
    ins_args="$1"

    case $ins_args in
        -username)
          SSO_USERNAME="$2"
          shift
        ;;
        -password)
          SSO_PASSWORD="$2"
          shift
        ;;
    esac
  shift
  done
  ARGS=$(echo "$SAVED_ARGS" | sed 's/.*-download//');
  if [[ `echo "$ARGS"|grep -ic "\-username"` -eq 0 ]]; then
    echo ""
    exec 3<&2; exec 2<&0
    $READ -p "Enter your my oracle support username:- " SSO_USERNAME
    read_code=`echo $?`;
    exec 2<&3
    process_prompt "$read_code" "SSO_USERNAME" ""
  fi
  if [[ `echo "$ARGS"|grep -ic "\-password"` -eq 0 ]]; then
    echo ""
    tty -s && stty -echo
    $READ -p "Enter your my oracle support password:- " SSO_PASSWORD
    read_code=`echo $?`;
    tty -s && stty echo
    process_prompt "$read_code" "SSO_PASSWORD" ""
    echo ""
  fi
  SSO_USERNAME=$(echo "$SSO_USERNAME"|sed 's/ //g')
  SSO_PASSWORD=$(echo "$SSO_PASSWORD"|sed 's/ //g')

  #Download....
  OLD_LOGFIL=$LOGFIL
  LOGFIL=$OUTPUTDIR/${program_name}_download_`date +%m-%d-%y-%H:%M`.log
  COOKIE_FILE=$RTEMPDIR/$$.cookies
  SSOFIL=$RTEMPDIR/sso.out
  DOWNLOADED_ZIP=$OUTPUTDIR/${program_name}.zip
  DOWNLOADED_XML=$OUTPUTDIR/download.xml

  if [[ ! -n $SAVED_ARGS ]]; then RAT_UPGRADE_LOC="$OUTPUTDIR,$RAT_UPGRADE_LOC"; fi
  RAT_UPGRADE_LOC=$(echo "$RAT_UPGRADE_LOC"|sed 's/,,/,/g'|sed 's/^,//g')

  if [[ -n $CURL_CMD ]]; then
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    download_using_CURL "$DOWNLOAD_LINK" "$SSO_USERNAME" "$SSO_PASSWORD" "$COOKIE_FILE" "$LOGFIL" "$DOWNLOADED_XML"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    if [[ -n $curl_return_code && $curl_return_code -eq "2" ]]; then
      check_WGET
      if [[ -n $is_wget_available && $is_wget_available -eq "1" ]]; then
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        download_using_WGET "$DOWNLOAD_LINK" "$SSO_USERNAME" "$SSO_PASSWORD" "$COOKIE_FILE" "$SSOFIL" "$LOGFIL" "$DOWNLOADED_XML" "$URL_HOST"
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
    fi
  else
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    download_using_WGET "$DOWNLOAD_LINK" "$SSO_USERNAME" "$SSO_PASSWORD" "$COOKIE_FILE" "$SSOFIL" "$LOGFIL" "$DOWNLOADED_XML" "$URL_HOST"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    if [[ -n $wget_return_code && $wget_return_code -eq "2" ]]; then
      check_CURL
      if [[ -n $is_curl_available && $is_curl_available -eq "1" ]]; then
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        download_using_CURL "$DOWNLOAD_LINK" "$SSO_USERNAME" "$SSO_PASSWORD" "$COOKIE_FILE" "$LOGFIL" "$DOWNLOADED_XML"
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
    fi
  fi

  if [[ -f "$DOWNLOADED_XML" ]]
  then
          DOWNLOAD_URL=`grep -w download_url $DOWNLOADED_XML|sed 's/.*https/https/'|sed 's/\.zip\]\].*/\.zip/'|sed 's/"><!\[CDATA\[//'|grep ${program_name}`;
	  zipname=`echo $DOWNLOAD_URL|sed 's/.*=//'`
	  DOWNLOADED_ZIP=$OUTPUTDIR/$zipname
  #        rm -f $DOWNLOADED_XML
  fi


  echo -e ""
  echo -e "Started downloading...."
  if [[ -n $CURL_CMD ]]; then
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    download_using_CURL "$DOWNLOAD_URL" "$SSO_USERNAME" "$SSO_PASSWORD" "$COOKIE_FILE" "$LOGFIL" "$DOWNLOADED_ZIP" 
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    if [[ -n $curl_return_code && $curl_return_code -eq "2" ]]; then
      check_WGET
      if [[ -n $is_wget_available && $is_wget_available -eq "1" ]]; then
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        download_using_WGET "$DOWNLOAD_URL" "$SSO_USERNAME" "$SSO_PASSWORD" "$COOKIE_FILE" "$SSOFIL" "$LOGFIL" "$DOWNLOADED_ZIP" "$URL_HOST"
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
    fi
  else
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    download_using_WGET "$DOWNLOAD_URL" "$SSO_USERNAME" "$SSO_PASSWORD" "$COOKIE_FILE" "$SSOFIL" "$LOGFIL" "$DOWNLOADED_ZIP" "$URL_HOST"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    if [[ -n $wget_return_code && $wget_return_code -eq "2" ]]; then
      check_CURL
      if [[ -n $is_curl_available && $is_curl_available -eq "1" ]]; then
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        download_using_CURL "$DOWNLOAD_URL" "$SSO_USERNAME" "$SSO_PASSWORD" "$COOKIE_FILE" "$LOGFIL" "$DOWNLOADED_ZIP" 
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      fi
    fi
  fi
 
  #Display/return messages....
  if [[ -n $curl_return_code && $curl_return_code -eq "1" ]] || [[ -n $wget_return_code && $wget_return_code -eq "1" ]]; then  
    DOWNLOAD_STATUS=1
    
    echo ""
    echo -e "${GREEN}${program_name}.zip successfully downloaded to $OUTPUTDIR${NORM}"
    echo ""
  elif [[ -n $curl_return_code && $curl_return_code -eq "0" ]] || [[ -n $wget_return_code && $wget_return_code -eq "0" ]]; then 
    DOWNLOAD_STATUS=0
    rm -f $DOWNLOADED_ZIP >/dev/null 2>&1

    echo ""
    echo -e "${RED}Incorrect username or password.${NORM}"
    echo -e "${RED}Please run ${program_name} -download.${NORM}"
    echo ""

    echo "Incorrect username or password." >>$LOGFIL
  elif [[ -n $curl_return_code && $curl_return_code -eq "2" ]] && [[ -n $wget_return_code && $wget_return_code -eq "2" ]]; then
    DOWNLOAD_STATUS=0
    rm -f $DOWNLOADED_ZIP >/dev/null 2>&1

    echo ""
    echo  -e "${RED}curl: SSL certificate problem and wget: Unexpected problem. Please review $LOGFIL for more detail${NORM}"    
    echo ""
  elif [[ -n $curl_return_code && $curl_return_code -eq "2" ]]; then
    DOWNLOAD_STATUS=0
    rm -f $DOWNLOADED_ZIP >/dev/null 2>&1

    echo ""
    echo  -e "${RED}curl: SSL certificate problem. Please review $LOGFIL for more detail${NORM}"
    echo ""
  elif [[ -n $wget_return_code && $wget_return_code -eq "2" ]]; then
    DOWNLOAD_STATUS=0
    rm -f $DOWNLOADED_ZIP >/dev/null 2>&1

    echo ""
    echo  -e "${RED}wget: Unexpected problem. Please review $LOGFIL for more detail${NORM}"
    echo ""
  fi

  #Cleanup
  rm -f $COOKIE_FILE >/dev/null 2>&1
  rm -f $SSOFIL >/dev/null 2>&1
  LOGFIL=$OLD_LOGFIL
  return
}

set_profile_run ()
{
  profileids2run=""
  profileids2exclude=""
  if [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]]; then  profiles2run="zfs";fi 
  if [[ $run_profile -eq "1" && -z "$profiles2run" ]] || [[ $exclude_profile -eq "1" && -z "$profiles2exclude" ]] ; then
    echo -e "${RED}Profile name is missing${NORM}"
    echo;
    usage_profilesw; 
    exit 1;
  elif [[ $exclude_profile -eq "1" ]]; then
    profile_db_checks=1
    profile_root_checks=1
    profile_cell_checks=1
    profile_zfs_checks=1
    profile_switch_checks=1
    profile_module_checks=1
    profile_cvm_only=1
  
    ex_selected_profiles=0
    old_ifs=$IFS
    IFS=","
    for aprofile in $profiles2exclude
    do
      aprofile_id=$(grep -i "^$aprofile|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
      if [ -z "$aprofile_id" ] ; then
        echo -e "${RED}Selected excludeprofile $aprofile does not exists.. exiting ${NORM}"
        echo;
        IFS="$old_ifs"
        usage_profiles; 
        exit 1;
      elif [ ! -e "$SCRIPTPATH/.cgrep/profiles/$aprofile_id.prf" ] ; then
        echo -e "${RED}Selected excludeprofile $aprofile does not exists.. exiting ${NORM}"
        echo;
        IFS="$old_ifs"
        usage_profiles; 
        exit 1;
      fi
      if [ -n $aprofile_id ]; then 
        if [ -z $profileids2exclude ]; then 
          profileids2exclude=$aprofile_id
        else
          profileids2exclude="$profileids2exclude $aprofile_id"
        fi
      fi
      ex_selected_profiles=$(expr $ex_selected_profiles + 1)
    done
  
    cell_in_exprofile=$(echo "$profiles2exclude" | grep -icw storage_server)
    if [ $cell_in_exprofile -eq 0 ];then cell_in_exprofile=$(echo "$profiles2exclude" | grep -icw storage);fi
    
    switch_in_exprofile=$(echo "$profiles2exclude" | grep -icw switch)
    zfs_in_exprofile=$(echo "$profiles2exclude" | grep -icw zfs)
    ellite_in_exprofile=$(echo "$profiles2exclude" | grep -icw el_lite)
    elextensive_in_exprofile=$(echo "$profiles2exclude" | grep -icw el_extensive)
  
    dba_in_exprofile=$(echo "$profiles2exclude" | grep -icw dba)
    clusterware_in_exprofile=$(echo "$profiles2exclude" | grep -icw clusterware)
    sysadmin_in_exprofile=$(echo "$profiles2exclude" | grep -icw sysadmin)
  
    if [[ $ex_selected_profiles -ge "1" ]] && [[ $sysadmin_in_exprofile -ge "1" ]] 
    then
      profile_cell_checks=0
      profile_zfs_checks=0
      profile_switch_checks=0 
      profile_root_checks=0
    fi
    if [[ $ex_selected_profiles -ge "1" ]] && [[ $dba_in_exprofile -ge "1" ]]
    then
      profile_db_checks=0 
    fi
    if [[ $ex_selected_profiles -ge "1" ]] && [[ $cell_in_exprofile -ge "1" ]]
    then
      profile_cell_checks=0
      profile_zfs_checks=0
    fi
    if [[ $ex_selected_profiles -ge "1" ]] && [[ $switch_in_exprofile -ge "1" ]]
    then
      profile_switch_checks=0 
    fi
    
    IFS=$old_ifs
  elif [[ $run_profile -eq "1" ]] ; then
  
    TYP="-b"
    profile_db_checks=0
    profile_root_checks=0
    profile_cell_checks=0
    profile_zfs_checks=0
    profile_switch_checks=0
    profile_module_checks=0
    selected_profiles=0
  
    old_ifs=$IFS
    IFS=","
    for aprofile in $profiles2run
    do
      if [[ -e $SCRIPTPATH/.cgrep/exalogic_zfs_checks_${aprofile}.aksh ]]; then ZFSAKSHSCRIPT=$SCRIPTPATH/.cgrep/exalogic_zfs_checks_${aprofile}.aksh; fi

	if [ $aprofile = "user_defined_checks" ]
	then
	
	 if [ $usern = "root" ]
	 then
	   echo "User defined checks profile cannot be run as root. Exiting ...";
	   exit 1;
	 fi
	   aprofile_id="RANDOMID";
           profileids2run="$profileids2run $aprofile_id"
	 else
      	aprofile_id=$(grep -i "^$aprofile|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
      if [ -z "$aprofile_id" ] ; then
        echo -e "${RED}Selected profile $aprofile does not exists.. exiting ${NORM}"
        echo;
        IFS="$old_ifs"
        usage_profilesw; 
        exit 1;
      elif [ ! -e "$SCRIPTPATH/.cgrep/profiles/$aprofile_id.prf" ] ; then
        echo -e "${RED}Selected profile $aprofile does not exists.. exiting ${NORM}"
        echo;
        IFS="$old_ifs"
        usage_profilesw; 
        exit 1;
      fi
      profileids2run="$profileids2run $aprofile_id"
      pline=$(grep -i "^$aprofile|" $SCRIPTPATH/.cgrep/profiles.dat);
      db_checks=$(echo $pline | cut -d"|" -f3)
      root_checks=$(echo $pline | cut -d"|" -f4)
      cell_checks=$(echo $pline | cut -d"|" -f5)
      zfs_checks=$(echo $pline | cut -d"|" -f5)
      switch_checks=$(echo $pline | cut -d"|" -f6)
      module_checks=$(echo $pline | cut -d"|" -f7)
  
      ccnt_file=$(wc -l $SCRIPTPATH/.cgrep/profiles/$aprofile_id.prf | awk '{print $1}')
      fi # user_defined_checks

      selected_profiles=$(expr $selected_profiles + 1)
  
      if [ -n "$db_checks" ] ; then
        profile_db_checks=$(expr $profile_db_checks + $db_checks)
      fi
  
      if [ -n "$root_checks" ] ; then
        profile_root_checks=$(expr $profile_root_checks + $root_checks)
      fi
      if [ -n "$cell_checks" ] ; then
        profile_cell_checks=$(expr $profile_cell_checks + $cell_checks)
      fi
      if [ -n "$zfs_checks" ] ; then
        profile_zfs_checks=$(expr $profile_zfs_checks + $zfs_checks)
      fi
      if [ -n "$switch_checks" ] ; then
        profile_switch_checks=$(expr $profile_switch_checks + $switch_checks)
      fi
      if [ -n "$comp_checks" ] ; then
        profile_module_checks=$(expr $profile_comp_checks + $comp_checks)
      fi
  
      if [[ -n "$pline" && `echo "$pline" | grep -ic "EXALOGIC_CVM="` -gt "0" ]]
      then
        cvm_ccnt=$(echo $pline | sed 's/.*EXALOGIC_CVM=//' | sed 's/|.*//'| sed 's/:.*//')
        if [[ -n "$ccnt_file" && -n "$cvm_ccnt" && $cvm_ccnt -eq $ccnt_file ]] ; then
          profile_cvm_only=1
        fi
      fi
    done
    IFS=$old_ifs
  
    #echo "selected_profiles=$selected_profiles profile_cell_checks=$profile_cell_checks";
    cell_in_profile=$(echo "$profiles2run" | grep -icw storage_server)
    debug_in_profile=$(echo "$profiles2run" | grep -icw debug_check)
    #To enable database status checking and pickup database from list in debug proifle
    if [ $debug_in_profile -eq 1 ];then  profile_db_checks=1;fi
    if [ $cell_in_profile -eq 0 ];then cell_in_profile=$(echo "$profiles2run" | grep -icw storage);fi
    switch_in_profile=$(echo "$profiles2run" | grep -icw switch)
  
    zfs_in_profile=$(echo "$profiles2run" | grep -icw zfs)
    ellite_in_profile=$(echo "$profiles2run" | grep -icw el_lite)
    elextensive_in_profile=$(echo "$profiles2run" | grep -icw el_extensive)
  
    # Set RAT_LOCALONLY if we are running on cell or switch
    if [ $selected_profiles -eq "1" ] && [[ $cell_in_profile -gt "0" || $switch_in_profile -gt "0" || $zfs_in_profile -gt "0" ]] ; then
      RAT_LOCALONLY=1
      localonly=1;
    elif  [[ $selected_profiles -eq "2" && $cell_in_profile -gt "0"  &&  $switch_in_profile -gt "0" ]] ; then
      RAT_LOCALONLY=1
      localonly=1;
    elif  [[ $selected_profiles -eq "2" && $switch_in_profile -gt "0" && $zfs_in_profile -gt "0" ]] ; then
      RAT_LOCALONLY=1
      localonly=1;
    fi
    # Ask root password in case cell is not selected and root count=0
    if [[ $switch_in_profile -gt "0"  && $profile_cell_checks -eq "0" && $profile_root_checks -eq "0" ]] ; then
      profile_root_checks=1
    fi
  
    if [ $selected_profiles -eq "1" ] && [ $cell_in_profile -gt "0" ]
    then
      profile_root_checks=0
    fi # ignore cell root
  
    #if [[ $profile_switch_checks -gt "0"  && $profile_cell_checks -eq "0" ]] ; then
    #  profile_cell_checks=1
    #  if [[ $selected_profiles -eq "1"  ]] ; then profile_root_checks=0; fi
    #fi
  fi
}

#This functions fixes all known security issues.
#List
#####=================================================
#=>[Fix]Use ABSOLUTE PATHs
#=>[ ]Create Secure environment- umask
#=>[ ]Filesystem Object Attributes:ownership, execution and permissions
#     Plugin
#     Intermediate Scripts
#     Output files/directories(access by different users)
#=>[ ]File to be used is not the symlink
#=>[ ]Validate any input(command line arguments and prompts) and output(fix as well)
#=>[ ]Validate env variables/RAT variables
#=>[ ]Fix Plugins
#=>[ ]Final Security Patching(Collections ZIP Ownership,Permissions)
#####=================================================
security_fix () 
{
 if [[ -n "$RAT_SKIP_SECURITY_VALIDATION" && $RAT_SKIP_SECURITY_VALIDATION -eq "1" ]]; then return; fi

  case $1 in 
    "is_symlinks")
      FILE_TO_CHECK=$2
      if [[ -z $FILE_TO_CHECK || ! -e $FILE_TO_CHECK ]]; then return; fi
      if [[ -h "$FILE_TO_CHECK" ]]; then
        echo -e "${RED}File [${FILE_TO_CHECK}] is a sym link and not a regular file. Please remove the symlink shown and re-run ${program_name}${NORM}"
	exit 2;
      fi
      unset FILE_TO_CHECK
    ;;
    "fix_plugin_or_rtscript_attributes")
      file_attr_fix_fail=0
      FILE_TO_CHECK=$2
      OWNERSHIP=$3
      PERMISSION=$4
      if [[ -z $FILE_TO_CHECK || ! -e $FILE_TO_CHECK ]]; then return; fi
      if [[ -z $PERMISSION ]]; then PERMISSION="540"; fi

      chmod $PERMISSION $FILE_TO_CHECK; if [[ $? -ne 0 ]]; then file_attr_fix_fail=1; fi
      if [[ -n $OWNERSHIP ]]; then chown $OWNERSHIP $FILE_TO_CHECK;  if [[ $? -ne 0 ]]; then file_attr_fix_fail=1; fi; fi

      if [[ -n $file_attr_fix_fail && $file_attr_fix_fail -eq 1 ]]; then 
	echo -e "${RED}Plugin [${FILE_TO_CHECK}] attributes(ownership/permissions) cannot be changed. Please remove the file shown and re-run ${program_name}${NORM}"
	exit 2; 
      fi
      unset FILE_TO_CHECK OWNERSHIP PERMISSION
    ;;
    "fix_file_attributes")
      file_attr_fix_fail=0
      FILE_TO_CHECK=$2
      OWNERSHIP=$3
      PERMISSION=$4
      if [[ -z $FILE_TO_CHECK || ! -e $FILE_TO_CHECK ]]; then return; fi
      if [[ -z $PERMISSION ]]; then PERMISSION="640"; fi

      chmod $PERMISSION $FILE_TO_CHECK; if [[ $? -ne 0 ]]; then file_attr_fix_fail=1; fi
      if [[ -n $OWNERSHIP ]]; then chown $OWNERSHIP $FILE_TO_CHECK;  if [[ $? -ne 0 ]]; then file_attr_fix_fail=1; fi; fi

      if [[ -n $file_attr_fix_fail && $file_attr_fix_fail -eq 1 ]]; then 
	echo -e "${RED}File [${FILE_TO_CHECK}] attributes(ownership/permissions) cannot be changed. Please remove the file shown and re-run ${program_name}${NORM}"
	exit 2; 
      fi
      unset FILE_TO_CHECK OWNERSHIP PERMISSION
    ;;
    "is_env_secure")
      sDATA=""
      is_secure=1
      for setvar in `env | grep "^RAT_"`
      do
	sfail=0
        e_key=$(echo $setvar| cut -d"=" -f1)
        e_val=$(echo $setvar| sed 's/[^=]*=//')

	if [[ $e_key = "" ]]; then
	  if [[ -n $sfail && $sfail -eq 1 ]]; then
	    sDATA=${sDATA}""
	    is_secure=0
	  fi
        elif [[ $e_key = "" ]]; then
	  if [[ -n $sfail && $sfail -eq 1 ]]; then
	    sDATA=${sDATA}""
	    is_secure=0
	  fi 
        fi        
	unset sfail
      done
      if [[ -n $is_secure && $is_secure -eq 0 ]]; then
	echo -e "${RED}Below RAT variable(s) value(s) posses potential security risk. Please unset the shown variable or set it to secure value and re-run ${program_name}${NORM}"
        echo -e "${RED}$sDATA${NORM}"
	exit 2;
      fi
    ;;
    "is_cmdl_args_secure")
    ;;
    "fix_intermediate_scripts")
      SCRIPT_TO_CHECK=$2
      OWNERSHIP=$3
      PERMISSION=$4
      CHECK_STAGE=$5
      if [[ -z $SCRIPT_TO_CHECK || ! -e $SCRIPT_TO_CHECK ]]; then return; fi
      if [[ $CHECK_STAGE = 'PRE' ]]; then
        if [[ -e $SCRIPT_TO_CHECK ]]; then
	  rm -f $SCRIPT_TO_CHECK;
	  if [[ $? -ne "0" ]]; then
            echo -e "${RED}Stale Intermediate script [${SCRIPT_TO_CHECK}] cannot be deleted. Please remove the file shown and re-run ${program_name}${NORM}"
            exit 2; 
	  fi
	fi
      else
        if [[ -z $PERMISSION ]]; then PERMISSION="540"; fi

        chmod $PERMISSION $SCRIPT_TO_CHECK; if [[ $? -ne 0 ]]; then script_attr_fix_fail=1; fi
        if [[ -n $OWNERSHIP ]]; then chown $OWNERSHIP $SCRIPT_TO_CHECK;  if [[ $? -ne 0 ]]; then script_attr_fix_fail=1; fi; fi

        if [[ -n $script_attr_fix_fail && $script_attr_fix_fail -eq 1 ]]; then 
          echo -e "${RED}Plugin [${SCRIPT_TO_CHECK}] attributes(ownership/permissions) cannot be changed. Please remove the file shown and re-run ${program_name}${NORM}"
          exit 2; 
        fi
      fi
      unset SCRIPT_TO_CHECK OWNERSHIP PERMISSION CHECK_STAGE
    ;;
    "is_userinput_secure")
    ;;
    "check_and_fix_script_existence")
      script_remove_fail=0
      SCRIPT_TO_CHECK=$2
      if [[ -e $SCRIPT_TO_CHECK ]]; then
        rm -f $SCRIPT_TO_CHECK;  if [[ $? -ne 0 ]]; then script_remove_fail=1; fi;
	if [[ -n $script_remove_fail && $script_remove_fail -eq 1 ]]; then
          echo -e "${RED}[${SCRIPT_TO_CHECK}] cannot be removed. Please remove the file shown and re-run ${program_name}${NORM}"
	  exit 2;
	fi
      fi
    ;;
    "verify_remcode")
      SCRIPT_TO_CHECK=$2
      REM_RCODE=$3
      if [[ $REM_RCODE -ne "0" ]]; then
          echo -e "${RED}[${SCRIPT_TO_CHECK}] cannot be removed. Please remove the file shown and re-run ${program_name}${NORM}"
	  exit 2;
      fi
    ;;
    "verify_attrmodcode")
      SCRIPT_TO_CHECK=$2
      REM_RCODE=$3
      if [[ $REM_RCODE -ne "0" ]]; then
          echo -e "${RED}[${SCRIPT_TO_CHECK}] attributes cannot be changed. Please remove the file shown and re-run ${program_name}${NORM}"
	  exit 2;
      fi
    ;;
  esac
}

create_program_cache ()
{
  if [[ -n $REFRESH_CACHE && $REFRESH_CACHE = 1 ]] || [[ -n $CREATE_CACHE && $CREATE_CACHE = 1 ]]; then
    CACHE_DIR=$WRKDIR
    if [[ -n $RAT_CACHE_LOC ]]; then CACHE_DIR=$RAT_CACHE_LOC; fi

    CACHE_FIL=$CACHE_DIR/.${program_name}_cache.cfg

    echo "--${program_name}.cache--"		>  $CACHE_FIL

    cache_files="O:$OUTPUTDIR/log/rat_env.txt O:$OUTPUTDIR/outfiles/o_host_list.out O:$OUTPUTDIR/outfiles/o_ibswitches.out O:$OUTPUTDIR/outfiles/o_ibswitches_full.out O:$OUTPUTDIR/outfiles/switch_ip_type_name_mapping_detail.out C:$CELLDIR/cellip.ora C:$CELLDIR/zfsip.ora O:$OUTPUTDIR/outfiles/o_storage.out O:$OUTPUTDIR/outfiles/o_spineswitches.out O:$OUTPUTDIR/outfiles/check_env.out O:$OUTPUTDIR/outfiles/mb_db_tmp.out O:$OUTPUTDIR/outfiles/mb_db_homes_distinct.out O:$OUTPUTDIR/outfiles/mb_db_versions_distinct.out O:$OUTPUTDIR/outfiles/mb_db_homes_versions_distinct_selected.out O:$OUTPUTDIR/outfiles/mb_db_homes_versions_distinct.out O:$OUTPUTDIR/ogg_homes_version.out"

    for file in `echo "$cache_files"`
    do
      LOC='O'
      LOC=$(echo "$file"|awk -F: '{print $1}');      
 
      ifile=$(echo "$file"|sed "s/${LOC}://g")

      if [ -e $ifile ]; then 
        fbasename=$(basename $ifile);
        echo "--cfs:${LOC}:${fbasename}--"	>> $CACHE_FIL
        cat "$ifile"				>> $CACHE_FIL
        echo "--cfe:${LOC}:${fbasename}--"	>> $CACHE_FIL
      fi
    done

    for file in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      LOC='C'
      fbasename=$(basename $file);
      echo "--cfs:${LOC}:${fbasename}--"      >> $CACHE_FIL
      cat "$file"                             >> $CACHE_FIL
      echo "--cfe:${LOC}:${fbasename}--"      >> $CACHE_FIL
    done
  fi
}

populate_guest_vm ()
{
  is_exalogic_guest_vm=0
  if [[ ! -z "$RAT_EL_GVM" ]]
  then
    rm -rf $EL_GVM_FILE >/dev/null 2>&1
    for el_guest_file in `echo $RAT_EL_GVM|sed 's/,/ /g'`
    do 	
      if [ -e "$el_guest_file" ]
      then
        cat $el_guest_file >> $EL_GVM_FILE
      fi
    done
    
    if [ -e "$EL_GVM_FILE" ]
    then
      is_exalogic_guest_vm=1
      el_guest_counter=0
      for el_vm_guest in `cat $EL_GVM_FILE|sort|uniq`
      do
      	el_guest_vms[$el_guest_counter]=$el_vm_guest
      	el_guest_counter=$(expr $el_guest_counter + 1)
      done
    else
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="Specified exalogic VM guest file(s) does not exist. Please provide correct filenames and then re-run ${program_name}"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "\n${RED}Specified exalogic VM guest file(s) does not exist. Please provide correct filenames and then re-run ${program_name}.${NORM}\n";
      echo -e "${RED}${program_name} is exiting...  ${NORM}\n";
      exit 1;	
    fi

    if [ $el_guest_counter -eq 0 ]
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="Specified exalogic VM guest file(s) are empty"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "\n${RED}Specified exalogic VM guest file(s) are empty.${NORM}\n";
      echo -e "${RED}${program_name} is exiting...  ${NORM}\n";
      exit 1;	
    fi 
  fi
}

call_func_check_space ()
{
  #Moving space check functionlality before copying check_tmp_status.sh to remote node
  func_check_space $1 $2
  #$READ -p "space_status=$space_status and space_fail_msg=$space_fail_msg space_pass_msg=$space_pass_msg"
  if [ $space_status -eq 1 ]
  then 
    if [[ -n "$daemon_init_mode" && $daemon_init_mode -eq 1 ]] || [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]]
    then
      echo -e "$space_fail_msg \n"
      echo -e "Please make at least 10MB space available at above location and re-run"
      echo -e ${RED}"${program_name} is exiting.."${NORM}
      exit 1
    fi
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="Please make at least 10MB space available at above location and re-run"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      exit 1
    fi

    while [ $space_status -eq 1 ]
    do
      echo -e "$space_fail_msg"
      exec 3<&2; exec 2<&0
      $READ -p "Please make at least 10MB space available at above location and retry to continue.[y/n][y]?" spaceYesNo
      read_code=`echo $?`;
      exec 2<&3
      process_prompt "$read_code" "spaceYesNo" "n"
      case $spaceYesNo in
          yes|Yes|Y|y|YES)
            func_check_space $1
          ;;
          no|No|N|NO|n)
            exit -1
          ;;
          *)
            func_check_space $1
         ;;
     esac
    done
  else
    if [[ -e $LOGFIL ]]; then echo $space_pass_msg >> $LOGFIL; fi
  fi
}


check_another_instance ()
{
  if [[ -n "$1" ]]; then echo "$1" > $HOSTLIST; fi

  for hname in `cat $HOSTLIST`
  do
    node_ssh_user=$usern
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
    then
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
        node_ssh_user="${root_user}"
      else
	node_ssh_user="${foxtrot_dom0_user}"
      fi
    fi

    if [ $hname = $localnode ]
    then
      if [ -e $LOCKFIL ]
      then
        lockfile_pid_status=$(ps -ef |grep $(cat $LOCKFIL)|grep -v grep|wc -l) 
        if [[ -n "$lockfile_pid_status" && $lockfile_pid_status -gt 0 ]]
        then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="Another instance of $program_name is running on $hname. Please allow it finish before initiating probe mode."
	    update_probe_xml "ERROR" "ONEOFF_RUN" "$EMSG"
	  fi
          echo -e "${RED}Another instance of $program_name is running on $hname. please allow it finish before you run it.\n${NORM}"
          delete_lock_file=1
          exit 1
        else
          echo $$>$LOCKFIL
        fi
      fi
    else
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$hname "echo \"\$HOME\""); fi 
	l_RTEMPDIR=${l_TMPDIR}/.${program_name}
	l_LOCKFIL=${l_RTEMPDIR}/${program_name}.pid
      else
	l_TMPDIR=$TMPDIR
	l_RTEMPDIR=$RTEMPDIR
  	l_LOCKFIL=$LOCKFIL
      fi

      remote_lock_file=$($SSHELL ${node_ssh_user}@$hname "$bash_scr -c \"if [ -e $l_LOCKFIL ]; then cat $l_LOCKFIL|wc -l;fi\"")
      remote_lockfile_pid=$($SSHELL ${node_ssh_user}@$hname "$bash_scr -c \"if [ -e $l_LOCKFIL ]; then cat $l_LOCKFIL|head -1;fi\"")
      remote_lockfile_pid_status=$($SSHELL ${node_ssh_user}@$hname "$bash_scr -c \"if [ -e $l_LOCKFIL ]; then ps -ef |grep $remote_lockfile_pid|grep -v grep|wc -l;fi\"")
      if [[ -n "$remote_lock_file" && $remote_lock_file -eq 1 && -n "$remote_lockfile_pid_status" && $remote_lockfile_pid_status -gt 0 ]]
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  EMSG="Another instance of $program_name is running on $hname. Please allow it finish before initiating probe mode."
	  update_probe_xml "ERROR" "ONEOFF_RUN" "$EMSG"
	fi
        echo -e "${RED}Another instance of $program_name is running on $hname.please allow it finish on $hname before you run it on $localnode.\n${NORM}"
        delete_lock_file=1
        exit 1
      elif [[ -n "$remote_lock_file" && $remote_lock_file -eq 1 ]] 
      then
        $SSHELL ${node_ssh_user}@$hname "touch $l_LOCKFIL"
        if [ `echo $?` -ne 0 ]; then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="Temporary files/directories of previous run exist on $hname at $l_RTEMPDIR. Delete them and re-run ${program_name}."
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
          echo -e ${RED}"\nTemporary files/directories of previous run exist on $hname at $l_RTEMPDIR. Delete them and re-run ${program_name}"${NORM}.
          echo -e "\n${program_name} is exiting..\n"
          exit 0
        else
          $SSHELL ${node_ssh_user}@$hname "echo $$>$l_LOCKFIL"
        fi
      fi
    fi
  done
}

print_idmsystem_type ()
{
  host_to_check=$1

  is_oud_host=0;
  unset itype
  unset idmsystem_type
  for rhost in ""${OUD[@]}""
  do
    if [[ `echo "$rhost"|grep -icw "$host_to_check"` -gt "0" ]]; then
      is_oud_host=1
      break;
    fi
  done
  if [[ $is_oud_host -eq "1" && `echo "$itype"|grep -icw "Oracle Unified Directory"` -eq "0" ]]; then
    itype="Oracle Unified Directory,${itype}"
  fi
  if [[ `echo "$OAM_Host"|grep -icw "$host_to_check"` -gt "0" && `echo "$itype"|grep -icw "Oracle Access Manager"` -eq "0" ]]; then
    itype="Oracle Access Manager,${itype}"
  fi
  if [[ `echo "$OIM_Host"|grep -icw "$host_to_check"` -gt "0" && `echo "$itype"|grep -icw "Oracle Identity Manager"` -eq "0" ]]; then
    itype="Oracle Identity Manager,${itype}"
  fi
  if [[ `echo "$single_node_idm"|grep -icw "Y"` -gt "0" && `echo "$itype" | grep -icw "Single Node"` -eq "0" ]]; then
    itype="Single Node"
  fi

  if [[ -e $RTEMPDIR/topology_kv.out ]]; then
    fmw_machine_id=$(grep topology.machines.machine.id= $RTEMPDIR/topology_kv.out |grep "\.name = $host_to_check" | cut -d\" -f2)
    if [[ -n "$fmw_machine_id" ]]; then
      for hid in `grep $fmw_machine_id $RTEMPDIR/topology_kv.out| grep "\.homeId = " | sed 's/.*\.homeId = //'`
      do
        hid_typ=$(grep "\.homes.home.id=.$hid.\.type = " $RTEMPDIR/topology_kv.out | sed 's/.*\.type = //' | sed 's/^\s*//g' | sed 's/\s*$//g')
    	if [[ -n "$hid_typ" && `echo "$hid_typ"|grep -icw "OUD"` -gt "0" && `echo "$itype"|grep -icw "Oracle Unified Directory"` -eq "0" ]]; then
    	  itype="Oracle Unified Directory,${itype}"
    	fi
    	if [[ -n "$hid_typ" && `echo "$hid_typ"|grep -icw "OAM"` -gt "0" && `echo "$itype"|grep -icw "Oracle Access Manager"` -eq "0" ]]; then
    	  itype="Oracle Access Manager,${itype}"
    	fi
    	if [[ -n "$hid_typ" && `echo "$hid_typ"|grep -icw "OIM"` -gt "0" && `echo "$itype" | grep -icw "Oracle Identity Manager"` -eq "0" ]]; then
    	  itype="Oracle Identity Manager,${itype}"
    	fi	
      done
    fi
  fi

  if [[ -n "$itype" ]]; then
    itype=$(echo "$itype"|sed 's/^,//g'|sed 's/,$//g')
    idmsystem_type="(${itype})"
  fi
}

fmw_preinput ()
{
  single_node_idm='N'
  idm_param_matches=0

  OLD_IFS=$IFS
  IFS=";"
  for idmparam in `echo "$idm_config"`
  do
    if [[ `echo "$idmparam"|grep -icw "OUD_HOST"` -gt 0 ]]; then
      no_ouds=0
      OUD_LIST=$(echo "$idmparam"|awk -F'=' '{print $2}'|sed 's/ //g')  
      oud_cnt=0
      iOLD_IFS=$IFS
      IFS=","
      for rhost in `echo "$OUD_LIST"`
      do
        if [[ ! -z $rhost ]]; then 
	  rhost=$(echo "$rhost"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r')
          OUD[$oud_cnt]=$rhost
 	  echo "$rhost" >> $IHOSTLIST
          oud_cnt=$(expr $oud_cnt + 1)
        fi
      done
      no_ouds=$oud_cnt
      IFS=$iOLD_IFS
      idm_param_matches=1
    elif [[ `echo "$idmparam"|grep -icw "OIM_HOST"` -gt 0 ]]; then
      no_oims=0
      OIM_LIST=$(echo "$idmparam"|awk -F'=' '{print $2}'|sed 's/ //g')  
      oim_cnt=0
      iOLD_IFS=$IFS
      IFS=","
      for rhost in `echo "$OIM_LIST"`
      do
        if [[ ! -z $rhost ]]; then 
	  rhost=$(echo "$rhost"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r')
          OIM[$oim_cnt]=$rhost
 	  echo "$rhost" >> $IHOSTLIST
          oim_cnt=$(expr $oim_cnt + 1)
        fi
      done
      no_oims=$oim_cnt
      IFS=$iOLD_IFS
      idm_param_matches=1
    elif [[ `echo "$idmparam"|grep -icw "OAM_HOST"` -gt 0 ]]; then
      no_oams=0
      OAM_LIST=$(echo "$idmparam"|awk -F'=' '{print $2}'|sed 's/ //g')  
      oam_cnt=0
      iOLD_IFS=$IFS
      IFS=","
      for rhost in `echo "$OAM_LIST"`
      do
        if [[ ! -z $rhost ]]; then 
	  rhost=$(echo "$rhost"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r')
          OAM[$oam_cnt]=$rhost
 	  echo "$rhost" >> $IHOSTLIST
          oam_cnt=$(expr $oam_cnt + 1)
        fi
      done
      no_oams=$oam_cnt
      IFS=$iOLD_IFS
      idm_param_matches=1
    #elif [[ `echo "$idmparam"|grep -icw "OHS_HOST"` -gt 0 ]]; then
    #  no_ohs=0
    #  OHS_LIST=$(echo "$idmparam"|awk -F'=' '{print $2}'|sed 's/ //g')  
    #  ohs_cnt=0
    #  iOLD_IFS=$IFS
    #  IFS=","
    #  for rhost in `echo "$OHS_LIST"`
    #  do
    #    if [[ ! -z $rhost ]]; then 
    #      rhost=$(echo "$rhost"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r')
    #      OHS[$ohs_cnt]=$rhost
    #      echo "$rhost" >> $IHOSTLIST
    #      ohs_cnt=$(expr $oam_cnt + 1)
    #    fi
    #  done
    #  no_ohs=$ohs_cnt
    #  IFS=$iOLD_IFS
    #  idm_param_matches=1
    elif [[ `echo "$idmparam"|grep -icw "SINGLENODE"` -gt 0 ]]; then
      single_node_idm='Y'
      idm_param_matches=1
    fi
  done
  IFS=$OLD_IFS

  if [[ -n "$idm_param_matches" && $idm_param_matches -eq "0" ]]; then
    echo
    echo -e "${RED}Please specify idm config correctly${NORM}"
    usage_IDM;
    echo
    exit 1
  fi
}

prompt_fmw_preinput ()
{
  if [[ -n "$idm_config" ]]; then
    fmw_preinput
  else
    if [[ $EM_PROBE_MODE -eq 1 ]]; then
      cat >> ${PROBE_XML}.tmp <<EOF
  <group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
    <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
      <text nls_id="orhc_exadata_n94_nlsid">
        Are you planning for Single Node Identity Management System(IDM)
      </text>
      <options>
        <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
          <text nls_id="orhc_exadata_n1_nlsid">True</text>
        </option>
        <option id="q${PROBE_QUES_CNT}o2">
          <text nls_id="orhc_exadata_n2_nlsid">False</text>
        </option>
      </options>
    </question>
    <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n95_nlsid">
      Enter all Oracle Unified Directory(OUD) Hosts delimited by comma
    </text>
    </question>
    <question id="q${PROBE_QUES_CNT}o2q2" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n96_nlsid">
      Enter all host names which are part of Oracle Identity Manager(OIM) Domain delimited by comma
    </text>
    </question>
    <question id="q${PROBE_QUES_CNT}o2q3" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n97_nlsid">
      Enter all host names which are part of Oracle Access Manager(OAM) Domain delimited by comma
    </text>
    </question>
  </group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
    elif [[ $EM_XMLD_MODE -eq 1 ]]; then
      read_probe_xml "Are you planning for Single Node Identity Management System(IDM)"
      single_node_idm=$xml_rvalue
      
      if [[ -z $single_node_idm ]]; then single_node_idm='N'; fi
      
      if [[ `echo "$single_node_idm"|sed 's/ //g'|grep -icw 'N'` -gt "0" ]]; then
        read_probe_xml "Enter all Oracle Unified Directory(OUD) Hosts delimited by comma"
	OUD_Host=$xml_rvalue
        read_probe_xml "Enter all host names which are part of Oracle Identity Manager(OIM) Domain delimited by comma"
	OIM_Host=$xml_rvalue
        read_probe_xml "Enter all host names which are part of Oracle Access Manager(OAM) Domain delimited by comma"
	OAM_Host=$xml_rvalue
        #read_probe_xml "Enter Oracle HTTP Server(OHS) Hosts"
	#OHS_Host=$xml_rvalue

        #idm_config="OUD_HOST=${OUD_Host};OIM_HOST=${OIM_Host};OAM_HOST=${OAM_Host};OHS_HOST=${OHS_Host}"
        idm_config="OUD_HOST=${OUD_Host};OIM_HOST=${OIM_Host};OAM_HOST=${OAM_Host}"
      else
	idm_config="SINGLENODE"
      fi            

      fmw_preinput
    else
      echo ""

      single_node_idm='N'
      exec 3<&2; exec 2<&0
      $READ -p "Are you planning for Single Node Identity Management System(IDM) [Y|N] [N] :" single_node_idm
      read_code=`echo $?`;
      exec 2<&3
      write_in_env "IDM_TYPE_OPTION" "$single_node_idm"
      process_prompt "$read_code" "single_node_idm" "N"
      echo ""

      if [[ -z $single_node_idm ]]; then single_node_idm='N'; fi

      if [[ `echo "$single_node_idm"|sed 's/ //g'|grep -icw 'N'` -gt "0" ]]; then
        exec 3<&2; exec 2<&0
        $READ -p "Enter all Oracle Unified Directory(OUD) Hosts delimited by comma (Press ENTER to skip) :" OUD_Host
        read_code=`echo $?`;
        exec 2<&3
        write_in_env "OUD_HOST" "$OUD_Host"
        process_prompt "$read_code" "OUD_host" ""
        echo ""

        exec 3<&2; exec 2<&0
        $READ -p "Enter all host names which are part of Oracle Identity Manager(OIM) Domain delimited by comma (Press ENTER to skip) :" OIM_Host
        read_code=`echo $?`;
        exec 2<&3
        write_in_env "OIM_HOST" "$OIM_Host"
        process_prompt "$read_code" "OIM_Host" ""
        echo ""
          
        exec 3<&2; exec 2<&0
        $READ -p "Enter all host names which are part of Oracle Access Manager(OAM) Domain delimited by comma (Press ENTER to skip) :" OAM_Host
        read_code=`echo $?`;
        exec 2<&3
        write_in_env "OAM_HOST" "$OAM_Host"
        process_prompt "$read_code" "OAM_Host" ""
        echo ""

        #exec 3<&2; exec 2<&0
        #$READ -p "Enter Oracle HTTP Server(OHS) Hosts(Press ENTER to skip) :" OHS_Host
        #read_code=`echo $?`;
        #exec 2<&3
        #write_in_env "OHM_HOST" "$OHS_Host"
        #process_prompt "$read_code" "OHS_Host" ""
        #echo ""

        #idm_config="OUD_HOST=${OUD_Host};OIM_HOST=${OIM_Host};OAM_HOST=${OAM_Host};OHS_HOST=${OHS_Host}"
        idm_config="OUD_HOST=${OUD_Host};OIM_HOST=${OIM_Host};OAM_HOST=${OAM_Host}"
      else
        idm_config="SINGLENODE"        
      fi

      fmw_preinput
    fi
  fi
}

prompt_fmw_input ()
{
  set_wallet=0
  host_info_available=0
  if [[ -e $IDMPATH/discovery/bin/credconfig ]]; then 
    set_java_home "$localnode"
  
    export DISCOVERY_HOME=$IDMPATH/discovery

    curr_dir=$(pwd);
    cd $IDMPATH/discovery/bin/credconfig

    #security_fix "fix_plugin_or_rtscript_attributes" "$IDMPATH/discovery/bin/credconfig/csf-util.sh" "" "540"

    OIM_Host=$($IDMPATH/discovery/bin/credconfig/csf-util.sh list | grep -iw 'OIM_HOST -' | awk -F'-' '{print $2}' | sed 's/ //g')  
    OAM_Host=$($IDMPATH/discovery/bin/credconfig/csf-util.sh list | grep -iw 'OAM_HOST -' | awk -F'-' '{print $2}' | sed 's/ //g')  
    single_node_idm=$($IDMPATH/discovery/bin/credconfig/csf-util.sh list | grep -iw 'SINGLE_NODE_IDM -' | awk -F'-' '{print $2}' | sed 's/ //g')  

    oud_cnt=0
    for rhost in `$IDMPATH/discovery/bin/credconfig/csf-util.sh list | grep -i "OUD_HOST.*\s*-" | awk -F'-' '{print $2}'|sed 's/ //g'`
    do
      OUD[$oud_cnt]=$rhost
      oud_cnt=$(expr $oud_cnt + 1)
      host_info_available=1
    done
    unset oud_cnt
    
    if [[ -n "$OIM_Host" ]]; then host_info_available=1; fi
    if [[ -n "$OAM_Host" ]]; then host_info_available=1; fi
    if [[ -n "$single_node_idm" ]]; then host_info_available=1; fi
    
    cd "$curr_dir"
  fi

  if [[ -n "$idm_config" ]]; then
    idm_param_matches=0
    no_oud_replicas=0

    OLD_IFS=$IFS
    IFS=";"
    for idmparam in `echo "$idm_config"`
    do
      if [[ `echo "$idmparam"|grep -icw "OUD_HOST"` -gt 0 ]]; then
        REPLICA_list=$(echo "$idmparam"|awk -F'=' '{print $2}'|sed 's/ //g')  
	oud_cnt=0
	iOLD_IFS=$IFS
	IFS=","
	for rhost in `echo "$REPLICA_list"`
	do
	  OUD[$oud_cnt]=$rhost
	  if [[ ! -z $rhost ]]; then echo "$rhost"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
	  oud_cnt=$(expr $oud_cnt + 1)
	done
        no_oud_replicas=$oud_cnt
	IFS=$iOLD_IFS
	idm_param_matches=1
      elif [[ `echo "$idmparam"|grep -icw "OIM_HOST"` -gt 0 ]]; then
	OIM_Host=$(echo "$idmparam"|awk -F'=' '{print $2}'|sed 's/ //g')
	if [[ ! -z $OIM_Host ]]; then echo "$OIM_Host"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
	idm_param_matches=1
      elif [[ `echo "$idmparam"|grep -icw "OAM_HOST"` -gt 0 ]]; then
	OAM_Host=$(echo "$idmparam"|awk -F'=' '{print $2}'|sed 's/ //g')
	if [[ ! -z $OAM_Host ]]; then echo "$OAM_Host"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
	idm_param_matches=1
      elif [[ `echo "$idmparam"|grep -icw "SINGLENODE"` -gt 0 ]]; then
	idm_param_matches=1
      fi
    done
    IFS=$OLD_IFS

    if [[ -n "$idm_param_matches" && $idm_param_matches -eq "0" ]]; then
      echo
      echo -e "${RED}Please specify idm config parameters correctly${NORM}"
      usage_IDM;
      echo
      exit 1
    else
      set_wallet=1
    fi
  elif [[ -n "$host_info_available" && $host_info_available -eq 1 ]]; then
    for rhost in ""${OUD[@]}""
    do
      if [[ ! -z $rhost ]]; then echo "$rhost"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
    done
    if [[ ! -z $OIM_Host ]]; then echo "$OIM_Host"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
    if [[ ! -z $OAM_Host ]]; then echo "$OAM_Host"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
  else
    if [[ $EM_PROBE_MODE -eq 1 ]]; then
      cat >> ${PROBE_XML}.tmp <<EOF
  <group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
    <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
      <text nls_id="orhc_exadata_n89_nlsid">
        Is this a Single Node Identity Management System(IDM)
      </text>
      <options>
        <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
          <text nls_id="orhc_exadata_n1_nlsid">True</text>
        </option>
        <option id="q${PROBE_QUES_CNT}o2">
          <text nls_id="orhc_exadata_n2_nlsid">False</text>
        </option>
      </options>
    </question>
    <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n90_nlsid">
      How many Oracle Unified Directory(OUD) clusters are present
    </text>
    </question>
    <question id="q${PROBE_QUES_CNT}o2q2" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n91_nlsid">
      Enter one of the Oracle Unified Directory(OUD) Host in cluster
    </text>
    </question>
    <question id="q${PROBE_QUES_CNT}o2q3" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n92_nlsid">
      Enter Oracle Identity Manager(OIM) Domain AdminServer Host 
    </text>
    </question>
    <question id="q${PROBE_QUES_CNT}o2q4" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n93_nlsid">
      Enter Oracle Access Manager(OAM) Domain AdminServer Host
    </text>
    </question>	
  </group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
    elif [[ $EM_XMLD_MODE -eq 1 ]]; then
      read_probe_xml "Is this a Single Node Identity Management System(IDM)"
      single_node_idm=$xml_rvalue
      
      if [[ -z $single_node_idm ]]; then single_node_idm='N'; fi
      
      if [[ `echo "$single_node_idm"|sed 's/ //g'|grep -icw 'N'` -gt "0" ]]; then
        idm_param_matches=0
        
        read_probe_xml "How many Oracle Unified Directory(OUD) clusters are present"
        no_oud_replicas=$xml_rvalue
        
        read_probe_xml "Enter one of the Oracle Unified Directory(OUD) Host in cluster"
        REPLICA_list=$xml_rvalue
        oud_cnt=0
        iOLD_IFS=$IFS
        IFS=","
        for rhost in `echo "$REPLICA_list"`
        do    
          OUD[$oud_cnt]=$rhost
          if [[ ! -z $rhost ]]; then echo "$rhost"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; idm_param_matches=1; fi
          oud_cnt=$(expr $oud_cnt + 1)
        done  
        no_oud_replicas=$oud_cnt
        IFS=$iOLD_IFS
          
        read_probe_xml "Enter Oracle Identity Manager(OIM) Domain AdminServer Host"
        OIM_Host=$(echo "$xml_rvalue"|awk -F'=' '{print $2}'|sed 's/ //g')
        if [[ ! -z $OIM_Host ]]; then echo "$OIM_Host"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; idm_param_matches=1; fi
        
        read_probe_xml "Enter Oracle Access Manager(OAM) Domain AdminServer Host"
        OAM_Host=$(echo "$xml_rvalue"|awk -F'=' '{print $2}'|sed 's/ //g')
        if [[ ! -z $OAM_Host ]]; then echo "$OAM_Host"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; idm_param_matches=1; fi
      else
        set_wallet=1
        idm_param_matches=1
      fi            

      if [[ -n "$idm_param_matches" && $idm_param_matches -eq "0" ]]; then
        echo -e "Please specify idm config correctly"
        exit 1
      else
        set_wallet=1
      fi
    else
      single_node_idm='N'
      exec 3<&2; exec 2<&0
      $READ -p "Is this a Single Node Identity Management System(IDM) [Y|N] [N] :" single_node_idm
      read_code=`echo $?`;
      exec 2<&3
      write_in_env "IDM_TYPE_OPTION" "$single_node_idm"
      process_prompt "$read_code" "single_node_idm" "N"
      echo ""

      if [[ -z $single_node_idm ]]; then single_node_idm='N'; fi

      if [[ `echo "$single_node_idm"|sed 's/ //g'|grep -icw 'N'` -gt "0" ]]; then
        no_oud_replicas=0
        exec 3<&2; exec 2<&0
        $READ -p "How many Oracle Unified Directory(OUD) clusters present[0-4][0] :" no_oud_replicas
        read_code=`echo $?`;
        exec 2<&3
        write_in_env "OUD_NO_CLUSTER_OPTION" "$no_oud_replicas"
        process_prompt "$read_code" "no_oud_replicas" "0"
        #echo ""

        if [[ -n "$no_oud_replicas" && $no_oud_replicas -ne "0" ]]; then 
          oud_cnt=0 
          for i in $(seq 1 1 ${no_oud_replicas}); 
          do
            exec 3<&2; exec 2<&0
            $READ -p "Enter one of the Oracle Unified Directory(OUD) Host in cluster $i :" OUD[$oud_cnt]
            read_code=`echo $?`;
            exec 2<&3
            write_in_env "OUD_HOST_$i" "${OUD[$oud_cnt]}"
            process_prompt "$read_code" "OUD[$oud_cnt]" "0"
            #echo ""
            if [[ ! -z ${OUD[$oud_cnt]} ]]; then echo "${OUD[$oud_cnt]}"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
            oud_cnt=$(expr $oud_cnt + 1)
          done  
          out_cnt=0
        fi

        echo ""
        exec 3<&2; exec 2<&0
        $READ -p "Enter Oracle Identity Manager(OIM) Domain AdminServer Host(Press ENTER to skip) :" OIM_Host
        read_code=`echo $?`;
        exec 2<&3
        write_in_env "OIM_HOST" "$OIM_Host"
        process_prompt "$read_code" "OIM_Host" ""
        echo ""
        if [[ ! -z $OIM_Host ]]; then echo "$OIM_Host"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
          
        exec 3<&2; exec 2<&0
        $READ -p "Enter Oracle Access Manager(OAM) Domain AdminServer Host(Press ENTER to skip) :" OAM_Host
        read_code=`echo $?`;
        exec 2<&3
        write_in_env "OAM_HOST" "$OAM_Host"
        process_prompt "$read_code" "OAM_Host" ""
        #echo ""
        if [[ ! -z $OAM_Host ]]; then echo "$OAM_Host"|tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r' >> $IHOSTLIST; fi
        set_wallet=1
      else
        set_wallet=1
      fi
    fi
  fi
}

discover_fmw_env_remote ()
{
  hname_id=$(grep topology.machines.machine.id= $RTEMPDIR/topology_kv.out |grep "\.name = $1" | cut -d\" -f2)
  if [[ -z $hname_id || $hname_id = "" ]]; then 
    if [[ `grep -icw "$1" $IHOSTLIST` -eq "0" ]]; then
      if [[ `echo "$replica_hname"|grep -icw "$1"` -eq "0" ]]; then
        return;
      fi
    fi 
  else 
    if [[ `grep "component.type = WLS_ADMIN" $RTEMPDIR/topology_kv.out |grep -c "$hname_id"` -eq "0" && `grep "type = OUD" $RTEMPDIR/topology_kv.out |grep -c $hname_id` -eq "0" ]]; then 
      if [[ `echo "$replica_hname"|grep -icw "$1"` -eq "0" ]]; then
        r_hostname=$($SSHELL ${node_ssh_user}@$1 "hostname 2>/dev/null"|tr "[A-Z]" "[a-z]"|cut -d'.' -f1);
	if [[ -n "$r_hostname" ]]; then
          if [[ "$localnode" = "$r_hostname" ]]; then 
            VHNMAP=("${VHNMAP[@]}" $1:$localnode);
            no_ssh_equivalency=1; 
            unset r_hostname
            return; 
          elif [[ `grep -icw "$r_hostname" $HOSTLIST` -gt "0" && "$1" != "$r_hostname" ]]; then
            match_host=$(grep -iw "$r_hostname" $HOSTLIST|sed 's/ //g')
            VHNMAP=("${VHNMAP[@]}" $1:$match_host);
            no_ssh_equivalency=1; 
            unset r_hostname
            return; 
          fi
	fi
        return;
      fi
    fi
  fi

  ssh_setup_remotenodes "$1"
  if [[ -n "$no_ssh_equivalency" && $no_ssh_equivalency -eq "0" ]]; then
    r_hostname=$($SSHELL ${node_ssh_user}@$1 hostname|tr "[A-Z]" "[a-z]"|cut -d'.' -f1);
    if [[ -n "$r_hostname" ]]; then
      if [[ "$localnode" = "$r_hostname" ]]; then 
        VHNMAP=("${VHNMAP[@]}" $1:$localnode);
        no_ssh_equivalency=1; 
        unset r_hostname
        return; 
      elif [[ `grep -icw "$r_hostname" $HOSTLIST` -gt "0" && "$1" != "$r_hostname" ]]; then
        match_host=$(grep -iw "$r_hostname" $HOSTLIST|sed 's/ //g')
        VHNMAP=("${VHNMAP[@]}" $1:$match_host);
        no_ssh_equivalency=1; 
        unset r_hostname
        return; 
      fi
    fi
    call_func_check_space "$1"
    check_tmp_status "$1"
    create_rtemp_dir "$1"
  else
    return;
  fi

  #echo -e ""
  print_idmsystem_type "$1"
  echo -e "Initiating Oracle Identity Management discovery on $1${idmsystem_type}\n"
  
  if [[ "$localnode" != "$1" ]]; then
    node_ssh_user=$usern
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
        node_ssh_user="${root_user}"
      else
        node_ssh_user="${foxtrot_dom0_user}"
      fi
      if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$1 "echo \"\$HOME\""); fi
      l_RTEMPDIR=${l_TMPDIR}/.${program_name}
    else
      l_TMPDIR=$TMPDIR
      l_RTEMPDIR=$RTEMPDIR
    fi
  
    IDMDISCSCRPT="$l_RTEMPDIR/discovery/bin/idmdisc.sh"
 	 
    set_java_home "$1"

    $SCOPY -r $RTEMPDIR/discovery $node_ssh_user@$1:$l_RTEMPDIR/discovery >/dev/null
    $SSHELL $node_ssh_user@$1 "chmod 540 $IDMDISCSCRPT >/dev/null"

    touch $ROOT_LCKFIL

    $SSHELL -t $node_ssh_user@$1 "$bash_scr -c \"cd $l_RTEMPDIR/discovery/bin; export JAVA_HOME=$JAVA_HOME; $IDMDISCSCRPT -mode ${program_name} -topology $l_RTEMPDIR/discovery/bin/topology.xml -credconfig $l_RTEMPDIR/discovery/bin/credconfig -logDir $l_RTEMPDIR $RAT_IDMDISCARGS\"";
    ridm_disc_status=`echo $?`
 
    if [ -e "$ROOT_LCKFIL" ] ; then rm -f $ROOT_LCKFIL >/dev/null 2>&1; fi
  
    $SCOPY -r $node_ssh_user@$1:$l_RTEMPDIR/discovery/bin/topology.xml $RTEMPDIR/discovery/bin/ >/dev/null 2>&1;
    $SCOPY -r $node_ssh_user@$1:$l_RTEMPDIR/discovery/bin/credconfig $RTEMPDIR/discovery/bin/ >/dev/null 2>&1;
    $SCOPY -r $node_ssh_user@$1:$l_RTEMPDIR/logs $RTEMPDIR/logs >/dev/null 2>&1;
    $SSHELL $node_ssh_user@$1 "$bash_scr -c \"if [ -d $l_RTEMPDIR ]; then rm -rf $l_RTEMPDIR >/dev/null; fi\""

    mv -f $RTEMPDIR/logs $WRKDIR/idmlogs_${FDS}/discovery/logs_$1 >/dev/null 2>&1;
    if [[ $ridm_disc_status -ne 0 ]]; then
      echo -e "\n${RED}Identity Management discovery failed on $1. Please refer Identity Management Discovery logs to fix the issue and then re-rerun ${program_name}${NORM}"
      #echo -e "\n---------------------------------------------------------------------------------"
      #if [[ -e $RTEMPDIR/logs/discovery/ ]]; then cat $RTEMPDIR/logs/discovery/*.log; fi
      #echo -e "\n---------------------------------------------------------------------------------"
      echo -e $RED"\n$program_name is exiting ....\n"$NORM
      exit 1
    fi 
    #mv -f $RTEMPDIR/logs $OUTPUTDIR/idmlogs/discovery/logs_$1
  fi
}

discover_fmw_env ()
{
  function is_zip_unzip_available ()
  {
    is_zip_unzip_available=1
    ZIP_CMD=$(which zip 2>/dev/null)
    if [[ -z "$ZIP_CMD" || `echo $?` -ne 0 || `echo "$ZIP_CMD" | grep -ic "no zip"` -gt "0" ]]; then
      unset ZIP_CMD
      is_zip_unzip_available=0
    else
      UNZIP_CMD=$(which unzip 2>/dev/null)
      if [[ -z "$UNZIP_CMD" || `echo $?` -ne 0 || `echo "$UNZIP_CMD" | grep -ic "no unzip"` -gt "0" ]]; then
        unset UNZIP_CMD
        is_zip_unzip_available=0
      fi
    fi
  }

  if [[ ! -e $IDMPATH/discovery/ ]]; then
    is_zip_unzip_available
    if [[ -n "$is_zip_unzip_available" && $is_zip_unzip_available -eq "0" ]] || [[ -z $is_zip_unzip_available ]]; then
      echo -e ${RED}"zip/unzip utility is missing. Please configure zip/unzip and re-run ${program_name}."${NORM}
      echo -e ${RED}"\n${program_name} is exiting..\n\n"${NORM}
      exit
    fi
    unzip -o $IDMPATH/idmdiscovery.zip -d $RTEMPDIR >/dev/null 2>&1 
  else
    curr_dir=$(pwd);
    cd "$IDMPATH";
    
    if [[ -e $IDMPATH/idmdiscovery.zip ]]; then 
      for idmobject in `unzip -Z -1 $IDMPATH/idmdiscovery.zip`
      do
        cp -rf $idmobject $RTEMPDIR >/dev/null 2>&1
      done
    else
      cp -rf $IDMPATH/discovery/ $RTEMPDIR >/dev/null 2>&1
    fi
    if [[ -e $RTEMPDIR/discovery/bin/topology.xml ]]; then rm -f $RTEMPDIR/discovery/bin/topology.xml >/dev/null; fi
    cd "$curr_dir"; 
  fi
   
  IDMDISCSCRPT="$RTEMPDIR/discovery/bin/idmdisc.sh"
  if [[ ! -e $IDMDISCSCRPT ]]; then
    echo -e ${RED}"$IDMDISCSCRPT is missing"${NORM}
    echo -e ${RED}"Please configure Oracle Identity Management Discovery Script correctly and re-reun ${program_name}"${NORM}
    echo -e ${RED}"\n${program_name} is exiting..\n\n"${NORM}
    exit
  fi

  if [[ -n "$1" && $1 = "copy_idmdiscovery" ]]; then return; fi

  set_java_home "$localnode"
  
  security_fix "fix_plugin_or_rtscript_attributes" "$IDMDISCSCRPT" "" "540"

  curr_dir=$(pwd) 

  touch $ROOT_LCKFIL

  cd "$RTEMPDIR/discovery/bin"
  $bash_scr $IDMDISCSCRPT -mode ${program_name} -topology "$RTEMPDIR/discovery/bin/topology.xml" -credconfig "$RTEMPDIR/discovery/bin/credconfig" -logDir "$RTEMPDIR" $RAT_IDMDISCARGS;
  idmdisc_rc=$(echo $?)

  if [ -e "$ROOT_LCKFIL" ] ; then rm -f $ROOT_LCKFIL >/dev/null 2>&1; fi

  mv -f $RTEMPDIR/logs $WRKDIR/idmlogs_${FDS}/discovery/logs_${localnode} >/dev/null 2>&1;
  if [[ $idmdisc_rc -ne 0 ]]; then
    echo -e "\n${RED}Identity Management discovery failed on ${localnode}. Please refer Identity Management Discovery logs to fix the issue and then re-rerun ${program_name}${NORM}"
    #echo -e "\n---------------------------------------------------------------------------------"
    #if [[ -e $RTEMPDIR/logs/discovery/ ]]; then cat $RTEMPDIR/logs/discovery/*.log; fi
    #echo -e "\n---------------------------------------------------------------------------------"
    echo -e $RED"\n$program_name is exiting ....\n"$NORM
    exit 1
  fi 
  #mv -f $RTEMPDIR/logs $OUTPUTDIR/idmlogs/discovery/logs_${localnode}

  cd "$curr_dir"

  set_in_wallet "$localnode.JAVA_HOME" "$JAVA_HOME";

  if [[ -e $RTEMPDIR/topology_kv.out ]]; then rm -f $RTEMPDIR/topology_kv.out >/dev/null; fi
  xml2kv "$RTEMPDIR/discovery/bin/topology.xml" "$RTEMPDIR/topology_kv.out"
  echo $localnode > $HOSTLIST
  grep 'topology.machines.machine.id=".*".name = ' $RTEMPDIR/topology_kv.out | grep -v instances | grep name |grep -v $localnode |sort -u | sed 's/.* = //' |cut -d. -f1 >> $HOSTLIST

  OLD_IFS=$IFS
  IFS=$'\n'
  for namel in `grep -n 'Replica' $RTEMPDIR/topology_kv.out | awk -F':' '{print $1}'`
  do
    valuel=$(expr $namel + 1)
    Replica_hname=$(sed -n ${valuel}p $RTEMPDIR/topology_kv.out | awk -F"=" '{print $NF}'|sed 's/ //g'|cut -d. -f1)
    echo "$Replica_hname" >>$HOSTLIST

    replica_hname="$replica_hname $Replica_hname"
  done
  IFS=$OLD_IFS
}

run_on_remote_nodes ()
{
  if [[ $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
    stack_counter_l=1
    for i in `grep -v $localnode $HOSTLIST`
    do
      node_ssh_user=$usern
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        if [[ `echo "$ea_dom0_nodes" | grep -ic "$i"` -le 0 ]]; then
          node_ssh_user="${root_user}"
        else
          node_ssh_user="${foxtrot_dom0_user}"
        fi
        if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$i "echo \"\$HOME\""); fi
        l_RTEMPDIR=${l_TMPDIR}/.${program_name}
      else
        l_TMPDIR=$TMPDIR
        l_RTEMPDIR=$RTEMPDIR
      fi
  
      if [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]] ; then
        compute_rootpassword=${a_compute_rootpassword[$stack_counter_l]}
        stack_counter_l=$(expr $stack_counter_l + 1)
      fi
      get_cygpath "SYSTEM_DESC_FIL"
      $SCOPY $SYSTEM_DESC_FIL $node_ssh_user@$i:$l_RTEMPDIR/ > /dev/null 2>&1
      restore_cygpath "SYSTEM_DESC_FIL"
      echo -e "\n${GREEN}Starting to run ${program_name} in background on $i $NORM\n"
	echo -e "\nStarting to run ${program_name} in background on $i\n"  >> $LOGFIL
      rm -f $RTEMPDIR/run.pid
      
      cr_file=$RTEMPDIR/${program_name}_compute_$i.sh
      run_file=$RTEMPDIR/${program_name}_run_slave_$i.sh
      security_fix "check_and_fix_script_existence" "$cr_file"
      security_fix "check_and_fix_script_existence" "$run_file"

      echo "#!$bash_scr" > $cr_file
      echo "$RAT_DEBUG_FLG" >> $cr_file
      echo "echo \$\$ > $RTEMPDIR/run.pid" >> $cr_file
      echo "$SSHELL_EL $node_ssh_user@$i $l_RTEMPDIR/${program_name}_run_slave_$i.sh" >> $cr_file
      
      security_fix "fix_plugin_or_rtscript_attributes" "$cr_file" "" "540"
  
      echo "#!$bash_scr" > $run_file
      echo "$bash_source" >> $run_file
      echo "$RAT_DEBUG_FLG" >> $run_file
      echo "cd $l_RTEMPDIR; export RAT_RUNMODE_INTERNAL=slave; " >> $run_file
      echo "export RAT_LOCALNODE_INTERNAL=\"$i\"; " >> $run_file
      echo "export RAT_FDS_INTERNAL=\"${FDS}\"; " >> $run_file
      echo "export RAT_COMPUTE_RUNMODE=\"parallel\"; " >> $run_file
      echo "export RAT_COMPUTEPASSWORD_INTERNAL=\"$rootYesNoint\"; " >> $run_file
      echo "export RAT_PRINT_PASS_ON_SCREEN_INTERNAL=\"$print_pass_on_screen\"; " >> $run_file
      echo "export RAT_EA_DB_NODE_INTERNAL=$ea_db_node" >> $run_file
      echo "export RAT_EA_EC1_NODE_INTERNAL=$ea_ec1_node" >> $run_file
      echo "export RAT_EA_OVMM_NODE_INTERNAL=$ea_ovmm_node" >> $run_file
      echo "export RAT_EA_PC1_NODE_INTERNAL=$ea_pc1_node" >> $run_file
      echo "export RAT_EA_PC2_NODE_INTERNAL=$ea_pc2_node" >> $run_file
      echo "export RAT_UPLOAD_COLLECTION_NAME_INTERNAL=$upload_collection_name" >> $run_file
      echo "l_TMPDIR=$l_TMPDIR" >> $run_file
      # Set all RAT_ env in remote nodes also
      env | grep RAT_ | grep -wv RAT_OUTPUT > $OUTPUTDIR/rat_env.txt
      while read envs
      do
        e_key=$(echo $envs| cut -d"=" -f1)
        e_val=$(echo $envs| sed 's/[^=]*=//')
        echo "export $e_key=\"$e_val\"" >> $run_file
      done < $OUTPUTDIR/rat_env.txt
      echo "echo > $l_RTEMPDIR/empty.log" >> $run_file
      echo "echo > $l_RTEMPDIR/empty.log" >> $run_file
      echo "echo > $l_RTEMPDIR/empty.log" >> $run_file
      scr=$(basename $0)
      if [[ -n "$bash_path" ]] ; then
        echo "export PATH=$bash_path:$PATH" >> $run_file
      fi
  
      slavedebugFileName=$RTEMPDIR/${program_name}_${i}_slave_debug.log

      cat >> $run_file <<EOF

is_zip_unzip_available=1
ZIP_CMD=\$(which zip 2>/dev/null)
if [[ -z "\$ZIP_CMD" || \`echo \$?\` -ne 0 || \`echo "\$ZIP_CMD" | grep -ic "no zip"\` -gt "0" ]]; then
  unset ZIP_CMD
  is_zip_unzip_available=0
else
  UNZIP_CMD=\$(which unzip 2>/dev/null)
  if [[ -z "\$UNZIP_CMD" || \`echo \$?\` -ne 0 || \`echo "\$UNZIP_CMD" | grep -ic "no unzip"\` -gt "0" ]]; then
    unset UNZIP_CMD
    is_zip_unzip_available=0
  fi
fi
if [ -d $l_RTEMPDIR/.cgrep ]; then
  cOLD_DIR=\`pwd\`
  cd $l_RTEMPDIR/.cgrep
  if [[ -n \$is_zip_unzip_available && \$is_zip_unzip_available -eq "1" ]]; then
    ls -l $l_RTEMPDIR/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print \$NF}'|xargs zip -qj ${l_RTEMPDIR}/${program_name}_utlscripts.zip >/dev/null 2>&1
  else
    ls -l $l_RTEMPDIR/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print \$NF}'|xargs tar -czf ${l_RTEMPDIR}/${program_name}_utlscripts.tar.gz >/dev/null 2>&1
  fi
  cd \$cOLD_DIR
fi
for utlscrpt_full in \`if [ -d $l_RTEMPDIR/.cgrep ]; then ls -l $l_RTEMPDIR/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print \$NF}';fi\`; 
do 
  utlscrpt=\$(basename \$utlscrpt_full);
  if  [ -e $l_RTEMPDIR/.cgrep/\${utlscrpt} ]; then 
    #cp -f $l_RTEMPDIR/.cgrep/\${utlscrpt} \$l_TMPDIR >/dev/null 2>&1;
    cp -f $l_RTEMPDIR/.cgrep/\${utlscrpt} \$l_TMPDIR/.${program_name} >/dev/null 2>&1;
    if [ \$utlscrpt = "$DBSAT" ]; then unzip -o \$l_TMPDIR/.${program_name}/\$utlscrpt -d \$l_TMPDIR/.${program_name} >/dev/null 2>&1; fi
    if [[ -n "\$RAT_ROOT_RUN" && \$RAT_ROOT_RUN -eq 1 ]] && [[ `echo "\$RAT_TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then 
      cp -f $l_RTEMPDIR/.cgrep/\${utlscrpt} \$RAT_TMP_OUTPUT/.${program_name}/ >/dev/null 2>&1; 
      if [ \$utlscrpt = "$DBSAT" ]; then unzip -o \$RAT_TMP_OUTPUT/.${program_name}/\$utlscrpt -d \$RAT_TMP_OUTPUT/.${program_name} >/dev/null 2>&1; fi
    fi;
  fi;
done
EOF

      if [ -n "$options_components" ]; then
        if [[ -n "$RAT_CLIENT_DEBUG" && $RAT_CLIENT_DEBUG -eq "1" ]]
        then
  	  echo "$bash_scr ./$scr -f -c $options_components 2>$slavedebugFileName" >> $run_file
        else
          echo "$bash_scr ./$scr -f -c $options_components" >> $run_file
        fi
      else
        if [[ -n "$RAT_CLIENT_DEBUG" && $RAT_CLIENT_DEBUG -eq "1" ]]
        then
  	  echo "$bash_scr ./$scr -f 2>$slavedebugFileName" >> $run_file
        else
          echo "$bash_scr ./$scr -f" >> $run_file
        fi
      fi
      security_fix "fix_plugin_or_rtscript_attributes" "$run_file" "" "540"
      get_cygpath "WRKDIR"
      get_cygpath "SCRIPTPATH"
      get_cygpath "INPUTDIR"
      get_cygpath "OUTPUTDIR"
      get_cygpath "RTEMPDIR"

      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        $SSHELL $node_ssh_user@$i "$bash_scr -c \"if [ -d $l_RTEMPDIR ]; then rm -rf $l_RTEMPDIR/${program_name}_run_slave_$i.sh $l_RTEMPDIR/.cgrep/ >/dev/null 2>&1; fi\""
      fi

      $SCOPY -r $run_file $RPDIR/${program_name} $WRKDIR/cgrep $SCRIPTPATH/collections.dat $SCRIPTPATH/rules.dat $SCRIPTPATH/.cgrep/ $INPUTDIR $OUTPUTDIR $node_ssh_user@$i:$l_RTEMPDIR/ > /dev/null 2>&1

      if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ "$RAT_RUNMODE_INTERNAL" != "slave" ]]; then
        $SCOPY -r $RTEMPDIR/healthcheck $RTEMPDIR/discovery/ $node_ssh_user@$i:$l_RTEMPDIR/ > /dev/null 2>&1
      fi
      restore_cygpath "WRKDIR"
      restore_cygpath "SCRIPTPATH"
      restore_cygpath "INPUTDIR"
      restore_cygpath "OUTPUTDIR"
      restore_cygpath "RTEMPDIR"
      if [ -e "$EXCLUDEFIL" ] ; then
        get_cygpath "EXCLUDEFIL"
        $SCOPY $EXCLUDEFIL $node_ssh_user@$i:$l_RTEMPDIR/ > /dev/null 2>&1
        restore_cygpath "EXCLUDEFIL"
      fi
      CMDEXCLUDEFIL="$OUTPUTDIR/cmdexfil.txt"
      if [ -e "$CMDEXCLUDEFIL" ] ; then
        get_cygpath "CMDEXCLUDEFIL"
        $SCOPY $CMDEXCLUDEFIL $node_ssh_user@$i:$l_RTEMPDIR/ > /dev/null 2>&1
        restore_cygpath "CMDEXCLUDEFIL"
      fi
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      is_SSH_blocked "$i" "$node_ssh_user" "$compute_rootpassword"
  
      if [[ $SSH_blocked -eq 1 ]]; then
        echo -e "\n${RED}${i} is reachable but SSH is blocked.No collections and audit checks will be executed on ${i}${NORM}\n"|tee -a $LOGFIL
        add_to_skipped_nodes "${i}" "SSH Issue: Node is reachable but SSH is blocked"
        continue;
      fi
  
      is_foxtrot_dom0_nodes=0
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then is_foxtrot_dom0_nodes=1; fi

      if  [[ $rootYesNoint -eq "3" || $userid -eq 0 ]] && [[ $is_foxtrot_dom0_nodes -eq "0" ]]; then
        $cr_file > $OUTPUTDIR/$i.slave.log </dev/null 2>&1 &
        run_pid=$!
      else
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        fixRootPassword "$compute_rootpassword"
        $EXPECT -f - > $OUTPUTDIR/$i.slave.log 2>&1 </dev/null << IBEOF &
          if { "$RAT_EXPECT_DEBUG" == "-d" } {
            exp_internal 1
          }
          set timeout $passwordcheck_timeout
    	  set le_compute_rootpassword "$fixedRootPassword"
          spawn -noecho $cr_file
          match_max 100000
          log_user 0
          expect -nocase "password:*";
  	  send -- "\$le_compute_rootpassword\n";
          expect -nocase "run:*";
          send -- "\n";
          set timeout -1
          log_user 1 
          expect -nocase eof
          exit
IBEOF
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        #run_pid=$(cat $RTEMPDIR/run.pid)
        run_pid=$!
      fi
      touch $RTEMPDIR/nowatch.pid
      echo "$run_pid" >>  $RTEMPDIR/nowatch.pid
      cpids[$run_pid]="$run_pid";
      cpid_names[$run_pid]="$i"
      if [ $is_windows -eq "1" ] ; then
        for _child in $(ps -ef |awk '$3 == '${run_pid}' {print $2}');
	do
	  echo ${_child} >> $RTEMPDIR/nowatch.pid
	done
      fi
    done
  
    # Master runs only on local node
    mv -f $HOSTLIST $HOSTLIST.org
    echo $localnode > $HOSTLIST
  fi
  
  #echo "Using $REFFIL and $REFFIL1";
  if [[ $OFFLINE -eq "0" ]]
  then
    echo "FAIL = 0" >> $CELLIBNTFILE
    echo "WARN = 0" >> $CELLIBNTFILE
    echo "INFO = 0" >> $CELLIBNTFILE
    echo "TOTAL = 0" >> $CELLIBNTFILE
  
    sed "/MULTIPLE_ORACLE_HOMES =/d" $MASTERFIL > $MASTERFIL.new
    if [ ! -z $multiple_oracle_homes ]
    then 
      echo "MULTIPLE_ORACLE_HOMES = $multiple_oracle_homes" >> $MASTERFIL.new
    else
      echo "MULTIPLE_ORACLE_HOMES = 0" >> $MASTERFIL.new
    fi
    mv -f $MASTERFIL.new $MASTERFIL
  fi
  
  if [ -n "$MERGEFILES" ]
  then 
    echo -e ""
  
    d_index=0;
    slave_check_index=""
    for xdir in $dirarr
    do	
      echo -e ""
      echo -e "Started merging $xdir"
      
      xdir=`basename $xdir`;
      xdir=$(echo $xdir|sed 's/\.zip//g');
      
      copy_from_dir;
      d_index=$(expr $d_index + 1);
    done
    mv -f $HOSTLIST $HOSTLIST.new
    touch $HOSTLIST
  fi
}

ssh_setup_remotenodes ()
{
  no_ssh_equivalency=0
  #ssh setup starts from here and not to change 
  if [[ `echo "$argsaved"|grep -ic 'initrmsetup'` -eq 0 && `echo "$argsaved"|grep -ic 'initcheck'` -eq 0 ]]; 
  then
    #calling check_hostname_mismatch to check if default hostname is not mapped to management network in Exadata
    if [[ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" && -z "$RAT_CLUSTERNODES" && `uname -p 2>/dev/null` != "sparc"  && $is_exadata_dom0_machine -eq 0 && $is_opc -eq 0 ]]
    then
      check_hostname_mismatch
    fi
    arr=0

    if [[ ! -z "$phy_nodes" ]]
    then
      cat $HOSTLIST|sort|uniq > $HOSTLIST.new
      mv -f $HOSTLIST.new $HOSTLIST

      sed /$localnode/d $HOSTLIST > $HOSTLIST.new
      rm -rf $HOSTLIST
      echo "$localnode" > $HOSTLIST
      cat $HOSTLIST.new >> $HOSTLIST
      rm -rf $HOSTLIST.new
    fi

    if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]; then search_invntr_platform "localonly"; fi

    if [[ $single_instance_run -eq "0" && $is_exalytics_machine -eq 0 && $is_opc -eq 0 ]] ; then
      if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
        echo ""
      else
        echo -e "\nChecking ssh user equivalency settings on all nodes in cluster\n"|tee -a $LOGFIL
      fi
    fi

    if [[ -n "$1" ]]; then
      if [[ -e $HOSTLIST ]]; then mv -f $HOSTLIST $HOSTLIST.bak; fi
      echo "$1" >$HOSTLIST
    fi

    use_expect_for_ssh=0
    for hname in `cat $HOSTLIST`
    do
      is_IP "$hname"
      print_hname="$hname"

      if [[ -z $is_exalogic_machine ]] || [[ -n "$is_exalogic_machine" && $is_exalogic_machine -ne "1" ]] ; then
        use_expect_for_ssh=0
        unset passwordToCheck
      fi
      if [[ -z $is_exalogic_foxtrot ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -ne "1" ]]; then
	use_expect_for_ssh=0
	unset passwordToCheck
      fi

      platform=`uname -s`
      if [ $hname != $localnode ]
      then
        node_ssh_user=$usern
	if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
	then
	  if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
	    node_ssh_user="${root_user}"
	  else
	    node_ssh_user="${foxtrot_dom0_user}"
	  fi
        fi

        test_node_reachability $hname $node_ssh_user;
        if [ $el_node_ping -eq "1" ] ; then
          exitcode=0;
        else
          exitcode=1;
        fi
      fi
      if [[ $exitcode = 0 && $hname != $localnode ]]
      then   
        /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $node_ssh_user $hname ls 2>/dev/null 1>/dev/null
        ssh_setup_status=$?
        if [ $ssh_setup_status -ne 0 ]
        then
          if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" || $is_ssc_globalzone_dbmachine -eq 1 || $is_ssc_globalzone_machine -eq 1 || $is_ssc_localzone_machine -eq 1 ]];
          then #takes too long
            rsh_setup_status=1
          else
           rsh -l $node_ssh_user $hname ls 2>/dev/null 1>/dev/null 
           rsh_setup_status=$? 
           if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
          fi
        fi
        echo "ssh_setup_status=$ssh_setup_status rsh_setup_status=$rsh_setup_status">>$LOGFIL
        if [[ $ssh_setup_status -eq 0 || $hname = $localnode || $rsh_setup_status -eq 0 ]]
        then
          hostfullname=$($SSHELL ${node_ssh_user}@$hname hostname)
          hostmap=("${hostmap[@]}" $hname:$hostfullname);

          if [[ -n $is_IPADDRESS && $is_IPADDRESS = 1 ]]; then print_hname="$hname ($hostfullname)"; fi
 
          echo -e $GREEN"Node $print_hname is configured for ssh user equivalency for $node_ssh_user user\n" $NORM
          echo "$hname is configured for ssh user equivalency for $node_ssh_user user" >>$LOGFIL
        else
          if [[ $use_expect_for_ssh -eq 0 ]] ; then
            echo -e $RED"Node $hname is not configured for ssh user equivalency and the script uses ssh to execute checks on remote nodes.\n\nWithout this facility the script cannot run audit checks on the remote nodes. \n\nIf necessary due to security policies the script can be run individually on each node.\n"$NORM
            echo -e "Node $hname is not configured for ssh user equivalency and the script uses ssh to execute checks on remote nodes.\n\nWithout this facility the script cannot run audit checks on the remote nodes. \n\nIf necessary due to security policies the script can be run individually on each node.\n">>$LOGFIL

	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      echo -e "\n\n"
	      emhostlist=("${emhostlist[@]}" $hname);
	      AutoLoginCheck="Yes" 
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
              echo -e "Do you want to configure SSH for user $node_ssh_user on $hname [y/n][y]"

	      read_probe_xml "For evaluating audit checks on the remote compute nodes of a cluster, SSH equivalency needs to be set up" "1" "1"
	      if [[ -n $xml_rvalue && $xml_rvalue -eq "1" ]]; then
		xml_rvalue="yes"
	      elif [[ -n $xml_rvalue && $xml_rvalue -eq "2" ]]; then
		xml_rvalue="no"
	      fi
	      AutoLoginCheck=$xml_rvalue 
	    else 
              exec 3<&2; exec 2<&0
              $READ -p "Do you want to configure SSH for user $node_ssh_user on $hname [y/n][y]" AutoLoginCheck
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "AutoLoginCheck" "n"
	    fi
          fi
          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
            AutoLoginCheckYes=1 
	
	    if [[ $EM_PROBE_MODE -eq 0 ]]
	    then
              func_setup_ssh -user $node_ssh_user -hosts "$hname" 
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
		no_ssh_equivalency=1;
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp -f $INPUTDIR/o_host_list.out $HOSTLIST
                rm -f $INPUTDIR/o_host_list.out
                add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency as password entered is incorrect.";
              else
                hostfullname=$($SSHELL ${node_ssh_user}@$hname hostname)
                hostmap=("${hostmap[@]}" $hname:$hostfullname);

                if [[ -n $is_IPADDRESS && $is_IPADDRESS = 1 ]]; then print_hname="$hname ($hostfullname)"; fi
 
                echo -e $GREEN"\nNode $print_hname has been configured for ssh user equivalency for $node_ssh_user user\n" $NORM
              fi
	    else
              sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
              cp -f $INPUTDIR/o_host_list.out $HOSTLIST
              rm -f $INPUTDIR/o_host_list.out
	    fi
            ;;
          n|N|NO|No|no)
	    if [[ $EM_XMLD_MODE -eq 1 ]]; then
	      tmpSshConf='No'
	    else 
              if [[ $use_expect_for_ssh -eq 0 ]] ; then
                exec 3<&2; exec 2<&0
                $READ -p "We can configure ssh only for this run and reverse the changes back. Do you want to continue?[y/n][y] " tmpSshConf
		read_code=`echo $?`;
                exec 2<&3
		process_prompt "$read_code" "tmpSshConf" "n"
              fi
	    fi
            case $tmpSshConf in
            y|Y|YES|yes|Yes)
              func_setup_ssh -user $node_ssh_user -hosts "$hname" 
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
		no_ssh_equivalency=1;
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp -f $INPUTDIR/o_host_list.out $HOSTLIST
                rm -f $INPUTDIR/o_host_list.out
                add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency as password entered is incorrect.";
              else
                hostfullname=$($SSHELL ${node_ssh_user}@$hname hostname)
                hostmap=("${hostmap[@]}" $hname:$hostfullname);

                if [[ -n $is_IPADDRESS && $is_IPADDRESS = 1 ]]; then print_hname="$hname ($hostfullname)"; fi 
 
                echo -e $GREEN"\nNode $print_hname has been configured for ssh user equivalency for $node_ssh_user user for this run\n" $NORM
                hnameArr[$arr]=$hname
                arr=`expr $arr + 1`
              fi
              ;;
            n|N|NO|No)
              if [ $hname = $localnode ]
              then
                echo -e $RED"\nWithout ssh user equivalency, collections and audit checks will be executed only on localnode ${localnode}\n"$NORM
                echo -e $RED"\nWithout ssh user equivalency, collections and audit checks will be executed only on localnode ${localnode}\n">>$LOGFIL
                echo $localnode >$HOSTLIST
              else
		no_ssh_equivalency=1;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on ${hname}\n"$NORM
                echo -e "\nWithout ssh user equivalency, no audit check will be executed on ${hname}\n">>$LOGFIL
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp -f $INPUTDIR/o_host_list.out $HOSTLIST
                rm -f $INPUTDIR/o_host_list.out
                add_to_skipped_nodes "$hname" "User chose not to setup ssh user equivalency.";
              fi
              ;;
            *)
              func_setup_ssh -user $node_ssh_user -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
		no_ssh_equivalency=1;
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp -f $INPUTDIR/o_host_list.out $HOSTLIST
                rm -f $INPUTDIR/o_host_list.out
                add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency as password entered is incorrect.";
              else
                hostfullname=$($SSHELL ${node_ssh_user}@$hname hostname)
                hostmap=("${hostmap[@]}" $hname:$hostfullname);

        	if [[ -n $is_IPADDRESS && $is_IPADDRESS = 1 ]]; then print_hname="$hname ($hostfullname)"; fi
 
                echo -e $GREEN"\nNode $print_hname has been configured for ssh user equivalency for $node_ssh_user user for this run\n" $NORM
                hnameArr[$arr]=$hname
                arr=`expr $arr + 1`
              fi
              ;;
            esac
            ;;
          *)
            AutoLoginCheckYes=1
            func_setup_ssh -user $node_ssh_user -hosts "$hname" 
            if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
            then
	      no_ssh_equivalency=1;
              sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
              cp -f $INPUTDIR/o_host_list.out $HOSTLIST
              rm -f $INPUTDIR/o_host_list.out
              add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency as password entered is incorrect.";
       	    else
              hostfullname=$($SSHELL ${node_ssh_user}@$hname hostname)
              hostmap=("${hostmap[@]}" $hname:$hostfullname);
              echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency for $node_ssh_user user\n" $NORM
            fi
          ;;
          esac
        fi
      elif [ $hname != $localnode ]
      then	
        no_ssh_equivalency=1
        sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
        cp -f $INPUTDIR/o_host_list.out $HOSTLIST
        rm -f $INPUTDIR/o_host_list.out

        if [[ $ssh_go_ahead = 0 ]]
        then
          add_to_skipped_nodes "$hname" "Network latency issue: Node is pingable but ssh took too long";
          echo "Node $hname is pingable but ssh took too long so removing from host list">>$LOGFIL
        else
          add_to_skipped_nodes "$hname" "Node is not pingable";
          echo "Node $hname is not pingable so removing from host list">>$LOGFIL
        fi
      fi
    done
    if [[ -n "$1" ]]; then
      if [[ -e $HOSTLIST.bak ]]; then mv -f $HOSTLIST.bak $HOSTLIST; fi
    fi
  else
    touch $HOSTLIST
  fi
}

set_in_wallet ()
{
  export DISCOVERY_HOME=$RTEMPDIR/discovery
  
  WALLET_SET_TIMEOUT=10
  if [[ -n "$RAT_WALLET_SET_TIMEOUT" ]]; then
    WALLET_SET_TIMEOUT=$RAT_WALLET_SET_TIMEOUT   
  fi

  CSFUTILPATH="$RTEMPDIR/discovery/bin/credconfig"

  curr_dir=$(pwd)
  cd $CSFUTILPATH
  security_fix "fix_plugin_or_rtscript_attributes" "$CSFUTILPATH/csf-util.sh" "" "540"
  KEY="$1"
  VALUE="$2"

  $EXPECT -f - <<IBEOF
    set timeout $WALLET_SET_TIMEOUT
    log_user 0
    if { "$RAT_EXPECT_DEBUG" == "-d" } {
      exp_internal 1
    }    
    spawn -noecho $CSFUTILPATH/csf-util.sh addgeneric
    match_max 100000
    expect {
      -nocase "*Key*" {
      send -- "$KEY\n"
    }
      -nocase "*Credential :" {
      send -- "$VALUE\n"
    }
      -nocase eof {
      exit
    }
    }
    expect {
      -nocase "*Key*" {
      send -- "$KEY\n"
    }
      -nocase "*Credential*" {
      send -- "$VALUE\n"
    }
      -nocase eof {
      exit
    }
    }
    expect -nocase eof
IBEOF
  cd "$curr_dir"
}

set_idm_healthcheck_env ()
{
  ##      ${JPS_JARS}  - jps jars location
  ##      ${IAM_HOME}  - iam home
  ##      ${WLS_HOME}  - wls home
  ##      ${SOA_HOME}  - soa home
  if [[ -z $RAT_IAM_HOME ]]; then
    IAM_HOME=$(grep $i.IAM\.HOME $MASTERFIL | head -1 | cut -d= -f2 | sed 's/ //g')
    if [[ -n "$IAM_HOME" ]]; then export IAM_HOME=$IAM_HOME
  else
    export IAM_HOME=$RAT_IAM_HOME
  fi

  if [[ `echo "$fmw_comps_running" | grep -icw "OUD"` -gt "0" ]]; then
    if [[ ! -n $IAM_HOME ]]; then
      if [[ -z $RAT_JPS_JARS ]]; then 
        JPS_JARS=$RTEMPDIR/discovery/lib  
        export JPS_JARS=$JPS_JARS
      else   
        export JPS_JARS=$RAT_JPS_JARS;
      fi
    fi
  fi

  if [[ `echo "$fmw_comps_running" | grep -icw "OIM\|OAM"` -gt "0" ]]; then
    if [[ -z $RAT_WLS_HOME ]]; then
      WLS_HOME=$(grep $i.WLS\.HOME $MASTERFIL | head -1 | cut -d= -f2 | sed 's/ //g')
      if [[ -n "$WLS_HOME" ]]; then 
        export WLS_HOME=$WLS_HOME; 
      else
        WLS_HOME=$(grep WLS\.HOME $MASTERFIL | head -1 | cut -d= -f2 | sed 's/ //g')
        if [[ -n "$WLS_HOME" ]]; then
          export WLS_HOME=$WLS_HOME;
	else
          wlsadmin_inst_id=$(grep -iw 'WLS_ADMIN' $OUTPUTDIR/topology_kv.out | grep 'instances' | tail -1 | cut -d\" -f4 | sed 's/ //g')
          if [[ -n "$wlsadmin_inst_id" ]]; then
	    wlsadmin_hid=$(grep "$wlsadmin_inst_id" $OUTPUTDIR/topology_kv.out | grep \.homeId | cut -d= -f4 | sed 's/ //g')
	    WLS_HOME=$(grep "$wlsadmin_hid" $OUTPUTDIR/topology_kv.out | grep \.path | cut -d= -f4 | sed 's/ //g')
            export WLS_HOME=$WLS_HOME;
	  fi
        fi
      fi
    else
      export WLS_HOME=$RAT_WLS_HOME; fi
    fi

    if [[ -z $RAT_SOA_HOME ]]; then
      SOA_HOME=$(grep $i.SOA\.HOME $MASTERFIL | head -1 | cut -d= -f2 | sed 's/ //g')
      if [[ -n "$SOA_HOME" ]]; then export SOA_HOME=$SOA_HOME; fi
    else
      export SOA_HOME=$RAT_SOA_HOME
    fi
  fi
}

set_java_home ()
{
  if [[ $EM_PROBE_MODE -eq 1 ]]; then return; fi

  if [[ -e $RTEMPDIR/discovery/bin/credconfig ]]; then
    export DISCOVERY_HOME=$RTEMPDIR/discovery
    curr_dir=$(pwd);
    cd $RTEMPDIR/discovery/bin/credconfig
    security_fix "fix_plugin_or_rtscript_attributes" "$RTEMPDIR/discovery/bin/credconfig/csf-util.sh" "" "540"
    WALLET_JAVA_HOME=$($RTEMPDIR/discovery/bin/credconfig/csf-util.sh list | grep -iw "$1\.JAVA_HOME -" | awk -F'-' '{print $2}' | sed 's/ //g')    
    cd "$curr_dir"
  fi

  if [[ -n "$RAT_JAVA_HOME" ]]; then
    JAVA_HOME=$RAT_JAVA_HOME
  elif [[ -e $MASTERFIL && `grep -ic "$1\.JAVA_HOME =" $MASTERFIL` -gt 0 ]]; then
    JAVA_HOME=$(grep -i "$1\.JAVA_HOME =" $MASTERFIL | cut -d= -f2 | sed 's/ //g')
  elif [[ -n $WALLET_JAVA_HOME && "$WALLET_JAVA_HOME" != "" ]]; then
    JAVA_HOME=$WALLET_JAVA_HOME
  elif [[ "$localnode" = $1 ]] && [[ -z "$RAT_RUNMODE_INTERNAL" || -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL != "slave" ]]; then
    JAVA_HOME=$($bash_scr $SCRIPTPATH/.cgrep/discover_java_home.sh)
    if [[ -z "$JAVA_HOME" || "$JAVA_HOME" = "" ]] ; then
      JAVACMD=$(which java)
      JAVA_HOME=$(readlink -f $JAVACMD|sed "s:bin/java::")
      if [ -z "$JAVA_HOME" ]; then
        JAVA_HOME="/usr"
      fi	
    fi

    echo ""
    default_jh='Y'
    exec 3<&2; exec 2<&0;
    $READ -p "JAVA_HOME is set to '$JAVA_HOME' on $1. Do you want to continue with same[y/n][y] :" default_jh
    read_code=`echo $?`; 
    exec 2<&3  	
    write_in_env "$1.DEFAULT_JAVAHOME_OPTION" "$default_jh"
    process_prompt "$read_code" "default_jh" "y"
    if [[ `echo "$default_jh"|grep -icw 'N'` -gt "0" ]]; then
      exec 3<&2; exec 2<&0; 
      $READ -p "Enter JAVA_HOME on $1 :" JAVA_HOME
      read_code=`echo $?`; 
      exec 2<&3  	
      write_in_env "$1.JAVAHOME_OPTION" "$JAVA_HOME"
      process_prompt "$read_code" "JAVA_HOME" "$JAVA_HOME"
    fi
	
    if [[ `echo "$single_node_idm" | grep -icw "N"` -gt "0" ]]; then 
      same_jh_allnodes='Y'
      exec 3<&2; exec 2<&0;
      $READ -p "JAVA_HOME is set to '$JAVA_HOME' on $1. Do you want to set same JAVA_HOME on all nodes[y/n][y] :" same_jh_allnodes
      read_code=`echo $?`; 
      exec 2<&3  	
      write_in_env "SAME_JAVAHOME_OPTION" "$same_jh_allnodes"
      process_prompt "$read_code" "same_jh_allnodes" "y"
          
      if [[ `echo "$same_jh_allnodes"|grep -icw 'N'` -eq "0" ]]; then
        export RAT_JAVA_HOME=$JAVA_HOME
        JAVA_HOME=$RAT_JAVA_HOME
      fi	
    fi
  else
    default_rjh='Y'
    $SCOPY -r $SCRIPTPATH/.cgrep/discover_java_home.sh $node_ssh_user@$1:$l_RTEMPDIR/ >/dev/null
    $SSHELL $node_ssh_user@$1 "chmod 540 $l_RTEMPDIR/discover_java_home.sh >/dev/null"

    REMOTE_JAVA_HOME=$($SSHELL -t $node_ssh_user@$1 "$bash_scr $l_RTEMPDIR/discover_java_home.sh")
    REMOTE_JAVA_HOME=$(echo "$REMOTE_JAVA_HOME" | tr -d '\r' | head -1 | sed 's/ //g')

    if [ -z "$REMOTE_JAVA_HOME" ] || [ "$REMOTE_JAVA_HOME" = "" ]; then
      REMOTE_JAVA_HOME=$($SSHELL -t $node_ssh_user@$1 "$bash_scr -c \"echo \$JAVA_HOME\"")
      REMOTE_JAVA_HOME=$(echo "$REMOTE_JAVA_HOME" | tr -d '\r' | head -1)
    fi

    if [[ -n "$REMOTE_JAVA_HOME" ]] && [[ "$REMOTE_JAVA_HOME" != "" && `echo "$REMOTE_JAVA_HOME"|grep -icw 'undefined'` -eq "0" ]]; then
      REMOTE_JAVA_HOME=$(echo "$REMOTE_JAVA_HOME" | sed 's/ //g')

      exec 3<&2; exec 2<&0; 
      echo ""
      $READ -p "JAVA_HOME is set to '$REMOTE_JAVA_HOME' on $1. Do you want to continue with same[y/n][y] :" default_rjh
      read_code=`echo $?`; 
      exec 2<&3  	
      write_in_env "$1.DEFAULT_RJAVAHOME_OPTION" "$default_rjh"
      process_prompt "$read_code" "default_rjh" "y"
          
      if [[ `echo "$default_rjh"|grep -icw 'N'` -gt "0" ]]; then
        exec 3<&2; exec 2<&0; 
        $READ -p "Enter JAVA_HOME on $1 :" JAVA_HOME
        read_code=`echo $?`; 
        exec 2<&3  	
        write_in_env "$1.JAVAHOME_OPTION" "$JAVA_HOME"
        process_prompt "$read_code" "JAVA_HOME" "$JAVA_HOME"
      else
	JAVA_HOME=$REMOTE_JAVA_HOME
      fi
    else
      exec 3<&2; exec 2<&0; 
      $READ -p "JAVA_HOME is not set on $1. Enter JAVA_HOME on $1 :" JAVA_HOME
      read_code=`echo $?`; 
      exec 2<&3  	
      write_in_env "$1.JAVAHOME_OPTION" "$JAVA_HOME"
      process_prompt "$read_code" "JAVA_HOME" "$JAVA_HOME"
    fi
  fi
  JAVA_HOME=$(echo "$JAVA_HOME"|sed 's/ //g')
  export JAVA_HOME=$JAVA_HOME
	
  if [[ -z "$RAT_RUNMODE_INTERNAL" ]] || [[ -n "$RAT_RUNMODE_INTERNAL" && "$RAT_RUNMODE_INTERNAL" != "slave" ]]; then
    if [[ `grep -ic "$1.JAVA_HOME =" $MASTERFIL` -eq "0" ]]; then 
      if [[ $fmw_runmode != "pre" ]]; then
        if [[ -e $RTEMPDIR/discovery/bin/credconfig ]]; then set_in_wallet "$1.JAVA_HOME" "$JAVA_HOME"; fi
      fi
      echo "$1.JAVA_HOME = $JAVA_HOME" >> $MASTERFIL; 
    fi
  fi
}

compare_with_dbusers ()
{
  user_dbuser_matched=0
  userToMatch=$1

  for dbuser in "${alldbusers[@]}"
  do
    if [[ "$userToMatch" = "$dbuser" ]]; then
      user_dbuser_matched=1
      return;
    fi
  done
}

validate_idm_owner ()
{
  if [[ -n "$RAT_SKIP_IDMOWNER" ]]; then return; fi

  idm_owner=$(ps -ef | grep -v grep | grep -v Dweblogic.management.server | grep -i Dweblogic.Name | head -1 | awk '{print $1}' | sed 's/ //g')
  if [[ -z $idm_owner || "$idm_owner" = "" ]]; then
    idm_owner=$(ps -aef | grep org.opends.server.core.DirectoryServer | grep config.ldif | grep -v grep | head -1 | awk '{print $1}' | sed 's/ //g')
  fi

  if [[ -n "$bgproc" ]]; then
    dbcntr=0
    for dbproc in `echo "$bgproc"`
    do
      dbuser=$(ps -ef|grep "$dbproc"|grep -v grep|grep -v asm_pmon|head -1|awk {'print $1'}|sed 's/ //g') 
      if [[ -n "$dbuser" ]]; then 
	alldbusers[$dbcntr]=$dbuser;
        dbcntr=$(expr $dbcntr + 1 )
      fi 
    done
    dbcntr=0
    unset dbuser
  fi
  same_idmdb_usern=0

  if [[ -n "$fmw_dbrunonly" && $fmw_dbrunonly -eq "1" ]]; then
    if [[ -n "$bgproc" ]]; then
      compare_with_dbusers "$usern"
      if [[ -n "${user_dbuser_matched}" && ${user_dbuser_matched} -eq "1" ]]; then
        is_fmw_machine=0
        if [ $fmw_runmode = "pre" ] ; then idm_db_components=IDMPREINSTALL; fi
        if [ $fmw_runmode = "post" ] ; then idm_db_components=IDMPOSTINSTALL; fi
        if [ $fmw_runmode = "runtime" ] ; then idm_db_components=IDM; fi
      else
        echo -e ""
        echo -e "${RED}Error: User must be one of database owners( `echo "${alldbusers[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '`)${NORM}"
	echo -e "${RED}Please re-run ${program_name} with correct user.${NORM}"
        echo -e ""
        echo -e ${RED}"${program_name} is exiting.."${NORM}
        echo -e ""
        exit 1;
      fi
    else
      echo -e ""
      echo -e ${RED}"Database is not running on ${localnode}."${NORM}
      echo -e ""
      echo -e ${RED}"${program_name} is exiting.."${NORM}
      echo -e ""
      exit 1;
    fi
  else
    if [[ "${usern}" != "${idm_owner}" ]]; then
      if [[ -n "$bgproc" ]]; then
  	compare_with_dbusers "$usern"
        if [[ -n "${user_dbuser_matched}" && ${user_dbuser_matched} -eq "0" ]]; then
          echo -e ""
          echo -e "${RED}Error: User must be '${idm_owner}' or one of database owners( `echo "${alldbusers[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '`)${NORM}"
	  echo -e "${RED}Please re-run ${program_name} with correct user.${NORM}"
          echo -e ""
          echo -e ${RED}"${program_name} is exiting.."${NORM}
          echo -e ""
          exit 1;
        else
          is_fmw_machine=0
          if [ $fmw_runmode = "pre" ] ; then idm_db_components=IDMPREINSTALL; fi
          if [ $fmw_runmode = "post" ] ; then idm_db_components=IDMPOSTINSTALL; fi
          if [ $fmw_runmode = "runtime" ] ; then idm_db_components=IDM; fi

          echo ""
        fi
      else    
        echo -e ""
        echo -e "${RED}Error: User must be '${idm_owner}'${NORM}"
	echo -e "${RED}Please re-run ${program_name} with correct user.${NORM}"
        echo -e ""
        echo -e ${RED}"${program_name} is exiting.."${NORM}
        echo -e ""
        exit 1;
      fi
    else
      #same user for both db and idm setup
      if [[ -n "$bgproc" ]]; then
  	compare_with_dbusers "$usern"
        if [[ -n "${user_dbuser_matched}" && ${user_dbuser_matched} -eq "1" ]]; then
          same_idmdb_usern=1
          if [ $fmw_runmode = "pre" ] ; then idm_db_components=IDMPREINSTALL; fi
          if [ $fmw_runmode = "post" ] ; then idm_db_components=IDMPOSTINSTALL; fi
          if [ $fmw_runmode = "runtime" ] ; then idm_db_components=IDM; fi

          echo ""
        fi
      fi
    fi
  fi
}

execute_idmhealthcheck ()
{
  curr_dir=$(pwd)
  cd $OUTPUTDIR
  
  if [ -z "$RAT_IDMHCBIN" ] ; then
    if [ -f "$RTEMPDIR/healthcheck/bin/idmhc.sh" ] ; then
      idmhcbin="$RTEMPDIR/healthcheck/bin"
    fi
  else
    idmhcbin=$RAT_IDMHCBIN
  fi
  if [ ! -f "$idmhcbin/idmhc.sh" ] ; then
    echo "Error: Failed to find idmhc.sh" >>$LOGFIL;
  fi
  
  set_java_home "$i"
  
  idmtype_checks=0
  #Running IDMHC_COLLECT Checks
  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/create_small_file.pl \"IDMHC_COLLECT\" $INPUTDIR/collections.dat \"$MANIFEST_XML\" \"$components\" \"$fmw_run_comps\" \"$fmw_comps_running\" \"$EXCLUDEFIL\" \"$fmw_exclude_comps\">/dev/null 2>&1"
  fi
  $perl_exe $SCRIPTPATH/.cgrep/create_small_file.pl "IDMHC_COLLECT" $INPUTDIR/collections.dat "$MANIFEST_XML" "$components" "$fmw_run_comps" "$fmw_comps_running" "$EXCLUDEFIL" "$fmw_exclude_comps">/dev/null 2>&1
  if [[ -e $MANIFEST_XML ]]; then
    idmtype_checks=1
    echo "Collecting - XML Checks"
    bMANIFEST_XML=$(basename $MANIFEST_XML)
    mv -f $MANIFEST_XML $OUTPUTDIR/$i.IC.${bMANIFEST_XML} 2>/dev/null
    xmlcheckresults=$OUTPUTDIR/$i.IC.xmlcheckresults.out
    rm -f $xmlcheckresults
    for file in $OUTPUTDIR/$i.IC.${bMANIFEST_XML}
    do
      touch $ROOT_LCKFIL

      OLD_ORACLE_HOME=$ORACLE_HOME
      unset ORACLE_HOME
      if [ -n "$fmw_credconfig" ] ; then
        if [[ -n $RAT_SCRIPT_DEBUG ]]; then		
  	  if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	  else
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -credconfig $fmw_credconfig -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
  	  fi
        else
  	  if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	  else
            $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -credconfig $fmw_credconfig -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
  	  fi
        fi
      else
        if [[ -n $RAT_SCRIPT_DEBUG ]]; then
  	  if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	  else
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
  	  fi
        else 
  	  if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS>> $xmlcheckresults
    	  else
            $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
  	  fi
        fi
      fi
      ORACLE_HOME=$OLD_ORACLE_HOME
      idmhcc_xml_outfile=`grep "HealthCheck XML report" $xmlcheckresults |awk '{print $NF}'| tail -1`
      if [ ! -n "$idmhcc_xml_outfile" ] ; then
        echo "Error : failed to run idmhc.sh"
        cat $xmlcheckresults
        idmhcc_xml_outfile=`find $OUTPUTDIR/logs/healthchecker/ -name "IDM_*.xml"|head -1`
      fi
      if [ "$RAT_DEBUG" -eq 1 ] ; then echo "IDMHC Check Collections are in $idmhcc_xml_outfile"; fi

      if [ -e "$ROOT_LCKFIL" ] ; then rm -f $ROOT_LCKFIL >/dev/null 2>&1; fi
    done
    if [[ -e $MANIFEST_XML ]]; then rm -f $MANIFEST_XML; fi
  fi
  
  #Running IDMHC Checks 
  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/create_small_file.pl \"IDMHC_CHECK\" $INPUTDIR/collections.dat \"$MANIFEST_XML\" \"$components\" \"$fmw_run_comps\" \"$fmw_comps_running\" \"$EXCLUDEFIL\" \"$fmw_exclude_comps\" >/dev/null 2>&1"
  fi
  $perl_exe $SCRIPTPATH/.cgrep/create_small_file.pl "IDMHC_CHECK" $INPUTDIR/collections.dat "$MANIFEST_XML" "$components" "$fmw_run_comps" "$fmw_comps_running" "$EXCLUDEFIL" "$fmw_exclude_comps" >/dev/null 2>&1
  if [[ -e $MANIFEST_XML ]]; then	
    idmtype_checks=1
    bMANIFEST_XML=$(basename $MANIFEST_XML)
    mv -f $MANIFEST_XML $OUTPUTDIR/$i.I.${bMANIFEST_XML} 2>/dev/null
    xmlcheckresults=$OUTPUTDIR/$i.I.xmlcheckresults.out
    rm -f $xmlcheckresults
    for file in $OUTPUTDIR/$i.I.${bMANIFEST_XML}
    do
      touch $ROOT_LCKFIL     

      OLD_ORACLE_HOME=$ORACLE_HOME
      unset ORACLE_HOME
      if [ -n "$fmw_credconfig" ] ; then
        if [[ -n $RAT_SCRIPT_DEBUG ]]; then		
  	  if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	  else
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -credconfig $fmw_credconfig -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
  	  fi
        else
  	  if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	  else
            $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -credconfig $fmw_credconfig -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
  	  fi
        fi
      else
        if [[ -n $RAT_SCRIPT_DEBUG ]]; then
  	  if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	  else
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
  	  fi
        else 
  	  if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	  else
            $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
  	  fi
        fi
      fi
      ORACLE_HOME=$OLD_ORACLE_HOME
      idmhc_xml_outfile=`grep "HealthCheck XML report" $xmlcheckresults |awk '{print $NF}'| tail -1`
      if [ ! -n "$idmhc_xml_outfile" ] ; then
        echo "Error : failed to run idmhc.sh"
        cat $xmlcheckresults
        idm_xmlhc_outfile=`find $OUTPUTDIR/logs/healthchecker/ -name "IDM_*.xml"|head -1`
      fi

      if [ -e "$ROOT_LCKFIL" ] ; then rm -f $ROOT_LCKFIL >/dev/null 2>&1; fi
    done
    if [[ -e $MANIFEST_XML ]]; then rm -f $MANIFEST_XML; fi
  fi
  cd $curr_dir
  
  #OLD CODE -Backward compatibility
  curr_dir=$(pwd)
  cd $OUTPUTDIR
  echo "Collecting - XML Checks"
  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/create_small_file.pl \"\" $INPUTDIR/collections.dat \"\" \"$components\" \"$fmw_run_comps\" \"$fmw_comps_running\" \"\" \"$fmw_exclude_comps\">/dev/null 2>&1"
  fi
  $perl_exe $SCRIPTPATH/.cgrep/create_small_file.pl "" $INPUTDIR/collections.dat "" "$components" "$fmw_run_comps" "$fmw_comps_running" "" "$fmw_exclude_comps">/dev/null 2>&1
  if [[ -e FMW_Checks.xml ]]; then
    mv -f FMW_Checks.xml $i.FMW_Checks.xml 2>/dev/null
    xmlcheckresults=$OUTPUTDIR/$i.xmlcheckresults.out
    rm -f $xmlcheckresults
    #echo "############# Running xml checks";
    for file in $i.FMW_Checks.xml
    do
      touch $ROOT_LCKFIL

      #echo "############# Running xml check in $file";
      if [ -z "$RAT_IDMHCBIN" ] ; then
        if [ -f "$RTEMPDIR/healthcheck/bin/idmhc.sh" ] ; then
          idmhcbin="$RTEMPDIR/healthcheck/bin"
        fi
      else
        idmhcbin=$RAT_IDMHCBIN
      fi
      if [ ! -f "$idmhcbin/idmhc.sh" ] ; then
        echo "Error: Failed to find idmhc.sh";
      fi
  
      set_java_home "$i"
  
      OLD_ORACLE_HOME=$ORACLE_HOME
      unset ORACLE_HOME
      if [ -n "$fmw_credconfig" ] ; then
        if [[ -n $RAT_SCRIPT_DEBUG ]]; then
          if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	    else
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -credconfig $fmw_credconfig -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
          fi
        else
          if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	    else
            $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -credconfig $fmw_credconfig -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
          fi
        fi
      else
        if [[ -n $RAT_SCRIPT_DEBUG ]]; then
          if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	    else
            $bash_scr -x $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
          fi
        else
          if [[ `echo "$components" | grep -icw "IDMPREINSTALL"` -gt "0" ]]; then
            $idmhcbin/idmhc.sh -manifest $file -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
    	    else
            $idmhcbin/idmhc.sh -manifest $file -topology $fmw_topology -logDir $OUTPUTDIR $RAT_IDMHCARGS >> $xmlcheckresults
          fi
        fi
      fi
      ORACLE_HOME=$OLD_ORACLE_HOME
      idm_xml_outfile=`grep "HealthCheck XML report" $xmlcheckresults |awk '{print $NF}'| tail -1`
      if [ ! -n "$idm_xml_outfile" ] ; then
        echo "Error : failed to run idmhc.sh"
        cat $xmlcheckresults
        idm_xml_outfile=`find $OUTPUTDIR/logs/healthchecker/ -name "IDM_*.xml"|head -1`
      fi
      if [ "$RAT_DEBUG" -eq 1 ] ; then echo "XML Check Collections are in $idm_xml_outfile"; fi

      if [ -e "$ROOT_LCKFIL" ] ; then rm -f $ROOT_LCKFIL >/dev/null 2>&1; fi
    done
  fi
  cd $curr_dir
}

validate_program_zip ()
{
  IS_OUD_MC=0
  IS_WLS_MC=0

  IS_OUD_MC=$(ps -aef | grep -v grep | grep -i org.opends.server.core.DirectoryServer | grep -i config.ldif | wc -l)
  IS_WLS_MC=$(ps -ef | grep -v grep | grep -i weblogic.Name | wc -l) 

  if [[ -z $is_fmw_machine ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
    if [[ -n "$IS_OUD_MC" && $IS_OUD_MC -gt "0" ]] || [[ -n "$IS_WLS_MC" && $IS_WLS_MC -gt "0" ]]; then
      is_fmw_machine=1
      APPTYPE="IDM"
    fi 
  else
    if [[ -n "$IS_OUD_MC" && $IS_OUD_MC -gt "0" ]] || [[ -n "$IS_WLS_MC" && $IS_WLS_MC -gt "0" ]]; then
      echo ""
    else
      echo -e ${RED}"This is not a Identity Mangement setup. Please re-run ${program_name} without Identity Management options."${NORM}
      echo -e ${RED}"${program_name} is exiting.."${NORM}
      echo ""
      exit 1
    fi 
  fi
}

#======================================================================================================================
#Set the defaults
#multilinemb_db_homes_fil 
#RAT_TMPDIR
#if [[ ${program_name} = "exachk" ]]; then TOOL_ID='ec'; else TOOL_ID='oc'; fi
#=====================================================================================================================

#following function is used to test whether exacli utility exists or not
check_EXACLI ()
{
  is_exacli_available=1
  if [[ -z $RAT_EXACLI_CMD ]]; then
    EXACLI_CMD=$(which exacli 2>/dev/null)
    if [[ -z "$EXACLI_CMD" || `echo $?` -ne 0 || `echo "$EXACLI_CMD" | grep -ic "no exacli"` -gt "0" ]]; then
      unset EXACLI_CMD
      is_exacli_available=0
    fi
  else
    EXACLI_CMD=$RAT_EXACLI_CMD
  fi
}

all_cell_ip_max_index=0;
wrong_exacli_password=0;
unable_to_lock_cell=0;
unable_to_unlock_cell=0;
exacli_ip_index=0;
called_to_validate=0;
probe_only_once=0;
exacli_cell_counter=1;

#Following function prompts for exacli password
exacli_passwd_prompt ()
{
  if [[ $EM_PROBE_MODE -eq 1 ]]
  then
    if [[ $probe_only_once -eq 0 ]]
    then
      cat >> ${PROBE_XML}.tmp <<EOF
  <group id="${GID_CC}" groupHeader="${GID_CC_HDR}">
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="SECRET" outcome="No">
    <text nls_id="orhc_exadata_n100_nlsid">Enter password for exacli user to unlock Storage Server</text>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <text nls_id="orhc_exadata_n101_nlsid">Enter exacli password</text>
    <multipart-question>
EOF
      probe_only_once=1;
    else
    cat >> ${PROBE_XML}.tmp <<EOF 
    <question id="q${PROBE_QUES_CNT}o2q1q${exacli_cell_counter}" questionType="SECRET" outcome="No">
      <text>$2</text>
    </question>
EOF
      exacli_cell_counter=$(expr $exacli_cell_counter + 1 )
    fi
  elif [[ $EM_XMLD_MODE -eq 1 ]]
  then
    echo -e "Enter password for EXACLI user $1 to unlock Storage Server $2:"
    if [[ $exacli_password_yesno == "Y" ]];then
      read_probe_xml "Enter password for exacli user to unlock Storage Server"
    else
      read_probe_xml "<text>${2}</text>"
    fi
      exacli_password=$xml_rvalue 
  else
    printf "\n\n"
    tty -s && stty -echo
    $READ -p "`echo $'\n'`Enter password for EXACLI user $1 to unlock Storage Server $2:" exacli_password;
    tty -s && stty echo
    printf "\n\nVerifying Exacli Password\n\n. . . "
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      fixExacliPassword "$exacli_password"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    if [[ -z $exacli_password ]]; then
      return 1;
    else
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    fi
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  fi
 
  if [[ $EM_PROBE_MODE -eq 1 ]]; then return 0; fi
 
  if [[ -z $RAT_EXACLIPASSWORD_TIMEOUT ]]; then
    exaclipasswordcheck_timeout=20
  else
    exaclipasswordcheck_timeout=$RAT_EXACLIPASSWORD_TIMEOUT
  fi

  $EXPECT -f - << IBEOF
    set timeout $exaclipasswordcheck_timeout
    set exacli_usr_password "$exacli_password"
    log_user 0
    if { "$RAT_EXPECT_DEBUG" == "-d" } {
      exp_internal 1
    }    
    spawn -noecho $EXACLI_CMD -l $1 -c $2 -e list cell
    expect {
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
    }
    expect {
      -nocase "*Error: Connection refused*" {
         exit 2  
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
      -nocase "*online*" {
        exit 0  
      }
      -nocase "*offline*" {
        exit 0  
      }
    }
    expect {
      -nocase "*Error: Connection refused*" {
         exit 2  
      }
      -nocase "Cannot login, bad username or password" {
         exit 1
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
      -nocase "*online*" {
        exit 0 
      }
      -nocase "*offline*" {
        exit 0 
      }
    }
    
    expect {
      -nocase "Cannot login, bad username or password" {
         exit 1
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
      -nocase "*online*" {
        exit 0 
      }
      -nocase "*offline*" {
        exit 0 
      }
      -nocase timeout {
        send_error "Timed out while checking exacli password\n";
        exit 1
      }
    }
IBEOF
  exacli_pwd_return_value=$?
  if [[ $exacli_pwd_return_value -eq 1 ]];then
    return 1
  elif [[ $exacli_pwd_return_value -eq 2 ]];then 
    return 2
  else
    return 0
 fi
}

#Following function is used to validate exacli password
validate_exacli_password ()
{
  exacli_pwd_tries="$3"
  exacli_passwd_prompt "$1" "$2"
  return_value_exacli_pwd=$?
  if [[ $return_value_exacli_pwd -eq 0 ]]
   then
   return 1
  fi
  if [[ $return_value_exacli_pwd -eq 1 ]]
  then
    printf "\n\n"
    echo "Invalid exacli password for $2 Storage Server. $exacli_pwd_tries retries remaining.."
    if [[ $exacli_pwd_tries -eq 0 ]]; then
      if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]];then
        echo
      else
        echo -e "\n\nWrong EXACLI password. Storage Server related checks will be skipped on $2" | tee -a $LOGFIL
        add_to_skipped_nodes "$2" "Unable to unlock Storage server because of invalid exacli password"
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
          EMSG="Unable to unlock Storage server because of invalid exacli password"
          update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
      fi
      return 0
    else
      exacli_pwd_tries=`expr $exacli_pwd_tries - 1`
      validate_exacli_password "$1" "$2" "$exacli_pwd_tries"
    fi
  elif [[ $return_value_exacli_pwd -eq 2 ]];then
    printf "\n\n"
    echo -e "Error: Connection refused for $2"
    if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]];then
      echo
    else
      add_to_skipped_nodes "$2" "Error: Connection refused."
    fi
    return 2
  fi
  
}

#following function lock the cells using exacli utility
lock_storage_cell_exacli ()
{
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  $EXPECT -f - << IBEOF
    set exacli_usr_password "$3"
    log_user 0
    if { "$RAT_EXPECT_DEBUG" == "-d" } {
      exp_internal 1
    }    
    spawn $EXACLI_CMD -l $1 -c $2 -e "alter cell accessLevelTemp=\"\""
    expect {
      -nocase "Cannot login, bad username or password" {
         exit 0
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
    }
    expect {
      -nocase "Cannot login, bad username or password" {
         exit 0
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
     -nocase "*?uccessfully altered*" {
      exit 1
      } 
    }
   expect {
      -nocase "Cannot login, bad username or password" {
         exit 0
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
     -nocase "*?uccessfully altered*" {
        exit 1
      }
    }
IBEOF
  cell_exacli_lock_status=$(echo $?);
  return $cell_exacli_lock_status;
}

#following function unlock the cells using exacli utility
cell_unlocked_flag=0
unlock_storage_cell_exacli ()
{
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  if [[ -z "$RAT_CELLUNLOCK_TIMEOUT" ]];then
    cell_lock_duration="50m"
  else
    cell_lock_duration=$RAT_CELLUNLOCK_TIMEOUT
  fi
    $EXPECT -f - << IBEOF
    set exacli_usr_password "$3"
    log_user 0
    if { "$RAT_EXPECT_DEBUG" == "-d" } {
      exp_internal 1
    }    
    spawn $EXACLI_CMD -l $1 -c $2 -e "alter cell accessLevelTemp=((accessLevel=\"remoteLoginEnabled\", startTime=\"now\", duration=\"$cell_lock_duration\", reason=\"Running Exachk\"))"
    expect {
      -nocase "Cannot login, bad username or password" {
         exit
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
    }
    expect {
      -nocase "Cannot login, bad username or password" {
         exit
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
      -nocase "*?uccessfully altered*" {
        exit 1
      }
    }
    expect {
      -nocase "Cannot login, bad username or password" {
         exit 0
      }
      -nocase "Do you want to accept and store this certificate*" {
        send -- "y\n"
      }
      -nocase "*?assword:*" {
        send -- "\$exacli_usr_password\n"
      }
      -nocase "*?uccessfully altered*" {
        exit 1
      }
    }
IBEOF
  cell_exacli_unlock_status=$(echo $?);
  return $cell_exacli_unlock_status;
}

passwordcheck_timeout=10
#Following function is used to test whether storage cell is locked
is_cell_locked ()
{
  cell_locked=0
  unlock_status=$(/usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -o ConnectTimeout=$passwordcheck_timeout -l "$2" "$1" ls 2>&1 | tr -d '\r')
  if [[ `echo "$unlock_status"|grep -ic 'Connection refused'` -gt 0 ]];
  then
    cell_locked=1
  fi
}

#following function prompts exacli user
exacli_user_prompt ()
{
  if [ -z "$READ" ]; then
    READ="read"
  fi

  if [[ $EM_PROBE_MODE -eq 1 ]]
  then  
    cat >> ${PROBE_XML}.tmp <<EOF 
<group id="${GID_CC}" groupHeader="${GID_CC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n98_nlsid">
      Enter exacli user name:
    </text>
  </question>
</group>
EOF
PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1)
cat >> ${PROBE_XML}.tmp <<EOF 
<group id="${GID_CC}" groupHeader="${GID_CC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" outcome="No">
    <text nls_id="orhc_exadata_n99_nlsid">Use the same exacli password on all Storage Servers</text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" qid="q${PROBE_QUES_CNT}o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
  elif [[ $EM_XMLD_MODE -eq 1 ]]
  then
    echo -e "\n\nEnter exacli user name:"
    read_probe_xml "Enter exacli user name:"
    exacli_user=$xml_rvalue
  else
    printf "\n\n"
    exec 3<&2; exec 2<&0
    $READ -p "`echo $'\n'`Enter exacli user name:" exacli_user;
    read_code=`echo $?`;
    exec 2<&3
    write_in_env "EXACLI_UTILITY_USER" "$exacli_user"
    process_prompt "$read_code" "exacli_user" "$EXACLI_USER_INDEX"
  fi
 
  if [[ $EM_XMLD_MODE -eq 1 ]]	
  then 
    echo -e "Is EXACLI password same on all Storage Servers?[y/n][y]"
    read_probe_xml "Use the same exacli password on all Storage Servers"
    exacli_password_yesno=$xml_rvalue
  else
    printf "\n\n"
    exec 3<&2; exec 2<&0
    $READ -p "`echo $'\n'`Is EXACLI password same on all Storage Servers?[y/n][y]" exacli_password_yesno;
    exec 2<&3
    process_prompt "$read_code" "exacli_password_yesno" "y"
  fi
		
  if [ -z $exacli_password_yesno ]
  then
    exacli_password_yesno="empty" 
  fi
  case $exacli_password_yesno in
  y|Y|Yes|YES|yes)
    exacli_password_yesno="Y"
  ;;
  n|N|No|NO|no)
    exacli_password_yesno="N"
  ;;
  esac
}

unlock_storage_cells ()
{
  if [[ $command_arguments == *"-unlockcells"* && $command_arguments == *"-cells"* ]];then
    #cli_cells=$(echo $command_arguments | awk '{print $3}')
    cli_cells=$(echo "$RAT_CELLS")
    temp_cells=$(echo $cli_cells | tr "," "\n")
    for single_cellip in $temp_cells
    do
      echo "cell=\"$single_cellip\"" >> $WRKDIR/cellip2.ora
    done
    CELLIP="$WRKDIR/cellip2.ora"
  fi

  if [[ -z $CELLIP ]];then
    if [[ -f "/etc/oracle/cell/network-config/cellip.ora" ]];then
      CELLIP="/etc/oracle/cell/network-config/cellip.ora"
    else    
      if [[ $unlockcells_through_commandline -eq 1 ]];then
        echo -e "\n${RED}No cell IPs found.\n\n${program_name} exiting .....\n${NORM}"
        exit 1;
      fi      
      return
    fi
  fi
  
  check_EXACLI
  if [[ -n $is_exacli_available && $is_exacli_available -eq "1" ]]; then
    exacli_passwd_list_index=0
    exacli_passwdonly_list_index=0
    for cell_ip in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`  
    do
      node_pingable $cell_ip
      if [[ $pingable -eq "1" ]] ; then    
      if [[ -z $cell_ssh_user ]];then
        if [[ -z "$RAT_CELL_SSH_USER" ]];then cell_ssh_user="root"; else cell_ssh_user=$RAT_CELL_SSH_USER;fi
      fi 
        is_cell_locked "$cell_ip" "$cell_ssh_user"
        if [[ $EM_PROBE_MODE -eq 1 ]];then
          cell_locked=1;
        fi
        if [[ $cell_locked -eq 1 ]]; then
          if [[ -z $exacli_password_yesno ]]; then
            exacli_user_prompt
          fi
          if [[ -n $exacli_password_yesno && $exacli_password_yesno == "empty" ]] || [[ -n $exacli_password_yesno && $exacli_password_yesno == "Y" ]]; then
            exacli_password_yesno="Y"
            if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            if [[ -z $global_exacli_passwd ]] && [[ $called_to_validate -eq "0" ]]; then
              called_to_validate=1
              validate_exacli_password "$exacli_user" "$cell_ip" "2"
              if [[ $? -eq "1" ]];then
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                global_exacli_passwd=$exacli_password;
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              else
                if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]];then
                  echo -e "\n\n${program_name} is exiting.${NORM}\n\n";
                  exit
                fi                                  
                wrong_exacli_password=1;
              fi
            else
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi
            if [[ $EM_PROBE_MODE -eq 1 ]];then
               validate_exacli_password "$exacli_user" "$cell_ip" "2"
            fi
            if [[ $wrong_exacli_password -eq "1" ]];then
              exacli_all_ip[exacli_ip_index]="$cell_ip"
              exacli_ip_index=`expr $exacli_ip_index + 1`
              exacli_all_ip[exacli_ip_index]=" "
              exacli_ip_index=`expr $exacli_ip_index + 1`
              sed "/$cell_ip/d" $CELLIP > $CELLIP.2
              mv -f $CELLIP.2 $CELLIP
            fi
            if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            if [[ -n $global_exacli_passwd ]];then
              unlock_storage_cell_exacli "$exacli_user" "$cell_ip" "$global_exacli_passwd"
              if [[ $? -eq "1" ]];then
                unlocked_storage_cell=1;
                exacli_passwd_list[exacli_passwd_list_index]="$cell_ip"
                exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                exacli_passwd_list[exacli_passwd_list_index]="$global_exacli_passwd"
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                exacli_passwdonly_list[exacli_passwdonly_list_index]="$exacli_password"
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                exacli_passwdonly_list_index=`expr $exacli_passwdonly_list_index + 1`
              fi
              exacli_all_ip[exacli_ip_index]="$cell_ip"
              exacli_ip_index=`expr $exacli_ip_index + 1`
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              exacli_all_ip[exacli_ip_index]="$global_exacli_passwd"
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              exacli_ip_index=`expr $exacli_ip_index + 1`
            else
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi                                      
          else
            validate_exacli_password "$exacli_user" "$cell_ip" "2"
            if [[ $? -eq "1" ]];then
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              unlock_storage_cell_exacli "$exacli_user" "$cell_ip" "$exacli_password"
              if [[ $? -eq "1" ]];then
                unlocked_storage_cell=1;
                exacli_passwd_list[exacli_passwd_list_index]="$cell_ip"
                exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                exacli_passwd_list[exacli_passwd_list_index]="$exacli_password"
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                exacli_passwdonly_list[exacli_passwdonly_list_index]="$exacli_password"
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                exacli_passwdonly_list_index=`expr $exacli_passwdonly_list_index + 1`
              fi
              exacli_all_ip[exacli_ip_index]="$cell_ip"
              exacli_ip_index=`expr $exacli_ip_index + 1`
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              exacli_all_ip[exacli_ip_index]="$exacli_password"
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              exacli_ip_index=`expr $exacli_ip_index + 1`
            else
              if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]]; then
                echo -e "\n\nWrong password for $cell_ip"
              fi
              exacli_all_ip[exacli_ip_index]="$cell_ip"
              exacli_ip_index=`expr $exacli_ip_index + 1`
              exacli_all_ip[exacli_ip_index]=" "
              exacli_ip_index=`expr $exacli_ip_index + 1`
              if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]]; then
                echo
              else
                sed "/$cell_ip/d" $CELLIP > $CELLIP.2
                mv -f $CELLIP.2 $CELLIP
              fi
            fi
          fi
          all_cell_ip_max_index=$exacli_ip_index
        else 
          if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]]; then
            echo -e "\n\n$cell_ip is already unlocked."
          fi
        fi
      fi
    done

    if [[ -e $WRKDIR/cellip2.ora ]];then 
      rm -f $WRKDIR/cellip2.ora
    fi

    if [[ -n $unlocked_storage_cell && $unlocked_storage_cell -eq 1 ]];then
      echo -e "\n\nUnlocking Storage Server...\n\n"
      cell_ip_max_index=$exacli_passwd_list_index
      for (( exacli_passwd_list_index = 0; exacli_passwd_list_index < $cell_ip_max_index; exacli_passwd_list_index++ ))
      do 
        exacli_locked_period_timeout=0
        is_cell_locked "${exacli_passwd_list[exacli_passwd_list_index]}" "$cell_ssh_user"
        if [[ -n $cell_locked && $cell_locked -eq 1 ]]; then
          while [ $cell_locked -eq 1 ]
          do
            is_cell_locked "${exacli_passwd_list[exacli_passwd_list_index]}" "$cell_ssh_user"
            sleep 3
            exacli_locked_period_timeout=`expr $exacli_locked_period_timeout + 3`
            if [[ $exacli_locked_period_timeout -eq "300" ]]; then
              echo -e "\n\nTimeout: Unable to unlock the storage Server $cell_ip"
              if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]]; then
                echo 
              else
                add_to_skipped_nodes "$cell_ip" "Storage server is not reachable"
              fi
              break
            fi
            printf  ". "
          done
        fi
        exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
      done
      echo -e "\n";
    else
      if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]]; then
        echo -e "\n\n${program_name} is exiting.${NORM}\n\n";
      fi
    fi
  else
    if [[ -n $exacli_command_line_enabled && $exacli_command_line_enabled -eq 1 ]]; then
      echo -e "\n\nExacli utility does not exist.\n\n${program_name} is exiting.${NORM}\n\n"
      exit
    fi
  fi
  if [[ $EM_PROBE_MODE -eq 1 && $probe_only_once -eq 1 ]];then
    PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
    cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
  fi
}


#Following function locks the storage cells using exacli through command line
lock_storage_cells ()
{  
  if [[ $command_arguments == *"-lockcells"* && $command_arguments == *"-cells"* ]];then
    #cli_cells=$(echo $command_arguments | awk '{print $3}')
    cli_cells=$(echo "$RAT_CELLS")
    temp_cells=$(echo $cli_cells | tr "," "\n")

    for single_cellip in $temp_cells
    do
      echo "cell=\"$single_cellip\"" >> $WRKDIR/cellip2.ora
    done
    CELLIP="$WRKDIR/cellip2.ora"
  fi

  if [[ -z $CELLIP ]]; then
    if [[ -f "/etc/oracle/cell/network-config/cellip.ora" ]];then
      CELLIP="/etc/oracle/cell/network-config/cellip.ora"
    else
      if [[ $lockcells_through_commandline -eq 1 ]];then
        echo -e "\n${RED}No cell IPs found.\n\n${program_name} exiting .....\n${NORM}"
        exit 1;
      fi
      return
    fi
  fi

  if [[ -z $RAT_EXACLI_ENABLED ]] || [[ -n $RAT_EXACLI_ENABLED && $RAT_EXACLI_ENABLED -eq "1" ]]; then
    check_EXACLI
    if [[ -n $is_exacli_available && $is_exacli_available -eq "1" ]]; then
      exacli_passwd_list_index=0
      exacli_passwdonly_list_index=0
      for cell_ip in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
      do
        node_pingable $cell_ip
        if [[ $pingable -eq "1" ]] ; then
          if [[ -z $cell_ssh_user ]];then
            if [[ -z "$RAT_CELL_SSH_USER" ]];then cell_ssh_user="root"; else cell_ssh_user=$RAT_CELL_SSH_USER;fi
          fi
          is_cell_locked "$cell_ip" "$cell_ssh_user"
          if [[ $cell_locked -eq 1 ]]; then
            echo -e "\n\n$cell_ip is already locked."
            continue;
          fi

          if [[ -z $exacli_password_yesno ]]; then
            exacli_user_prompt
          fi
          if [[ -n $exacli_password_yesno && $exacli_password_yesno == "empty" ]] || [[ -n $exacli_password_yesno && $exacli_password_yesno == "Y" ]]; then
            exacli_password_yesno="Y"
            if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            if [[ -z $global_exacli_passwd ]] && [[ $called_to_validate -eq "0" ]]; then
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              called_to_validate=1
              validate_exacli_password "$exacli_user" "$cell_ip" "2"
              if [[ $? -eq "1" ]];then
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                global_exacli_passwd=$exacli_password;
                if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              elif [[ $? -eq "2" ]];then
                echo -e "\n\n${program_name} is exiting.${NORM}\n\n"
                exit
              else
                echo -e "\n\nWrong exacli password.\n\n${program_name} is exiting.${NORM}\n\n"
                exit
              fi
            else
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi
            if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            if [[ -n $global_exacli_passwd ]];then
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              unlocked_storage_cell=1;
              exacli_passwd_list[exacli_passwd_list_index]="$cell_ip"
              exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              exacli_passwd_list[exacli_passwd_list_index]="$global_exacli_passwd"
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              exacli_passwdonly_list[exacli_passwdonly_list_index]="$exacli_password"
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              exacli_passwdonly_list_index=`expr $exacli_passwdonly_list_index + 1`

              exacli_all_ip[exacli_ip_index]="$cell_ip"
              exacli_ip_index=`expr $exacli_ip_index + 1`
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              exacli_all_ip[exacli_ip_index]="$global_exacli_passwd"
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              exacli_ip_index=`expr $exacli_ip_index + 1`
            else
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi
          else
            if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            validate_exacli_password "$exacli_user" "$cell_ip" "2"
            if [[ $? -eq "1" ]];then
              unlocked_storage_cell=1

              exacli_passwd_list[exacli_passwd_list_index]="$cell_ip"
              exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              exacli_passwd_list[exacli_passwd_list_index]="$exacli_password"
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`

              exacli_all_ip[exacli_ip_index]="$cell_ip"
              exacli_ip_index=`expr $exacli_ip_index + 1`
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              exacli_all_ip[exacli_ip_index]="$exacli_password"
              if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              exacli_ip_index=`expr $exacli_ip_index + 1`
            elif [[ $? -eq "2" ]];then
              echo
            else
              echo -e "\n\nWrong exacli password for $cell_ip"
              exacli_all_ip[exacli_ip_index]="$cell_ip"
              exacli_ip_index=`expr $exacli_ip_index + 1`
              exacli_all_ip[exacli_ip_index]=" "
              exacli_ip_index=`expr $exacli_ip_index + 1`
            fi
          fi
          all_cell_ip_max_index=$exacli_ip_index
        else
          echo -e "\n\nStorage cells $cell_ip is not pingable"
        fi
      done

      if [[ -e $WRKDIR/cellip2.ora ]]; then
        rm -f $WRKDIR/cellip2.ora
      fi

      if [[ -n $unlocked_storage_cell && $unlocked_storage_cell -eq 1 ]];then
        cell_ip_max_index=$exacli_passwd_list_index
        echo -e "\n\nLocking the Storage Servers..."
        for (( exacli_passwd_list_index = 0; exacli_passwd_list_index < $cell_ip_max_index; exacli_passwd_list_index++ ))
        do
          cell_ip=${exacli_passwd_list[exacli_passwd_list_index]}
          exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
          if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
          lock_storage_cell_exacli "$exacli_user" "$cell_ip" "${exacli_passwd_list[exacli_passwd_list_index]}"
          if [[ $? -eq "0" ]]; then
            echo -e "\n\nUnable to lock Storage Server $cell_ip"
          fi
        done
        echo -e "\n";
      else
        echo -e "\n\n${program_name} is exiting.${NORM}\n\n";
        exit
      fi
    else
      echo -e "\n\nExacli utility does not exist.\n\n${program_name} is exiting.${NORM}\n\n"
      exit
    fi
  fi
}

#Following function is used to get the directories to perform file attribute changes
get_check_dirs ()
{
  CHECK_DIRS=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-includedir") print $(i+1)}')
  if [[ -n $CHECK_DIRS && $exlude_discovered_dir -eq 1 ]];then
    export CHECK_DIRS=$CHECK_DIRS
    CHECK_DIRS_PRINT=$(echo $CHECK_DIRS| sed 's/,/\\n/g')
    echo -e "\nList of directories(recursive) for checking file attributes:\n\n$CHECK_DIRS_PRINT"
  else
    ALL_ORACLE_DB_HOME=`grep 'DB_NAME' $MASTERFIL |$AWK -F'|' '{print $NF}'|sort|uniq`
    for db_home_temp in $ALL_ORACLE_DB_HOME
    do 
      dir_owner=$(ls -l $db_home_temp |$AWK '{print $3}'|sort|uniq|grep $usern)
      if [[ -n $dir_owner || $usern == "root" ]];then
        echo
      else
        ALL_ORACLE_DB_HOME=$(echo $ALL_ORACLE_DB_HOME | sed "s|^$db_home_temp$||g")
      fi
    done
    if [[ -n $CRS ]];then
      dir_owner=$(ls -ld $CRS |tail -1|$AWK '{print $3}'|sort|uniq|grep $usern)
      if [[ -n $dir_owner || $usern == "root" ]];then
        DISCOVERED_DIRS=$CRS
      fi
      if [[ -n $ALL_ORACLE_DB_HOME ]];then
        DISCOVERED_DIRS="$DISCOVERED_DIRS $ALL_ORACLE_DB_HOME"
      fi    
    else  
      if [[ -n $ALL_ORACLE_DB_HOME ]];then
        DISCOVERED_DIRS="$ALL_ORACLE_DB_HOME"
      fi    
    fi    
    if [[ -n $DISCOVERED_DIRS ]];then
      DISCOVERED_DIRS=$(echo $DISCOVERED_DIRS| sed 's/ /,/g')
      if [[ -n $CHECK_DIRS ]];then
        DISCOVERED_DIRS="$DISCOVERED_DIRS,$CHECK_DIRS"
      fi
      DISCOVERED_DIRS_PRINT=$(echo $DISCOVERED_DIRS| sed 's/,/\\n/g')
      echo -e "\nList of directories(recursive) for checking file attributes:\n\n$DISCOVERED_DIRS_PRINT"
      export DISCOVERED_DIRS=$DISCOVERED_DIRS
    else
      if [[ -n $CHECK_DIRS ]];then
        export DISCOVERED_DIRS="$CHECK_DIRS"
        DISCOVERED_DIRS_PRINT=$(echo $CHECK_DIRS| sed 's/,/\\n/g')
        echo -e "\nList of directories(recursive) for checking file attributes:\n\n$DISCOVERED_DIRS_PRINT"
      else
        echo -e "\n${RED}${program_name} did not discover any Grid Infrastructure or RDBMS ORACLE_HOME to check file attributes.\n${NORM}";
        if [[ $daemon_running -eq "1" ]] ; then
          log_daemon "\n${program_name} did not discover any Grid Infrastructure or RDBMS ORACLE_HOME to check file attributes.\n"
        fi
        echo -e "${RED}${program_name} is exiting...\n$NORM";
        exit 1;
      fi
    fi
  fi

}

#Following function is used to create or search for output directory to store the snashots of filechecking
get_output_dir_for_filecheck ()
{
  output_file_tag=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-tag") print $(i+1)}') 
  filecheck_out_path=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-baseline") print $(i+1)}')
  if [[ -z $filecheck_out_path ]];then
    filecheck_out_path=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-output") print $(i+1)}')
    if [[ -z $filecheck_out_path ]];then
      filecheck_out_path=$WRKDIR
    fi
    #filecheck_out_dir="$filecheck_out_path/${program_name}_Snapshot_files"
    if [[ -z $timestamp ]];then
      timestamp=$(date '+%Y%m%d_%H%M%S')
    fi
    HOSTNAME=$(echo "$HOSTNAME"|$AWK -F"." '{print $1}');
    if [[ $command_arguments == *"-fileattr start"* ]];then
      filecheck_out_dir="$filecheck_out_path/${program_name}_${HOSTNAME}_${timestamp}"
      if [[ -n $output_file_tag ]];then
        output_file_tag=$(echo $output_file_tag|sed 's/ /_/g')
        filecheck_out_dir="$filecheck_out_path/${program_name}_${HOSTNAME}_${timestamp}_${output_file_tag}" 
      fi
      if [[ ! -d $filecheck_out_dir ]];then
        mkdir $filecheck_out_dir >/dev/null 2>&1;
      fi
    elif [[ $command_arguments == *"-fileattr check"*  ]];then
      dir_count=$(ls $filecheck_out_path|grep ${program_name}_${HOSTNAME}_ | wc -l)
      i_dir=1;
      while [[ $i_dir -le $dir_count ]]
      do
        filecheck_out_dir=$(ls -r $filecheck_out_path |grep ${program_name}_${HOSTNAME}_ | head -n $i_dir | tail -1)
        filecheck_out_dir="$filecheck_out_path/$filecheck_out_dir"
        snap_exist=$(ls ${filecheck_out_dir} |grep Snapshot_ |wc -l)
        file_snapshot=$(ls ${filecheck_out_dir} |grep Snapshot_ )
        if [[ -n $filecheck_out_dir && $snap_exist -eq 1 ]];then
          break;
        fi 
        i_dir=$(expr $i_dir + 1)
      done
      if [[ $snap_exist -eq 0 ]];then
        echo -e "\n${RED}Snapshot does not exist to check file attributes.\n${NORM}";
        if [[ $daemon_running -eq "1" ]] ; then
          log_daemon "\nSnapshot does not exist to check file attributes.\n"
        fi
        echo -e "${RED}${program_name} is exiting...\n$NORM";
        exit 1;
      fi
    fi 
  else
    filecheck_out_dir=$(dirname $filecheck_out_path)
    if [[ ! -d $filecheck_out_dir ]];then
      echo -e "\n${RED}$filecheck_out_dir : No such directory found to check file attributes.\n${NORM}";
      echo -e "${RED}${program_name} is exiting...\n$NORM";
      exit 1;
    fi
  fi
  if [[ ! -w $filecheck_out_dir ]];then
    echo -e "\n${RED}Insufficient privilege for writing in directory $filecheck_out_dir\n${NORM}";
    echo -e "${RED}${program_name} is exiting...\n$NORM";
    exit 1;
  fi 
  export FILECHECK_OUTPUT_DIR="$filecheck_out_dir"
}

#Following function keeps on looping till the filechecker.sh script run in background
keep_looping_for_filechecker ()
{
  if [[ -z "$RAT_TIMEOUT" ]];then
    max_loop_limit=120;
  else
    max_loop_limit=$RAT_TIMEOUT;  
  fi
  keep_looping=1
  loop_limit=0;
  while [[ $keep_looping -eq "1" ]]
  do
    if [[ `ps -ef | grep -c rac_file_checker.pl|grep -v 'grep'` -gt 0 ]]; then
      printf ". "
      sleep 3
      loop_limit=`expr $loop_limit + 3`
      if [[ $loop_limit -ge $max_loop_limit ]]; then
        keep_looping=0;
        break;
      fi
    else
      keep_looping=0
      echo -e "\n";
    fi
  done
}

#Following function is used to perform critical filechecking
start_file_checker ()
{
  get_check_dirs 
  get_output_dir_for_filecheck
  if [[ -z $CRS ]];then
    echo -e "\n${RED}CRS is not installed. File attribute checking can not be performed.\n${NORM}";
    echo -e "${RED}${program_name} is exiting...\n$NORM";
    if [[ $daemon_running -eq "1" ]] ; then
      log_daemon "\nCRS is not installed. File attribute checking can not be performed.\n"
    fi
    exit 1;
  fi 
  filechecker_arg=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-fileattr") print $(i+1)}')
  if [[ $filechecker_arg == "start" ]];then
    if [[ -n $CHECK_DIRS && $exlude_discovered_dir -eq 1 ]];then
      echo -e "$CHECK_DIRS_PRINT" |sort > $filecheck_out_dir/start_dir.txt
    else
      echo -e "$DISCOVERED_DIRS_PRINT" |sort > $filecheck_out_dir/start_dir.txt
    fi
    old_snapshot_files=$(ls ${filecheck_out_dir} |grep Snapshot_ |$AWK -F"." '{print $1}' | $AWK '{print $0}')
    if [[ -n $old_snapshot_files ]];then
      mv $filecheck_out_dir ${filecheck_out_path}/${program_name}_$old_snapshot_files
    fi
    if [[ ! -d $filecheck_out_dir ]];then
      mkdir $filecheck_out_dir >/dev/null 2>&1;
    fi
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" ]]; then
      $bash_scr -x $SCRIPTPATH/.cgrep/filechecker.sh "start"
      $bash_scr -x $SCRIPTPATH/.cgrep/filechecker.sh "check"
    else
      $SCRIPTPATH/.cgrep/filechecker.sh "start"
      $SCRIPTPATH/.cgrep/filechecker.sh "check"
    fi
    keep_looping_for_filechecker
    file_snapshot=$(ls ${filecheck_out_dir} |grep Snapshot_ )
    echo -e "\n\n${program_name} has taken snapshot of file attributes for above directories at: $filecheck_out_dir/$file_snapshot\n"
    exit 0;
  elif [[ $filechecker_arg == "check" ]];then
    if [[ -z $DISCOVERED_DIRS_PRINT ]];then  
      DISCOVERED_DIRS_PRINT=$CHECK_DIRS_PRINT
    fi
    echo -e "$DISCOVERED_DIRS_PRINT" |sort > $filecheck_out_dir/check_dir.txt
    uncheck_dir=$(comm -1 -3 $filecheck_out_dir/start_dir.txt $filecheck_out_dir/check_dir.txt);
    if [[ -n $uncheck_dir ]];then
      echo -e "\nSnapshot for following directories does not exist:\n"
      echo -e "$uncheck_dir\n"
      if [[ $daemon_running -eq "1" ]] ; then
        log_daemon "\nSnapshot for following directories does not exist:\n $uncheck_dir"
      fi
    fi
    echo -e "\nChecking file attribute changes...\n";
  
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" ]]; then
      if [[ -z $file_snapshot ]];then
        file_snapshot=$(ls ${filecheck_out_dir} |grep Snapshot_ )
      fi
      $bash_scr -x $SCRIPTPATH/.cgrep/filechecker.sh "check"
      keep_looping_for_filechecker
     else
      file_snapshot=$(ls ${filecheck_out_dir} |grep Snapshot_ )
      $SCRIPTPATH/.cgrep/filechecker.sh "check"
      keep_looping_for_filechecker
    fi
    if [[ -e $filecheck_out_dir/Email_Warning ]];then
      if [[ $daemon_running -eq "1" ]] ; then
        file_changes=$(cat $filecheck_out_dir/Email_Warning) 
        log_daemon "$file_changes"
      fi
    fi
  elif [[ $filechecker_arg == "remove" ]];then
    echo -e "\nRemoving file attribute related files...\n";
    rm -rf ${filecheck_out_path}/${program_name}_${HOSTNAME}_* >/dev/null 2>&1;
  fi    
  return 0
}

#This function used to perform pre setup before calling validate_email
pre_email_validation ()
{
  if [[ $(echo $command_arguments|grep -ic "NOTIFICATION_EMAIL") -gt 0 ]];then 
    if [[ -n $test_email_config && $test_email_config -eq 1 ]];then 
      list_of_ids=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-testemail") print $(i+1)}')
    elif [[ $command_arguments == *"-sendemail"* ]];then 
      list_of_ids=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-sendemail") print $(i+1)}')
    fi
    list_of_ids=$(echo "$list_of_ids" | $AWK -F"=" '{print $2}' | $AWK '{print $1}')
    list_of_ids=$(echo $list_of_ids | sed 's/,/ /g');
    for email_id in $list_of_ids
    do
      validate_email "$email_id"
      if [[ $? -eq 1 ]];then 
        echo    
      else    
        echo -e "\n\n${RED}$email_id is an invalid email address. please enter valid email address and try again.${NORM}\n";
        exit 1; 
      fi      
    done    
  fi
}

valid_input_format_flag=0;

# The following function validate command line arguments it returns 0 if command argument is valid otherswise it return some number gt 0
validate_arguments()
{
  if [[ $command_arguments == *"-profile"* ]];then
    if [[ $command_arguments == *"-excludeprofile"* ]];then
      return 1;
    fi
    return 0;
  fi
  if [[ $command_arguments == *"-set"* ]];then
    if [[ $(echo $command_arguments|grep -ic "AUTORUN_SCHEDULE") -gt 0 ]];then
      modified_command_arguments=$(echo "$command_arguments"|sed "s/;/ ;/g")
      modified_command_arguments=$(echo "$modified_command_arguments"|tr [A-Z] [a-z]|sed "s/=/ =/g")
      list_of_hours=$(echo "$modified_command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="autorun_schedule") print $(i+1)}')
      list_of_hours=$(echo $list_of_hours |sed "s/=//")
      list_of_date=$(echo "$modified_command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="autorun_schedule") print $(i+2)}')
      list_of_months=$(echo "$modified_command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="autorun_schedule") print $(i+3)}') 
      list_of_days=$(echo "$modified_command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="autorun_schedule") print $(i+4)}')
      if [[ "\"$list_of_hours\"" == "\"*\"" ]];then
        valid_input_format_flag=1;
      else
        validate_hour $list_of_hours
        if [[ $valid_input_format_flag -eq 2 ]];then
          return 2; 
        fi
      fi
      if [[ "\"$list_of_date\"" == "\"*\"" ]];then
        valid_input_format_flag=1;
      else
        validate_date $list_of_date
        if [[ $valid_input_format_flag -eq 3 ]];then
          return 3;
        fi
      fi
      if [[ "\"$list_of_months\"" == "\"*\"" ]];then
        valid_input_format_flag=1;
      else
        validate_month $list_of_months
        if [[ $valid_input_format_flag -eq 4 ]];then
          return 4;
        fi
      fi
  
      if [[ "\"$list_of_days\"" == "\"*\"" ]];then
        valid_input_format_flag=1;
      else
        validate_day $list_of_days
        if [[ $valid_input_format_flag -eq 5 ]];then
          return 5;
        fi
      fi
    fi
    if [[ $(echo $command_arguments|grep -ic "NOTIFICATION_EMAIL") -gt 0 ]];then
      modified_command_arguments=$(echo "$command_arguments"|sed "s/;/ ; /g")
      modified_command_arguments=$(echo "$modified_command_arguments"|tr [A-Z] [a-z]|sed "s/=/ =/g")
      list_of_ids=$(echo "$modified_command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="notification_email") print $(i+1)}')
      list_of_ids=$(echo "$list_of_ids" | $AWK -F"=" '{print $2}' | $AWK '{print $1}')       
      list_of_ids=$(echo $list_of_ids |sed 's/,/ /g')
      for email_id in $list_of_ids
      do
         validate_email "$email_id"
         if [[ $? -eq 1 ]];then
           echo
         else 
           echo -e "\n\n$email_id is an invalid email id. please enter valid email id and try again.\n";
           exit 1;
         fi
      done
    fi
  elif [[ $command_arguments == *"-sendemail"* ]];then
    pre_email_validation
  else
    return 0;
  fi
}

#following function takes an array and an element as arguments and returns index position of element in the array
get_element_index_in_array ()
{
modified_command_arguments=("${!1}")
for item_in_command_arguments in "${!modified_command_arguments[@]}";
do
   if [[ "${modified_command_arguments[$item_in_command_arguments]}" = "$2" ]];
       then
       return "${item_in_command_arguments}";
   fi
done
}


#validate_hour function validate for valid hours in 0-23 range
validate_hour ()
{
for element_for_validation in $(echo $1 | sed "s/,/ /g")
do
  if [ "$element_for_validation" -eq "$element_for_validation" ] 2>/dev/null;
  then
    if [[ "element_for_validation" -ge 0 && "$element_for_validation" -le 23 ]]
    then
      continue;
    else
      valid_input_format_flag=2
      break;
    fi
  else
   valid_input_format_flag=2
   break;
  fi
done
return $valid_input_format_flag;
}

#validate_date function validate for valid date in 1-31 range
validate_date ()
{
for element_for_validation in $(echo $1 | sed "s/,/ /g")
do
  if [ "$element_for_validation" -eq "$element_for_validation" ] 2>/dev/null;
  then
    if [[ "element_for_validation" -ge 1 && "$element_for_validation" -le 31 ]]
    then
      continue;
    else
      valid_input_format_flag=3
      break;
    fi
  else
   valid_input_format_flag=3
   break;
  fi
done
return $valid_input_format_flag;
}

#validate_day function validate for valid day in 0-6 range
validate_day ()
{
for element_for_validation in $(echo $1 | sed "s/,/ /g")
do
  if [ "$element_for_validation" -eq "$element_for_validation" ] 2>/dev/null;
  then
    if [[ "element_for_validation" -ge 0 && "$element_for_validation" -le 6 ]]
    then
      continue;
    else
      valid_input_format_flag=5
      break;
    fi
  else
   valid_input_format_flag=5
   break;
  fi
done
return $valid_input_format_flag;
}

#validate_month function validate for valid month in 1-12 range
validate_month ()
{
for element_for_validation in $(echo $1 | sed "s/,/ /g")
do
  if [ "$element_for_validation" -eq "$element_for_validation" ] 2>/dev/null;
  then
    if [[ "element_for_validation" -ge 1 && "$element_for_validation" -le 12 ]]
    then
      continue;
    else
      valid_input_format_flag=4
      break;
    fi
  else
   valid_input_format_flag=4
   break;
  fi
done
return $valid_input_format_flag;
}

command_arguments="$@";
validate_arguments;
validate_argument_return_value=$?;
if [[ $validate_argument_return_value == 1 ]]
then
  echo "-profile and -excludeprofile options are mutually exclusive. Make use of any one option at a time. Exiting the program.";
  exit;
fi
#Following code sengment is used to validate accurate values for autorun_schedule
if [ $valid_input_format_flag -eq 2 ]
then
  echo -e "\n${RED} Inaccurate hour values for autorun schedule. Please enter values in 0-23 range. \n\n ${program_name} exiting .....\n${NORM}"
  exit 1;
fi

if [ $valid_input_format_flag -eq 3 ]
then
  echo -e "\n${RED} Inaccurate day of month for autorun schedule. Please enter values in 1-31 range. \n\n ${program_name} exiting .....\n${NORM}"
  exit 1;
fi

if [ $valid_input_format_flag -eq 4 ]
then
  echo -e "\n${RED} Inaccurate month values for autorun schedule. Please enter values in 1-12 range. \n\n ${program_name} exiting .....\n${NORM}"
  exit 1;
fi

if [ $valid_input_format_flag -eq 5 ]
then
  echo -e "\n${RED} Inaccurate day of week for autorun schedule. Please enter values in 0-6 range. \n\n ${program_name} exiting .....\n${NORM}"
  exit 1;
fi

#Following functions set the database home path for wallet functionality execution.
setdbHomeforWallet ()
{
  if [[ -n $CRS ]];then
    if [[ -z $RAT_UPLOAD_ORACLE_HOME ]];then
      RAT_UPLOAD_ORACLE_HOME="$CRS";
      export RAT_UPLOAD_ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME"
    else
     export RAT_UPLOAD_ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME"
    fi
  else
    if [[ -z $RAT_UPLOAD_ORACLE_HOME ]];then
      if [[ -n $ORACLE_HOME ]]; then
        export RAT_UPLOAD_ORACLE_HOME="$ORACLE_HOME";
      else
        if [ -f "$ORATAB" ]
        then
          for oh_path in `grep ":/" $ORATAB |grep -v "+"|grep -v "^#"|cut -d: -f2`
          do
	    if [[ -e $oh_path ]]; then export RAT_UPLOAD_ORACLE_HOME=$oh_path; break; fi
          done
	  unset oh_path
	fi
      fi
      if [[ -z $RAT_UPLOAD_ORACLE_HOME ]];then
        echo -e "\n${RED}Database home path is not set please set Database home path and try again.\n\neg: export RAT_UPLOAD_ORACLE_HOME=/u01/app/oracle/product/11.2.0.4/dbhome_1/\n\n${program_name} exiting..${NORM}\n";
        exit 1;
      fi
    else
      export RAT_UPLOAD_ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME"
    fi
  fi
}

#Following function is used to get the wallet path
getWalletPath ()
{
  if [[ -n $RAT_WALLET_LOC ]];then
    if [[ -d $RAT_WALLET_LOC/${program_name}_wallet ]];then
      WALLET_DIR=$RAT_WALLET_LOC/${program_name}_wallet;
    else
      echo -e "\nNone of the parameters are set in ${program_name}_wallet. To set wallet parameters use following command:\n\n./${program_name} -setdbupload all/<Parameters Name>\n";
      exit 1;
    fi
  else
    if [[ -d ${WRKDIR}/${program_name}_wallet ]];then
      WALLET_DIR=${WRKDIR}/${program_name}_wallet;
    elif [[ $wallet_upload -eq 2 || $wallet_upload -eq 3 || $wallet_upload -eq 4 || $cmdline_cm_upgrade -eq 1 ]];then
      echo -e "\nNone of the parameters are set in ${program_name}_wallet. To set wallet parameters use following command:\n\n./${program_name} -setdbupload all/<Parameters Name>\n";
      exit 1;
    fi
  fi
}

#Following function unsets variables inside oracle wallet
unsetEnvInWallet ()
{
  getWalletPath
  setdbHomeforWallet

  export WALLET_DIR="$WALLET_DIR";

  WALLETS=$SCRIPTPATH/.cgrep/wallet2.pl 

  if [[ $command_arguments == *"-unsetdbupload"* ]];then
    temp_str=$(echo $command_arguments | $AWK '{print $2}')
    all_var=$(echo $temp_str | tr "," "\n")
    if [[ $temp_str == "all" || $temp_str == "All" ]];then
      temp_str="RAT_UPLOAD_CONNECT_STRING,RAT_UPLOAD_TABLE,RAT_ZIP_UPLOAD_TABLE,RAT_PATCH_UPLOAD_TABLE,RAT_UPLOAD_USER,RAT_UPLOAD_PASSWORD";
      all_var=$(echo $temp_str | tr "," "\n")
    fi
    for WALLET_KEY in $all_var
    do
      export WALLET_KEY=$WALLET_KEY;
      wallet_outcome=`perl -e "require qw($WALLETS) ; removeEntryFromWallet();"`
      wallet_return=$(echo "$wallet_outcome"|grep 'PKI-02002'|$AWK -F":" '{print $0}');
      if [[ $wallet_return == *"Unable to open the wallet. Check password"* ]];then
        echo -e "\n\nInvalid wallet password. Unable to open the wallet\n\n";
        return;
      fi
    done
    temp_str=$(echo $command_arguments | $AWK '{print $2}')
    if [[ $temp_str == "all" || $temp_str == "All" ]];then
      if [[ -d "$WALLET_DIR" ]]; then
        rm -rf $WALLET_DIR >/dev/null 2>&1;
        echo -e "\nParameters successfully removed from ${program_name}_wallet\n";
      fi
    fi
  fi
}

#Following function set the varibales inside oracle wallet 
setEnvInWallet ()
{
  setdbHomeforWallet

  WALLETS=$SCRIPTPATH/.cgrep/wallet2.pl
 
  if [[ -n $RAT_WALLET_LOC ]];then
    if [[ ! -d $RAT_WALLET_LOC/${program_name}_wallet ]];then
      mkdir $RAT_WALLET_LOC/${program_name}_wallet >/dev/null 2>&1;
    fi
    WALLET_DIR=$RAT_WALLET_LOC/${program_name}_wallet;
  fi

  if [[ -d "$WALLET_DIR" ]]; then
    echo
  elif [[ -n $RAT_OUTPUT ]];then
    mkdir $RAT_OUTPUT/${program_name}_wallet >/dev/null 2>&1;
    WALLET_DIR=$RAT_OUTPUT/${program_name}_wallet;
  else
    mkdir ${program_name}_wallet >/dev/null 2>&1;
    WALLET_DIR=$WRKDIR/${program_name}_wallet;
  fi
  
  export WALLET_DIR="$WALLET_DIR";
  if [[ -e $WALLET_DIR/cwallet.sso && ! -w $WALLET_DIR/cwallet.sso ]];then
    echo -e "\n${RED}${program_name}_wallet already exist. Insufficient privilege to set values in existing ${program_name}_wallet\n${NORM}";
    echo -e "${RED}${program_name} is exiting...\n$NORM";
    exit 1; 
  fi

  if [[ $command_arguments == *"-setdbupload"* ]];then
    next_cmd_arg=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-setdbupload") print $(i+1)}')
    next_cmd_arg=`echo $next_cmd_arg | tr "[A-Z]" "[a-z]"`
    if [[ $next_cmd_arg == "all" ]];then
      wallet_outcome=`perl -e "require qw($WALLETS) ; createWallet();"`
      wallet_return=$(echo "$wallet_outcome"|grep 'PKI-02001'|$AWK -F":" '{print $2}');
    fi
    if [[ -e $WALLET_DIR/cwallet.sso ]];then
      echo
    else
      wallet_outcome=`perl -e "require qw($WALLETS) ; createWallet();"`
      wallet_return=$(echo "$wallet_outcome"|grep 'PKI-02001'|$AWK -F":" '{print $2}');
    fi  
  fi
  if [[ $command_arguments == *"-setdbupload"* ]];then
    temp_str=$(echo $command_arguments | $AWK '{for(i=1;i<=NF;i++) if ($i=="-setdbupload") print $(i+1)}')
    all_var=$(echo $temp_str | tr "," "\n")
    if [[ $next_cmd_arg == "all" ]];then
      temp_str="RAT_UPLOAD_CONNECT_STRING,RAT_UPLOAD_PASSWORD";      
      all_var=$(echo $temp_str | tr "," "\n")   
        WALLET_VALUE="RCA13_DOCS";
        export WALLET_KEY="RAT_ZIP_UPLOAD_TABLE"
        export WALLET_VALUE="\"$WALLET_VALUE\"";
        wallet_outcome=`perl -e "require qw($WALLETS) ; modifyEntryInWallet();"`
        wallet_return=$(echo "$wallet_outcome"|grep 'PKI-03002'|$AWK -F":" '{print $0}');
        if [[ $wallet_return == *"No entry found for"* ]];then
          wallet_outcome=`perl -e "require qw($WALLETS) ; addEntryInWallet();"`
        fi
        #WALLET_VALUE="ORACHK_CM";
        WALLET_VALUE="ORACHKCM";
        export WALLET_KEY="RAT_UPLOAD_USER"
        export WALLET_VALUE="\"$WALLET_VALUE\"";
        wallet_outcome=`perl -e "require qw($WALLETS) ; modifyEntryInWallet();"`
        wallet_return=$(echo "$wallet_outcome"|grep 'PKI-03002'|$AWK -F":" '{print $0}');
        if [[ $wallet_return == *"No entry found for"* ]];then
          wallet_outcome=`perl -e "require qw($WALLETS) ; addEntryInWallet();"`
        fi
    fi
    for WALLET_KEY in $all_var
    do
      if [[ $WALLET_KEY == *"RAT_UPLOAD_PASSWORD"* ]];then
        printf "\n\n"
        tty -s && stty -echo
        $READ -p "`echo $'\n'`Enter value for $WALLET_KEY:" WALLET_VALUE;
        tty -s && stty echo
        printf "\n\n"
      else
        
        printf "\n\n"
        exec 3<&2; exec 2<&0
        $READ -p "`echo $'\n'`Enter value for $WALLET_KEY:" WALLET_VALUE;
        exec 2<&3
      fi
      export WALLET_KEY=$WALLET_KEY;
      export WALLET_VALUE="\"$WALLET_VALUE\"";
      wallet_outcome=`perl -e "require qw($WALLETS) ; modifyEntryInWallet();"`
      wallet_return=$(echo "$wallet_outcome"|grep 'PKI-03002'|$AWK -F":" '{print $0}');
      if [[ $wallet_return == *"No entry found for"* ]];then
        wallet_outcome=`perl -e "require qw($WALLETS) ; addEntryInWallet();"`
      fi
    done
  fi
  if [[ -e $WALLET_DIR/cwallet.sso ]];then
    chmod 600 "$WALLET_DIR/cwallet.sso"
    echo -e "\nDatabase upload parameters successfully stored in ${program_name}_wallet. ${program_name} run will keep uploading the collections in database until it is unset using ./${program_name} -unsetdbupload all/<env variable name>\n"; 
  fi
}

#following function read the wallet values and set the environment variables 
getEnvFromWallet ()
{
  getWalletPath
 
  if [ -d "$WALLET_DIR" ]; then
    setdbHomeforWallet
    export WALLET_DIR="$WALLET_DIR";
    if [[ -e $WALLET_DIR/cwallet.sso && ! -r $WALLET_DIR/cwallet.sso ]];then
      if [[ $wallet_upload -eq 4 ]];then
        echo -e "\n${RED}Insufficient privilege to read ${program_name}_wallet\n${NORM}";
        echo -e "${RED}${program_name} is exiting...\n$NORM";
        exit 1;
      else
        echo -e "\n${RED}Insufficient privilege to read ${program_name}_wallet\n${NORM}" | tee -a $LOGFIL
        return;
      fi
    fi
    WALLETS=$SCRIPTPATH/.cgrep/wallet2.pl
    
    all_var=`$RAT_UPLOAD_ORACLE_HOME/bin/mkstore -wrl "$WALLET_DIR" -list|sed '1,/Oracle Secret Store entries:/d'`

    for WALLET_KEY in $all_var
    do
      export WALLET_KEY=$WALLET_KEY;
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      wallet_outcome=`perl -e "require qw($WALLETS) ; getSecretFromWallet();"`
      wallet_return=$(echo "$wallet_outcome"|grep 'RETURN'|$AWK -F":" '{print $2}');
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      if [[ $WALLET_KEY == "RAT_UPLOAD_PASSWORD" ]];then
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        RAT_UPLOAD_PASSWORD="$wallet_return";
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        if [[ $wallet_upload -eq 4 ]];then echo -e "\nRAT_UPLOAD_PASSWORD = ******\n";fi
      else
        WALLET_VALUE="$wallet_return";
        if [[ $wallet_upload -eq 4 ]];then echo -e "\n$WALLET_KEY = $WALLET_VALUE\n"; fi
        if [[ $WALLET_KEY == "RAT_UPLOAD_CONNECT_STRING" ]];then
          RAT_UPLOAD_CONNECT_STRING="$wallet_return";   
        elif [[ $WALLET_KEY == "RAT_UPLOAD_TABLE" ]];then
          export RAT_UPLOAD_TABLE="$wallet_return";   
        elif [[ $WALLET_KEY == "RAT_ZIP_UPLOAD_TABLE" ]];then
          export RAT_ZIP_UPLOAD_TABLE="$wallet_return";    
        elif [[ $WALLET_KEY == "RAT_PATCH_UPLOAD_TABLE" ]];then
          export RAT_PATCH_UPLOAD_TABLE="$wallet_return";    
        elif [[ $WALLET_KEY == "RAT_UPLOAD_USER" ]];then
          RAT_UPLOAD_USER="$wallet_return";      
        elif [[ $WALLET_KEY == "RAT_UPLOAD_PASSWORD" ]];then
          RAT_UPLOAD_PASSWORD="$wallet_return";
        fi
      fi 
    done
  fi
}

#Following Function is used to check if collection manager is upgrading if yes, then this function returns Y.
check_flag_status ()
{
  cm_upgrade_flag="N";
  does_table_exist=$(echo "SELECT 1 FROM RCA13_INTRACK_PREFERENCES;"|$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING")
  if [[ $(echo $does_table_exist |grep -c "table or view does not exist" ) -gt 0 ]];then
    cm_upgrade_flag="";
  else
    cm_upgrade_flag=$(echo "set heading off 
    SELECT PREFERENCE_VALUE FROM RCA13_INTRACK_PREFERENCES where PREFERENCE_NAME='CM_UPGRADE_MODE';"|$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING")
    cm_upgrade_flag=$(echo $cm_upgrade_flag |tr -d '\n')
  fi
}

#Following function is used to upgrade collection manager app
upgrade_cm ()
{
  #Define required_cm_version here whenever its needed if the variable is not defined then orachk will upload without upgrading hence the func here returning 0
  #required_cm_version="12.2.0.1.1"
  if [[ -z $required_cm_version && -z $cmdline_cm_upgrade ]];then
    cm_upgrade_status=0
    return $cm_upgrade_status
  fi
  export LD_LIBRARY_PATH=$ORACLE_HOME/lib;
  export RAT_UPLOAD_USER=$RAT_UPLOAD_USER;
  export RAT_UPLOAD_CONNECT_STRING=$RAT_UPLOAD_CONNECT_STRING;
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  export RAT_UPLOAD_PASSWORD=$RAT_UPLOAD_PASSWORD;
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  if [[ -z $prompt_timeout ]];then
    prompt_timeout=0
  fi
  if [[ -n $RAT_PERL_EXE ]];then
    # set RAT_PERL_EXE to the ORACLE_HOME where you have installed DBI,DBD::Oracle.pm module
    old_perl_exe=$perl_exe
    perl_exe="$RAT_PERL_EXE/perl/bin/perl"
  fi 
  cm_upgrade_result=$($perl_exe $SCRIPTPATH/.cgrep/cm_lib.pl $program_name $program_version "2" 2>&1 >/dev/null)
  if [[ -n $cm_upgrade_result && `echo $cm_upgrade_result|grep -icw "Can\'t locate DBD\/Oracle.pm in"` -ge 0 ]]; then
    echo -e "\n${RED}$program_name is unable to determine collection manager version. perl module DBD::Oracle.pm does not exists. Please install the module and try again or set RAT_PERL_EXE to ORACLE_HOME where required perl module is installed.${NORM}\n"
    cm_upgrade_status=1 #return 1 means will not upload the collections. 0 menas will upload the collections
    return $cm_upgrade_status
  else
    if [[ -z $cmdline_cm_upgrade ]];then
      cmdline_cm_upgrade=0
    fi
    $perl_exe $SCRIPTPATH/.cgrep/cm_lib.pl $program_name $program_version $prompt_timeout $daemon_running $daemon_init_mode $daemon_init_mode_sudo $cmdline_cm_upgrade $SCRIPTPATH
    cm_version_return_status=$?;
  fi
  if [[ -n $RAT_PERL_EXE ]];then
    perl_exe=$old_perl_exe
    perl_exe="$RAT_PERL_EXE/perl/bin/perl"
  fi 

  if [[ $cm_version_return_status -eq 0 ]];then
    cp $SCRIPTPATH/CollectionManager_App.sql $SCRIPTPATH/.cgrep >/dev/null 2>&1;
    cp $SCRIPTPATH/Apex5_CollectionManager_App.sql $SCRIPTPATH/.cgrep >/dev/null 2>&1; 
    cm_wrapper_output=$($RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING" @$SCRIPTPATH/.cgrep/CM_Wrapper.sql)
    cm_wrapper_status=$?
    is_upgrade_successful=$(echo $cm_wrapper_output|grep -iwc "Wrapper Execution ends")
    if [[ (-n $is_upgrade_successful && $is_upgrade_successful -ge 1) && (-n $cm_wrapper_status && $cm_wrapper_status -eq 0) ]];then
      cm_upgrade_status=0
      echo -e "\nOracle Health Checks Collection Manager has been successfully upgraded to $program_version.\n"
    else   
      echo -e "\nAn interrupt has occurred during Collection Manager App execution. Collection Manager is not upgraded. Please set RAT_TIMEOUT to some higher value and try again\n\neg: export RAT_TIMEOUT=180\n"|tee -a $LOGFIL
      cm_upgrade_status=1
    fi
    rm -rf $SCRIPTPATH/.cgrep/CollectionManager_App.sql >/dev/null 2>&1;
    rm -rf $SCRIPTPATH/.cgrep/Apex5_CollectionManager_App.sql >/dev/null 2>&1; 
  elif [[ $cm_version_return_status -eq 1 ]];then
    cm_upgrade_status=0
    if [[ -n $cmdline_cm_upgrade && $cmdline_cm_upgrade -eq 1 ]];then 
      echo -e "\nOracle Health Checks Collection Manager is already updated to latest version.\n";
    fi
  elif [[ $cm_version_return_status -eq 2 ]];then
    cm_upgrade_status=1
  elif [[ $cm_version_return_status -eq 3 ]];then
    cm_upgrade_status=1
  elif [[ $cm_version_return_status -eq 4 ]];then
    cm_upgrade_status=1
    echo -e "\n\nDaemon is running. Sending email..\n\n";
    upgrade_email_subj="New version of Oracle Health Checks Collection Manager is available";
    matter="A new version of Oracle Health Checks Collection Manager is available at $SCRIPTPATH. Please upgrade the Collection Manager using ./${program_name} -cmupgrade and restart the ${program_name} daemon.";
    send_email "$upgrade_email_subj" "$matter" "0" "all"; 
  fi
  return $cm_upgrade_status;
}

#This function is used to send a test email through command line option
send_test_mail ()
{
  matter="This is test mail sent by $program_name from $HOSTNAME"
  temp_arg_flag=$(echo $command_arguments | grep  -iwc "all")
  if [[ ! $temp_arg_flag -gt 0 ]];then
    pre_email_validation  
  fi
  
  if [ ! -d $RTEMPDIR ]; then mkdir $RTEMPDIR >/dev/null 2>&1;fi

  if [[ -n $RAT_CELLS ]];then
    cli_cells=$(echo "$RAT_CELLS")
    temp_cells=$(echo $cli_cells | tr "," "\n")
    for single_cellip in $temp_cells
    do
      echo "cell=\"$single_cellip\"" >> $RTEMPDIR/cellip_for_mail.ora
    done
    CELLIP="$RTEMPDIR/cellip_for_mail.ora"
  fi

  if [[ -z $CELLIP ]]; then
    if [[ -f "/etc/oracle/cell/network-config/cellip.ora" ]];then
      CELLIP="/etc/oracle/cell/network-config/cellip.ora"
      if [[ ! -d $RTEMPDIR_D ]];then
        mkdir $RTEMPDIR_D >/dev/null 2>&1;
      fi
      if [[ -n "$CELLIP" && -e "$CELLIP" ]] ; then cp -f $CELLIP $RTEMPDIR_D/.cells.txt; fi
    fi    
  fi

  if [[ $temp_arg_flag -eq 0 ]];then 
    cmd_line_email=2 
  fi    
  echo "This is test email attachment" > "$RTEMPDIR/test_attachment.txt"
  html_report="$RTEMPDIR/test_attachment.txt"
  send_email "First : Test mail sent by $program_name" "$matter" "1" "all"
  if [[ -n $mail_sent_from_cell && $mail_sent_from_cell -eq 1 ]];then
    matter="This is test mail sent by $program_name from $HOSTNAME"
    send_email_with_attachment
  fi
  rm -rf $RTEMPDIR/test_attachment.txt >/dev/null 2>&1
  #rm -rf $RTEMPDIR_D >/dev/null 2>&1
  rm -rf $RTEMPDIR/cellip_for_mail.ora >/dev/null 2>&1
  exit;
}

#Following function is used to discover the collections for which collections does not get uploaded successfully in CM
get_failed_uploads ()
{
     collection_mngr_path=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-output") print $(i+1)}')
      if [[ -z $collection_mngr_path ]];then
        collection_mngr_path=$WRKDIR
      fi
      HOSTNAME=`echo "$HOSTNAME"|$AWK -F'.' '{print $1}'`
      dir_count=$(ls $collection_mngr_path|grep ${program_name}_ | wc -l)
      i_dir=1;
      while [[ $i_dir -le $dir_count ]]
      do
        collection_mngr_dir=$(ls -r $collection_mngr_path |grep ${program_name}_ | head -n $i_dir | tail -1)
        cm_full_path="$collection_mngr_path/${collection_mngr_dir}"
        if [[ -d $cm_full_path ]];then
          if [[ -e $cm_full_path/outfiles/check_env.out ]];then
            DATABASE_UPLOAD_SETUP=`grep DATABASE_UPLOAD_SETUP $cm_full_path/outfiles/check_env.out | head -1 | $AWK -F'=' '{print $2}'`
            DATABASE_UPLOAD_STATUS=`grep DATABASE_UPLOAD_STATUS $cm_full_path/outfiles/check_env.out | tail -1 | $AWK -F'=' '{print $2}'`
          else
            DATABASE_UPLOAD_SETUP=0;
          fi
          if [[ $DATABASE_UPLOAD_SETUP -eq 1 ]];then
            if [[ $DATABASE_UPLOAD_STATUS -eq 0 ]];then
              if [[ -z $unsuccess_coll ]];then
                unsuccess_coll=$cm_full_path
              else
                unsuccess_coll="$unsuccess_coll $cm_full_path"
              fi
            fi
          fi
        fi
        i_dir=$(expr $i_dir + 1)
      done
}

get_date_epoch () 
{
  inputtime="$1"

  input_day=$(echo "$inputtime"|awk -F':' '{print $1}'|awk '{print $1}'|sed 's/^0//'|tr "[a-z]" "[A-Z]")
  input_mon=$(echo "$inputtime"|awk -F':' '{print $1}'|awk '{print $2}'|sed 's/^0//'|tr "[a-z]" "[A-Z]")
  input_date=$(echo "$inputtime"|awk -F':' '{print $1}'|awk '{print $3}'|sed 's/^0//')
  input_hr=$(echo "$inputtime"|awk -F':' '{print $1}'|awk '{print $4}'|sed 's/^0//')
  input_mi=$(echo "$inputtime"|awk -F':' '{print $2}'|sed 's/^0//')
  input_sec=$(echo "$inputtime"|awk -F':' '{print $3}'|awk '{print $1}'|sed 's/^0//')
  input_year=$(echo "$inputtime"|awk -F':' '{print $3}'|awk '{print $2}'|sed 's/^0//')

  case $input_mon in
    JAN) inputmNo=1;;
    FEB) inputmNo=2;;
    MAR) inputmNo=3;;
    APR) inputmNo=4;;
    MAY) inputmNo=5;;
    JUN) inputmNo=6;;
    JUL) inputmNo=7;;
    AUG) inputmNo=8;;
    SEP) inputmNo=9;;
    OCT) inputmNo=10;;
    NOV) inputmNo=11;;
    DEC) inputmNo=12;;
    *) inputmNo=0;;
  esac
  date_epoch=$(perl -e 'use Time::Local;print timelocal('$input_sec','$input_mi','$input_hr','$input_date','$inputmNo'-1,'$input_year');')
}

collect_duration ()
{
  inputcol=$1
  outcol=$2

  cs_time=$(grep 'STARTED ON ' $inputcol|sed 's/\(^.* [0-9]* [0-9]*:[0-9]*:[0-9]* [0-9]*\).*$/\1/')
  if [[ -z $cs_time ]]; then return; fi
  get_date_epoch "$cs_time"
  cs_epoch=$date_epoch 

  ce_time=$(tail -1 $inputcol|sed 's/\(^.* [0-9]* [0-9]*:[0-9]*:[0-9]* [0-9]*\).*$/\1/')
  if [[ -z $ce_time ]]; then return; fi
  get_date_epoch "$ce_time"
  ce_epoch=$date_epoch

  let chk_dur=$ce_epoch-$cs_epoch
  let dh=$chk_dur/3600
  let dm=($chk_dur-3600*$dh)/60
  let ds=($chk_dur-3600*$dh)-60*$dm
  dsec=$(echo "$ds" | awk '{printf("%d\n",$1 + 0.5)}')
  
  if [ $dh -gt 0 ]; then
    checks_duration="$dh Hours, $dm mins, $dsec seconds";
  else
    if [ $dm -gt 0 ]; then
      checks_duration="$dm mins, $dsec seconds";
    else
      checks_duration="$dsec seconds";
    fi
  fi

  echo "--------------------------------" >> $outcol
  echo "ToTal Duration: $checks_duration" >> $outcol
  echo "--------------------------------" >> $outcol
  echo ""				  >> $outcol
}

show_daemonlog_policy () {
  if [[ -e $DLOG_CONFFILE ]]; then
    RAT_DAEMON_LOGMAXSIZE=$(cat $DLOG_CONFFILE|awk -F':' '{print $1}')
    RAT_DAEMON_LOGRETPOLICY=$(cat $DLOG_CONFFILE|awk -F':' '{print $2}')

    if [[ -n "$RAT_DAEMON_LOGRETPOLICY" && `echo "$RAT_DAEMON_LOGRETPOLICY"|grep -icw 'delete'` -gt "0" ]]; then 
      dlog_msg='deleted'
    elif [[ -n "$RAT_DAEMON_LOGRETPOLICY" && `echo "$RAT_DAEMON_LOGRETPOLICY"|grep -icw 'archive'` -gt "0" ]]; then
      dlog_msg='archived'
    fi

    if [[ -z $1 ]]; then
      echo ""
      echo "Daemon logmaxsize is set to '$RAT_DAEMON_LOGMAXSIZE' and daemon logs will be '$dlog_msg' on extending the limit."
      echo ""
      exit
    fi
  else
    echo ""
    echo -e "${program_name} daemon log rotation policy is not set."
    echo ""
    exit ;
  fi
}

make_daemonlog_policy () {
  if [[ -z $RAT_DAEMON_LOGMAXSIZE ]]; then return; fi
 
  if [[ -n "$RAT_DAEMON_LOGMAXSIZE" && "$RAT_DAEMON_LOGMAXSIZE" = "0" ]]; then
    if [[ -e $DLOG_CONFFILE ]]; then
      rm -f $DLOG_CONFFILE >/dev/null 2>&1;
      if [[ $? -eq "0" ]]; then
        echo ""
        echo -e "${program_name} daemon log rotation policy successfully removed."
        echo ""
        exit ;
      else
        echo ""
        echo -e ${RED}"Unexpected error while removing daemon log rotation policy."${NORM}
        echo -e "\n${RED}${program_name} is exiting..\n"${NORM}
        echo ""
        exit ;
      fi
    else
      echo ""
      echo -e "${program_name} daemon log rotation policy is not set."
      echo ""
      exit ;
    fi
  fi
 
  if [[ -z $RAT_DAEMON_LOGRETPOLICY && ! -e $DLOG_CONFFILE ]]; then 
    RAT_DAEMON_LOGRETPOLICY='delete'; 
  elif [[ -z $RAT_DAEMON_LOGRETPOLICY && -e $DLOG_CONFFILE ]]; then  
    RAT_DAEMON_LOGRETPOLICY=$(cat $DLOG_CONFFILE|awk -F':' '{print $2}')
  fi
  export RAT_DAEMON_LOGRETPOLICY=$RAT_DAEMON_LOGRETPOLICY
 
  daemon_log_entry=$RAT_DAEMON_LOGMAXSIZE
  if [[ -n "$RAT_DAEMON_LOGRETPOLICY" && `echo "$RAT_DAEMON_LOGRETPOLICY"|grep -icw 'delete'` -gt "0" ]]; then 
    daemon_log_entry=${daemon_log_entry}:DELETE 
    dlog_msg='deleted'
  elif [[ -n "$RAT_DAEMON_LOGRETPOLICY" && `echo "$RAT_DAEMON_LOGRETPOLICY"|grep -icw 'archive'` -gt "0" ]]; then
    daemon_log_entry=${daemon_log_entry}:ARCHIVE 
    dlog_msg='archived'
  else
    echo ""
    echo -e ${RED}"Please enter correct daemon log retention value. It can be either 'delete' or 'archive'."{NORM}
    echo -e "\n${RED}${program_name} is exiting..\n"${NORM}
    exit 1;
  fi
  
  if [[ `echo "$RAT_DAEMON_LOGMAXSIZE"|grep -ic "^[0-9][0-9]*[K,M,G]B$"` -eq "0" ]]; then
    echo ""
    echo -e ${RED}"Please enter correct daemon logmaxsize value. logmaxsize value can be in KB or MB or GB like '100KB or 100MB or 100GB'"${NORM}
    echo -e "\n${RED}${program_name} is exiting..\n"${NORM}
    exit 1;
  fi
 
  rm -f $DLOG_CONFFILE >/dev/null 2>&1
  echo "$daemon_log_entry" > $DLOG_CONFFILE
 
  echo ""
  echo "Daemon logmaxsize set to '$RAT_DAEMON_LOGMAXSIZE'. Daemon logs will be '$dlog_msg' on extending the limit."
  echo ""
 
  if [[ -n "$daemon_command" ]]; then
    return;
  else
    exit;
  fi
}

function dump_ocr_data () 
{
  DOD_CC_STATUS=0
  perl_exe=$(which perl| tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi

  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
    echo "$perl_exe $SCRIPTPATH/.cgrep/discoverdbasm.pl -c \"$CRS\" -f \"$MASTERFIL\" -e \"$RTEMPDIR/nowatch.pid\" -o \"$OFFLINE\" -d \"$pdebug\""
  fi
  $perl_exe $SCRIPTPATH/.cgrep/discoverdbasm.pl -c "$CRS" -f "$MASTERFIL" -e "$RTEMPDIR/nowatch.pid" -o "$OFFLINE" -d "$pdebug"
  DOD_CC_STATUS=`echo $?`;

  if [[ $DOD_CC_STATUS -eq "1" ]]; then CRS12=1; fi
  #query_crs_active_version_update_env;
}

function query_crs_active_version_update_env
{
  l_stack_counter=0
  #for qstack in `grep "OLSNODES = " $MASTERFIL |sed 's/OLSNODES = //' `
  for qstack in `cat $HOSTLIST`
  do
    if [ $qstack = $localnode ] ; then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
        get_dbOwner
        ORACLE_HOME=$OLD_OH
        stack_crs_version[$l_stack_counter]=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|sed 's/ //g'"`
        write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR
      else
        stack_crs_version[$l_stack_counter]=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|sed 's/ //g'`
      fi
    else
      if [[ -n "$localonly" && $localonly -eq "1" ]]; then continue; fi
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
        get_dbOwner
        ORACLE_HOME=$OLD_OH
        stack_crs_version[$l_stack_counter]=`$SSHELL $qstack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crsctl query $crs_version_switch 2>/dev/null|grep active|sed -n 's/.*\[//p'|sed 's/\]//g'\""`
        write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR
      else
        stack_crs_version[$l_stack_counter]=`$SSHELL $qstack $CRS/bin/crsctl query $crs_version_switch|grep active|sed -n 's/.*\[//p'|sed 's/\]//g'`
      fi
    fi
    if [ -n "${stack_crs_version[$l_stack_counter]}" ] ; then
      sed -e "s/${qstack}.CRS_ACTIVE_VERSION =.*/${qstack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$l_stack_counter]}/g" $MASTERFIL > $MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
    fi
    l_stack_counter=`expr $l_stack_counter + 1`
  done
}

function subs_files_to_usr_files ()
{
  FILES_TO_CHG=$1
  FPAT_TO_CHG=$2
  USR_TAG=$3

  if [[ -z $USR_TAG ]]; then USR_TAG=$dbOwner; fi

  old_ifs=$IFS;IFS=$','

  for file in `echo "$FILES_TO_CHG"`
  do
    if [[ `echo "$file"|grep -ic "[0-9a-zA-Z]"` -eq "0" ]]; then continue; fi

    for fpattern in `echo "$FPAT_TO_CHG"`
    do
      if [[ `echo "$fpattern"|grep -ic "[0-9a-zA-Z]"` -eq "0" ]]; then continue; fi
	       
      if [[ `echo "$fpattern"|grep -c "USR_HOMEDIR"` -gt "0" ]]; then 
        new_absname="$TMP_OUTPUT"
      #else
      #  fdir=$(dirname "$fpattern")
      #  new_absname="${fdir}/${USR_TAG}/${fbase}"
      #fi

      #fdir=$(dirname "$fpattern")
      #fbase=$(basename "$fpattern")

      #new_absname="${fdir}/${USR_TAG}/${fbase}"

        sed -e "s|$fpattern|$new_absname|g" $file > $file.bak && mv -f $file.bak $file
      fi
    done
  done

  IFS=$old_ifs
  unset USR_TAG
}

function chg_files_for_usr ()
{
  VARS_TO_CHG=$1
  CURR_VALUES=$2
  USR_TAG=$3
  GRP_TAG=$4

  if [[ -z $USR_TAG ]]; then USR_TAG=$dbOwner; fi
  if [[ -z $GRP_TAG ]]; then GRP_TAG=$dbGroup; fi

  old_ifs=$IFS;IFS=$','

  mod_cntr=0
  for var in `echo "$VARS_TO_CHG"`
  do
    allvars[$mod_cntr]=$var
    mod_cntr=$(expr $mod_cntr + 1)
  done

  mod_cntr=0
  for value in `echo "$CURR_VALUES"`
  do
    allvalues[$mod_cntr]=$value
    mod_cntr=$(expr $mod_cntr + 1)
  done

  IFS=$old_ifs

  for (( index = 0; index < $mod_cntr; index++ ))
  do
    if [[ `echo "${allvalues[$index]}"|grep -ic "[0-9a-zA-Z]"` -eq "0" ]]; then continue; fi

    if [[ `echo "${allvalues[$index]}"|grep -c "USR_HOMEDIR"` -gt "0" ]]; then 
      fdir="$TMP_OUTPUT"
    elif [[ `echo "$PSEUDOERRFIL"|grep -c "USR_HOMEDIR"` -gt 0 && "${allvars[$index]}" = 'ERRFIL' ]]; then
      fdir="$TMP_OUTPUT"
    else
      fdir=$(dirname ${allvalues[$index]})
    fi
    fbase=$(basename ${allvalues[$index]})

    new_absname="${fdir}/${USR_TAG}/${fbase}"
    if [[ `echo "$new_absname"|grep -c "/$USR_TAG/$USR_TAG/"` -gt "0" ]]; then new_absname="${fdir}/${fbase}"; fi

    if [[ "${allvars[$index]}" = 'ERRFIL' ]]; then
      eval "${allvars[$index]}=$TMP_OUTPUT/${USR_TAG}/${fbase}"

      if [[ ! -e $ERRFIL ]]; then touch $ERRFIL; fi 
      security_fix "fix_file_attributes" "$ERRFIL" "$USR_TAG:$GRP_TAG"
    else
      eval "${allvars[$index]}=$new_absname"
    fi
    eval "ORIG_${allvars[$index]}=${allvalues[$index]}"
  done

  unset USR_TAG GRP_TAG
}

function write_del_rolbk_errlog ()
{
  ERRFIL=$(echo $ERRFIL|sed "s|//|/|g")
  if [[ "$ERRFIL" = "$ORIG_ERRFIL" ]]; then return; fi

  if [[ `echo "$ORIG_ERRFIL"|grep -cw "USR_HOMEDIR"` -gt "0" ]]; then 
    cat $ERRFIL >> $OUTPUTDIR/${program_name}_error.log
  else
    cat $ERRFIL >> $ORIG_ERRFIL
  fi
  rm -f $ERRFIL >/dev/null 2>&1
  ERRFIL=$ORIG_ERRFIL
}

function write_del_rolbk_tmpoutput ()
{
  if [[ -n $OLD_TMP_OUTPUT ]]; then TMP_OUTPUT=$OLD_TMP_OUTPUT; fi
  unset OLD_TMP_OUTPUT
}

get_files_for_mixedcellhw ()
{
  if [ ! -e $CELLDIR ];then mkdir $CELLDIR >/dev/null 2>&1;fi

  root_cell_counter=0
  for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'` 
  do
    if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then 
      el_node_ping=1; 
    else
      test_node_reachability $cellname $cell_ssh_user;
    fi

    if [ $el_node_ping -eq "1" ] ; then
      cellPingStatus=0;
    else
      cellPingStatus=1;
    fi

    if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
    then
      cellname_short=$(echo $cellname|sed 's/\./_/g')
      OUTFILNAME="c_cbc_CellMakeModel_${cellname_short}.out"
      REPORTNAME="c_cbc_CellMakeModel_${cellname_short}_report.out"

      noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $cellname)

      if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then 
        cellcli -e "list cell attributes makeModel" >>$CELLDIR/$OUTFILNAME 
      elif [[ -n "$cell_password_status" && $cell_password_status -eq 1 ]]
      then
        printf ". ";
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 0 ]]; then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	  cell_rootpassword=${a_cell_rootpassword[$root_cell_counter]}
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	fi

        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        is_SSH_blocked "$cellname" "$cell_ssh_user" "$cell_rootpassword" "CELL"
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        if [[ $SSH_blocked -eq 1 ]]; then
          root_cell_counter=$(expr $root_cell_counter + 1)
          continue;
        fi     

        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        fixRootPassword "$cell_rootpassword"
      
        cellattributes=$($EXPECT -f - << IBEOF
                               set timeout $passwordcheck_timeout
			       set le_cell_password "$fixedRootPassword"
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }    
                               spawn -noecho $SSHELL $cell_ssh_user@$cellname "cellcli -e \"list cell attributes makeModel\""
                               match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_cell_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_cell_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while extracting files from $cellname\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
)
	 if [[ `echo "$cellattributes" | grep -ic "password:"` -gt 0 ]]
	 then
	   cellattributes=$(echo $cellattributes|$AWK 'BEGIN { FS = "password:" };{print $2}'|tr -d '\r')
	 else
	   cellattributes=$(echo $cellattributes|tr -d '\r')
	 fi
	 echo "$cellattributes" >> $CELLDIR/$OUTFILNAME
       if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
       printf ". ";	
     elif [[ -n "$cell_password_status" && $cell_password_status -eq 0 ]];
     then
       printf ". ";	
       $SSHELL $cell_ssh_user@$cellname "cellcli -e \"list cell attributes makeModel\"" >>$CELLDIR/$OUTFILNAME 
       printf ". ";	
     fi
     cp -f $CELLDIR/$OUTFILNAME $CELLDIR/$REPORTNAME >/dev/null 2>&1;
     root_cell_counter=$(expr $root_cell_counter + 1)
   fi
  done
  root_cell_counter=0
}

get_cell_name ()
{
  cell_to_check=$1

  root_cell_counter=0
  for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'` 
  do
    if [[ $cellname != $cell_to_check ]]; then root_cell_counter=$(expr $root_cell_counter + 1); continue; fi
	     
    test_node_reachability $cell_to_check $cell_ssh_user;
    if [ $el_node_ping -eq "1" ] ; then
      cellPingStatus=0;
    else
      cellPingStatus=1;
    fi

    if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
    then
      noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $cell_to_check)

      if [[ -n "$cell_password_status" && $cell_password_status -eq 1 ]]
      then
        printf ". ";
	if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 0 ]]; then
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	  cell_rootpassword=${a_cell_rootpassword[$root_cell_counter]}
	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	fi

        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        is_SSH_blocked "$cell_to_check" "$cell_ssh_user" "$cell_rootpassword" "CELL"
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        if [[ $SSH_blocked -eq 1 ]]; then
          root_cell_counter=$(expr $root_cell_counter + 1)
          continue;
        fi     

        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        fixRootPassword "$cell_rootpassword"
        cell_name=$($EXPECT -f - << IBEOF
                      set timeout $passwordcheck_timeout
		      set le_cell_rootpassword "$fixedRootPassword"
                      #log_user 0
                      if { "$RAT_EXPECT_DEBUG" == "-d" } {
                        exp_internal 1
                      } 
                      spawn -noecho $SSHELL $cell_ssh_user@$cell_to_check "hostname|cut -d. -f1"
                      match_max 100000
                      expect {
		  	  -nocase "permission denied *" {
		  	     exit 4;
		        }
                  	  -nocase "no)?" {
                  	     send -- "yes\n"
                        }
		  	  -nocase "*?assword:*" {
		  	     send -- "\$le_cell_rootpassword\n"
		  	}
		  	  -nocase eof {
		  	     exit
		  	}
                      }
		      # Look for passwd prompt
			expect {
			    -nocase "*?assword:*" {
				 send -- "\$le_cell_rootpassword\n"
			    }
			    -nocase eof {
				 exit
			    }
			    -nocase timeout {
				send_error "Timed out\n";
				exit
			    }
			 }
		      # Stop the on logon tests and if asked to connect to master switch choose no
			 expect {
			    -nocase eof {
				 exit
			    }
			    -nocase timeout {
				send_error "Timed out\n";
				exit
			    }
			 }
IBEOF
)
	cell_name=$(echo "$cell_name"|tail -1|sed 's/ //g'|tr -d '\r')
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      elif [[ -n "$cell_password_status" && $cell_password_status -eq 0 ]];
      then
        cell_name=$($SSHELL $cell_ssh_user@$cell_to_check "hostname|cut -d. -f1")
      fi
      root_cell_counter=$(expr $root_cell_counter + 1)
    fi
  done
  root_cell_counter=0
}

function assign_execute_once ()
{
  if [[ -n "$execute_once" ]]; then
    if   [[ `echo "$execute_once"|grep -ic "none"` -gt "0" ]];      then execute_once=0;
    elif [[ `echo "$execute_once"|grep -ic "localnode"` -gt "0" ]]; then execute_once=1;
    elif [[ `echo "$execute_once"|grep -ic "compute"` -gt "0" ]];   then execute_once=2;
    elif [[ `echo "$execute_once"|grep -ic "storage"` -gt "0" ]];   then execute_once=3;
    elif [[ `echo "$execute_once"|grep -ic "zfs"` -gt "0" ]];       then execute_once=4;
    elif [[ `echo "$execute_once"|grep -ic "ibswitch"` -gt "0" ]];  then execute_once=5;
    fi
  else
    execute_once=0
  fi
}

function get_first_cell ()
{
  first_storage_cell=""
  if [[ `grep -icw "FIRST_STORAGE_CELL" $MASTERFIL` -gt "0" ]]; then
    first_storage_cell=$(grep -iw "FIRST_STORAGE_CELL" $MASTERFIL | awk -F"=" '{print $2}' | sed 's/ //g')
    return; 
  fi 

  if [[ -n "$CELLIP" && -e "$CELLIP" ]]; then
    first_storage_cell=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)
    if [ -e $CELLDIR/cells.out ]; then first_storage_cell=$(grep -w "$first_storage_cell" $CELLDIR/cells.out|grep -v "^ *#"|awk '{print $NF}'|head -1); else get_cell_name "$first_storage_cell"; first_storage_cell=$cell_name;  fi 

    echo "FIRST_STORAGE_CELL = $first_storage_cell" >> $MASTERFIL  
  fi
}

function get_first_zfs ()
{
  first_zfs=""
  if [[ `grep -icw "FIRST_ZFS" $MASTERFIL` -gt "0" ]]; then
    first_zfs=$(grep -iw "FIRST_ZFS" $MASTERFIL | awk -F"=" '{print $2}' | sed 's/ //g')
    return; 
  fi 

  if [[ -n "$ZFSIP" && -e $ZFSIP ]]; then 
    first_zfs=$(cat $ZFSIP|cut -d\" -f2|cut -d\; -f2|head -1)
    echo "FIRST_ZFS = $first_zfs" >> $MASTERFIL  
  fi
}

function get_first_ibswitch ()
{
  first_ibswitch=""
  if [[ `grep -icw "FIRST_IBSWITCH" $MASTERFIL` -gt "0" ]]; then
    first_ibswitch=$(grep -iw "FIRST_IBSWITCH" $MASTERFIL | awk -F"=" '{print $2}' | sed 's/ //g')
    return;
  fi 

  if [[ -e $OUTPUTDIR/o_ibswitches.out ]]; then
    first_ibswitch=$(cat $OUTPUTDIR/o_ibswitches.out|head -1)

    echo "FIRST_IBSWITCH = $first_ibswitch" >> $MASTERFIL  
  fi
}

function get_first_compute ()
{
  first_compute=""

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" ]] && [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "0" ]]; then return; fi

  if [[ `grep -icw "FIRST_COMPUTE" $MASTERFIL` -gt "0" ]]; then 
    first_compute=$(grep -iw "FIRST_COMPUTE" $MASTERFIL | awk -F"=" '{print $2}' | sed 's/ //g')
    return; 
  fi 

  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    first_compute=$(echo "$ea_dom0_nodes"|head -1)
  else
    first_compute=$(grep "c_nodes_01_IPoIB-admin=" $EAOUT|cut -d= -f2)
    is_IP "$first_compute"
    if [[ $is_IPADDRESS -eq "1" ]]; then
      ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 $first_compute ls >/dev/null 2>&1;echo $?);
      if [[ -n "$ssh_status" && $ssh_status -eq "0" ]]; then
        first_compute_name=$($SSHELL $first_compute "hostname|cut -d. -f1")
      fi
      if [[ -n "$first_compute_name" ]]; then first_compute=$first_compute_name; fi
    fi
  fi

  echo "FIRST_COMPUTE = $first_compute" >> $MASTERFIL  
}

function set_switch_arrays_in_ocm
{
  sw_samerootpassword=0
  root_sw_counter=0
  sw_to_skip=""
  for swname in `echo "$RAT_TORSWITCHES" | tr ',' '\n'`
  do
    inc_counter=1
    sw_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $sw_ssh_user $swname ls >/dev/null 2>&1;echo $?);
    if [[ -n "$sw_ssh_status2" && $sw_ssh_status2 -eq 0 ]]
    then
      echo "$sw_ssh_user password not checked on $swname because ssh user equivalence found for $sw_ssh_user">>$LOGFIL
    else
      if [ ! -f "$OCM_SW_CREDFILE" ] ; then
        echo -e "${RED}Error: Credential file $OCM_SW_CREDFILE is missing. Exiting..${NORM}"
        sw_cellname_ip=`nslookup "$swname" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`;
        opc_syslog_tag=" [HOST: $swname] [IPADDRESS: $sw_cellname_ip]"
        errm="Credential file $OCM_SW_CREDFILE is missing. Exiting"
        update_errm_in_syslog
        opc_syslog_tag=""
        exit
      fi
      sw_ssh_user=$(cat "$OCM_SW_CREDFILE" |grep -w "$swname" | awk -F"|" '{print $2}');
      sw_rootpassword=$(cat "$OCM_SW_CREDFILE" |grep -w "$swname" | awk -F"|" '{print $3}');
      printf "\n\nVerifying ${sw_ssh_user} password in $swname.\n\n. . ";
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      checkUserPassword "$swname" "$sw_ssh_user" "$sw_rootpassword" "1" $cell_type
      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      then
        sw_rootpassword=$passwordToCheck
        a_sw_rootpassword[$root_sw_counter]=$sw_rootpassword
      else
        sw_rootpassword=
        a_sw_rootpassword[$root_sw_counter]=
        inc_counter=0
        sw_to_skip="$sw_to_skip $swname"
        echo -e "${RED}Error: Password is wrong for $swname. Removing it${NORM}" 
        add_to_skipped_nodes "$swname" "Password is wrong for $swname"
      fi
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      printf ". ";
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    fi
    if [ $inc_counter -eq 1 ] ; then
      root_sw_counter=$(expr $root_sw_counter + 1 )
    fi
    #TODO if host is not reachable or ssh fails.. add to skipped hosts and create json entry with WARN
  done
  RAT_TORSWITCHES=`echo "$RAT_TORSWITCHES" | tr ',' '\n'`
  for swname in $sw_to_skip
  do
    if [ -n "$swname" ] ; then
      RAT_TORSWITCHES=`echo -e "$RAT_TORSWITCHES" | grep -v $swname`
    fi
    sw_cellname_ip=`nslookup "$swname" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`;
    opc_syslog_tag=" [HOST: $swname] [IPADDRESS: $sw_cellname_ip]"
    errm="Skipping best practice checks on $swname as credentials are wrong"
    update_errm_in_syslog
    opc_syslog_tag=""
  done
}

function set_zfs_arrays_in_opc
{
  zfs_samerootpassword=0
  root_zfs_counter=0
  zfs_to_skip=""
  for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
  do
    inc_counter=1
    zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
    if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
    then
      echo "$zfs_ssh_user password not checked on $zfsname because ssh user equivalence found for $zfs_ssh_user">>$LOGFIL
    else
      if [ ! -f "$OPC_ZFS_CREDFILE" ] ; then
        echo -e "${RED}Error: Credential file $OPC_ZFS_CREDFILE is missing. Exiting..${NORM}"
        zfs_cellname_ip=`nslookup "$zfsname" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`;
        opc_syslog_tag=" [HOST: $zfsname] [IPADDRESS: $zfs_cellname_ip]"
        errm="Credential file $OPC_ZFS_CREDFILE is missing. Exiting"
        update_errm_in_syslog
        opc_syslog_tag=""
        exit
      fi
      zfs_ssh_user=$(cat "$OPC_ZFS_CREDFILE" |grep -w "$zfsname" | awk -F"|" '{print $2}');
      zfs_rootpassword=$(cat "$OPC_ZFS_CREDFILE" |grep -w "$zfsname" | awk -F"|" '{print $3}');
      printf "\n\nVerifying ${zfs_ssh_user} password in $zfsname.\n\n. . ";
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "1" $cell_type
      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      then
        zfs_rootpassword=$passwordToCheck
        a_zfs_rootpassword[$root_zfs_counter]=$zfs_rootpassword
      else
        zfs_rootpassword=
        a_zfs_rootpassword[$root_zfs_counter]=
        inc_counter=0
        zfs_to_skip="$zfs_to_skip $zfsname"
        echo -e "${RED}Error: Password is wrong for $zfsname. Removing it${NORM}" 
        add_to_skipped_nodes "$zfsname" "Password is wrong for $zfsname"
      fi
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      printf ". ";
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    fi
    if [ $inc_counter -eq 1 ] ; then
      root_zfs_counter=$(expr $root_zfs_counter + 1 )
    fi
    #TODO if host is not reachable or ssh fails.. add to skipped hosts and create json entry with WARN
  done
  for zfsname in $zfs_to_skip
  do
    if [ -n "$zfsname" ] ; then
      grep -vw $zfsname $ZFSIP > $ZFSIP.saved
      cp -f $ZFSIP.saved $ZFSIP
      rm -f $ZFSIP.saved
    fi
    zfs_cellname_ip=`nslookup "$zfsname" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`;
    opc_syslog_tag=" [HOST: $zfsname] [IPADDRESS: $zfs_cellname_ip]"
    errm="Skipping best practice checks on $zfsname as credentials are wrong"
    update_errm_in_syslog
    opc_syslog_tag=""
  done
}

set_pdb_data ()
{ 
  #Same old legacy discovery code
  stack_dbinst_name[$stack_counter]=""
  stack_dbinst_up[$stack_counter]=""
  stack_dbinst_version[$stack_counter]="" 
  
  stack_dbinst_name[$stack_counter]=`grep -w $qstack $stack_status|cut -d'|' -f1`
  stack_dbinst_up[$stack_counter]=`grep -w $qstack $stack_status|cut -d'|' -f2`
  stack_dbinst_version[$stack_counter]=`grep -w $qstack $stack_status|cut -d'|' -f3`
  db_version=${stack_dbinst_version[$stack_counter]}
  
  if [ -z ${stack_dbinst_up[$stack_counter]} ]
  then
    stack_dbinst_up[$stack_counter]=0
    db_up=0
    printf ". "
  else
    db_up=1
    printf ". "
  fi         
  stack_host[stack_counter]=$qstack
  printf ". "
  echo "${qstack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
  echo "${qstack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
  echo "${qstack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
  printf ". "
}    

copy_cellfiles_to_remotenodes ()
{
  TMP_CELLDIR=$RTEMPDIR/.CELLDIR/
  #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then TMP_CELLDIR=$TMP_OUTPUT/.CELLDIR/; fi
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then TMP_CELLDIR=$TMP_OUTPUT/.CELLDIR/; fi

  if [[ ! -d $TMP_CELLDIR ]]; then return; fi

  for ihost in `if [ -e $HOSTLIST.org ]; then grep -v $localnode $HOSTLIST.org; fi`
  do
    node_ssh_user=$usern
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$ihost"` -le 0 ]]; then
        node_ssh_user="${root_user}"
      else  
        node_ssh_user="${foxtrot_dom0_user}"
      fi    
      if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$ihost "echo \"\$HOME\""); fi
      l_RTEMPDIR=${l_TMPDIR}/.${program_name}
    else  
      l_TMPDIR=$TMPDIR
      l_RTEMPDIR=$RTEMPDIR
    fi    
    TMP_CELLDIR_PDIR=$l_RTEMPDIR
    #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then TMP_CELLDIR_PDIR=$TMP_OUTPUT; fi
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then TMP_CELLDIR_PDIR=$TMP_OUTPUT; fi

    $SCOPY -r $TMP_CELLDIR $node_ssh_user@$ihost:$TMP_CELLDIR_PDIR/ > /dev/null 2>&1
  done
}

set_pdebug ()
{
  pdebug=0
  if [[ -n "$RAT_SCRIPT_DEBUG" && $RAT_SCRIPT_DEBUG -eq "1" ]]; then export RAT_PDEBUG=1; fi

  dmod_st=$(perl -MData::Dumper -e 1 >/dev/null 2>&1; echo $?)
  if [[ -n "$dmod_st"  && $dmod_st -ne "0" ]]; then unset RAT_PDEBUG; fi

  if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then pdebug=1; fi
}

set_program_oncell ()
{
  if [[ -n "$usern" && $usern != "root" && $usern != "celladmin" ]]; then
    echo -e "${RED}${program_name} cannot be run as the '$usern' user. Please re-run ${program_name} as 'root' or 'celladmin' user${NORM}"  
    echo -e "${RED}${program_name} is exiting..\n"${NORM}
  fi

  RUNNING_ONCELL=1 
  localonly=1
  export RAT_LOCALONLY=1
  
  run_profile=1;
  profiles2run="storage"
  set_profile_run

  is_engineered_system=1
  cell_password_status=0

  export RAT_SKIP_USR_PROMPT_VALIDATION=1
}

#split_files "<big_outfile>" "<splitter>" "<smallfiles>"
split_files () 
{
  full_sql_result_file=$1
  sql_splitter=$2
  sql_small_files="$3"

  file_cntr=0
  for sfile in `echo "$sql_small_files"`
  do
    sfiles[$file_cntr]=$sfile
    file_cntr=$(expr $file_cntr + 1)
  done
  file_cntr=0

  if [[ -e $full_sql_result_file ]]; then
    while read sline
    do
      if [[ `echo "$sline"|grep -icw "_SQL_SPLITTER_"` -gt "0" ]]; then 
	file_cntr=$(expr $file_cntr + 1)
	touch ${sfiles[$file_cntr]}
        continue
      fi
      echo "$sline" >> ${sfiles[$file_cntr]}	              
    done < $full_sql_result_file
  fi
}

create_rtmpoutput ()
{
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    if [[ "$1" != "$localnode" ]]; then 
      $SSHELL $1 "if [ -f $2 ]; then rm -f $2 >/dev/null 2>&1; fi";
      $SSHELL $1 "if [ ! -e $2/$3 ]; then mkdir -p $2/$3 >/dev/null 2>&1; fi; chown -R $3:$4 $2 >/dev/null 2>&1;"; 
    fi
  fi
}

create_usr_dirs_on_remote ()
{
  #if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "serial" ]]; then  
    if [[ -e $HOSTLIST ]]; then
      if [[ -n "$CREATE_PENDING" ]]; then
        for rhost in `grep -v $localnode $HOSTLIST`
        do
	  for data in `echo "$CREATE_PENDING"`
	  do
	    chk_dir=`echo $data | awk -F, '{print $1}'`
	    chk_usr=`echo $data | awk -F, '{print $2}'`
	    chk_grp=`echo $data | awk -F, '{print $3}'`
	    		  
            $SSHELL $rhost "$bash_scr -c \"if [ -f ${chk_dir} ]; then rm -f ${chk_dir} >/dev/null 2>&1; fi\"";
            $SSHELL $rhost "$bash_scr -c \"if [ ! -e ${chk_dir}/${chk_usr} ]; then mkdir -p ${chk_dir}/${chk_usr} >/dev/null 2>&1; fi; chown -R ${chk_usr}:${chk_grp} ${chk_dir} >/dev/null 2>&1;\""; 

	    unset chk_dir chk_usr chk_grp
	  done
        done

        unset CREATE_PENDING
      fi

      if [[ -n "$1" ]]; then
        for rhost in `grep -v $localnode $HOSTLIST`
        do
          $SSHELL $rhost "$bash_scr -c \"if [ -f $1 ]; then rm -f $1 >/dev/null 2>&1; fi\"";
          $SSHELL $rhost "$bash_scr -c \"if [ ! -e $1/$2 ]; then mkdir -p $1/$2 >/dev/null 2>&1; fi; chown -R $2:$3 $1 >/dev/null 2>&1;\""; 
        done
      fi
    else
      if [[ -n "$1" ]]; then
        if [[ -n "$CREATE_PENDING" && `echo "$CREATE_PENDING"|grep -ic "$1,$2,$3"` -eq 0 ]] || [[ -z $CREATE_PENDING ]]; then	      
          CREATE_PENDING=${CREATE_PENDING}"$1,$2,$3 "
        fi
      fi
    fi
  #fi
}

set_rat_legacy_discovery ()
{
  if [ $is_windows -eq "1" ] ; then export RAT_LEGACY_DISCOVERY=1; return; fi

  if [[ -n "$RAT_DB" ]]; then
    fcrsversion="$RAT_DB"
    if [[ `echo "$fcrsversion"|grep -ic '\.'` -eq "0" ]]; then fcrsversion=`echo "${fcrsversion:0:2}"`; fi 
  else
    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
      check_crs_stat=`$CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
    else
      check_crs_stat=`$CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?`
    fi
    if [ $check_crs_stat -eq 0 ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
        get_dbOwner
        fcrsversion=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|sed 's/ //g'"`
        ORACLE_HOME=$OLD_OH
	write_del_rolbk_tmpoutput
        cd $OLD_DIR
        unset OLD_DIR
      else
        fcrsversion=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|sed 's/ //g'`
      fi
    fi
  fi

  fcrsversion_d1=`echo "$fcrsversion"|awk -F. '{print $1}'|sed 's/ //g'`
  if [[ -n "$fcrsversion_d1" && $fcrsversion_d1 -lt 11 ]]; then export RAT_LEGACY_DISCOVERY=1; fi
}

remove_dup_hostlist ()
{
  node_ssh_user=$usern
  for node in `cat $HOSTLIST`
  do
    r_hostname=$($SSHELL ${node_ssh_user}@$node hostname|tr "[A-Z]" "[a-z]"|cut -d'.' -f1);
    if [[ -n "$r_hostname" ]]; then
      if [[ "$node" != "$r_hostname" ]]; then
        VHNMAP=("${VHNMAP[@]}" $node:$r_hostname);
      else
        echo "$node" >> $HOSTLIST.dup
      fi
      unset r_hostname 
    fi
  done
  mv -f $HOSTLIST.dup $HOSTLIST >/dev/null 2>&1
}

write_fmw_mapping ()
{
  for mapping in ${VHNMAP[@]}
  do
    vhost=${mapping%%:*}
    ahost=${mapping#*:}
    if [[ `grep -ic "FMWVHSET:${vhost} = ${ahost}" $MASTERFIL` -eq 0 ]]; then echo "FMWVHSET:${vhost} = ${ahost}" >> $MASTERFIL; fi
  done
  unset mapping vhost ahost
}

read_fmw_mapping ()
{
  mOLDIFS=$IFS
  IFS=$'\n'
  for mapping in `grep "FMWVHSET:" $MASTERFIL|awk -F: '{print $2}'`
  do
    vhost=$(echo "$mapping"|awk -F"=" '{print $1}'|sed 's/ //g')
    ahost=$(echo "$mapping"|awk -F"=" '{print $2}'|sed 's/ //g')
    VHNMAP=("${VHNMAP[@]}" ${vhost}:${ahost});
  done
  IFS=$mOLDIFS
  unset mapping vhost ahost
}

check_usr_prompts ()
{
  uHOME=$2
  print_PMSG="either \$HOME/.bash_profile or \$HOME/.bash_login or \$HOME/.profile"
  
  if [[ -n "$RAT_SKIP_USR_PROMPT_VALIDATION" ]]; then return; fi
  
  if [[ $OFFLINE -eq "0" && $RAT_RUNMODE_INTERNAL != "slave" ]]; then
    if [[ `echo "$P_USR_STATUS"|grep -icw "$1"` -eq "0" ]]; then
      if [[ -e $HOSTLIST ]]; then
  	echo -e "\nChecking for prompts for $1 user on all nodes...\n"
        for rhost in `cat $HOSTLIST`
        do
          p_returncode=0
          if [ $rhost != $localnode ]; then
	    $SSHELL -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $rhost ls 2>/dev/null 1>/dev/null
	    ssh_setup_status=$?
	    if [[ -n "$ssh_setup_status" && $ssh_setup_status -eq 0 ]]; then
	      usr_present=0
	      usr_present=`$SSHELL $t_flag $rhost "$bash_scr -c \"grep -ic "^$1:" /etc/passwd|sed 's/ //g'\""`	    
	      if [[ $usr_present -ne "0" ]]; then
	        print_PMSG='/etc/profile'	  
		p_returncode=`$SSHELL -o NumberOfPasswordPrompts=0 $t_flag $rhost "$bash_scr -c \"su $1 -c \\\\\\"$bash_scr -c \\\\\\\\\\\\\"if [ -e \"/etc/profile\" ] ; then (. /etc/profile >/dev/null 2>&1); fi;\\\\\\\\\\\\\" \\\\\\"\"";`
		p_returncode=$(echo $?)
	        if [[ -n "$p_returncode" && $p_returncode -eq "0" ]]; then
	          if [[ -n "$uHOME" ]]; then
		    print_PMSG=`$SSHELL -o NumberOfPasswordPrompts=0 $t_flag $rhost "$bash_scr -c \"if [ -e \"$uHOME/.bash_profile\" ] ; then echo $uHOME/.bash_profile; elif [ -e \"$uHOME/.bash_login\" ] ; then echo $uHOME/.bash_login; elif [ -e \"$uHOME/.profile\" ] ; then echo $uHOME/.profile; fi\""`
	          fi 
	          p_returncode=`$SSHELL -o NumberOfPasswordPrompts=0 $t_flag $rhost "$bash_scr -c \"su - $1 -c \\\\\\"ls >/dev/null \\\\\\"\" >/dev/null 2>&1" >/dev/null 2>&1;echo $?`
	        fi
	      fi
	    else
	      unset ssh_setup_status
	      continue
	    fi
	    unset ssh_setup_status
          elif [[ `echo "$P_USR_STATUS_LOCAL"|grep -icw "$1"` -eq "0" ]]; then
	    p_returncode=0
	    if [[ `grep -ic "^$1:" /etc/passwd|sed 's/ //g'` -ne "0" ]]; then
	      print_PMSG='/etc/profile'	  
	      p_returncode=`su $1 -c "if [ -e /etc/profile ]; then (. /etc/profile >/dev/null 2>&1); fi";`
	      p_returncode=$(echo $?)
	      if [[ -n "$p_returncode" && $p_returncode -eq "0" ]]; then
	        if [[ -n "$uHOME" ]]; then
    	          print_PMSG=`if [ -e "$uHOME/.bash_profile" ]; then echo $uHOME/.bash_profile; elif [ -e "$uHOME/.bash_login" ]; then echo $uHOME/.bash_login; elif [ -e "$uHOME/.profile" ]; then echo $uHOME/.profile; fi`	
		fi
 	        p_returncode=`su - $1 -c "ls >/dev/null 2>&1" >/dev/null 2>&1;echo $?`	
	      fi
	      P_USR_STATUS_LOCAL=${P_USR_STATUS_LOCAL}:$1;
	    fi
          fi
	  if [[ -n "$p_returncode" && $p_returncode -ne 0 ]] || [[ -z $p_returncode ]]; then
            echo -e "${RED}\nThere are prompts in $print_PMSG on '$rhost' for '$1' user which will cause issues in $program_name successful execution. Please remove or comment all prompts in $print_PMSG of $1 user and run again.\n\n"${NORM}
            exit 1
	  fi
	  unset p_returncode
        done
	P_USR_STATUS=${P_USR_STATUS}:$1;
      else
	if [[ `echo "$P_USR_STATUS_LOCAL"|grep -icw "$1"` -eq "0" ]]; then
	  if [[ `grep -ic "^$1:" /etc/passwd|sed 's/ //g'` -ne "0" ]]; then
  	    echo -e "\nChecking for prompts on $localnode for $1 user...\n"

	    p_returncode=`su $1 -c "if [ -e /etc/profile ]; then (. /etc/profile >/dev/null 2>&1); fi";`
	    p_returncode=$(echo $?)
	    print_PMSG='/etc/profile'	  
	    if [[ -n "$p_returncode" && $p_returncode -eq "0" ]]; then
	      if [[ -n "$uHOME" ]]; then
    	        print_PMSG=`if [ -e "$uHOME/.bash_profile" ]; then echo $uHOME/.bash_profile; elif [ -e "$uHOME/.bash_login" ]; then echo $uHOME/.bash_login; elif [ -e "$uHOME/.profile" ]; then echo $uHOME/.profile; fi`	
	      fi	
 	      p_returncode=`su - $1 -c "ls >/dev/null 2>&1" >/dev/null 2>&1;echo \$?`	
	    fi
	    if [[ -n "$p_returncode" && $p_returncode -ne 0 ]] || [[ -z $p_returncode ]]; then
              echo -e "${RED}\nThere are prompts in $print_PMSG on '$localnode' for '$1' user which will cause issues in $program_name successful execution. Please remove or comment all prompts in $print_PMSG of $1 user and run again.\n\n"${NORM}
              exit 1
	    fi
	    P_USR_STATUS_LOCAL=${P_USR_STATUS_LOCAL}:$1;
	  fi
	  unset p_returncode
	fi			    
      fi
    fi
  fi
}

get_set_crs_OH ()
{
  for t_db_name_to_check in $(grep ":$1$" $running_db_host_list|awk -F: '{print $2}'|sed 's/ //g')
  do
    crs_OH=$(grep -w "$t_db_name_to_check" $db_list_fil_verbose|head -1|awk '{print $2}'|sed 's/ //g') 
    if [[ "$1" = "$localnode" ]]; then
      if [[ -n "$crs_OH" && -e $crs_OH/bin/oracle ]]; then break; fi
    else
      $SSHELL $1 ls -l $crs_OH/bin/oracle >/dev/null 2>&1
      remote_oracle_file_status=$(echo $?)
      if [[ -n "$remote_oracle_file_status" && $remote_oracle_file_status -eq "0" ]]; then break; fi
    fi
  done
}	

#====================================================================================================================
#main scripts execution starts from here
#====================================================================================================================

initialize "$@"

for arg in "$@"
do
  remove_arg=0
  
  if [[ $read_p2r = "-profile" ]] ; then
    if [[ $arg = "-h" ]] ; then
      usage_profilesw;exit 1;
    fi

    p2r_or2run="$arg"
    #profiles2run=$(echo $arg| sed 's/,/ /g');
    profiles2run=$arg
    
    remove_arg=1
    run_args="$run_args -profile $arg"
  elif [[ $read_p2r = "-acchk" && $arg = "-h" ]] ; then
        echo -e " 
        acchk options:
        1) -acchk
                Env variables to be set:
                  RAT_AC_ASMJAR=path to asm-all-5.0.3.jar       
                  RAT_JAVA_HOME=path to jdk8       
                  RAT_AC_JARDIR=Directory where jar files are present for concrete class       
                  RAT_AC_TRCDIR=Directory where trace files are present for coverage class
                Runs acchk. Expects env variables to be set
        2) Run orachk without any parameter. 
                If the above env variables are set, orachk can be run without any parameter to run acchk.
        3) Passing values in command line instead of env variables.
                ./orachk -acchk -javahome <path to jdk8> -asmhome <path to asm-all-5.0.3.jar > -appjar <directory where jar files are present for concrete class > -apptrc <directory where trace files are present for coverage class>

        Optional variable RAT_ACTRACEFILE_WINDOW variable can be set to <number of days> . Based on this value, files older than the RAT_ACTRACEFILE_WINDOW days are ignored.

                With -h prints help.
";  exit 1;
  elif [[ $read_p2r = "-check" ]] ; then
    if [[ $arg = "-h" ]] ; then
      echo -e " 
        Check Run Options:
        -check
                To execute specific set of checks, pass check_ids at command prompt
                With -h prints help.
";  exit 1;
    fi

    check2run=$arg
    remove_arg=1
    run_args="$run_args -check $arg"
  elif [[ $read_p2r = "-excludecheck" ]] ; then
    if [[ $arg = "-h" ]] ; then
      echo -e " 
        Check Run Options:
        -excludecheck
                To exclude specific set of checks, pass check_ids at command prompt
                With -h prints help.
";  exit 1;
    fi

    check2run=$arg
    remove_arg=1
    run_args="$run_args -excludecheck $arg"
  elif [[ $read_p2r = "-excludeprofile" ]] ; then
    p2r_org="$arg"
    profiles2exclude=$arg
    remove_arg=1
    run_args="$run_args -excludeprofile $arg"
  elif [[ $read_p2r = "-id" ]] ; then
    setting_autorun_id=1
    remove_arg=1
    autorun_id=$(echo "$arg" | sed 's/ //g')
    if [[ -z $autorun_id || `echo "$autorun_id" |grep -c "^\s*$"` -gt "0" ]] ; then usage_daemon; exit 1; fi;
  elif [[ $read_p2r = "-set" ]] ; then
    setting_conf=1
    remove_arg=1
    options2set="$arg"
  elif [[ $read_p2r = "-unset" ]] ; then
    unset_conf=1
    remove_arg=1
    options2unset="$arg"
  elif [[ $read_p2r = "-get" ]] ; then
    reading_conf=1
    remove_arg=1
    options2get="$arg"
  elif [[ $read_p2r = "-sendemail" ]] ; then
    setting_conf=1
    remove_arg=1
    options2set="$arg"
  elif [[ $read_p2r = "-get_dlog_policy" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-auto_restart" ]]; then
    if [[ $arg = "-h" ]] ; then
      usage_AR;exit 1;
    fi
  elif [[ $read_p2r = "-idm" ]]; then
    if [[ $arg = "-h" ]] ; then
      usage_IDM;exit 1;
    fi
  elif [[ $read_p2r = "-d" ]]; then
    if [[ $arg = "-h" ]] ; then
      usage_dopt;exit 1;
    fi
  elif [[ $read_p2r = "-dbparallel" ]] ; then
    if [[ `perl -e 'if ( "'$arg'" =~ m/[0-9]+$/ ) {print "1";} else {print "0";}'` -gt "0" ]]; then
    #if [[ `echo "$arg"|grep -Ec "[0-9]+$"` -gt 0 ]]; then
      export RAT_DB_PAR_LIMIT="$arg"
    fi
  elif [[ $read_p2r = "-dbparallelmax" ]] ; then
    export RAT_DB_PAR_LIMIT="max"
  elif [[ $read_p2r = "-clusternodes" ]] ; then
    export RAT_CLUSTERNODES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-cleanup" ]] ; then
    MCLEANUP=1
    OFFLINE=0
    HOSTLIST="$arg"
    LOGFIL="$WRKDIR/${program_name}_manual_cleanup.log"
    localnode=`hostname | tr "[A-Z]" "[a-z]"|cut -d. -f1|tr -d '\r'`
    assign_scr_switches
    ssh_setup_remotenodes
    cleanup
    exit 0
    remove_arg=1
  elif [[ $read_p2r = "compute_user" ]] ; then
    foxtrot_dom0_user="$arg" 
    remove_arg=1
  elif [[ $read_p2r = "-output" ]] ; then
    export RAT_OUTPUT="$arg"
    RAT_OUTPUT_INTERNAL=1
    initialize
    remove_arg=1
  elif [[ $read_p2r = "-includedir" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-uploadfailed" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-baseline" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-tag" ]] ; then
    TAG=_"$arg"
    remove_arg=1
  elif [[ $read_p2r = "-phy" ]] ; then
    if [ $exalogic_hybrid -eq "1" ] ; then
      phy_nodes="$arg"
      remove_arg=1
    fi
  elif [[ $read_p2r = "-vmguest" ]] ; then
    export RAT_EL_GVM="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-cells" ]] ; then
    export RAT_CELLS="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-zfsnodes" ]] ; then
    export RAT_ZFS_NODES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-extzfsnodes" ]] ; then
    export RAT_EXT_ZFS_NODES="$arg"
    remove_arg=1
 elif [[ $read_p2r = "-zfssa" ]] ; then
    export RAT_ZFS_NODES="$arg"
    remove_arg=1
 elif [[ $read_p2r = "-credfile" ]] ; then
    opc_credfile="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-ibswitches" ]] ; then
    export RAT_IBSWITCHES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-torswitches" ]] ; then
    export RAT_TORSWITCHES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-outfile" ]] ; then
    report3="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-targetversion" ]]; then
    targetversion="$arg" 
    remove_arg=1
  elif [[ $read_p2r = "-dbnames" ]] ; then
    export RAT_DBNAMES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-testemail" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-setdbupload" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-unsetdbupload" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-lockcells" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-unlockcells" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-sendemail" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-fileattr" ]] ; then
    remove_arg=1
  elif [[ $read_p2r = "-javahome" ]] ; then
    export RAT_JAVA_HOME="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-asmhome" ]] ; then
    export RAT_AC_ASMJAR="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-appjar" ]] ; then
    export RAT_AC_JARDIR="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-apptrc" ]] ; then
    export RAT_AC_TRCDIR="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-systemtype" ]]; then
    export SYS_TYPE="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-orainst" ]]; then
    ask_inv_loc="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-merge" ]]; then
    export MERGEFILES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-topology" ]]; then
    export fmw_topology="$arg"
    is_fmw_machine=1
    APPTYPE="IDM"
    lt_ver_check=0;
    remove_arg=1
  elif [[ $read_p2r = "-credconfig" ]]; then
    export fmw_credconfig="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-idm_config" ]] ; then
    idm_config="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-dlogmaxsize" ]]; then
    RAT_DAEMON_LOGMAXSIZE="$arg"
    RAT_DAEMON_LOGMAXSIZE=$(echo "$RAT_DAEMON_LOGMAXSIZE"|sed 's/ //g')
    export RAT_DAEMON_LOGMAXSIZE=$RAT_DAEMON_LOGMAXSIZE
    remove_arg=1
  elif [[ $read_p2r = "-idmdiscargs" ]] ; then
    export RAT_IDMDISCARGS="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-idmhcargs" ]] ; then
    export RAT_IDMHCARGS="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-auto_restart" ]]; then
   if [[ $arg = "-h" ]] ; then
    usage_AR;exit 1;
   fi
  elif [[ $read_p2r = "-idm" ]]; then
   if [[ $arg = "-h" ]] ; then
    usage_IDM;exit 1;
   fi
  elif [[ $read_p2r = "-d" ]]; then
   if [[ $arg = "-h" ]] ; then
    usage_dopt;exit 1;
   fi
  #elif [[ $read_p2r = "-debug" ]]; then
  # if [[ $arg = "-h" ]] ; then
  #  usage_granular $read_p2r;exit 1;
  # fi
  fi

  if [ $remove_arg -eq "1" ] ; then
    arg=$(echo "$arg"| sed 's/\*/\\\*/g')
    argnew=$(echo "$argnew" | sed 's|'"$read_p2r"'||' | sed "s|$arg||")
    long_args=1
  elif [ $remove_arg -eq "3" ] ; then
    read_p2r=$(echo "$read_p2r"| sed 's/\*/\\\*/g')
    argnew=$(echo $argnew | sed 's/'"$read_p2r"'//')
    long_args=1
  fi

  case $arg in 
  "-profile")
    run_profile=1;
    TYP="-b";
    read_p2r="$arg"
    ;;
  "-check")
    run_check=1;
    TYP="-b";
    read_p2r="$arg"
    ;;
  "-excludecheck")
    exclude_check=1;
    TYP="-b";
    read_p2r="$arg"
    ;;
  "-h")
    usage_granular $read_p2r;exit 1;
    ;;
  #"-diff")
  #  read_p2r="$arg"
  #  ;;
  "-dbserial")
    export RAT_DB_PARALLEL=0
    unset RAT_DB_PAR_LIMIT    
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-dbparallel")
    export RAT_DB_PARALLEL=1    
    set_db_par_limit=1
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-dbparallelmax")
    export RAT_DB_PARALLEL=1    
    set_db_par_limit=1
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-dbnodeserial")
    read_p2r="$arg"
    export RAT_COMPUTE_RUNMODE="serial"
    remove_arg=2
    ;;
  "-cellserial")
    read_p2r="$arg"
    export RAT_CELL_RUNMODE="serial"
    remove_arg=2
    ;;
  "-switchserial")
    read_p2r="$arg"
    export RAT_IBSWITCH_RUNMODE="serial"
    remove_arg=2
    ;;
  "-allserial")
    read_p2r="$arg"
    export RAT_GLOBAL_RUNMODE="serial"
    export RAT_COMPUTE_RUNMODE="serial"
    export RAT_CELL_RUNMODE="serial"
    export RAT_IBSWITCH_RUNMODE="serial"
    remove_arg=2
    ;;
  "-excludeprofile")
    exclude_profile=1;
    TYP="-b";
    read_p2r="$arg"
    ;;
  "-id")
    read_p2r="$arg"
    ;;
  "-set"|"-get"|"-unset")
    read_p2r="$arg"
    ;;
  "-get_dlog_policy")
    show_daemonlog_policy 
    ;;
  "-clusternodes")
    read_p2r="$arg"
    ;;
  "-cleanup")
    read_p2r="$arg"
    ;;
  "-output")
    read_p2r="$arg"
    ;;
  "-includedir")
    read_p2r="$arg"
    ;;
  "-uploadfailed")
    upload_failed=1;
    read_p2r="$arg"
    ;; 
  "-baseline")
    read_p2r="$arg"
    ;;
  "-tag")
    read_p2r="$arg"
    ;;
  "-phy")
    read_p2r="$arg"
    ;;
  "-force")
    read_p2r="$arg"
    SKIP_CRS_VAL=1 
    remove_arg=2
    ;;
  "-vmguest")
    read_p2r="$arg"
    ;;
  "-merge")
    TYP="-f"
    read_p2r="$arg"
    ;;
  "-testemail")
    read_p2r="$arg"
    test_email_config=1
    ;;
  "-setdbupload")
    read_p2r="$arg"
    wallet_upload=1
    ;;
  "-unsetdbupload")
    read_p2r="$arg"
    wallet_upload=2
    ;;
  "-lockcells")
    read_p2r="$arg"
    exacli_command_line_enabled=1
    lockcells_through_commandline=1
    ;;
  "-unlockcells")
    read_p2r="$arg"
    exacli_command_line_enabled=1
    unlockcells_through_commandline=1
    ;;
  "-fileattr")
    read_p2r="$arg"
    file_checker=1
    ;;
  "-sendemail")
    read_p2r="$arg"
    cmd_line_email=1
    ;;  
  "-dbnames")
    read_p2r="$arg"
    dbnames=1
    ;;
  "-topology")
    read_p2r="$arg"
    ;;
  "-credconfig")
    read_p2r="$arg"
    ;;
  "-archive"|"-delete")
    export RAT_DAEMON_LOGRETPOLICY="$arg"
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-idmruntime")
    APPTYPE="IDM"
    export fmw_runmode="runtime"
    is_fmw_machine=1
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-idmdbruntime")
    read_p2r="$arg"
    APPTYPE="IDM"
    export fmw_runmode="runtime"
    is_fmw_machine=1
    fmw_dbrunonly=1
    remove_arg=2
    ;;
  "-idm_config")
    read_p2r="$arg"
    ;;
  "-dlogmaxsize")
    read_p2r="$arg"
    ;;
  "-idmdiscargs")
    read_p2r="$arg"
    ;;
  "-idmhcargs")
    read_p2r="$arg"
    ;;
  #"-idm_comps")
  #  read_p2r="$arg"
  #  ;;
  "-idmpreinstall")
    APPTYPE="IDM"
    export fmw_runmode="pre"
    is_fmw_machine=1
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-idmdbpreinstall")
    read_p2r="$arg"
    APPTYPE="IDM"
    export fmw_runmode="pre"
    is_fmw_machine=1
    fmw_dbrunonly=1
    remove_arg=2
    ;;
  "-idmpostinstall")
    APPTYPE="IDM"
    export fmw_runmode="post"
    is_fmw_machine=1
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-idmdbpostinstall")
    read_p2r="$arg"
    APPTYPE="IDM"
    export fmw_runmode="post"
    is_fmw_machine=1
    fmw_dbrunonly=1
    remove_arg=2
    ;;
  "-idm")
    read_p2r="$arg"
    ;;
  "-cells")
    read_p2r="$arg"
    ;;
  "-zfsnodes")
    read_p2r="$arg"
    ;;
  "-extzfsnodes")
    read_p2r="$arg"
    ;;
  "-zfssa")
    read_p2r="$arg"
    run_profile=1
    is_zfssa_machine=1
    if [ -z "$RAT_ROOT_TIMEOUT" ] ; then RAT_ROOT_TIMEOUT=1200; fi
    ;;
  "-credfile")
    read_p2r="$arg"
    ;;
  "-ibswitches")
    read_p2r="$arg"
    ;;
  "-auto_restart")
    read_p2r="$arg"
    ;;
  "-localonly")
    read_p2r="$arg"
    localonly=1
    export RAT_LOCALONLY=1
    remove_arg=2
    ;;
  "-refresh_cache")
    read_p2r="$arg"
    REFRESH_CACHE=1
    remove_arg=2
    ;;
  "-create_cache")
    read_p2r="$arg"
    CREATE_CACHE=1
    remove_arg=2
    ;;
  "-use_cache")
    read_p2r="$arg"
    export RAT_CACHE_RUN=1
    initialize 
    remove_arg=2
    ;;
  "-oracle_compute")
    read_p2r="$arg"
    is_exalogic_foxtrot=1
    remove_arg=2
    ;;
  "-torswitches")
    read_p2r="$arg"
    ;;
  "-opc")
    read_p2r="$arg"
    is_opc=1
    prompt_timeout=1
    remove_arg=2
    ;;
  "-syslog")
    read_p2r="$arg"
    RAT_SEND_TO_RSYSLOG=1
    RAT_SEND_TO_RSYSLOG_CMDLINE=1
    remove_arg=2
    ;;
  "-silentforce")
    read_p2r="$arg"
    prompt_timeout=1
    remove_arg=2
    ;;
  "-noupgrade")
    read_p2r="$arg"
    remove_arg=2
    no_upgrade=1
    ;;
  "-skip_usr_def_checks")
    read_p2r="$arg"
    remove_arg=2
    skip_usr_def_checks=1
    ;;
  "-oracle_restart")
    read_p2r="$arg"
    export RAT_ORACLE_RESTART=1
    remove_arg=2
    ;;
  "-probe")
    read_p2r="$arg"
    EM_PROBE_MODE=1
    export RAT_EM_PROBE=1
    remove_arg=2
    ;;
  "-upgrade")
    set_upgrade=1
    read_p2r="$arg"
    ;;  
  "-acchk")
    localonly=1
    export RAT_LOCALONLY=1
    run_acchk=1
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-debug")
    read_p2r="$arg"
    export RAT_SCRIPT_DEBUG=1
    debugflagset=1;
    ;;
   "-a")
     read_p2r="$arg"
     ;;
   "-b")
     read_p2r="$arg"
     ;;
   "-v")
     read_p2r="$arg"
     ;;
   "-p")
     read_p2r="$arg"
     ;;
   "-m")
     read_p2r="$arg"
     ;;
   "-u")
     read_p2r="$arg"
     ;;
   "-f")
     read_p2r="$arg"
     ;;
   "-o")
     read_p2r="$arg"
     ;;
   "-clusternodes")
     read_p2r="$arg"
     ;;
   "-cleanup")
     read_p2r="$arg"
     ;;
   "-output")
     read_p2r="$arg"
     ;;
   "-includedir")
    read_p2r="$arg"
    ;;
   "-uploadfailed")
    read_p2r="$arg"
    ;;
   "-baseline")
     read_p2r="$arg"
     ;;
   "-testemail")
     read_p2r="$arg"
     ;;
   "-setdbupload")
     read_p2r="$arg"
     ;;
   "-unsetdbupload")
     read_p2r="$arg"
     ;;   
   "-lockcells")
     read_p2r="$arg"
     ;;
   "-unlockcells")
     read_p2r="$arg"
     ;; 
   "-sendemail")
     read_p2r="$arg"
     ;;
   "-fileattr")
     read_p2r="$arg"
     ;;
   "-dbnames")
     read_p2r="$arg"
     ;;
   "-c")
     read_p2r="$arg"
     ;;
   "-d")
     read_p2r="$arg"
     ;;
  "-dbnone")
    read_p2r="$arg"
    export RAT_DBNONE=1
    remove_arg=2
    ;;
  "-dball")
    read_p2r="$arg"
    export RAT_DBALL=1
    remove_arg=2
    ;;
  "-ebs32bit")
    read_p2r="$arg"
    ebs32bit=1
    remove_arg=2
    ;;
  "-hybrid")
    read_p2r="$arg"
    exalogic_hybrid=1
    remove_arg=2
    ;;
  "-initpresetup")
    read_p2r="$arg"
    prepare_init=1
    remove_arg=2
    ;;
  "-init")
    read_p2r="$arg"
    daemon_init_mode=1
    remove_arg=2
    ;;
  "-initsudo")
    read_p2r="$arg"
    daemon_init_mode=1
    daemon_init_mode_sudo=1
    remove_arg=2
    ;;
  "-initsetup")
    read_p2r="$arg"
    setup_inittab=1
    remove_arg=2
    ;;
  "-initdebugsetup")
    read_p2r="$arg"
    setup_inittab=7
    remove_arg=2
    ;;
  #"-initrestart")
  #  read_p2r="$arg"
  #  setup_inittab=2
  #  remove_arg=2
  #  ;;
  "-initcheck")
    read_p2r="$arg"
    setup_inittab=3
    remove_arg=2
    ;;
  "-initrmsetup")
    read_p2r="$arg"
    setup_inittab=10
    remove_arg=2
    ;;
  #"-update")
  #  read_p2r="$arg"
  #  UPDATE_RUN=1 
  #  remove_arg=2
  #  ;;
  "-nopass")
    read_p2r="$arg"
    print_pass_in_report=0
    remove_arg=2
    run_args="$run_args -nopass"
    export RAT_UPLOAD_PASS_CHECKS=0
    ;;
  "-noscore")
    read_p2r="$arg"
    print_score_in_report=0
    remove_arg=2
    run_args="$run_args -noscore"
    ;;
  "-showpass")
    read_p2r="$arg"
    show_pass_in_report=1
    remove_arg=2
    run_args="$run_args -showpass"
    export RAT_SHOWPASS=1
    ;;
  "-show_critical")
    read_p2r="$arg"
    show_critical_in_report=1
    remove_arg=2
    run_args="$run_args -show_critical"
    export RAT_SHOW_CRITICAL_INTERNAL=1
    ;;
  "-preupgrade")
    TYP="-u"
    upgrade_mode=1
    remove_arg=2
    argnew="-u -o pre"
    ;;
  "-postupgrade")
    TYP="-u"
    upgrade_mode=1
    remove_arg=2
    argnew="-u -o post"
    ;;
  "-targetversion")
    read_p2r="$arg"
    supportedTargetVersion="112040 121020 122010 122000"
    supportedTargetVersionPrint="11.2.0.4.0, 12.1.0.2.0 or 12.2.0.1.0"
    ;;
  "-sf")
    #change this line before beta (scp)
    scp $2 my@myhost:/home/me/test_reports
    exit 0
    ;;
   "-sk")
    #change this line before beta (scp)
    cop_file_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
    scp me@myhost:/net/me/scratch/me/view_storage/me_tfa/tfa/lib/$cop_file_name.zip .
    unzip -oq $cop_file_name.zip
    exit 0
    ;;

  "-setupssh")
    remote_setup_ssh=1
    func_remote_setup_ssh $*
    exit 0
    ;;
  "-diff")
    compare_reports $*
    exit 0
    ;;
  "-usecompute")
    read_p2r="$arg"
    remove_arg=2
    use_dbserver_mail=1
    ;;
  "-checkfaileduploads")
    read_p2r="$arg"
    remove_arg=2
    check_failed_uploads=1;
    ;; 
  "-checkdbupload")
    read_p2r="$arg"
    remove_arg=2
    wallet_upload=3
    ;;
  "-getdbupload")
    read_p2r="$arg"
    remove_arg=2
    wallet_upload=4
    ;; 
  "-cmupgrade")
    read_p2r="$arg"
    remove_arg=2
    cmdline_cm_upgrade=1
    ;; 
  "-excludediscovery")
    read_p2r="$arg"
    remove_arg=2
    exlude_discovered_dir=1;
    ;; 
  "-fileattronly")
    read_p2r="$arg"
    remove_arg=2
    file_check_only=1;
    ;;
  "-download")
    download_ARU=1 
    ;;
  "-exadiff")
    compare_exalogic_rack $*
    exit 0
    ;;
  #"-resetcrs")
  #  reset_crs $*
  #  exit
  #  ;;
  "-outfile")
    read_p2r="$arg"
    ;;
  "-nodaemon")
    read_p2r="$arg"
    opt_n=1;
    remove_arg=2
    ;;
  "-daemon")
    read_p2r="$arg"
    daemon_only=1;
    remove_arg=2
    ;;
  "-systemtype")
    read_p2r="$arg"
    ;;    
  "-orainst")
    read_p2r="$arg"
    ;;
  "-a")
    read_p2r="$arg"
    ;;
  "-b")
    read_p2r="$arg"
    ;;
  "-v")
    read_p2r="$arg"
    ;;
  "-p")
    read_p2r="$arg"
    ;;
  "-m")
    read_p2r="$arg"
    ;;
  "-u")
    read_p2r="$arg"
    ;;
  "-f")
    read_p2r="$arg"
    ;;
  "-o")
    read_p2r="$arg"
    ;;
  "-clusternodes")
    read_p2r="$arg"
    ;;
  "-cleanup")
    read_p2r="$arg"
    ;;
  "-output")
    read_p2r="$arg"
    ;;
  "-includedir")
    read_p2r="$arg"
    ;;
  "-uploadfailed")
    read_p2r="$arg"
    ;;
  "-baseline")
    read_p2r="$arg"
    ;;
  "-testemail")
    read_p2r="$arg"
    ;;
  "-setdbupload")
    read_p2r="$arg"
    ;;   
  "-unsetdbupload")
    read_p2r="$arg"
    ;;
  "-lockcells")
    read_p2r="$arg"
    ;;
  "-unlockcells")
    read_p2r="$arg"
    ;;
  "-sendemail")
    read_p2r="$arg"
    ;;
  "-fileattr")
    read_p2r="$arg"
    ;; 
  "-dbnames")
    read_p2r="$arg"
    ;;
  "-javahome")
    read_p2r="$arg"
    ;;
  "-asmhome")
    read_p2r="$arg"
    ;;
  "-appjar")
    read_p2r="$arg"
    ;;
  "-apptrc")
    read_p2r="$arg"
    ;;
  "-c")
    read_p2r="$arg"
    ;;
  "-d")
    read_p2r="$arg"
    ;;
  *)
    read_p2r="none"
    ;;
  esac

  if [ $remove_arg -eq "2" ] ; then
    read_p2r=$(echo "$read_p2r"| sed 's/\*/\\\*/g')
    argnew=$(echo $argnew | sed 's/'"$read_p2r"'//')
    long_args=1
  fi
done

if [[ -n "$RAT_SEND_TO_RSYSLOG" && $RAT_SEND_TO_RSYSLOG -eq 1 ]] ; then
  RAT_SEND_TO_RSYSLOG_CMDLINE=1
fi

if [[ -n "$opc_credfile" && ! -r "$opc_credfile" ]] ; then
  echo -e "${RED}Error: Cannot open $opc_credfile for reading.${NORM}";
  exit;
fi
  if [ -n "$opc_credfile" ] ; then
    OPC_ZFS_CREDFILE=$opc_credfile
    OCM_SW_CREDFILE=$opc_credfile
  fi

if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN = 1 && "$RAT_RUNMODE_INTERNAL" != "slave" ]]; then
  echo "Using cache.."
  echo ""

  CACHE_DIR=$WRKDIR
  if [[ -n $RAT_CACHE_LOC ]]; then CACHE_DIR=$RAT_CACHE_LOC; fi
  CACHE_FIL=$CACHE_DIR/.${program_name}_cache.cfg

  if [ ! -r $CACHE_FIL ]; then export RAT_CACHE_RUN=0; fi
fi
  
if [ $debugflagset -eq "1" ]
then
  insargs="$@"
  insargs=$(echo "$insargs"|sed 's/-debug//g')

  #PDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" 
  PDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
  ${PDIR}/${program_name} "$insargs"
  exit 0
fi

if [ ! -n "$perl_exe" ] ; then perl_exe=$(which perl|tr -d '\r'); fi
tag_without_sp=$(echo "$TAG" | $perl_exe -p -e "s/[\W\s]//g")
if [[ -n "$TAG" && $TAG != "$tag_without_sp" ]] ; then
  echo -e ${RED}"Invalid tag"${NORM}
  usage_granular "-tag"
  echo -e "\n${RED}${program_name} is exiting..\n"${NORM}
  exit 1;
fi 

# Exit options not supported in windows
if [ $is_windows -eq "1" ] ; then
  if [[ $setup_inittab -eq "1" || $setup_inittab -eq "7" || $daemon_init_mode -eq 1 || $daemon_init_mode_sudo -eq "1" || $prepare_init -eq "1" ]] ; then
    echo 
    echo "The flag '$*' is not supported in windows.. exiting..";
    echo
    exit;
  fi
fi

READ="read"
if [[ $prompt_timeout -eq 1 ]]
then
  if [[ -z $RAT_PROMPT_TIMEOUT ]]; then export RAT_PROMPT_TIMEOUT=0; fi
  READ="read -t $RAT_PROMPT_TIMEOUT"
fi
if [[ -n "$profiles2run" && $profiles2run = "security" ]] 
then
    if [[ $EM_XMLD_MODE -eq 1 ]]
    then
	echo -e "Security profile will check set of default passwords for Operating system and database users. Your fail password count will increase and user account may be locked for certain period"
	read_probe_xml "Do you want to continue to run security profile?[y/n][n]"
	securityYesNo=$xml_rvalue
    else
	echo -e $RED"\n\nSecurity profile will check set of default passwords for Operating system and database users. Your fail password count will increase and user account may be locked for certain period\n\n"$NORM
        exec 3<&2; exec 2<&0 
	$READ -p "Do you want to continue to run security profile?[y/n][n]" securityYesNo
	read_code=`echo $?`;
	exec 2<&3
	process_prompt "$read_code" "securityYesNo" "n"
    fi
    case $securityYesNo in
    n|N|No|NO|no)
	echo -e $RED"\n\n$program_name is exiting ....\n\n"$NORM
	exit 1
	;;
    y|Y|yes|Yes|YES)
    	export RAT_DB_PARALLEL=0
	unset RAT_DB_PAR_LIMIT
        ;; 
    *)
	echo -e $RED"\n\n$program_name is exiting ....\n\n"$NORM
       exit 1
       ;;
    esac
fi
if [[ -n $download_ARU && $download_ARU -eq "1" ]]; then
  check_wrkdir

  localnode=`hostname | tr "[A-Z]" "[a-z]"|cut -d. -f1|tr -d '\r'`
  OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
  OUTPUTDIR=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}${TAG}

  mkdir $OUTPUTDIR >/dev/null 2>&1
  if [ ! -d $RTEMPDIR ]; then mkdir $RTEMPDIR >/dev/null 2>&1;fi

  download_from_ARU $*
  
  if [ -e "$RAT_DEBUG_FILENAME_INTERNAL" ]; then cp -f $RAT_DEBUG_FILENAME_INTERNAL $OUTPUTDIR >/dev/null 2>&1; fi

  cleanup
  exit 0
fi

if [[  $set_upgrade -eq "1" ]] ; then
  if [[ -n  "$RAT_UPGRADE_LOC" ]] ; then
    check_upgrade
    if [[ "$check_upgrade_ret_val" != "0" && "$check_upgrade_ret_val" != "-1" ]]
    then
      upgrade_orachk
    else
	if [ "$check_upgrade_ret_val" = "-1" ]
        then
                echo "
        unzip is not found. please install unzip, add it to the path and run again.
                ";
	else
		echo "
        No new version is available in RAT_UPGRADE_LOC.
      ";
        fi
    fi
  else
    echo "
	RAT_UPGRADE_LOC not set
    ";
  fi 
  exit 0
fi

if [[  -n "$RAT_UPLOAD_PASS_CHECKS" &&  $RAT_UPLOAD_PASS_CHECKS -eq "0" ]] && [[  -n "$RAT_SHOWPASS" &&  $RAT_SHOWPASS -eq "1" ]] ; then
	
	echo "
-nopass and -showpass options are mutually exclusive and hence cannot be used together";
	echo "
		-nopass
                Skip PASS'ed check to print in ${program_name} report and upload to database."
	echo "
		-showpass 
                Show PASS'ed checks in the ${program_name} report by default"

	echo -e ${RED}"\n${program_name} is exiting.."${NORM}
	exit 0;	
fi

if [[  -n "$RAT_JAVA_HOME" && -n "$RAT_AC_ASMJAR" ]] && [[ -n "$RAT_AC_JARDIR" || -n "$RAT_AC_TRCDIR" ]] ; then
  echo "
Acchk related env vars set. Running Acchk

";
  run_acchk=1;
  if [[ ! -d "$RAT_JAVA_HOME" ]]
  then
    echo "Invalid JAVA HOME $RAT_JAVA_HOME. Exiting....";
    exit 0;
  fi
  if [[ ! -f "$RAT_AC_ASMJAR" ]]
  then
    echo "ASM jar $RAT_AC_ASMJAR does not exist. Exiting....";
    exit 0;
  fi
  if [[ -n "$RAT_AC_JARDIR" && ! -d "$RAT_AC_JARDIR" ]]
  then
    echo "Application jar directory $RAT_AC_JARDIR does not exist. Exiting....";
    exit 0;
  fi
  if [[ -n "$RAT_AC_TRCDIR" && ! -d "$RAT_AC_TRCDIR" ]]
  then
    echo "Application trc directory $RAT_AC_TRCDIR does not exist. Exiting....";
    exit 0;
  fi
fi

if [[  -n $run_acchk && $run_acchk -eq "1" ]] ; then
  if [[  -z "$RAT_JAVA_HOME" || -z "$RAT_AC_ASMJAR" ]] ; then
    echo "
    Please set RAT_JAVA_HOME and RAT_AC_ASMJAR before running this option.";
    echo -e ${RED}"\n${program_name} is exiting.."${NORM}
    exit 0;
  fi
  if [[  -z "$RAT_AC_JARDIR" && -z "$RAT_AC_TRCDIR" ]] ; then
    echo "
    Please set either RAT_AC_JARDIR for concrete class checks or RAT_AC_TRCDIR for coverage checks";
    echo -e ${RED}"\n${program_name} is exiting.."${NORM}
    exit 0;
  fi
fi

#if [[  -z $run_acchk || $run_acchk -eq "0" ]] ; then
argnew_afterlong=""
if [[ -n "$long_args" && $long_args -eq "1" ]] ; then
  argnew_afterlong=$(echo $argnew| sed 's/ //g')
  if [[ -z "$argnew" || `echo "$argnew" | grep -ic '^ *$'` -gt "0" ]] ; then argnew="-a"; fi
else
  argnew="$*"
  argnew_afterlong="$argnew"
fi
#To add current directory in PATH to execute cgrep from current location

argnew=$(echo "$argnew"|sed "s/^[ ]*//g" | sed "s/[ ]*$//g")

argnew_chk=`perl <<PERLEOF
if ( "$argnew" =~ m/[a-zA-Z]{2,}$/ ) {print "1";} else {print "0";}
PERLEOF
`

if [[ $argnew_chk -gt "0" ]] && [[ `echo "$argnew" | grep -c "\-d"` -le "0" ]] && [[ `echo "$argnew" | grep -c "\-o "` -le 0 ]] && [[ `echo "$argnew" | grep -c "\-c"` -le "0" ]]; then display_usage; exit 1; fi

argsnum=$#

while getopts "abnvhpfmsuSo:c:t:d:" OPT $argnew
do
  case $OPT in
  a) 
     TYP="-a"
     run_args="$run_args $TYP"
     ;;
  b) 
     TYP="-b"
     run_args="$run_args $TYP"
     ;;
  p) 
     TYP="-p"
     run_args="$run_args $TYP"
     ;;
  f) 
     TYP="-f"
     ;;
  s) 
     TYP_S="-s"
     no_upgrade=1
     ;;
  t) 
     supportedTargetVersion="112040 121020 122010 122000"
     supportedTargetVersionPrint="11.2.0.4.0, 12.1.0.2.0 or 12.2.0.1.0"
     if [ -n "$OPTARG" ]
     then
       targetversion=$OPTARG
     else
       echo "Invalid input for target version.";
       exit 1;
     fi
     ;;
  u) 
     TYP="-u"
     upgrade_mode=1
     #opt_n=1
     supportedTargetVersion="112040 121020 122010 122000"
     supportedTargetVersionPrint="11.2.0.4.0, 12.1.0.2.0 or 12.2.0.1.0"
     run_args="$run_args $TYP"
     ;;
  S)
     TYP_S="-S"
     no_upgrade=1
     ;;
  o)
     case $OPTARG in
     verbose|VERBOSE|Verbose|V|v)
       print_pass_on_screen=1
       ;;
     pre)
       if [[ -n "$upgrade_mode" && $upgrade_mode -eq 1 ]];then upgrade_mode=2;components=$(echo "${components}:PREUPGR");fi
       ;;
     post)
       if [[ -n "$upgrade_mode" && $upgrade_mode -eq 1 ]];then upgrade_mode=3;if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]; then components=$(echo "${components}:POSTUPGR");else components=$(echo "${components}:RACCHECK:MAA:POSTUPGR");fi;fi
       ;;
     *)
       echo "Invalid option : -o $OPTARG"
       exit 1;
       ;;
     esac
     ;;
  c)
     if [ -n "$OPTARG" ]
     then
       OPTARG=$(echo $OPTARG|tr "[A-Z]" "[a-z]")
       OPTARG=$(echo "$OPTARG"|sed 's/[:_,]/:/g')
       components=$OPTARG
       options_components=$OPTARG
       #$READ -p "options_components=$options_components"  
     fi
     ;;
  n)
     opt_n=1;
     ;;
  d)
     daemon_mode=1;
     daemon_command="start";
     if [ -n "$OPTARG" ]
     then
       OPTARG=$(echo $OPTARG|tr "[A-Z]" "[a-z]") 
       daemon_command="$OPTARG";
     fi
     ;;
  v)
     lt_ver_check=0
     TYP="-v"
     ;;
  m)
     TYP="-m"
     skip_maa_scorecard=1 
     run_args="$run_args $TYP"
     ;;
  r)
     TYP="-r"
     skip_hacheck=1 
     run_args="$run_args $TYP"
     ;;
  *) display_usage; exit 1;;
  esac
done

shift `expr $OPTIND`

#fi

#if [ $# -gt 5 ]
#then
# usage
#fi

check_wrkdir;

make_daemonlog_policy

if [[ $EM_PROBE_MODE -eq 1 ]]
then
  #group ids
  #GID_EC='g1'; GID_EC_HDR="${program_name} Configuration";
  GID_EC='g1'; GID_EC_HDR="General Configuration";
  GID_DC='g2'; GID_DC_HDR="Database Configuration";
  GID_CC='g3'; GID_CC_HDR="Cell Cluster Configuration";
  GID_SC='g4'; GID_SC_HDR="InfiniBand Configuration";
  GID_ZC='g5'; GID_ZC_HDR="ZFS Appliance Configurations";

  EMINPUT=$(cat);

  for VALUES in `echo "$EMINPUT"`
  do
    if [[ `echo $VALUES| grep -ic "PASSWORD"` -gt 0 ]];
    then
      probe_root_password=$(echo "$VALUES"|grep -i 'PASSWORD'|cut -d'=' -f2|sed 's/ //g');
    else
      export $VALUES
    fi
  done

  pre_is_fmw_machine=$is_fmw_machine

  initialize "$@"
  EM_PROBE_MODE=1
  
  is_fmw_machine=$pre_is_fmw_machine

  if [[ -n $probe_root_password && `echo "$probe_root_password"|sed 's/ //g'` != "" ]] || [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then 
    em_probe_sudo_mode=0; 
  fi

  echo "<?xml version=\"1.0\" encoding=\"utf-8\"?>" > $PROBE_XML 
  echo "<probeoutput ${program_name}Version=\"PROGRAM_VERSION\" ESModel=\"MACHINEMODEL\" ESType=\"MACHINETYPE\">" >> $PROBE_XML

  echo "<exports>" >> $PROBE_XML
  env|grep "^RAT_" | grep -v 'RAT_EM_PROBE' | sed 's/^/  <export>/' | sed 's/$/<\/export>/' >> $PROBE_XML
  echo "</exports>" >> $PROBE_XML
fi

if [[ -n "$reading_conf" && $reading_conf -eq "1" || -n "$setting_conf" && $setting_conf -eq "1" || -n "$unset_conf" && $unset_conf -eq "1" ]]
then
  modify_conf_file
else
  if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "1" ]] && [[ -n "$daemon_mode" && $daemon_mode -ne "1" ]]
  then
    usage_daemon; exit 1;
  fi  
fi

if [[ $argsnum -lt 1 || -z "$TYP" ]]
then
  TYP="-a"
fi
if [[ $run_check -eq 1 ]]
then
  TYP="-b"
fi

if [[ -n "$RAT_DBNONE" && $RAT_DBNONE -eq "1" ]]; then dboption="none"; fi;
if [[ -n "$RAT_DBALL" && $RAT_DBALL -eq "1" ]]; then dboption="all"; fi;

if [[ -n "$reading_conf" && $reading_conf -eq "1" ]] ; then
  show_conf_file $options2get
  exit 0
fi

if [ -n "$MERGEFILES" ]
then
  TYP="-f"
  perl_exe=$(which perl|tr -d '\r');
  if [ -n "$perl_exe" ] ; then
    localhost=$(hostname|cut -d"." -f1)
    if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
      echo "$perl_exe $SCRIPTPATH/.cgrep/merge_collections.pl -f ${MERGEFILES} -n $localhost -p ${program_name} -d ${WRKDIR} -o ${SKIP_CRS_VAL}"
    fi
    $perl_exe $SCRIPTPATH/.cgrep/merge_collections.pl -f ${MERGEFILES} -n $localhost -p ${program_name} -d ${WRKDIR} -o ${SKIP_CRS_VAL}
    mr_code=$(echo $?);

    if [ $mr_code -eq 5 ]
    then
      echo -e ""
      echo -e "Collections are not from same CLUSTER."
    
      for mergedir in `echo "$MERGEFILES"|sed 's/,/ /g'`
      do
	mergedir=$(echo "$mergedir"|sed 's/\.zip//g');
    	found_cluster_name=$(grep CLUSTER_NAME ${mergedir}/outfiles/check_env.out | awk -F"=" '{print $2}')
    	echo -e "  $mergedir : $found_cluster_name"	
      done	

      echo -e ${RED}"\nPlease use -force if candidate collections are from dom0 and domu or global and local zones like ./${program_name} -merge $MERGEFILES -force."${NORM}
      echo -e ${RED}"\n${program_name} is exiting.."${NORM}
      rm -rf $WRKDIR/.MERGED_COLLECTIONS >/dev/null 2>&1;
      exit 1;
    elif [ $mr_code -eq 4 ]
    then
      echo -e ""
      echo -e ${RED}"Please specify correct collections and re-run ${program_name}."${NORM}
      echo -e ${RED}"\n${program_name} is exiting.."${NORM}
      rm -rf $WRKDIR/.MERGED_COLLECTIONS >/dev/null 2>&1;
      exit 1
    fi
    NEW_MASTERFIL1=$WRKDIR/.MERGED_COLLECTIONS/check_env.out.merge
  fi
  copy_localonly
fi

if [[ "$TYP" = "-u" && $upgrade_mode -eq 1 ]]; then echo -e "\n${RED}specify -o pre or -o post option with -u argument like ./${program_name} -u -o pre\n\n${NORM}";exit;fi
user_components=$components

if [[ -n "$setting_conf" && $setting_conf -eq "1" ]] || [[ -n "$unset_conf" && $unset_conf -eq "1" ]] ; then
  update_conf_file
  if [ -z "$argnew_afterlong" ] ; then 
    if [[ ! $cmd_line_email -eq 1 ]]; then exit 0;fi
  fi
fi

daemon_running=0
if [[ -e "$RTEMPDIR_D/daemon.pid" ]] ; then # daemon is running
  dpid=$(cat $RTEMPDIR_D/daemon.pid)
  if [[ -n "$dpid" && `ps -ef | grep $dpid | grep -v grep | wc -l` -gt "0" ]] ; then
    daemon_running=1
  fi
fi

a_daemon_running=0
if [[ `ps -ef|grep -v 'grep'|grep "${program_name}"|grep -vw "$usern"|grep -ic '\-d start'` -gt "0" ]] ; then
  a_daemon_running=2
  a_daemon_user=$(ps -ef|grep -v 'grep'|grep "${program_name}"|grep -vw "$usern"|grep '\-d start'|cut -d' ' -f1|head -1|sed 's/ //g')
  A_RTEMPDIR_D="$TMPDIR/.${program_name}_${a_daemon_user}_d"
  if [[ -d "$A_RTEMPDIR_D" ]] ; then
    a_daemon_running=1
  else
    HDIR=$(cat /etc/passwd|grep -w "$a_daemon_user"|cut -d":" -f6);
    A_RTEMPDIR_D="$HDIR/.${program_name}_${a_daemon_user}_d"
    if [[ -d "$A_RTEMPDIR_D" ]] ; then
      a_daemon_running=1
    fi   
  fi
fi

if [[ $daemon_running -eq "0" && -n "$RTEMPDIR_D" && -d "$RTEMPDIR_D" ]] ; then
  rm -rf $RTEMPDIR_D
fi

# Dont use daemon for offline, silent or -S/-s
#if [[ "$TYP" = "-f" || "$TYP_S" = "S" || "$TYP_S" = "s" ]] ; then
if [[ "$TYP" = "-f" || "$TYP" = "-v" ]] ; then
  opt_n=1
fi

if [[ -n "$opt_n" && $opt_n -eq "1" ]] ; then
  daemon_running=0
  daemon_command=""
  daemon_mode=0
fi

if [[ $EM_PROBE_MODE -eq 1 ]] ; then
 d_running=0
 if [[ $a_daemon_running -eq "1" ]]
 then
    DAEMONFIL="${A_RTEMPDIR_D}/.${program_name}_daemon.loc" 
    d_running=1 
 elif [[ $daemon_running -eq "1" ]]
 then
    d_running=1 
 fi

 if [[ $d_running -eq "1" ]]; then
   if [ -r "$DAEMONFIL" ] ; then
     dloc=$(grep "Install location" $DAEMONFIL|cut -d'=' -f2|sed 's/ //g')   
     dversion=$(grep "${program_name} daemon version" $DAEMONFIL|cut -d'=' -f2|cut -d'_' -f1|sed 's/ //g')   
   fi 
   EMSG="$program_name is already running in daemon mode."
   update_probe_xml "ERROR" "DAEMON" "$EMSG"
   exit 1
 fi
fi

if [[ -n "$daemon_only" && $daemon_only -eq "1" && $daemon_running -eq "0" ]] ; then
  echo
  echo -e "${RED}$program_name daemon is not running. Please start it using '$program_name -d start'${NORM}";
  echo
  exit 1;
fi

if [[ -n "$daemon_command" && $daemon_command = "start_debug" ]]
then
  daemon_command="start"
  RAT_DAEMON_DEBUG=1
elif [[ -n "$daemon_command" && $daemon_command = "xml_start_debug" ]]
then
  EMXML=$(cat);
 
  re_initialize "$@"
  RAT_DAEMON_DEBUG=1
  EM_XMLD_MODE=1
  daemon_command="start"
  daemon_mode=1;
elif [[ -n "$daemon_command" && $daemon_command = "xml_start" ]]
then
  EMXML=$(cat);

  re_initialize "$@"
  EM_XMLD_MODE=1
  daemon_command="start"
  daemon_mode=1;
else
  if [[ -z $RAT_DAEMON_DEBUG ]]
  then
    RAT_DAEMON_DEBUG=0
  else
    RAT_DAEMON_DEBUG=$RAT_DAEMON_DEBUG
  fi
fi
export RAT_DAEMON_DEBUG="$RAT_DAEMON_DEBUG"

if [[ -n "$daemon_command" && $daemon_command != "start" && $daemon_command != "stop" && $daemon_command != "status" && $daemon_command != "nextautorun" && $daemon_command != "info" && $daemon_command != "stop_client" ]] ; then
  echo
  echo -e "${RED}Invalid daemon command $daemon_command. Valid options are start,start_debug,stop,status,info,stop_client,nextautorun${NORM}";
  echo
  exit 1;
fi

if [[ $daemon_running -eq "1" && -n "$daemon_command" && $daemon_command = "start" ]] ; then
  echo
  echo -e "${RED}Daemon is already running with PID $dpid${NORM}";
  echo
  exit 1;
fi

if [[ $a_daemon_running -eq "1" ]]
then
  echo
  if [[ -n "$daemon_command" && $daemon_command = "start" ]] ; then
    if [ -r "$A_RTEMPDIR_D/daemon.pid" ]
    then
      a_dpid=$(cat $A_RTEMPDIR_D/daemon.pid)
      echo -e "${RED}Daemon is already running with PID $a_dpid which is started by ${a_daemon_user} user${NORM}"; 
    else
      echo -e "${RED}Daemon is already running which is started by ${a_daemon_user} user${NORM}"; 
    fi
    echo
    exit 1;
  elif [[ -n "$daemon_command" && $daemon_command = "status" ]] ; then
    if [ -r "$A_RTEMPDIR_D/daemon.pid" ]
    then
      a_dpid=$(cat $A_RTEMPDIR_D/daemon.pid)
      echo -e "Daemon is running with PID $a_dpid which is started by ${a_daemon_user} user"
    else
      echo -e "Daemon is running which is started by ${a_daemon_user} user"; 
    fi
    echo
    exit 1;
  elif [[ -n "$daemon_command" && $daemon_command = "info" ]] ; then
    echo -e "Daemon is running which is started by ${a_daemon_user} user"; 

    A_DAEMONFIL="${A_RTEMPDIR_D}/.${program_name}_daemon.loc" 
    if [ -r "$A_DAEMONFIL" ] ; then
      cat $A_DAEMONFIL
    fi 
    echo
    exit 1;
  elif [[ -n "$daemon_command" && $daemon_command = "stop" ]] ; then
    if [ -r "$A_RTEMPDIR_D/daemon.pid" ]
    then
      a_dpid=$(cat $A_RTEMPDIR_D/daemon.pid)
      echo -e "${RED}Daemon is running with PID $a_dpid which is started by ${a_daemon_user} user.${NORM}"; 
    else
      echo -e "${RED}Daemon is running which is started by ${a_daemon_user} user.${NORM}"; 
    fi
    echo -e "${RED}Please login as ${a_daemon_user} user and then stop the daemon.${NORM}";
    echo
    exit 1;
  fi
elif [[ -n "$daemon_command" && $a_daemon_running -eq "2" ]]
then
  echo 
  if [[ -n "$daemon_command" && $daemon_command = "start" ]] ; then
    echo -e "${RED}Daemon is already running which is started by ${a_daemon_user} user${NORM}";
  elif [[ -n "$daemon_command" && $daemon_command = "status" ]] ; then
    echo -e "Daemon is running which is started by ${a_daemon_user} user";
  elif [[ -n "$daemon_command" && $daemon_command = "info" ]] ; then
    echo -e "Daemon is running which is started by ${a_daemon_user} user";
    echo -e "No more information available";
  elif [[ -n "$daemon_command" && $daemon_command = "stop" ]] ; then
    echo -e "${RED}Daemon is running which is started by ${a_daemon_user} user.${NORM}";
    echo -e "${RED}Please login as ${a_daemon_user} user and then stop the daemon.${NORM}";
  fi
  echo 
  exit 1;
fi


if [[ $daemon_running -eq "0" && $daemon_command = "nextautorun" ]] ; then
  echo
  echo -e "${RED}$program_name daemon is not running. Please start it using '$program_name -d start'${NORM}";
  echo
  exit 1;
elif [[ $daemon_command = "nextautorun" ]] ; then
  next_autorun_on
  exit 1 
fi

if [[ -n "$daemon_command" && $daemon_command = "info" ]] ; then
  if [[ $daemon_running -eq "1" ]] ; then
    if [ -e "$DAEMONFIL" ] ; then
      cat $DAEMONFIL
      echo
      exit 0;
    else
      echo -e "${RED}No information available.${NORM}";
    fi
  else
    echo -e "\n$program_name daemon is not running.";
  fi
  echo
  exit 1;
fi

if [[ -n "$daemon_command" && $daemon_command = "start" &&  ! -e "$EXPECT" ]] ; then
  # expect should be there
  echo -e "${RED}Could not start ${program_name} in daemon mode because expect($EXPECT) is not available to supply ${root_user} passwords.${NORM}" 
  echo
  echo -e "${RED}NOTICE:  Installing the expect utility ($EXPECT) will allow ${program_name} to gather ${root_user} passwords at the beginning of the process and execute ${program_name} on all nodes in parallel speeding up the entire process. For more info - http://www.nist.gov/el/msid/expect.cfm.  Expect is available for all major platforms.  See User Guide for more details.${NORM}"
  echo;
  exit 1;
fi

if [[ $daemon_running -eq "1" && -n "$daemon_command" && $daemon_command = "stop" ]] ; then
  printf "Stopping $program_name daemon.. ";
  if [ -e "$RTEMPDIR_D/commands" ] ; then
    echo
    if [ -f "$RTEMPDIR_D/client.pid" ] ; then
      cpid=$(cat $RTEMPDIR_D/client.pid);
    else
      cpid=$(cat $RTEMPDIR_D/run.pid);
    fi
    echo -e "${RED}Failed to stop the $program_name daemon as there is an active client run (PID : $cpid)${NORM}"
    echo
    touch $RTEMPDIR_D/stop
    echo "$program_name daemon will be stopped once the active client run is finished.";
    echo
    exit 1;
  fi
  stop_daemon_actual
elif [[ $daemon_running -eq "0" && -n "$daemon_command" && $daemon_command = "stop" ]] ; then
  echo -e "\n$program_name daemon is not running\n"
  exit 1
fi

if [[ -n "$daemon_command" && $daemon_command = "stop_client" ]] ; then
  if [[ $daemon_running -eq "1" ]] ; then
     stop_daemon_client 
  else
     echo -e "\n$program_name daemon is not running.";
  fi
  echo
  exit 1;
fi

if [[ -n "$daemon_command" && $daemon_command = "status" ]] ; then
  if [[ $daemon_running -eq "1" ]] ; then
    echo -e "\n$program_name daemon is running. Daemon PID : $dpid\n";
    exit 0;
  else
    echo -e "\n$program_name daemon is not running.";
  fi
  echo
  exit 1;
fi

# Client mode. just submit command and wait for daemon
if [ `echo $argsaved | grep -cw 'update'` -eq "0" ] 
then
  if [[ $daemon_running -eq "1" && -z "$daemon_command" && -z "$RAT_DAEMON_CLIENT" ]] 
  then
    if [[ -n "$setup_inittab" && $setup_inittab -ne "3" ]] 
    then
      if [ -e "$RTEMPDIR_D/commands" ] 
      then
        echo "Another $program_name instance is already in queue.. exiting";
        exit 1;
      fi
    fi
  
    if [[ `echo "$argsaved"|grep -ic 'initrmsetup'` -eq 0 && `echo "$argsaved"|grep -ic 'initcheck'` -eq 0 && `echo "$argsaved"|grep -ic 'initrestart'` -eq 0 && `echo "$argsaved"|grep -ic 'initsetup'` -eq 0 && `echo "$argsaved"|grep -ic 'initdebugsetup'` -eq 0 ]]
    then
      trap 'cleanup_client $USER_INTERRUPT' INT TERM EXIT
      echo "Sending commands to daemon (mypid $$) args : $argsaved"
  
      submit_client_run
    fi
  fi
fi

#trap 'cleanup;exit $USER_INTERRUPT' INT TERM EXIT
if [[ -n "$daemon_command" && $daemon_command = "start" ]]; then export RAT_SKIP_MERGE_INTERNAL=1; fi

set_profile_run 

# Target version
if [ -n "$targetversion" ]
then
  read_targetversion_count=1
  correct_target_version=0

  targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
  targetversion=$(echo $targetversion|sed 's/\.//g') 
  if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
  then 
    echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
    correct_target_version=0
  else 
    correct_target_version=1
  fi
  while [[ $read_targetversion_count -le 2 && $correct_target_version -eq 0 ]]
  do
    read_targetversion
    read_targetversion_count=$(expr $read_targetversion_count + 1)
  done
  if [ $correct_target_version -ne 1 ]; then cleanup;exit -1;fi
fi

if [ ! -e $REFFIL ]
then
  #this reference file drives the entire script  if we can't find it then no use proceeding
  echo -e $RED"The reference data file cannot be found."$NORM
  echo -e $RED"Expected location - "${REFFIL}${NORM}
  exit 1
fi

#Following section to copy right executable at working directory
data_file_type=$(grep -ic FILE_ID $REFFIL)
DECRYPT_VDAT=0
if [ ! -e $EXADATA_CELL_COLLECTIONS ]; then touch $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1;fi
if [[ -n "$data_file_type" && $data_file_type -le 0 ]]
then 
  cgrep_platform=$(uname -s)

  if [ `echo $cgrep_platform|grep -c CYGWIN` -gt 0 ]
  then
    if [ $(uname -m) != "x86_64" ]; then 
      echo -e "\n${RED}Installed Cygwin version is not supported by ${program_name}. Please install 64-Bit Cygwin.\n\n ${program_name} exiting .....\n${NORM}"
      exit 1;
    fi
  fi

  if [[  -e $WRKDIR/cgrep || -d $WRKDIR/cgrep ]] && [[  -z "$RAT_RUNMODE_INTERNAL" ]] && [[ -z $RAT_IGNORE_CGREP_VALIDATION ]]; then
    cgrep_owner="";
    if [[ -f $WRKDIR/cgrep ]] 
    then
      cgrep_owner=`ls -l  $WRKDIR/cgrep 2>/dev/null >&1|$AWK '{print $3}'`;
    fi
    if [[ -d $WRKDIR/cgrep ]] || [[ -f $WRKDIR/cgrep && $usern != $cgrep_owner ]]
    then	
      echo -e "\n${RED}Found cgrep file or dir under $WRKDIR. Please delete or rename the file or dir and run ${program_name} again\n\n ${program_name} exiting .....\n${NORM}"
      exit 1;
    fi
  fi

  if [ $cgrep_platform = "CYGWIN_NT-6.0" ]
  then
    cgrep_platform="CYGWIN_NT-6.3"
  fi
  if [ -e $SCRIPTPATH/.cgrep/cgrep ]
  then
    cp -f $SCRIPTPATH/.cgrep/cgrep $WRKDIR/cgrep >/dev/null 2>&1
  elif [ $cgrep_platform = "Linux" ]
  then 
    if [ -e /etc/redhat-release ] 
    then
      #os_version=$(cat /etc/redhat-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version_json=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [ $os_version -eq 3 ]
      then
        cp -f $SCRIPTPATH/.cgrep/lcgrep3 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 4 ]
      then
        cp -f $SCRIPTPATH/.cgrep/lcgrep4 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 5 ]
      then
        #cp -f $SCRIPTPATH/.cgrep/lcgrep5 $WRKDIR/cgrep >/dev/null 2>&1
        if [ $(uname -p) = "s390x" ]
        then
          cp -f $SCRIPTPATH/.cgrep/zlcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        else
          cp -f $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        fi
      elif [ $os_version -ge 6 ]
      then
        if [ $(uname -p) = "s390x" ]
        then
          cp -f $SCRIPTPATH/.cgrep/zlcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        elif [ $(uname -p) = "sparc64" ]
        then 
          cp -f $SCRIPTPATH/.cgrep/lcgrep6s $WRKDIR/cgrep >/dev/null 2>&1
        else
          cp -f $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        fi
      fi    
      #$READ -p "what_os=$what_os is_exalogic_machine=$is_exalogic_machine and os_version=$os_version"
    elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      os_version=6
      os_version_json=6.4
      cp -f $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
    elif [ -e /etc/SuSE-release ] 
    then
      #os_version=$(cat /etc/SuSE-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      #if [ -z "$os_version" ]; then os_version=$(cat /etc/SuSE-release|grep -i version|awk '{print $3}');fi
      os_version=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version_json=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [ -z "$os_version" ]; then os_version=$(grep -i version /etc/SuSE-release|awk '{print $3}');fi
      if [ $os_version -eq 9 ]
      then
        cp -f $SCRIPTPATH/.cgrep/lcgreps9 $WRKDIR/cgrep >/dev/null 2>&1    
      elif [ $os_version -eq 10 ]
      then
        cp -f $SCRIPTPATH/.cgrep/lcgreps10 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -ge 11 ]
      then 
        if [ $(uname -p) = "s390x" ]
        then
          cp -f $SCRIPTPATH/.cgrep/zlcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
        else
          cp -f $SCRIPTPATH/.cgrep/lcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
        fi
      fi
    fi
  elif [ $cgrep_platform = "SunOS" ]
  then
    if [ `uname -p` = "sparc" ]
    then
      cp -f $SCRIPTPATH/.cgrep/scgrep $WRKDIR/cgrep >/dev/null 2>&1
    elif [ `uname -p|grep -ic 86` -ge 1 ]
    then
      cp -f $SCRIPTPATH/.cgrep/scgrepx86 $WRKDIR/cgrep >/dev/null 2>&1
    fi 
  elif [ $cgrep_platform = "AIX" ]
  then 
    cp -f $SCRIPTPATH/.cgrep/acgrep $WRKDIR/cgrep >/dev/null 2>&1
  elif [ $cgrep_platform = "HP-UX" ]
  then
    cp -f $SCRIPTPATH/.cgrep/hiacgrep $WRKDIR/cgrep >/dev/null 2>&1
  #else
  # echo -e "\n${RED}Error RC-001- Unable to read driver files. Please report this error to your Oracle representative for action.\n\nExiting .....\n${NORM}"
  # exit 1;
  #elif [[ $cgrep_platform = "CYGWIN_NT-6.3" || $cgrep_platform = "CYGWIN_NT-6.1" ]]
  elif [[ $cgrep_platform = "CYGWIN_NT-6.3" || $cgrep_platform = "CYGWIN_NT-6.2" || $cgrep_platform = "CYGWIN_NT-6.1" || $cgrep_platform = "CYGWIN_NT-5.2" ]]
  then
    win_v=$(echo $cgrep_platform | sed 's/CYGWIN_NT-//' | sed 's/\.//');
    if [[ "$win_v" = "62" || "$win_v" = "52" ]]; then win_v=63; fi
    cp -f $SCRIPTPATH/.cgrep/cgrepwin$win_v $WRKDIR/cgrep >/dev/null 2>&1
  fi
  security_fix "fix_file_attributes" "$WRKDIR/cgrep" "" "540"
  #cgrep_perm=$(ls -l cgrep |awk '{ print $1}'|grep -ic x)
  #if [ $cgrep_perm -le 0 ];then echo -e "\n${RED}Error RC-002 - cgrep is not executable. Please change permission to 755 for cgrep and run agian.\n\nExiting .....\n${NORM}";exit 1;fi;
  if [ ! -e $WRKDIR/cgrep ]
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="RC-001- Unable to read driver files.  Please refer to the section for this error code in \"Appendix A - Troubleshooting Scenarios\" of the ${program_name} User Guide"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    errm="RC-001- Unable to read driver files.  Please refer to the section for this error code in Appendix A - Troubleshooting Scenarios of the User Guide"
    echo -e "\n${RED}RC-001- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
    update_errm_in_syslog
    exit 1;
  fi
  export PATH=$PATH:. 
  cgrep_test=$($WRKDIR/cgrep FILE_ID $REFFIL>/dev/null 2>&1)
  if [ $? -ne 0 ]
  then
    #$READ -p "grep =$GREP cgrep_test=$cgrep_test"
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="RC-002- Unable to read driver files.  Please refer to the section for this error code in \"Appendix A - Troubleshooting Scenarios\" of the ${program_name} User Guide"
      update_probe_xml "ERROR" "GENERIC" "$EMSG" 
    fi
    errm="RC-001- Unable to read driver files.  Please refer to the section for this error code in Appendix A - Troubleshooting Scenarios of the User Guide"
    echo -e "\n${RED}RC-002- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
    update_errm_in_syslog
    exit 1;
  fi
  GREP=$WRKDIR/cgrep
  DECRYPT_VDAT=1
else 
  GREP=/bin/grep
fi

au_checked=0
show_version

if [ "$TYP" = "-v" ]
then 
  v_chk_run=1
  echo -e "\n$program_name  version: ${program_version}_${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[a-z]" "[A-Z]"
  cleanup
  exit 0
else
  show_version_envfile=$(echo "${program_name}_version = ${program_version}_${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[a-z]" "[A-Z]")  
  modelVersion=$(echo $show_version_envfile | awk -F"=" '{print $2}')
  if [[ $UPDATE_RUN -eq 0 ]]; then validate_datafile_date;fi
  #modelVersion=$(echo "${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[:lower:]"  "[:upper:]")
fi

if [[ -n $lt_ver_check  && $lt_ver_check -eq "1" ]]; then
  export RAT_IGNORE_CGREP_VALIDATION=1
  search_latest_version
  unset RAT_IGNORE_CGREP_VALIDATION

  if [[ -n $skip_search_latest_version && $skip_search_latest_version -eq "0" ]]; then
    echo -e ""
    echo -e "Running ${program_name}"
    echo -e "----------------------------------------------------------"
    printf "%-30s" "PATH"
    printf "%-31s\n" ": ${LATEST_KIT_PATH}"
    printf "%-30s" "VERSION"
    printf "%-31s\n" ": ${LATEST_VERSION}"
    printf "%-30s" "COLLECTIONS DATA LOCATION"
    printf "%-31s\n" ": $WRKDIR"
    echo -e "----------------------------------------------------------"

    echo -e ""

    t_argsaved="$argsaved -noupgrade"
    export RAT_LT_VERCHECK=0
    if [ -d $LATEST_KIT_PATH ]; then ${LATEST_KIT_PATH}/${program_name} $t_argsaved; exit 0; fi
  fi
fi

#Auto Downloader
if [[ "$au_checked" = "0" ]]
then
  download_from_mos
fi

#follwoing check is to not to run non storage server
if [ "$TYP" != "-f"  ]
then
  if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]
  then 
    if [ -e  /opt/oracle/cell/cellsrv/deploy/config/cellinit.ora ]
    then
      #if [[ $EM_PROBE_MODE -eq 1 ]]
      #then
      #  EMSG="Running ${program_name} on Storage server is not supported.Please run it from compute node"
      #  update_probe_xml "ERROR" "GENERIC" "$EMSG"
      #fi
      #echo -e "${RED}Running ${program_name} on Storage server is not supported.Please run it from compute node.${NORM}"
      #exit 1
      echo -e "\nRunning ${program_name} on Storage server."
      set_program_oncell
    fi
  fi
fi 
#######

components=$(echo $components|tr "[a-z]" "[A-Z]")
components=$(echo "$components"|sed 's/[:_,]/:/g'|sed 's/ /:/g')
#$READ -p "components=$components"
loop_components=$(echo $components|sed 's/:/ /g')
for loop_component in $loop_components
do
  if [ `echo $supported_modules| grep -ic $loop_component` -lt 1 ]
  then
    echo -e "${RED}${components} is not supported component. ${program_name} will run generic checks for components identified from environment${NORM}"
    unset options_components user_components
    if [[ -n "$setup_inittab" ]] && [[ $setup_inittab -ne "3" && $setup_inittab -ne "10" ]] ; then
      if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] || [[ $EM_PROBE_MODE -eq 0 ]]; then 
	exec 3<&2; exec 2<&0; 
 	$READ -p "Press any key to continue ..."; 
	exec 2<&3; 
      fi
    fi
    components=NONE
  fi
done

if [ "$upgrade_mode" -eq "2" ]
then
  read_targetversion_count=0
  while [[ $read_targetversion_count -le 2 && $correct_target_version -eq 0 ]]
  do
    read_targetversion
    read_targetversion_count=$(expr $read_targetversion_count + 1)  
  done
  if [ $correct_target_version -ne 1 ]; then cleanup;exit -1;fi
  user_components=PREUPGR 
elif [ "$upgrade_mode" -eq "3" ]
then
  user_components="RACCHECK:MAA:POSTUPGR"
fi 

#$READ -p "print_pass=$print_pass_on_screen and components=$user_components type=$TYP"
if [ "$TYP_S" = "-s" ]
then
  NOQUESTION="1"
  #TYP="-a"
  if [[ -n "$is_minicluster" && $is_minicluster -eq "1" ]];
  then
      rootYesNoint=3
      DOROOT="0"
   else
      rootYesNoint=2
      DOROOT="1"
   fi
elif [ "$TYP_S" = "-S" ]
then
  NOQUESTION="1"
  DOROOT="0"
  #TYP="-a"
  rootYesNoint=3
  #if [ -z "$RAT_CELL_SSH_USER" ];then RAT_CELL_SSH_USER=cellmonitor;fi
  #if [ -e $CELLIP ]; then checkCellSshConfig "$RAT_CELL_SSH_USER";fi
else
  NOQUESTION="0"
fi

skip_in_silent=1
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then skip_in_silent=0; fi
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 1 && $daemon_running -eq "1" ]] ; then skip_in_silent=0; fi

if [ -f "$REFFIL1" ]
then
  SILENT="0"
else
  SILENT="1"
  UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_collect_${FDS}
  #in case of SILENT mode, force $TYP to -a, 
  #ignore whatever command line argument the use may have used
  if [ "$TYP" != "-u" ]; then TYP="-a";fi
fi

#To unset ORACLE_HOME and CRS_HOME if  its running in non-interactive mode
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]; then unset CRS_HOME ORACLE_HOME; fi;
#Code to set debug=0 if no environment varaiable is found 

if [ -z "$RAT_DEBUG" ]
then
  RAT_DEBUG=0
else
  RAT_DEBUG=1
fi

if [[ -n $lockcells_through_commandline && $lockcells_through_commandline -eq 1 ]]; then
  lock_storage_cells
  exit
fi

if [[ -n $unlockcells_through_commandline && $unlockcells_through_commandline -eq 1 ]]; then
  unlock_storage_cells
  exit  
fi

if [[ $test_email_config -eq 1 ]];then
  send_test_mail
fi

#change this line before beta
#RAT_DEBUG=1
#following line to print info pass also in screen
RAT_INFOPASS=1
#########################################################################################
#To generate a text file in output directory. this text file will have node names in
#cluster and will be used to run the script in offline mode
#########################################################################################
#if [ $UID -eq 0 ]
#then
#   echo -e $RED"Script should not be executed as root user.rather its prefered to execute using software owner\n"$NORM
#   exit 1;
#fi

html_rack_type="Cluster";

#to find out what kind of data files will be processed either small or big one
file_mode=$(grep -c "DB_VERSION" $REFFIL)
if [[ -n "$file_mode" && $file_mode -ge 1 ]] 
then
  DBVERSION=$(grep "DB_VERSION" $REFFIL|awk '{print $3}')
  op_mode=0
else
  op_mode=1
fi

#Condition: -f
if [ $TYP = "-f" ]
then
  OFFLINE=1
  CURRDIR=`pwd`
  if [ -z $RAT_OUTPUT ]; then CURRDIR=$CURRDIR; else CURRDIR=$RAT_OUTPUT; fi; 
  DUMPDIR=`ls -ltr $CURRDIR|grep ^d|grep ${program_name}|tail -1|awk {' print $9'}`
  DUMPDIR=$CURRDIR/$DUMPDIR
  CHKFIL=`basename $MASTERFIL`
  #echo "$%%%%%%%%%%%%%DUMPDIR=$DUMPDIR%%%%%%%%%%%%%%%%%%%%"
  #$READ -p  "$DUMPDIR $MASTERFIL and $CHKFIL"
  if [ -n "$MERGEFILES" ]
  then
    echo -e ""
    echo -e "Merging following collections:"
    echo -e ""
    
    dirarr=$(echo "$MERGEFILES" |tr "," "\n");
    d_index=0;
    for xdir in $dirarr
    do
      if [ $d_index -eq 0 ];
      then
        DUMPDIR=`basename $xdir`;
        DUMPDIR=$(echo $DUMPDIR|sed 's/\.zip//g');
      fi
      echo -e "  $xdir"
      d_index=$(expr $d_index + 1);
    done
    DUMPDIR=$WRKDIR/.MERGED_COLLECTIONS/$DUMPDIR;
    COLLECT_TIMING=$DUMPDIR/${program_name}_collection_timings.out
    #CELLIBNTFILE=$DUMPDIR/cell_ib_count.out
    CELLIBNTFILE=$WRKDIR/.MERGED_COLLECTIONS/cell_ib_count.out.merge
  else
    #if [ $# -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
    if [ $argsnum -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
    then
      echo "" > /dev/null 2&>1
    elif [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
      if [[ -n "$RAT_COMPUTEPASSWORD_INTERNAL" &&  $RAT_COMPUTEPASSWORD_INTERNAL -ne "3" && $UID -ne "0" ]] ; then
        $READ -r -s -p "Enter root password:" root_pass
        $READ -s -p "Start the run:" run_start
      fi
    else
      find $DUMPDIR -name $MASTERFIL 2> /dev/null
      if [ `find $DUMPDIR -name $CHKFIL |wc -l` -ne 1 ]
      then
        if [ `find $DUMPDIR -name check_env.out |wc -l` -ne 1 ]
        then
          echo ""
          exec 3<&2; exec 2<&0
          $READ -p "Please specify the directory which has all files from customer site:-" DUMPDIR
          exec 2<&3
        fi
      fi
      if [ -d "$DUMPDIR" ]
      then
        if [ -z "$MERGEFILES" ]
        then 
      	  exec 3<&2; exec 2<&0
          $READ -p  "Output directory to read for offline use is ${DUMPDIR} Is this correct[y/n][y]" ynoutputdir
	  read_code=`echo $?`;
      	  exec 2<&3
	  process_prompt "$read_code" "ynoutputdir" "y" 

          case  $ynoutputdir in
            y|Y|yes|YES|Yes)
            ;;  
            n|N|No|NO)
              echo ""  
              exec 3<&2; exec 2<&0
              $READ -p "Please specify the directory which has all files from customer site:-" DUMPDIR
              exec 2<&3
              ;;
            *)
              ;;
          esac
        fi
      else
        echo -e "Directory $DUMPDIR does not exists\n"
        exit 1;
      fi
    fi
  fi

  #following statement is to copy files from all directories to OUTPUTDIR to support offline. At the end, it will move files back to directories
  OLD_TMPDIR=$TMPDIR
  TMPDIR=$RTEMPDIR
  if [ -e $DUMPDIR/.CELLDIR ]; then cp -rf $DUMPDIR/.CELLDIR $TMPDIR/ >/dev/null 2>&1;fi
  find $DUMPDIR -name '*.*' -type f -exec mv -f {} $DUMPDIR  \; >/dev/null 2>&1
  if [ -e $TMPDIR/.CELLDIR ] ;then mv -f $TMPDIR/.CELLDIR $DUMPDIR >/dev/null 2>&1;fi
  if [ -e $DUMPDIR/check_env.out ]; then mv -f $DUMPDIR/check_env.out $DUMPDIR/raccheck_env.out;fi
  TMPDIR=$OLD_TMPDIR
  outfilefds1=$(basename $DUMPDIR|cut -d_ -f2)
  outfilefds2=$(basename $DUMPDIR|cut -d_ -f3)
  outfilefds3=$(basename $DUMPDIR|cut -d_ -f4)
  outfilefds4=$(basename $DUMPDIR|cut -d_ -f5)
  if [ -n "$outfilefds4" ] ; then outfilefds3="${outfilefds3}_${outfilefds4}"; fi

  UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${outfilefds1}_${outfilefds2}_${outfilefds3}
  #$READ -p "${UPLOADFIL} is the correct directory to analyze?[y/n][y]"
  HOSTLIST=$DUMPDIR/o_host_list.out
  OUTPUTDIR=$DUMPDIR
  SPOOLFIL=$OUTPUTDIR/d_check.out
  OSOUTFIL=$OUTPUTDIR/o_check
  UPDATEFIL=$OUTPUTDIR/db_update_$FDS.sql
  SQLLOGFIL=$OUTPUTDIR/sql.log
  CHK_TIMINGS=$OUTPUTDIR/${program_name}_epoch_checks_timings.out
  COLLECT_TIMING=$OUTPUTDIR/${program_name}_collection_timings.out
  napply_missing_list=$OUTPUTDIR/o_napply_missing_list.out
  if [[ -z "$RAT_RUNMODE_INTERNAL" ]] ; then
    LOGFIL=/dev/null
    SKIPFIL=/dev/null
    RSKIPFIL=/dev/null
    REPFIL=/dev/null
    XMLREPFIL=/dev/null
    XMLSKIPFIL=/dev/null
    JSONREPFIL=/dev/null
    CLOUDLOG=/dev/null
    JSONSKIPFIL=/dev/null
    XMLRECFIL=/dev/null
    SREPFIL=/dev/null
    REPFIL_PASS=/dev/null
    SREPFIL_PASS=/dev/null
    REPFIL_FAIL=/dev/null
    SREPFIL_FAIL=/dev/null
    PREPFIL=/dev/null
    PSREPFIL=/dev/null
    CWCREPFIL_PASS=/dev/null
    SCWCREPFIL_PASS=/dev/null
    CWCREPFIL_FAIL=/dev/null
    SCWCREPFIL_FAIL=/dev/null
    CWSQLPARAM=/dev/null
    CWOSPARAM=/dev/null
    CWOSPKG=/dev/null
    CWOSPATCH=/dev/null
    MISCCWCHECK=/dev/null
  elif [[ $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
    hostname | cut -d"." -f1 > $HOSTLIST
    #LOGFIL=$OUTPUTDIR/${program_name}.log
  fi
  OGGHOMESVERSIONFIL=$OUTPUTDIR/ogg_homes_version.out
  CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
  CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
  CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
  CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
  IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
  IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
  IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
  IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    #ERRFIL=$TMP_OUTPUT/${program_name}_error.log
    OLD_ERRFIL=$OUTPUTDIR/${program_name}_error.log
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
    PSEUDOERRFIL=$TMP_OUTPUT/${program_name}_error.log
  else
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
  fi

  userid=$UID
  ASM_HOME=`grep ASM_HOME $DUMPDIR/$CHKFIL |awk '{print $3}'`
  RUNMODE=`grep -w SILENT $DUMPDIR/$CHKFIL |awk '{print $3}'`
  RUNSWITCH=`grep -w SWITCH $DUMPDIR/$CHKFIL |awk '{print $3}'`
  RUNFILEID=`grep FILE_ID $DUMPDIR/$CHKFIL |awk '{print $3}'`
  get_winpath "REFFIL"
  get_winpath "REFFIL1"
  FILEID=`$GREP FILE_ID $REFFIL |awk '{print $3}'`
  FILEDATE=`$GREP FILE_DATE $REFFIL |awk '{print $3}'`
  FILEID2=`$GREP FILE_ID $REFFIL1 |awk '{print $3}'|head -1`
  restore_winpath "REFFIL"
  restore_winpath "REFFIL1"
  FILESIG=`grep FILE_SIG $DUMPDIR/$CHKFIL|awk '{print $3 }'`
  localnode=`grep LOCALNODE $DUMPDIR/$CHKFIL |awk '{print $3}'|tr -d '\r'`
  crs_installed=`grep ${localnode}.CRS_INSTALLED $DUMPDIR/$CHKFIL |awk '{print $3}'`
  rdbms_installed=`grep ${localnode}.RDBMS_INSTALLED $DUMPDIR/$CHKFIL |awk '{print $3}'`
  crs_up=`grep CRS_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
  db_up=`grep ${ORACLE_SID}_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
  somdb_up=`grep SOMEDB_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
  rootYesNoint=`grep ROOT_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}'`
  multiple_db=$(grep MULTIPLE_DATABASE $DUMPDIR/$CHKFIL |awk '{print $3}')
  components=$(grep ${localnode}.COMPONENTS $DUMPDIR/$CHKFIL |awk '{print $3}')
  if [[ -n "$RUNSWITCH" && $RUNSWITCH = "-u" ]]; then upgrade_mode=$(grep UPGRADE_MODE $DUMPDIR/$CHKFIL |awk '{print $3}');fi
  CRS=$(grep CRS_HOME $DUMPDIR/$CHKFIL |awk '{print $3}')
  #if [[ -z $ORACLE_HOME && $RAT_RUNMODE_INTERNAL = "slave" ]]; then 
  #  currentnode=$(hostname | cut -d"." -f1)
  #  ORACLE_HOME=$(grep "RDBMS_ORACLE_HOME = " $DUMPDIR/$CHKFIL|grep -wi ${currentnode}|tail -1|awk -F"=" '{print $2}'|awk -F"|" '{print $1}'|sed 's/ //g')
  #  ORACLE_SID=$(grep "DB_NAME =" $DUMPDIR/$CHKFIL|grep -i "$ORACLE_HOME"|tail -1|awk -F"=" '{print $2}'|awk -F"|" '{print $1}'|sed 's/ //g')
  #fi
  ibswitch_password_status=$(grep IBSWITCH_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
  cell_password_status=$(grep CELL_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
  zfs_password_status=$(grep ZFS_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
  current_exadata_version=$(grep CURRENT_EXADATA_VERSION $DUMPDIR/$CHKFIL |awk '{print $3}')
  print_score_in_report=$(grep PRINT_SCORE_IN_REPORT $DUMPDIR/$CHKFIL |awk '{print $3}')

  offline_counter=0
  wrong_customer_id_tries=0
  mb_db_counter=0
  CELLDIR="$OUTPUTDIR/.CELLDIR"
  CELLIP="$CELLDIR/cellip.ora"   
  ZFSIP="$CELLDIR/zfsip.ora"   

  is_exadata_dom0_machine=$(grep IS_EXADATA_DOM0_MACHINE $DUMPDIR/$CHKFIL |awk '{print $3}'); if [ ! -n "$is_exadata_dom0_machine" ]; then is_exadata_dom0_machine=0; fi
  is_opc=$(grep IS_OPC $DUMPDIR/$CHKFIL |awk '{print $3}'); if [ ! -n "$is_opc" ]; then is_opc=0; fi
  ssczonetype=$(grep SSCZONETYPE $DUMPDIR/$CHKFIL |awk '{print $3}'); if [ ! -n "$ssczonetype" ]; then ssczonetype=0; fi
  is_ssc_localzone_machine=$(grep IS_SSC_LOCALZONE_MACHINE $DUMPDIR/$CHKFIL |awk '{print $3}'); if [ ! -n "$is_ssc_localzone_machine" ]; then is_ssc_localzone_machine=0; fi
  is_ssc_globalzone_machine=$(grep IS_SSC_GLOBALZONE_MACHINE $DUMPDIR/$CHKFIL |awk '{print $3}'); if [ ! -n "$is_ssc_globalzone_machine" ]; then is_ssc_globalzone_machine=0; fi
  is_ssc_globalzone_dbmachine=$(grep IS_SSC_GLOBALZONE_DBMACHINE $DUMPDIR/$CHKFIL |awk '{print $3}'); if [ ! -n "$is_ssc_globalzone_dbmachine" ]; then is_ssc_globalzone_dbmachine=0; fi
  is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ ! -n "$is_exalogic_machine" ] ; then is_exalogic_machine=0; fi
  is_exalogic_foxtrot=`grep IS_EXALOGIC_FOXTROT_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ ! -n "$is_exalogic_foxtrot" ] ; then is_exalogic_foxtrot=0; fi
  foxtrot_dom0_user=`grep FOXTROT_DOM0_USER $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ ! -n "$foxtrot_dom0_user" ] ; then foxtrot_dom0_user="oracleadmin"; fi
  ea_dom0_nodes=`grep FOXTROT_DOM0_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_dbvm_nodes=`grep FOXTROT_DBVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_grillvm_nodes=`grep FOXTROT_GRILLVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_psmvm_nodes=`grep FOXTROT_PSMVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_sdivm_nodes=`grep FOXTROT_SDIVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_simvm_nodes=`grep FOXTROT_SIMVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_extvm_nodes=`grep FOXTROT_EXTVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_intvm_nodes=`grep FOXTROT_INTVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_icsvm_nodes=`grep FOXTROT_ICSVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  ea_mcsvm_nodes=`grep FOXTROT_MCSVM_NODES $DUMPDIR/$CHKFIL | awk -F'=' '{print $2}'`
  in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`
  exalogic_version=`grep EXALOGIC_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $DUMPDIR/$CHKFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`
  is_exalytics_machine=`grep IS_EXALYTICS_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`; 
  exalytics_version=`grep EXALYTICS_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ ! -n "$is_exalytics_machine" ]; then is_exalytics_machine=0; fi
  RackIdentifier=`grep EXALYTICS_RACK_IDENTIFIER $DUMPDIR/$CHKFIL | sed 's/EXALYTICS_RACK_IDENTIFIER = //'`
  crs112=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "11.2"`
  crs121=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.1"`
  crs122=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.2"`
  is_bda_machine=`grep IS_BDA_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ ! -n "$is_bda_machine" ]; then is_bda_machine=0; fi
  is_fmw_machine=`grep IS_FMW_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ ! -n "$is_fmw_machine" ]; then is_fmw_machine=0; fi
  fmw_dbrunonly=`grep FMW_DBRUNONLY $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ ! -n "$fmw_dbrunonly" ]; then fmw_dbrunonly=0; fi
  fmw_topology=`grep FMW_TOPOLOGY $DUMPDIR/$CHKFIL | awk '{print $3}'`
  fmw_credconfig=`grep FMW_CREDCONFIG $DUMPDIR/$CHKFIL | awk '{print $3}'`
  fmw_runmode=`grep FMW_RUNMODE $DUMPDIR/$CHKFIL | awk '{print $3}'`
  fmw_run_comps=`grep FMW_RUN_COMPS $DUMPDIR/$CHKFIL | awk '{print $3}'`
  fmw_exclude_comps=`grep FMW_EXCLUDE_COMPS $DUMPDIR/$CHKFIL | awk '{print $3}'`
  bda_version=`grep BDA_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  bda_actual_version=`grep BDA_ACTUAL_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  bda_identifier=`grep BDA_IDENTIFIER $DUMPDIR/$CHKFIL | awk '{print $3}'`
  is_exalogic_guest_vm=`grep IS_EXALOGIC_GUEST_VM $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ ! -n "$is_exalogic_guest_vm" ]; then is_exalogic_guest_vm=0; fi
  exalogic_hybrid=`grep IS_EXALOGIC_HYBRID $DUMPDIR/$CHKFIL | awk '{print $3}'`
  phy_nodes=`grep PHYSICAL_NODES $DUMPDIR/$CHKFIL | awk '{print $3}'`
  exclude_profile=`grep EXCLUDE_PROFILE_RUN $DUMPDIR/$CHKFIL | awk '{print $3}'`
  profiles2exclude=`grep EXCLUDE_PROFILE_NAMES $DUMPDIR/$CHKFIL | awk '{print $3}'`
  profileids2exclude=`grep EXCLUDE_PROFILES $DUMPDIR/$CHKFIL | awk '{print $3}'`
  RDBMS_INVENTORY=`grep RDBMS_INVENTORY $DUMPDIR/$CHKFIL | awk '{print $3}'`
  CRS_INVENTORY=`grep CRS_INVENTORY $DUMPDIR/$CHKFIL | awk '{print $3}'`
  ASM_INVENTORY=`grep ASM_INVENTORY $DUMPDIR/$CHKFIL | awk '{print $3}'`
  is_engineered_system=`grep IS_ENGINEERED_SYSTEM $DUMPDIR/$CHKFIL | awk '{print $3}'`
  only_hacheck_run=`grep ONLY_HACHECK_RUN $DUMPDIR/$CHKFIL | awk '{print $3}'`;  if [ -z $only_hacheck_run ]; then only_hacheck_run=0; fi
  is_windows=`grep IS_WINDOWS $DUMPDIR/$CHKFIL | awk '{print $3}'`; if [ -z $is_windows ]; then is_windows=0; fi
  if [[ -n "$is_windows" && "$is_windows" = "False" ]]; then is_windows=0; fi
  if [[ -n "$is_windows" && "$is_windows" = "True" ]]; then is_windows=1; fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    unset_root_run;
  else
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$RAT_TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then validate_tod "$RAT_TMP_OUTPUT"; fi
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    root_user_allowed=1
    #oumask=$(umask)
    #umask 0000
    #if [[ -e $OUTPUTDIR ]]; then chmod 777 $OUTPUTDIR; fi
    #if [[ -e $INPUTDIR ]]; then chmod 777 $INPUTDIR; fi
    #if [ -e $ERRFIL ]; then rm -f $ERRFIL; fi; touch $ERRFIL; chmod 777 $ERRFIL;
  fi
 
  #function to discover and support mixed hardware type storage servers
  mixed_hardware_cells_discovery 
  if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.1"`;fi
  if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.2"`;fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] || [[ -n "$is_opc" && $is_opc -eq "1" ]];
  then
    func_init_arrays
    multiple_db=0
    mb_running_host[0]=0;
  fi
  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
  then
    func_init_arrays
    multiple_db=0
    mb_running_host[0]=0;
    read_exalytics_bi_env
    set_exalytics_tt_env
  fi

  single_instance_run=`grep SINGLE_INSTANCE_RUN $DUMPDIR/$CHKFIL | awk '{print $3}'`
  O_IFS=$IFS
  IFS=$'\n'
  for db_name_to_check in `grep -i DB_NAME $DUMPDIR/$CHKFIL|cut -d'|' -f1|awk -F'=' '{print $2}'|sed 's/^ *//;s/ *$//'`	
  do
    mb_db_names[$mb_db_counter]=$db_name_to_check
    mb_database_role[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_ROLE" $DUMPDIR/$CHKFIL|awk '{print $3}')
    mb_database_type[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_TYPE" $DUMPDIR/$CHKFIL|awk '{print $3}')
    mb_database_app_user[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_APP_USER" $DUMPDIR/$CHKFIL|awk '{print $3}')
    mb_database_global_name[$mb_db_counter]=$(grep -w "${db_name_to_check}.GLOBAL_NAME" $DUMPDIR/$CHKFIL|awk '{print $3}')
    mb_running_host[$mb_db_counter]=$(grep -w "${db_name_to_check}.CHECKED_NODE" $DUMPDIR/$CHKFIL|awk '{print $3}')
    #echo "${mb_database_role[$mb_db_counter]}"
    mb_db_counter=$(expr $mb_db_counter + 1 )
  done
  mb_db_counter=0 
  #$READ -p "stop"
  IFS=$O_IFS;

  if [[ $RAT_RUNMODE_INTERNAL = "slave" ]] ; then calculate_no_of_child_proc; fi

  olsnodes_ssh_disabled=`grep -ic "OLSNODES_SSH_DISABLED" $DUMPDIR/$CHKFIL`;
  if [[ $olsnodes_ssh_disabled -eq 1 ]];
  then
    for node in `cat $HOSTLIST`
    do	
      rnoden=`grep -i 'MAP:' $DUMPDIR/$CHKFIL|grep -i "$node"|head -1|awk '{print $1}'|sed 's/MAP://g'`
      echo "$rnoden" >> $HOSTLIST.new
    done
    mv -f $HOSTLIST.new $HOSTLIST		
  fi

  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_crs_version[$offline_counter]=`grep -i "$node.CRS_ACTIVE_VERSION" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`

    if [[ -n "$multiple_db" && $multiple_db -eq 1 ]]
    then
      db_status_counter=0
      mb_db_counter_local=0
      stack_db_instances[$offline_counter]=`grep -i "$node" $DUMPDIR/$CHKFIL|grep INSTANCE_NAME|awk '{print $3}'`
      #echo "instances on $node ${stack_db_instances[$offline_counter]}"
      for db_name_to_check in "${mb_db_names[@]}"
      do
        if [[ $node = ${mb_running_host[$mb_db_counter_local]} ]]
        then #remote_database_code
          stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
          stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $DUMPDIR/$CHKFIL|awk '{print $3}'`
          #stack_db_name[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
          #echo "$db_name_to_check instance is  ${stack_local_db_inst[$db_status_counter]}"
          db_status_counter=$(expr $db_status_counter + 1)
        fi
        mb_db_counter_local=$(expr $mb_db_counter_local + 1)
      done
      db_status_counter=0
    else
      stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $DUMPDIR/$CHKFIL|awk '{print $3}'`
      if [[ -n "${mb_running_host[$mb_db_counter_local]}" && $node = ${mb_running_host[$mb_db_counter_local]} ]]
      then
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
        #$READ -p " stack_db_status=${stack_db_status[$db_status_counter]}"
      fi;
      stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
    fi
    offline_counter=`expr $offline_counter + 1`  
  done

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
  then
    func_init_arrays
    components=EXALOGIC
  elif [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]]
  then
    func_init_arrays
    components="Big Data Appliance"
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]]
  then
    func_init_arrays
    components="IDM"
  elif [[ -n "$is_opc" && $is_opc -eq "1" ]]
  then
    func_init_arrays
    components="OPC"
  fi

  mb_set_oracle_home_version_distinct
  #is_this_db_machine
  write_db_machine_info_to_envfile $localnode
  GetMachineRole
  is_this_oda

  if [[ `echo $components|grep -icw dbm` -ge 1 && `echo $components|grep -ic rdbms` -lt 1 && $db_machine_compute -eq 1 ]]
  then
    components=EXADATA
  fi
  #$READ -p "components=$components at 8490"
  #echo "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} ${mb_oracle_homes_version_distinct[@]}"
  #$READ -p "see it"
  offline_counter=0
  if [ $op_mode -eq 1 ]
  then
    func_create_small_files
  fi

  if [[ $RUNSWITCH != "-p" && ${stack_dbinst_up[$offline_counter]} -ne 0 ]]
  then
    DB=$(grep -i "DB_NAME" $DUMPDIR/$CHKFIL |awk '{print $3}'|cut -d'|' -f1|cut -d'|' -f1)
    if [[ -z $RAT_LEGACY_DISCOVERY && `echo "$DB"|wc -l|sed 's/ //g'` -gt "1" ]]; then
      for sdb in `echo "$DB"`
      do
        if [[ `grep -ic "$sdb\.RUNNING = 1" $DUMPDIR/$CHKFIL` -ne "0" ]]; then 
    	  DB=$(grep -i "DB_NAME" $DUMPDIR/$CHKFIL |grep -i "$sdb"|awk '{print $3}'|cut -d'|' -f1|cut -d'|' -f1)
	  break
	fi
      done
    fi
  fi
  #FILESIG=`echo $FILESIG |sed -e 's/ /g'`
  if [[ $RUNMODE -eq "1" ]]
  then
    MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
    REPFIL=$OUTPUTDIR/${program_name}.rep
    XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
    XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
    JSONREPFIL=$OUTPUTDIR/${program_name}_results.json
    CLOUDLOG=$OUTPUTDIR/${program_name}_opc.json
    JSONSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.json
    XMLRECFIL=$OUTPUTDIR/${program_name}_recommendations.xml
    SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
    REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
    REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
    SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
    SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
    CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
    SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
    CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
    SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
    PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
    PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
    CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
    CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
    CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
    CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
    CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
    CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
    CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
    CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
    IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
    IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
    IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
    IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
    SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
    RSKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks_runtime.log
     
    #to fix the bug reported by Srini. if user runs raccheck in offline for more than, report will have data for more than 1
    if [ -f $REPFIL ]; then rm -f $REPFIL;fi;
    if [ -f $XMLREPFIL ]; then rm -f $XMLREPFIL;fi;
    if [ -f $XMLSKIPFIL ]; then rm -f $XMLSKIPFIL;fi;   
    if [ -f $JSONREPFIL ]; then rm -f $JSONREPFIL;fi;
    if [ -f $JSONSKIPFIL ]; then rm -f $JSONSKIPFIL;fi;
    if [ -f $SREPFIL ]; then rm -f $SREPFIL; fi;
    if [ -f $SCWCREPFIL_FAIL  ]; then rm -f $SCWCREPFIL_FAIL; fi;
    if [ -f $SREPFIL_FAIL ]; then rm -f $SREPFIL_FAIL; fi;
    if [ -f $SCWCREPFIL_PASS ]; then rm -f $SCWCREPFIL_PASS; fi;
    if [ -f $SREPFIL_PASS ]; then rm -f $SREPFIL_PASS; fi;
    if [ -f $CWCREPFIL_FAIL ]; then rm -f $CWCREPFIL_FAIL; fi;
    if [ -f $REPFIL_FAIL ]; then rm -f $REPFIL_FAIL; fi;
    if [ -f $CWCREPFIL_PASS ]; then rm -f $CWCREPFIL_PASS; fi;
    if [ -f $REPFIL_PASS ]; then rm -f $REPFIL_PASS; fi;
    if [ -f $PREPFIL ]; then rm -f $PREPFIL; fi;
    if [ -f $PSREPFIL ]; then rm -f $PSREPFIL; fi;
    if [ -f $CWSQLPARAM ]; then rm -f $CWSQLPARAM; fi;
    if [ -f $CWOSPARAM ]; then rm -f $CWOSPARAM; fi;
    if [ -f $CWOSPKG ]; then rm -f $CWOSPKG; fi;
    if [ -f $CWOSPATCH ]; then rm -f $CWOSPATCH; fi;
    if [ -f $MISCCWCHECK ]; then rm -f $MISCCWCHECK; fi;
    if [ -f $CELLSREPFIL_PASS ]; then rm -f $CELLSREPFIL_PASS;fi
    if [ -f $CELLSREPFIL_FAIL ]; then rm -f $CELLSREPFIL_FAIL;fi
    if [ -f $CELLREPFIL_PASS ]; then rm -f $CELLREPFIL_PASS;fi
    if [ -f $CELLREPFIL_FAIL ]; then rm -f $CELLREPFIL_FAIL;fi
    if [ -f $IBSREPFIL_PASS ]; then rm -f $IBSREPFIL_PASS;fi
    if [ -f $IBSREPFIL_FAIL ]; then rm -f $IBSREPFIL_FAIL;fi
    if [ -f $IBREPFIL_PASS ]; then rm -f $IBREPFIL_PASS;fi
    if [ -f $IBREPFIL_FAIL ]; then rm -f $IBREPFIL_FAIL;fi
    if [ -f $SKIPFIL ]; then rm -f $SKIPFIL;fi
  fi

  echo  "RUNFILEID=$RUNFILEID FILEID=$FILEID AND FILEID2=$FILEID2">>$LOGFIL
  #$READ -p  "RUNFILEID=$RUNFILEID FILEID=$FILEID AND FILEID2=$FILEID2"
  #$READ -p "check fileids"
  if [ "$RUNFILEID" !=  "$FILEID" ]
  then
    echo -e "$RED Data file $REFFIL is not same file which was used for online run.$NORM"
    exit -1;
  fi
  if [ "$RUNFILEID" !=  "$FILEID2" ]
  then
    echo -e "$RED Data file $REFFIL1 is not same file which should be used with this collection.$NORM"
    exit -1;
  fi
  stack_counter=0
  no_patch_rollup=0 
  no_patch_rollup=`grep -ic "NO Patch rollup selected" $REFFIL1`
  if [ $no_patch_rollup -gt 0 ]
  then
    no_patches=1
  fi

  #code for entering correct custmer id in racrx_env.
  #if [ $RUNMODE -eq 1 ] && [ "$FILESIG" = "46C40115700EFB00E0401490CACF67C6" -o "$FILESIG" = "632427F6919907D9E0401490CACF59F0" ] 
  #if [ $# -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
  if [ $argsnum -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
  then
    echo "" > /dev/null 2&>1
  else
    if [ "$FILESIG" = "46C40115700EFB00E0401490CACF67C6" -o "$FILESIG" = "632427F6919907D9E0401490CACF59F0" ] && [ 1 -eq 0 ]
    then
      exec 3<&2; exec 2<&0
      $READ -p "Enter Customer ID from RAT Customer page (Customer Tab > Customer Details region):- " customerid
      exec 2<&3
      while true
      do
        if [ `echo $customerid|wc -c` -ne 33 ]
        then
        echo -e "${RED}Customer ID is not correct.Enter Customer ID from RAT Customer page (Customer Tab > Customer Details region):-${NORM}"
        $READ customerid
        fi
        wrong_customer_id_tries=$(expr $wrong_customer_id_tries + 1)
        if [[ $wrong_customer_id_tries -gt 1 || `echo $customerid|wc -c` -eq 33 ]];then break;fi;
      done
      custfile="$DUMPDIR/$CHKFIL" 
      sed "s/$FILESIG/$customerid/" $custfile > $DUMPDIR/fileid.out
      cp -f $DUMPDIR/fileid.out $custfile
      rm -f $DUMPDIR/fileid.out
    fi
  fi
  #echo "$%%%%%%%%%%%%%RUNMODE=$RUNMODE%%%%%%%%%%%%%%%%%%%%" 
  #echo "$%%%%%%%%%%%%%FREPFIL=$FREPFIL%%%%%%%%%%%%%%%%%%%%" 
elif [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN = 1 ]]; then
  OFFLINE=0
  #getEnvFromWallet
  if [[ ! -n "$RAT_GLOBAL_RUNMODE" ]] ; then RAT_GLOBAL_RUNMODE="parallel"; fi;

  if [ ! -d "$WRKDIR" ] ;then mkdir -p $WRKDIR >/dev/null 2>&1;fi
  if [ ! -d "$INPUTDIR" ]; then mkdir $INPUTDIR >/dev/null 2>&1;fi
  if [ ! -d "$OUTPUTDIR" ]; then mkdir $OUTPUTDIR >/dev/null 2>&1;fi
  if [ ! -d "$CELLDIR" ]; then mkdir $CELLDIR >/dev/null 2>&1;fi
  if [ ! -d "$RTEMPDIR" ]; then mkdir $RTEMPDIR >/dev/null 2>&1;fi
  #if [[ ! -d "$TMP_OUTPUT" && -n $TMP_OUTPUT ]]; then mkdir $TMP_OUTPUT >/dev/null 2>&1; chmod 777 $TMP_OUTPUT; fi
  if [[ ! -d "$TMP_OUTPUT" && -n $TMP_OUTPUT ]]; then mkdir $TMP_OUTPUT >/dev/null 2>&1; fi

  for file in `grep '\--cfs:' $CACHE_FIL|sed 's/--//g'|sed 's/cfs://g'`
  do
    LOC=$(echo "$file"|awk -F: '{print $1}')
    if [[ -n $LOC && $LOC = "O" ]]; then
      TARGETDIR=$OUTPUTDIR
    elif [[ -n $LOC && $LOC = "I" ]]; then
      TARGETDIR=$INPUTDIR
    elif [[ -n $LOC && $LOC = "C" ]]; then
      TARGETDIR=$CELLDIR
    elif [[ -n $LOC && $LOC = "T" ]]; then
      TARGETDIR=$RTEMPDIR
    fi

    ifile=$(echo "$file"|sed "s/${LOC}://g")

    CONTENT=$(sed "/--cfs:${LOC}:${ifile}--/, /--cfe:${LOC}:${ifile}--/!d" $CACHE_FIL|sed "s/--cfs:${LOC}:${ifile}--//g"|sed "s/--cfe:${LOC}:${ifile}--//g"|grep -v "^\s*$")

    if [[ $ifile = "check_env.out" ]]; then ifile="raccheck_env.out"; fi
    TARGETFIL=$TARGETDIR/$ifile

    echo "$CONTENT" >$TARGETFIL
  done

  populate_guest_vm
  if [[ ! -z "$RAT_EL_GVM" ]]
  then
    rm -rf $EL_GVM_FILE >/dev/null 2>&1
    for el_guest_file in `echo $RAT_EL_GVM|sed 's/,/ /g'`
    do
      if [ -e "$el_guest_file" ]
      then
        cp -f $el_guest_file $OUTPUTDIR  
      fi
    done
  fi

  userid=$UID
  ASM_HOME=`grep ASM_HOME $MASTERFIL |awk '{print $3}'`
  RUNMODE=`grep -w SILENT $MASTERFIL |awk '{print $3}'`
  RUNSWITCH=`grep -w SWITCH $MASTERFIL |awk '{print $3}'`
  RUNFILEID=`grep FILE_ID $MASTERFIL |awk '{print $3}'`
  get_winpath "REFFIL"
  get_winpath "REFFIL1"
  FILEID=`$GREP FILE_ID $REFFIL |awk '{print $3}'`
  FILEDATE=`$GREP FILE_DATE $REFFIL |awk '{print $3}'`
  FILEID2=`$GREP FILE_ID $REFFIL1 |awk '{print $3}'|head -1`
  restore_winpath "REFFIL"
  restore_winpath "REFFIL1"
  FILESIG=`grep FILE_SIG $MASTERFIL|awk '{print $3 }'`
  localnode=`grep LOCALNODE $MASTERFIL |awk '{print $3}'|tr -d '\r'`
  crs_installed=`grep ${localnode}.CRS_INSTALLED $MASTERFIL |awk '{print $3}'`
  rdbms_installed=`grep ${localnode}.RDBMS_INSTALLED $MASTERFIL |awk '{print $3}'`
  crs_up=`grep CRS_UP $MASTERFIL |awk '{print $3}'`
  oracle_restart=`grep ORACLE_RESTART $MASTERFIL |awk '{print $3}'`
  db_up=`grep ${ORACLE_SID}_UP $MASTERFIL |awk '{print $3}'|head -1`
  somdb_up=`grep SOMEDB_UP $MASTERFIL |awk '{print $3}'`
  rootYesNoint=`grep ROOT_OPTION $MASTERFIL |awk '{print $3}'`
  multiple_db=$(grep MULTIPLE_DATABASE $MASTERFIL |awk '{print $3}')
  components=$(grep ${localnode}.COMPONENTS $MASTERFIL |awk '{print $3}')
  if [[ -n "$RUNSWITCH" && $RUNSWITCH = "-u" ]]; then upgrade_mode=$(grep UPGRADE_MODE $MASTERFIL |awk '{print $3}');fi
  CRS=$(grep CRS_HOME $MASTERFIL |awk '{print $3}')
  #if [[ -z $ORACLE_HOME && $RAT_RUNMODE_INTERNAL = "slave" ]]; then 
  #  currentnode=$(hostname | cut -d"." -f1)
  #  ORACLE_HOME=$(grep "RDBMS_ORACLE_HOME = " $MASTERFIL|grep -wi ${currentnode}|tail -1|awk -F"=" '{print $2}'|awk -F"|" '{print $1}'|sed 's/ //g')
  #  ORACLE_SID=$(grep "DB_NAME =" $MASTERFIL|grep -i "$ORACLE_HOME"|tail -1|awk -F"=" '{print $2}'|awk -F"|" '{print $1}'|sed 's/ //g')
  #fi
  ibswitch_password_status=$(grep IBSWITCH_PASSWORD_OPTION $MASTERFIL |awk '{print $3}')
  cell_password_status=$(grep CELL_PASSWORD_OPTION $MASTERFIL |awk '{print $3}')
  zfs_password_status=$(grep ZFS_PASSWORD_OPTION $MASTERFIL |awk '{print $3}')
  current_exadata_version=$(grep CURRENT_EXADATA_VERSION $MASTERFIL |awk '{print $3}')
  print_score_in_report=$(grep PRINT_SCORE_IN_REPORT $MASTERFIL |awk '{print $3}')
  is_exadata_dom0_machine=$(grep IS_EXADATA_DOM0_MACHINE $MASTERFIL |awk '{print $3}'); if [ ! -n "$is_exadata_dom0_machine" ]; then is_exadata_dom0_machine=0; fi
  is_opc=$(grep IS_OPC $MASTERFIL |awk '{print $3}'); if [ ! -n "$is_opc" ]; then is_opc=0; fi
  ssczonetype=$(grep SSCZONETYPE $MASTERFIL |awk '{print $3}'); if [ ! -n "$ssczonetype" ]; then ssczonetype=0; fi
  is_ssc_localzone_machine=$(grep IS_SSC_LOCALZONE_MACHINE $MASTERFIL |awk '{print $3}'); if [ ! -n "$is_ssc_localzone_machine" ]; then is_ssc_localzone_machine=0; fi
  is_ssc_globalzone_machine=$(grep IS_SSC_GLOBALZONE_MACHINE $MASTERFIL |awk '{print $3}'); if [ ! -n "$is_ssc_globalzone_machine" ]; then is_ssc_globalzone_machine=0; fi
  is_ssc_globalzone_dbmachine=$(grep IS_SSC_GLOBALZONE_DBMACHINE $MASTERFIL |awk '{print $3}'); if [ ! -n "$is_ssc_globalzone_dbmachine" ]; then is_ssc_globalzone_dbmachine=0; fi

  mb_db_counter=0
  offline_counter=0
  CELLDIR="$OUTPUTDIR/.CELLDIR"
  CELLIP="$CELLDIR/cellip.ora"   
  ZFSIP="$CELLDIR/zfsip.ora"   

  is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $MASTERFIL | awk '{print $3}'`; if [ ! -n "$is_exalogic_machine" ] ; then is_exalogic_machine=0; fi
  is_exalogic_foxtrot=`grep IS_EXALOGIC_FOXTROT_MACHINE $MASTERFIL | awk '{print $3}'`; if [ ! -n "$is_exalogic_foxtrot" ] ; then is_exalogic_foxtrot=0; fi
  foxtrot_dom0_user=`grep FOXTROT_DOM0_USER $MASTERFIL | awk '{print $3}'`; if [ ! -n "$foxtrot_dom0_user" ] ; then foxtrot_dom0_user="oracleadmin"; fi
  ea_dom0_nodes=`grep FOXTROT_DOM0_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_dbvm_nodes=`grep FOXTROT_DBVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_grillvm_nodes=`grep FOXTROT_GRILLVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_psmvm_nodes=`grep FOXTROT_PSMVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_sdivm_nodes=`grep FOXTROT_SDIVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_simvm_nodes=`grep FOXTROT_SIMVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_extvm_nodes=`grep FOXTROT_EXTVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_intvm_nodes=`grep FOXTROT_INTVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_icsvm_nodes=`grep FOXTROT_ICSVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  ea_mcsvm_nodes=`grep FOXTROT_MCSVM_NODES $MASTERFIL | awk -F'=' '{print $2}'`
  in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $MASTERFIL | awk '{print $3}'`
  exalogic_version=`grep EXALOGIC_VERSION $MASTERFIL | awk '{print $3}'`
  exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $MASTERFIL | awk '{print $3}'`
  RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $MASTERFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`
  is_exalytics_machine=`grep IS_EXALYTICS_MACHINE $MASTERFIL | awk '{print $3}'`; if [ ! -n "$is_exalytics_machine" ]; then is_exalytics_machine=0; fi
  exalytics_version=`grep EXALYTICS_VERSION $MASTERFIL | awk '{print $3}'`
  RackIdentifier=`grep EXALYTICS_RACK_IDENTIFIER $MASTERFIL | sed 's/EXALYTICS_RACK_IDENTIFIER = //'`
  crs112=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "11.2"`
  crs121=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "12.1"`
  crs122=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "12.2"`
  is_bda_machine=`grep IS_BDA_MACHINE $MASTERFIL | awk '{print $3}'`; if [ ! -n "$is_bda_machine" ]; then is_bda_machine=0; fi
  is_fmw_machine=`grep IS_FMW_MACHINE $MASTERFIL | awk '{print $3}'`; if [ ! -n "$is_fmw_machine" ]; then is_fmw_machine=0; fi
  fmw_dbrunonly=`grep FMW_DBRUNONLY $MASTERFIL | awk '{print $3}'`; if [ ! -n "$fmw_dbrunonly" ]; then fmw_dbrunonly=0; fi
  fmw_topology=`grep FMW_TOPOLOGY $MASTERFIL | awk '{print $3}'`
  fmw_credconfig=`grep FMW_CREDCONFIG $MASTERFIL | awk '{print $3}'`
  fmw_runmode=`grep FMW_RUNMODE $MASTERFIL | awk '{print $3}'`
  fmw_run_comps=`grep FMW_RUN_COMPS $MASTERFIL | awk '{print $3}'`
  fmw_exclude_comps=`grep FMW_EXCLUDE_COMPS $MASTERFIL | awk '{print $3}'`
  bda_version=`grep BDA_VERSION $MASTERFIL | awk '{print $3}'`
  bda_actual_version=`grep BDA_ACTUAL_VERSION $MASTERFIL | awk '{print $3}'`
  bda_identifier=`grep BDA_IDENTIFIER $MASTERFIL | awk '{print $3}'`
  is_exalogic_guest_vm=`grep IS_EXALOGIC_GUEST_VM $MASTERFIL | awk '{print $3}'`; if [ ! -n "$is_exalogic_guest_vm" ]; then is_exalogic_guest_vm=0; fi
  exalogic_hybrid=`grep IS_EXALOGIC_HYBRID $MASTERFIL | awk '{print $3}'`
  phy_nodes=`grep PHYSICAL_NODES $MASTERFIL | awk '{print $3}'`
  exclude_profile=`grep EXCLUDE_PROFILE_RUN $MASTERFIL | awk '{print $3}'`
  profiles2exclude=`grep EXCLUDE_PROFILE_NAMES $MASTERFIL | awk '{print $3}'`
  profileids2exclude=`grep EXCLUDE_PROFILES $MASTERFIL | awk '{print $3}'`
  RDBMS_INVENTORY=`grep RDBMS_INVENTORY $MASTERFIL | awk '{print $3}'`
  CRS_INVENTORY=`grep CRS_INVENTORY $MASTERFIL | awk '{print $3}'`
  ASM_INVENTORY=`grep ASM_INVENTORY $MASTERFIL | awk '{print $3}'`
  is_engineered_system=`grep IS_ENGINEERED_SYSTEM $MASTERFIL | awk '{print $3}'`
  only_hacheck_run=`grep ONLY_HACHECK_RUN $MASTERFIL | awk '{print $3}'`;  if [ -z $only_hacheck_run ]; then only_hacheck_run=0; fi
  is_windows=`grep IS_WINDOWS $MASTERFIL | awk '{print $3}'`; if [ -z $is_windows ]; then is_windows=0; fi
  if [[ -n "$is_windows" && "$is_windows" = "False" ]]; then is_windows=0; fi
  if [[ -n "$is_windows" && "$is_windows" = "True" ]]; then is_windows=1; fi

  #Initialization of variables through wallet for uploading run results in the table
  getEnvFromWallet

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; 
  then
    unset_root_run;
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    root_user_allowed=1
    #oumask=$(umask)
    #umask 0000
    #if [[ -e $OUTPUTDIR ]]; then chmod 777 $OUTPUTDIR; fi
    #if [[ -e $INPUTDIR ]]; then chmod 777 $INPUTDIR; fi
    #if [ -e $ERRFIL ]; then rm -f $ERRFIL; fi; touch $ERRFIL; chmod 777 $ERRFIL;
  fi
 
  touch $COLLDIFFFIL >/dev/null 2>&1  
  touch $CHECKSFILE >/dev/null 2>&1

  #function to discover and support mixed hardware type storage servers
  mixed_hardware_cells_discovery 
  if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "12.1"`;fi
  if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "12.2"`;fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] || [[ -n "$is_opc" && $is_opc -eq "1" ]] ;
  then
    func_init_arrays
    multiple_db=0
    mb_running_host[0]=0;
  fi
  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
  then
    func_init_arrays
    multiple_db=0
    mb_running_host[0]=0;
    read_exalytics_bi_env
    set_exalytics_tt_env
  fi

  single_instance_run=`grep SINGLE_INSTANCE_RUN $MASTERFIL | awk '{print $3}'`
  O_IFS=$IFS
  IFS=$'\n'
  for db_name_to_check in `grep -i DB_NAME $MASTERFIL|cut -d'|' -f1|awk -F'=' '{print $2}'|sed 's/^ *//;s/ *$//'`	
  do
    mb_db_names[$mb_db_counter]=$db_name_to_check
    mb_database_role[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_ROLE" $MASTERFIL|awk '{print $3}')
    mb_database_type[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_TYPE" $MASTERFIL|awk '{print $3}')
    mb_database_app_user[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_APP_USER" $MASTERFIL|awk '{print $3}')
    mb_database_global_name[$mb_db_counter]=$(grep -w "${db_name_to_check}.GLOBAL_NAME" $MASTERFIL|awk '{print $3}')
    mb_running_host[$mb_db_counter]=$(grep -w "${db_name_to_check}.CHECKED_NODE" $MASTERFIL|awk '{print $3}')
    mb_oracle_homes[$mb_db_counter]=$(grep -w "DB_NAME = ${db_name_to_check}" $MASTERFIL|awk '{print $3}'|cut -d '|' -f3)
    mb_oracle_sids[$mb_db_counter]=$(grep "${localnode}.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}')
    mb_db_counter=$(expr $mb_db_counter + 1 )
  done
  mb_db_counter=0 
  IFS=$O_IFS;

  if [[ $set_db_par_limit -eq 1 && -z $RAT_DB_PAR_LIMIT && $OFFLINE -eq 0 ]]
  then
    export RAT_DB_PAR_LIMIT=${#mb_db_names[@]}
  fi
  calculate_no_of_child_proc

  olsnodes_ssh_disabled=`grep -ic "OLSNODES_SSH_DISABLED" $MASTERFIL`;

  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL |awk '{print $3}'`
    stack_crs_version[$offline_counter]=`grep -i "$node.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL |awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL |awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL |awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL |awk '{print $3}'`

    if [[ -n "$multiple_db" && $multiple_db -eq 1 ]]
    then
      db_status_counter=0
      mb_db_counter_local=0
      stack_db_instances[$offline_counter]=`grep -i "$node" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}'`
      for db_name_to_check in "${mb_db_names[@]}"
      do
        if [ $node = ${mb_running_host[$mb_db_counter_local]} ]
        then #remote_database_code
          stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
          stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
          db_status_counter=$(expr $db_status_counter + 1)
        fi
        mb_db_counter_local=$(expr $mb_db_counter_local + 1)
      done
      db_status_counter=0
    else
      stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
      if [[ -n "${mb_running_host[$mb_db_counter_local]}" && $node = ${mb_running_host[$mb_db_counter_local]} ]]
      then
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE" $MASTERFIL|awk '{print $3}'`
      fi;
      stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE" $MASTERFIL|awk '{print $3}'`
    fi
    offline_counter=`expr $offline_counter + 1`  
  done

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
  then
    func_init_arrays
    components=EXALOGIC
  elif [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]]
  then
    func_init_arrays
    components="Big Data Appliance"
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]]
  then
    func_init_arrays
    components="IDM"
  elif [[ -n "$is_opc" && $is_opc -eq "1" ]]
  then
    func_init_arrays
    components="OPC"
  fi
 
  mb_set_oracle_home_version_distinct
  write_db_machine_info_to_envfile $localnode
  GetMachineRole
  is_this_oda

  if [[ `echo $components|grep -icw dbm` -ge 1 && `echo $components|grep -ic rdbms` -lt 1 && $db_machine_compute -eq 1 ]]
  then
    components=EXADATA
  fi
  offline_counter=0
  if [ $op_mode -eq 1 ]
  then
    func_create_small_files
  fi

  if [[ $RUNSWITCH != "-p" && ${stack_dbinst_up[$offline_counter]} -ne 0 ]]
  then
    DB=$(grep -i "DB_NAME" $MASTERFIL |awk '{print $3}'|cut -d'|' -f1|cut -d'|' -f1)
    if [[ -z $RAT_LEGACY_DISCOVERY && `echo "$DB"|wc -l|sed 's/ //g'` -gt "1" ]]; then
      for sdb in `echo "$DB"`
      do
        if [[ `grep -ic "$sdb\.RUNNING = 1" $MASTERFIL` -ne "0" ]]; then 
    	  DB=$(grep -i "DB_NAME" $MASTERFIL |grep -i "$sdb"|awk '{print $3}'|cut -d'|' -f1|cut -d'|' -f1)
	  break
	fi
      done
    fi
  else
    DB=$(grep -i "DB_NAME" $MASTERFIL |head -1|awk '{print $3}'|cut -d'|' -f1|cut -d'|' -f1)
  fi
  
  MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
  REPFIL=$OUTPUTDIR/${program_name}.rep
  XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
  XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
  JSONREPFIL=$OUTPUTDIR/${program_name}_results.json
  CLOUDLOG=$OUTPUTDIR/${program_name}_opc.json
  JSONSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.json
  XMLRECFIL=$OUTPUTDIR/${program_name}_recommendations.xml
  SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
  REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
  REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
  SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
  SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
  CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
  SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
  CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
  SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
  PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
  PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
  CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
  CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
  CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
  CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
  CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
  CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
  CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
  CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
  IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
  IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
  IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
  IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
  SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
  RSKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks_runtime.log
     
  stack_counter=0
  no_patch_rollup=0 
  no_patch_rollup=`grep -ic "NO Patch rollup selected" $REFFIL1`
  if [ $no_patch_rollup -gt 0 ]
  then
    no_patches=1
  fi

  fmt_timing_lines="--------------------------------------------------------------------------------"
  echo -e "$fmt_timing_lines\n" >>$RACCHECK_TIMING
  echo -e "`date '+%a %b %d %H:%M:%S %Y'` - ${program_name} execution started\n">>$RACCHECK_TIMING
  trap 'cleanup;exit $USER_INTERRUPT' INT TERM EXIT
else
  #Exalogic check
  #Initialization of variables through wallet for uploading run results in the table
  #getEnvFromWallet

  OFFLINE=0
  if [[ ! -n "$RAT_GLOBAL_RUNMODE" ]] ; then RAT_GLOBAL_RUNMODE="parallel"; fi; 

  populate_guest_vm

  if [[ -e /etc/ovs-release && -e /opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP ]];then is_exadata_dom0_machine=1;fi

  if [[ `uname -s` = "HP-UX" ]]; then
    platform_type=`uname -m 2>/dev/null`    
  else
    platform_type=`uname -p 2>/dev/null`    
  fi

  #if [ $(uname -p 2>/dev/null) = "sparc" ]
  if [[ "$platform_type" = "sparc" ]]
  then 
    ssczonetype=$($ZONENAME)
    ssctuner_exists=$($SVCS -a|grep -wc ssctuner)
  fi
  if [[ -n "$ssczonetype" && "$ssczonetype" != "global" && -e /opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP  && -e /etc/oracle/cell/network-config/cellip.ora ]];then is_ssc_localzone_machine=1;fi

  #if [[ $(uname -p 2>/dev/null) = "sparc" && $ssctuner_exists -gt 0 && ! -e /etc/oracle/cell/network-config/cellip.ora && "$ssczonetype" = "global" ]]
  if [[ "$platform_type" = "sparc" && $ssctuner_exists -gt 0 && ! -e /etc/oracle/cell/network-config/cellip.ora && "$ssczonetype" = "global" ]]
  then
    is_ssc_globalzone_machine=1
  fi
  #if [[ $(uname -p 2>/dev/null) = "sparc" && -e /opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP && -e /etc/oracle/cell/network-config/cellip.ora && "$ssczonetype" = "global" ]]
  if [[ "$platform_type" = "sparc" && -e /opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP && -e /etc/oracle/cell/network-config/cellip.ora && "$ssczonetype" = "global" ]]
  then
    is_ssc_globalzone_dbmachine=1
  fi
  check_if_bda
  check_if_exalytics
  check_if_exalogic
  check_if_opc

  if [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq "1" || $is_exalytics_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then 
    unset_root_run; 
  else 
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$RAT_TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then validate_tod "$RAT_TMP_OUTPUT"; fi
  fi

  #moved this validation from top to here is because Solaris express is supported in EL
  if [[ $is_exalogic_machine -eq 0 && "`uname -v`" = "snv_151a" ]]
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="The ${program_name} is not supported on Solaris 11 Express."
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "\n${RED}The ${program_name} is not supported on Solaris 11 Express. ${NORM}\n"
    exit 1;
  fi

  #if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" && $usern != "${root_user}" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ern != "${root_user}" ]]
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" && $usern != "${root_user}" ]]
  then
    #privilegechk=`/usr/sbin/imageinfo 2>/dev/null |grep -iw "image version"`
    if [ `uname -s` = "Linux" ] ; then
      privilegechk=`/sbin/ifconfig | grep -w "inet" | awk '{print $2}'|cut -d: -f1 | head -1`
    else
      /sbin/ifconfig -a >/dev/null 2>&1
      if [ $? -eq "0" ] ; then privilegechk="addr"; fi
    fi
  fi 

  if [[ $EM_PROBE_MODE -eq 1 || $EM_XMLD_MODE -eq 1 ]]; then
    if [[ $is_exalogic_machine -eq "1" && $user_uid != "0" ]] && [[ -z $privilegechk || "$privilegechk" != "addr" ]]
    then
      EMSG="*********** Error: User must be privileged user"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      exit 1;
    elif [[ $is_exalytics_machine -eq "1" && $usern != "${root_user}" ]] 
    then
      EMSG="*********** Error: User must be ${root_user} "
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      exit 1;
    elif [[ $is_bda_machine -eq "1" && $usern != "${root_user}" ]]
    then
      EMSG="*********** Error: User must be ${root_user} " 
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      exit 1;
    elif [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq "1" ]]
    then
      echo ""
    fi
  else
    if [[ $is_exalogic_machine -eq "1" && $user_uid != "0" ]] && [[ -z $privilegechk || "$privilegechk" != "addr" ]]
    then
      echo "*********** Error: User must be privileged user"
      exit 1;
    elif [[ $is_exalytics_machine -eq "1" && $USER != "${root_user}" ]] 
    then
      echo "*********** Error: User must be ${root_user} "
      exit 1;
    elif [[ $is_bda_machine -eq "1" && $USER != "${root_user}" ]]
    then
      echo "*********** Error: User must be ${root_user} "
      exit 1;
    elif [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq "1" ]]
    then
      #echo "*********** Running in a exalogic machine and user is fine"
      echo ""
    fi
  fi

  stack_counter=0
  if [ ! -d "$WRKDIR" ]
  then
    mkdir -p $WRKDIR
  fi

  touch $COLLDIFFFIL >/dev/null 2>&1  
  touch $CHECKSFILE >/dev/null 2>&1

 if [[  -z $run_acchk || $run_acchk -eq "0" ]] ; then
  if [[ `echo "$argsaved"|grep -ic 'initrmsetup'` -gt 0 || `echo "$argsaved"|grep -ic 'initcheck'` -gt 0 || `echo "$argsaved"|grep -ic 'initrestart'` -gt 0 || `echo "$argsaved"|grep -ic 'initsetup'` -gt 0 || `echo "$argsaved"|grep -ic 'initdebugsetup'` -gt 0 ]]
  then
    RUNSWITCH="-a"
  else
    if [ $argsnum -lt 1 ]; then RUNSWITCH="-a"; else RUNSWITCH=$TYP;fi
  fi
 else
  RUNSWITCH="-a"
 fi

  mkdir $INPUTDIR >/dev/null 2>&1
  mkdir $OUTPUTDIR >/dev/null 2>&1

  echo "IS_EXADATA_DOM0_MACHINE = $is_exadata_dom0_machine" >> $MASTERFIL
  echo "SSCZONETYPE = $ssczonetype" >> $MASTERFIL
  echo "IS_SSC_LOCALZONE_MACHINE = $is_ssc_localzone_machine" >> $MASTERFIL
  echo "IS_SSC_GLOBLZONE_MACHINE = $is_ssc_globalzone_machine" >> $MASTERFIL
  echo "IS_SSC_GLOBLZONE_DBMACHINE = $is_ssc_globalzone_dbmachine" >> $MASTERFIL

  if [ ! -d $RTEMPDIR ]; then mkdir $RTEMPDIR >/dev/null 2>&1;fi

  if [[ ! -z "$RAT_EL_GVM" ]]
  then
    rm -rf $EL_GVM_FILE >/dev/null 2>&1
    for el_guest_file in `echo $RAT_EL_GVM|sed 's/,/ /g'`
    do
      if [ -e "$el_guest_file" ]
      then
        cp -f $el_guest_file $OUTPUTDIR  
      fi
    done
  fi

  if [[ $OFFLINE -eq "0" ]] || [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
    if [ -e "$RTEMPDIR" ]; then
      del_rtempdir=0
      if [ -e $LOCKFIL ]; then
        lockfile_pid_status=$(ps -ef |grep $(cat $LOCKFIL)|grep -v grep|wc -l)
        if [[ -n "$lockfile_pid_status" && $lockfile_pid_status -gt 0 ]]; then
      	del_rtempdir=0
        else
      	del_rtempdir=1
        fi
      elif [ -f "$RTEMPDIR" ]; then
         del_rtempdir=1
      fi
      
      if [[ "$del_rtempdir" -eq "1" ]]; then
        rm -rf $RTEMPDIR >/dev/null 2>&1;
        if [ `echo $?` -ne 0 ]; then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="Temporary files/directories of previous run exist at $RTEMPDIR. Delete them and re-run ${program_name}."
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e ${RED}"\nTemporary files/directories of previous run exist at $RTEMPDIR. Delete them and re-run ${program_name}"${NORM}. 
          echo -e "\n${program_name} is exiting..\n"
          exit 1
        fi
      fi
    fi

    if [ -w "$TMPDIR" ]
    then
      mount >/dev/null 2>&1
      if [ `echo $?` -eq 0 ] 
      then
        #if [ `mount|grep -w "tmp"|grep -icw "noexec"` -gt 0 ]
        if [ `mount|grep -w "$TMPDIR"|grep -icw "noexec"` -gt 0 ]
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="Please change the entry for $TMPDIR in /etc/fstab file from 'noexec' to 'exec' and then re-run ${program_name}"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e ${RED}"Please change the entry for $TMPDIR in /etc/fstab file from 'noexec' to 'exec' and then re-run ${program_name}"${NORM}
          echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
          exit 1
        fi
      fi
    else
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="$TMPDIR directory is not writable.Please make sure that $TMPDIR is writable and then re-run ${program_name}"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e ${RED}"$TMPDIR directory is not writable.Please make sure that $TMPDIR is writable and then re-run ${program_name}"${NORM}
      echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
      exit 1
    fi
  fi

  if [ ! -d $RTEMPDIR ]; then mkdir -p $RTEMPDIR>/dev/null 2>&1;fi
  fmt_timing_lines="--------------------------------------------------------------------------------"
  echo -e "$fmt_timing_lines\n" >>$RACCHECK_TIMING
  echo -e "`date '+%a %b %d %H:%M:%S %Y'` - ${program_name} execution started\n">>$RACCHECK_TIMING
  trap 'cleanup;exit $USER_INTERRUPT' INT TERM EXIT
  localnode=`hostname | tr "[A-Z]" "[a-z]"|cut -d. -f1|tr -d '\r'`
  userid=$UID

  if [[ $op_mode -eq 1 && -z "$RAT_OS" ]] 
  then  
    func_what_platform
    if [[  -z "$os_name" || -z "$os_arch" || -z "$os_bit" || -z "$os_version" ]]
    then 
      echo -e "\n${RED}${program_name} could not find enough information about Operating system. Please set RAT_OS environment variable as following and re-run it.${NORM}"
      echo -e "\nValue in RAT_OS for Oracle Enterprise Linux 5 will be like LINUXX8664OELRHEL5 or for Solaris 10 on Sparc will be SOLARISSPARC6410"
      echo -e "\nTo construct correct value for RAT_OS, use following piece of OS information"
      echo -e "\nOS Name=LINUX \nOS Architecture=X86 or IA \nBits either 32 or 64 OS version=4 \nOS type in case of Linux like RHELOEL or SUSE etc"
      exit 1
    fi
    if [[ -n "$os_bit" && -n "$os_name" && "$os_name" = "Linux" && $os_bit -eq 32 ]]
    then
      if [[ -n "$ebs32bit" && $ebs32bit -eq 1 && $(ps -ef|grep -v grep |grep -ci ora_pmon_) -gt 0 ]] 
      then
        echo "Running on ${os_bit}-bit on $os_name because ebs32bit is $ebs32bit and atleast one database is running">>$LOGFIL
      else
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
	  EMSG="${program_name} is not supported on ${os_bit}-bit ${os_name}.\nTo run ${program_name} for EBS 32-bit database on Linux,use -ebs32bit command line option."
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
        echo -e "\n${RED}${program_name} is not supported on ${os_bit}-bit ${os_name}.\n\nTo run ${program_name} for EBS 32-bit database on Linux,use -ebs32bit command line option.\n\n${program_name} is exiting...${NORM}\n\n"  
        exit 1
      fi 
    fi  
  else
    what_os=$RAT_OS 
  fi
fi

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
  cp -f $DUMPDIR/../.input*/*.dat $DUMPDIR/
  WATCHDOG=$DUMPDIR/watchdog.sh
  WATCHLOG=$DUMPDIR/watchdog.log
  REFFIL=$DUMPDIR/collections.dat
  userid=$UID
  LOGFIL=$DUMPDIR/${program_name}.log
  LOGFIL=$DUMPDIR/${program_name}.log
  SKIPFIL=$DUMPDIR/${program_name}_skipped_checks.log
  RSKIPFIL=$DUMPDIR/${program_name}_skipped_checks_runtime.log
  REPFIL=$DUMPDIR/${program_name}.rep
  XMLREPFIL=$DUMPDIR/${program_name}_results.xml
  XMLSKIPFIL=$DUMPDIR/${program_name}_exceptions.xml
  JSONREPFIL=$DUMPDIR/${program_name}_results.json
  CLOUDLOG=$DUMPDIR/${program_name}_opc.json
  JSONSKIPFIL=$DUMPDIR/${program_name}_exceptions.json
  XMLRECFIL=$DUMPDIR/${program_name}_recommendations.xml
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    #ERRFIL=$TMP_OUTPUT/${program_name}_error.log
    OLD_ERRFIL=$DUMPDIR/${program_name}_error.log
    ERRFIL=$DUMPDIR/${program_name}_error.log
    PSEUDOERRFIL=$TMP_OUTPUT/${program_name}_error.log
  else
    ERRFIL=$DUMPDIR/${program_name}_error.log
  fi
  COLLECT_TIMING=$DUMPDIR/${program_name}_collection_timings.out
  CHECKS_TIMING=$DUMPDIR/${program_name}_checks_timings.out
  RACCHECK_TIMING=$DUMPDIR/${program_name}_timings.out
  MISCCWCHECK=$DUMPDIR/o_misc_clusterwide_checks.out
fi
if [[ -n "$raccheck_deprecate_msg" ]]; then echo -e "\n${raccheck_deprecate_msg}\n">>$LOGFIL;fi 
log_env_varaibles "RAT_TIMEOUT" "$RAT_TIMEOUT"
log_env_varaibles "RAT_ROOT_TIMEOUT" "$RAT_ROOT_TIMEOUT"
log_env_varaibles "RAT_SQL_TIMEOUT" "$RAT_SQL_TIMEOUT"
log_env_varaibles "RAT_UPLOAD_CONNECT_STRING" "$RAT_UPLOAD_CONNECT_STRING"
log_env_varaibles "RAT_UPLOAD_TABLE" "$RAT_UPLOAD_TABLE"
log_env_varaibles "RAT_ZIP_UPLOAD_TABLE" "$RAT_ZIP_UPLOAD_TABLE"
log_env_varaibles "RAT_PATCH_UPLOAD_TABLE" "$RAT_PATCH_UPLOAD_TABLE"
log_env_varaibles "RAT_UPLOAD_USER" "$RAT_UPLOAD_USER"
log_env_varaibles "RAT_UPLOAD_PASSWORD" "$RAT_UPLOAD_PASSWORD"
log_env_varaibles "RAT_UPLOAD_ORACLE_HOME" "$RAT_UPLOAD_ORACLE_HOME"
log_env_varaibles "RAT_CRS_HOME" "$RAT_CRS_HOME"
log_env_varaibles "RAT_INV_LOC" "$RAT_INV_LOC"
log_env_varaibles "RAT_ORACLE_HOME" "$RAT_ORACLE_HOME"
log_env_varaibles "RAT_ASM_HOME" "$RAT_ASM_HOME"
log_env_varaibles "RAT_OS" "$RAT_OS"
log_env_varaibles "RAT_DB" "$RAT_DB"
log_env_varaibles "RAT_DBNAMES" "$RAT_DBNAMES" "1"
log_env_varaibles "RAT_PDBNAMES" "$RAT_PDBNAMES" "1"
log_env_varaibles "RAT_DBHOMES" "$RAT_DBHOMES" 
log_env_varaibles "RAT_OUTPUT" "$RAT_OUTPUT"
log_env_varaibles "RAT_TMP_OUTPUT" "$RAT_TMP_OUTPUT"
log_env_varaibles "RAT_DEBUG" "$RAT_DEBUG"
log_env_varaibles "RAT_INFOPASS" "$RAT_INFOPASS"
log_env_varaibles "RAT_SCOPY" "$RAT_SCOPY"
log_env_varaibles "RAT_SSHEL" "$RAT_SSHELL"
log_env_varaibles "RAT_LOCAL" "$RAT_LOCAL"
log_env_varaibles "RAT_CELLS" "$RAT_CELLS" "1"
log_env_varaibles "RAT_ZFS_NODES" "$RAT_ZFS_NODES" "1"
log_env_varaibles "RAT_EXT_ZFS_NODES" "$RAT_EXT_ZFS_NODES" "1"
log_env_varaibles "RAT_CLUSTERNODES" "$RAT_CLUSTERNODES" "1"
log_env_varaibles "RAT_IBSWITCHES" "$RAT_IBSWITCHES" "1"
log_env_varaibles "RAT_TORSWITCHES" "$RAT_TORSWITCHES" "1"
log_env_varaibles "RAT_CELL_SSH_USER" "$RAT_CELL_SSH_USER"
log_env_varaibles "RAT_IBSWITCH_USER" "$RAT_IBSWITCH_USER"
log_env_varaibles "RAT_ROOT_USER" "$RAT_ROOT_USER"
log_env_varaibles "RAT_EXPECT_STRACE_DEBUG" "$RAT_EXPECT_STRACE_DEBUG"
log_env_varaibles "RAT_EXPECT_DEBUG" "$RAT_EXPECT_DEBUG"
log_env_varaibles "RAT_PDB_USER" "$RAT_PDB_USER"
log_env_varaibles "RAT_BDA" "$RAT_BDA"
log_env_varaibles "RAT_PASSWORDCHECK_TIMEOUT" "$RAT_PASSWORDCHECK_TIMEOUT"
log_env_varaibles "RAT_USER_DEFINED_CHECKS" "$RAT_USER_DEFINED_CHECKS"
log_env_varaibles "RAT_SKIP_XML_VALIDATION" "$RAT_SKIP_XML_VALIDATION"
log_env_varaibles "RAT_NO_INSTANT_COLLECTION" "$RAT_NO_INSTANT_COLLECTION"
log_env_varaibles "RAT_NO_COMPONENTS_FILTER" "$RAT_NO_COMPONENTS_FILTER"

if [ -f "$RTEMPDIR" ]; then rm -f "$RTEMPDIR"; fi

#writing to log file here because where these variables are assigned, LOGFIL variable does not exists
echo -e "is_exadata_dom0_machine = $is_exadata_dom0_machine \n is_ssc_localzone_machine = $is_ssc_localzone_machine \n is_ssc_globalzone_machine = $is_ssc_globalzone_machine \n is_ssc_globalzone_dbmachine = $is_ssc_globalzone_dbmachine">>$LOGFIL

assign_scr_switches;
if [[ $OFFLINE -eq "0" ]] || [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
  #following code is to generate watcher script
  if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ];then watchdog_dbm_root=1;else watchdog_dbm_root=0;fi 
  if [ -z "$RAT_TIMEOUT" ]
  then
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      watchdog_wakeup=150
    elif [[ -n "$run_acchk" || $run_acchk -eq "1" ]] ; then
      watchdog_wakeup=900
    elif [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] ; then
      watchdog_wakeup=150
    #elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] ; then
    #  watchdog_wakeup=600
    else
      watchdog_wakeup=`grep RACCHECK_TIMEOUT $REFFIL|awk '{print $3}'` 
      if [ -z "$watchdog_wakeup" ]; then watchdog_wakeup=90;fi
    fi
  else
    watchdog_wakeup=$RAT_TIMEOUT    
  fi 
  if [ -z "$RAT_ROOT_TIMEOUT" ]
  then
    if [ -e /opt/oracle/oak/install/inittab ]
    then 
      watchdog_wakeup_root=600
    else             
      watchdog_wakeup_root=450
    fi
  else
    watchdog_wakeup_root=$RAT_ROOT_TIMEOUT
  fi
  if [ -z "$RAT_SQL_TIMEOUT" ]
  then
    watchdog_wakeup_sql=180
  else
    watchdog_wakeup_sql=$RAT_SQL_TIMEOUT
  fi 
  echo -e "RAT_TIMEOUT=$RAT_TIMEOUT watchdog_wakeup=$watchdog_wakeup watchdog_wakeup_root=$watchdog_wakeup_root watchdog_wakeup_sql=$watchdog_wakeup_sql">>$LOGFIL
  #watchlogdate=$(date '+%a %b %d %H:%M:%S %Y')
  touch $RTEMPDIR/nowatch.pid
  echo "#!$bash_scr" > $WATCHDOG  
  echo "watchdog_wakeup=$watchdog_wakeup">>$WATCHDOG
  echo "watchdog_wakeup_root=$watchdog_wakeup_root">>$WATCHDOG
  echo "watchdog_wakeup_sql=$watchdog_wakeup_sql">>$WATCHDOG
  echo "wakeup_count=1">>$WATCHDOG
  echo "watchdog_dbm_root=$watchdog_dbm_root">>$WATCHDOG
  echo "watchdog_long_wakeup=1">>$WATCHDOG
  echo "ppid=$$">>$WATCHDOG
  echo "mypid=\$\$">>$WATCHDOG
  echo "function killtree() {" >> $WATCHDOG #http://stackoverflow.com/questions/392022/best-way-to-kill-all-child-processes
  echo "  local _pid=\$1" >> $WATCHDOG
  echo "  local _sig=\${2-TERM}" >> $WATCHDOG
  if [[ `uname -a|grep 'SunOS'|grep 'sparc'|grep -c '5.11'` -eq "0" ]]; then
    echo "  kill -stop \${_pid}" >> $WATCHDOG
  fi
  #echo "  for _child in \$(ps -o pid --no-headers --ppid \${_pid}); do " >> $WATCHDOG
  echo "  for _child in \$(ps -ef |awk '\$3 == '\${_pid}' {print \$2}'); do " >> $WATCHDOG
  echo "    killtree \${_child} \${_sig}" >> $WATCHDOG
  echo "  done" >>$WATCHDOG
  echo "  kill -\${_sig} \${_pid}" >> $WATCHDOG
  echo "}" >> $WATCHDOG
  echo "echo \"\`date '+%a %b %d %H:%M:%S %Y'\` started watcher\" >$WATCHLOG">>$WATCHDOG
  #echo "echo \" mypid=\$mypid\"">>$WATCHDOG
  #echo "echo \"Process id of gracrx is \$ppid and log file is $WATCHLOG\"">>$WATCHDOG     
  echo "while [ 1 ]">>$WATCHDOG
  echo "do">>$WATCHDOG
  #echo "  lpid=\$(ps -p \$ppid|grep -v PID|awk '{print \$1}')">>$WATCHDOG
  ps -o pid >/dev/null 2>&1
  ps_o_ret=$?
  if [[ -n "$ps_o_ret" && $ps_o_ret -eq 0 ]] ; then
    echo "  lpid=\$(ps -o pid -p \$ppid|grep -v PID)">>$WATCHDOG
  else
    echo "  lpid=\$(ps -f -p  \$ppid|grep -v PID | awk '{print \$2}')">>$WATCHDOG
  fi
  echo "  if [ -z \$lpid ]">>$WATCHDOG
  echo "  then">>$WATCHDOG
  #echo "      echo -e \"Darwin is not running\\nexiting...\">>$WATCHLOG">>$WATCHDOG 
  echo "      for inputrmfile in \$(ls $INPUTDIR/* >/dev/null 2>&1|grep -v watchdog.sh)">>$WATCHDOG 
  echo "      do">>$WATCHDOG 
  echo "        rm -f \$inputrmfile >/dev/null 2>&1">>$WATCHDOG 
  echo "      done">>$WATCHDOG 
  echo "      exit 0">>$WATCHDOG
  echo "  else">>$WATCHDOG
  #echo "     if [[ -n \"\$opid\"  && \$opid -gt 1 ]]">>$WATCHDOG
  echo "     if [ -n \"\$opid\" ]">>$WATCHDOG
  echo "     then">>$WATCHDOG
  echo "     if [ \`echo \$opid|wc -w\` -gt 1 ];then opid=\$(echo \$opid|awk '{print \$1}');fi">>$WATCHDOG
  #echo "         spid=\$(ps -o pid -p \$opid >>$WATCHLOG 2>/dev/null|grep -v PID|sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
  if [[ -n "$ps_o_ret" && $ps_o_ret -eq 0 ]] ; then
    echo "         spid=\$(ps -o pid -p \$opid|grep -v PID |sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
  else
    echo "         spid=\$(ps -f -p \$opid|grep -v PID |  awk '{print \$2}' | sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
  fi
  echo "         if [[ -n \"\$spid\" && \"\$spid\" -eq \"\$opid\" && \`grep -wc \"\$spid\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq 0 ]] && [[ -n \"\$spid\" && \"\$spid\" -eq \"\$opid\" && \`grep -wc \"\$spid\" $TMPDIR/.initdaemon.pid 2>/dev/null\` -eq 0 ]] ">>$WATCHDOG
  echo "         then">>$WATCHDOG
  #echo "             scmd=\$(ps -ef|grep \$opid|grep -v grep|awk ' { print \$8 }')">>$WATCHDOG
  echo "             echo \"\`date '+%a %b %d %H:%M:%S %Y'\` candidate pid opid=\$opid still found as spid=\$spid\">>$WATCHLOG">>$WATCHDOG
  echo "             for cpid in \$(ps -ef |awk '\$3 == '\${spid}' {print \$2}') ">>$WATCHDOG        
  echo "             do">>$WATCHDOG
  echo "               if [[ \`grep -wc \"\$cpid\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq 0 ]] && [[ \`grep -wc \"\$cpid\" $TMPDIR/.initdaemon.pid 2>/dev/null\` -eq 0 ]]">>$WATCHDOG
  echo "               then">>$WATCHDOG
  echo "                  if [ \"$(/bin/uname -s)\" = \"Linux\" ]">>$WATCHDOG
  echo "                  then">>$WATCHDOG
  echo "                      scmd=\$(ps -o command -p \$opid |grep -v COMMAND)">>$WATCHDOG
  echo "                      ccmd=\$(ps -o command -p \$cpid |grep -v COMMAND)">>$WATCHDOG
  echo "                  fi">>$WATCHDOG
  echo "                  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` Stuck child pid \$cpid  of parent \$spid\">>$WATCHLOG">>$WATCHDOG
  echo "                  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` Stuck child command is \$ccmd\">>$WATCHLOG">>$WATCHDOG
  echo "                  killtree \$cpid 9 >>$WATCHLOG 2>&1">>$WATCHDOG
  echo "               fi">>$WATCHDOG
  echo "             done">>$WATCHDOG
  echo "             echo \"\`date '+%a %b %d %H:%M:%S %Y'\` killing stuck command \$scmd . Operating system process ID \$opid \">>$WATCHLOG">>$WATCHDOG
  echo "             kill -9 \$spid >>$WATCHLOG 2>&1">>$WATCHDOG
  echo "         fi">>$WATCHDOG
  echo "     fi">>$WATCHDOG
  echo "  fi">>$WATCHDOG
  echo "  if [ -e $WATCHLOG ];then  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` running watcher \$wakeup_count \" >>$WATCHLOG;fi">>$WATCHDOG
  echo "  wakeup_count=\`expr \$wakeup_count + 1\`">>$WATCHDOG  
  #echo "  for opid in \`ps -ef|grep -v \"watchdog.sh\"| awk '\$3 == '\${ppid}' { print \$2 }'\`">>$WATCHDOG
  #echo "  opid=\$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute| awk '\$3 == '\${ppid}' { print \$2 }')">>$WATCHDOG
   echo "  opid_long=\"\";opid=\"\";for oop in \$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute| awk '\$3 == '\${ppid}' { print \$2 }'); do if [[ \`grep -wc \"\$oop\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq "0" ]] && [[ \`grep -wc \"\$oop\" $TMPDIR/.initdaemon.pid 2>/dev/null\` -eq "0" ]]; then opid=\"\$opid \$oop\"; if [ -z \"\$opid_long\" ] ; then opid_long=\$oop; fi; fi; done">>$WATCHDOG
  #echo "  opid_long=\$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute | awk '\$3 == '\${ppid}' { print \$2 }'|head -1)">>$WATCHDOG
  echo "                  if [ \"$(/bin/uname -s)\" = \"Linux\" ]">>$WATCHDOG
  echo "                  then">>$WATCHDOG
  echo "  if [ -n \"\$opid\" ]; then ocomm_name=\$( ps -p \$opid_long -o command 2>/dev/null|grep -vi command|awk -F/ '{print \$NF}');fi">>$WATCHDOG
  echo "                  else">>$WATCHDOG
  echo "  if [ -n \"\$opid\" ]; then ocomm_name=\$( ps -ef |awk '\$2 == '\${opid_long}' {print \$0}');fi">>$WATCHDOG
  echo "                  fi">>$WATCHDOG
  #echo "  echo ocomm_name=\$ocomm_name">>$WATCHDOG
  echo "  if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` candidate child pid for killing is \$opid - \$ocomm_name \" >>$WATCHLOG;fi">>$WATCHDOG
  #echo "  do">>$WATCHDOG 
  #echo "     opid=\$opid">>$WATCHDOG
  #echo "  done">>$WATCHDOG
  echo "  found_raccheck_sql=\$(echo \$ocomm_name|grep -c \"exec_raccheck_sqls\")">>$WATCHDOG
  echo "  found_raccheck_root=\$(echo \$ocomm_name|grep -c \"root_${program_name}\")">>$WATCHDOG
  echo "  found_raccheck_cells=\$(echo \$ocomm_name|grep -c \"${program_name}_cells\")">>$WATCHDOG
  echo "  found_raccheck_root_samepassword=\$(echo \$ocomm_name|grep -c \"expect -f\")">>$WATCHDOG
  echo "  if [ -e \"$ROOT_LCKFIL\" ]; then found_raccheck_root=1;fi">>$WATCHDOG
  echo "  if [[ -n \"\$found_raccheck_sql\" && \$found_raccheck_sql -ge 1 && \$watchdog_long_wakeup -eq 1 ]]">>$WATCHDOG
  echo "  then">>$WATCHDOG
  #echo "      watchdog_long_wakeup=0">>$WATCHDOG
  #echo "      echo \$watchdog_wakeup_sql">>$WATCHDOG
  echo "if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup_sql seconds \" >>$WATCHLOG;fi">>$WATCHDOG
  echo "       sleep \$watchdog_wakeup_sql">>$WATCHDOG
  #echo "  elif [[ \$watchdog_long_wakeup -eq 1 && \$watchdog_dbm_root -eq 1 ]] && [[ -n \"\$found_raccheck_root\" && \$found_raccheck_root -ge 1 || -n \"\$found_raccheck_root_samepassword\" && \$found_raccheck_root_samepassword -ge 1 ]]">>$WATCHDOG
  echo "  elif [[ -n \"\$found_raccheck_root\" && \$found_raccheck_root -ge 1 || -n \"\$found_raccheck_root_samepassword\" && \$found_raccheck_root_samepassword -ge 1 || -n \"\$found_raccheck_cells\" && \$found_raccheck_cells -ge 1 ]]">>$WATCHDOG
  echo "  then">>$WATCHDOG
  #echo "      watchdog_long_wakeup=0">>$WATCHDOG
  #echo "      echo \$watchdog_wakeup_root">>$WATCHDOG
  echo " if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup_root seconds \" >>$WATCHLOG;fi">>$WATCHDOG
  echo "      sleep \$watchdog_wakeup_root">>$WATCHDOG
  echo "  else">>$WATCHDOG
  #echo "      echo \$watchdog_wakeup">>$WATCHDOG
  echo " if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup seconds \" >>$WATCHLOG;fi">>$WATCHDOG
  echo "      sleep \$watchdog_wakeup">>$WATCHDOG
  echo "  fi">>$WATCHDOG
  echo "done">>$WATCHDOG
  
  security_fix "fix_plugin_or_rtscript_attributes" "$WATCHDOG" "" "540"
  #$READ -p "see $WATCHDOG"
  #bash -x $WATCHDOG  >>watchdoglog.out 2>&1 & 
  $WATCHDOG &
  watchdog_pid=$! 

  if [[ `ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|wc -l|sed 's/ //g'` -eq 0 ]]; then
    unset ORACLE_SID 
  fi

  #port specicifc commands are determined here and used in rest of the scipt
  case `/bin/uname` in
    Linux) 
      EMHOMEVERSIONFIL="/etc/oragchomelist"
      EMHOMEVERSIONFIL2="/var/opt/oragchomelist"
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
      PROFILE="$HOME/.bash_profile"
      if [ ! -f $PROFILE ]; then PROFILE="$HOME/.profile";fi 
      v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}'|head -1)
      usern=`whoami`
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
	ORATAB=$RAT_ORATAB_LOC
      else
      	ORATAB=/etc/oratab  
      fi
    ;;
    SunOS) 
      EMHOMEVERSIONFIL="/var/opt/oracle/oragchomelist"
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}'|head -1)
      if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]; then v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}'|head -1);fi
      if [ -z "$bgproc" ]
      then
        bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
      fi
      PROFILE="$HOME/.profile"
      #usern=`who am i|awk {'print $1}'`
      usern=`id|awk '{print $1}'|cut -d'(' -f2|cut -d')' -f1`
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        ORATAB=$RAT_ORATAB_LOC
      else
	ORATAB="/var/opt/oracle/oratab" 
      fi
    ;;
    HP-UX) 
      PROFILE="$HOME/.profile"
      usern=`whoami`
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}'|head -1) 
      if [ -z "$bgproc" ]
      then
        bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
        v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}'|head -1) 
      fi
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        ORATAB=$RAT_ORATAB_LOC
      else
        ORATAB=/etc/oratab
      fi
    ;;
    AIX)   
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}'|head -1) 
      if [ -z "$bgproc" ]
      then
        bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
        v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}'|head -1) 
      fi
      PROFILE="$HOME/.profile"
      usern=`whoami`
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        ORATAB=$RAT_ORATAB_LOC
      else
        ORATAB=/etc/oratab
      fi
    ;;
    CYGWIN_NT-[0-9].[0-9])
      perl_exe=$(which perl|tr -d '\r');
      if [[ ! -n "$perl_exe" && -f "windiscover.out" ]] ; then
         v_home1=`grep HOME= windiscover.out | head -1 | sed 's/.*HOME=//' | sed 's/\|.*//'`;
         if [ -n "$v_home1" ] ; then
           perl_exe="$v_home1/perl/bin/perl"
         fi
      fi
      if [ -z "$perl_exe" ] ; then
        echo "";
        echo "Failed to find perl exectable in PATH. Discovery needs perl. Please set PATH and run again.";
        echo "";
        exit;
      fi
      $perl_exe $SCRIPTPATH/.cgrep/readreg.pl "$OUTPUTDIR"
      win_services=$OUTPUTDIR/win_services.out
      windiscover=$OUTPUTDIR/windiscover.out
	if [[ -n "$RAT_ORATAB_LOC" ]]
        then
          ORATAB=$RAT_ORATAB_LOC
	else
	  ORATAB=$OUTPUTDIR/win_oratab.out
	fi
      bgproc=`cat $win_services | grep OracleService |head -1 | sed 's/.*OracleService//'`;
      bgproc="ora_pmon_$bgproc";
      PROFILE="$HOME/.bash_profile"
      if [ ! -f $PROFILE ]; then PROFILE="$HOME/.profile";fi
      v_crs_home_bin=$(grep CRS_HOME= $windiscover | sed 's/CRS_HOME=//')
      v_crs_home_bin="$v_crs_home_bin/bin/crsd.exe"
      usern=`whoami`
      cp -f $windiscover . >/dev/null 2>&1
    ;;
    *)
      /bin/echo "ERROR: Unknown Operating System"
      exit -1
    ;;
  esac
  #watcher script code entds here

  #validate_program_zip

  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ -n "$fmw_dbrunonly" && $fmw_dbrunonly -eq "1" ]]; then
    echo "FMW_DBRUNONLY = $fmw_dbrunonly" >> $MASTERFIL
    validate_idm_owner
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ -n "$fmw_topology" && -e $fmw_topology ]] && [[ -n "$fmw_credconfig" && -e $fmw_credconfig ]]; then
    export fmw_topology=$fmw_topology;
    export fmw_credconfig=$fmw_credconfig;

    if [[ ! -e $OUTPUTDIR/idmlogs/healthcheck/ ]]; then 
      mkdir -p $OUTPUTDIR/idmlogs/healthcheck/ >/dev/null 2>&1
    fi

    discover_fmw_env "copy_idmdiscovery"
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ -e $IDMPATH/idmdiscovery.zip || -e $IDMPATH/discovery ]] && [[ $fmw_runmode != "pre" ]]; then 
    validate_idm_owner

    if [[ -z "$idm_db_components" ]] || [[ -n "$idm_db_components" && $idm_db_components = "" ]] || [[ -n "$same_idmdb_usern" && $same_idmdb_usern -eq "1" ]]; then 
    if [[ ! -e $WRKDIR/idmlogs/discovery/ ]]; then 
      mkdir -p $WRKDIR/idmlogs_${FDS}/discovery/ >/dev/null 2>&1
    fi

    #if [[ ! -e $OUTPUTDIR/idmlogs/discovery/ ]]; then 
    #  mkdir -p $OUTPUTDIR/idmlogs/discovery/ >/dev/null 2>&1
    #fi

    if [[ ! -e $OUTPUTDIR/idmlogs/healthcheck/ ]]; then 
      mkdir -p $OUTPUTDIR/idmlogs/healthcheck/ >/dev/null 2>&1
    fi

    replica_hname=""
    echo -e "Running ${program_name} on Oracle Identity Management System:\n"

    is_fmw_machine=1
    
    call_func_check_space "$localnode"
    check_another_instance "$localnode"

    IHOSTLIST=$OUTPUTDIR/i_o_host_list.out
    prompt_fmw_input

    if [[ -n $EM_PROBE_MODE && $EM_PROBE_MODE -eq 1 ]]; then 
      echo ""
    else
      print_idmsystem_type ${localnode}
      echo ""
      echo -e "Initiating Oracle Identity Management discovery on ${localnode}${idmsystem_type} :"

      discover_fmw_env

      if [[ -n "$set_wallet" && $set_wallet -eq 1 ]]; then
        i=1
        for rhost in ""${OUD[@]}""
        do
          set_in_wallet "OUD_HOST${i}" "$rhost"
          i=$(expr $i + 1)
        done
        unset i
        set_in_wallet "OIM_HOST" "$OIM_Host"
        set_in_wallet "OAM_HOST" "$OAM_Host"
        set_in_wallet "SINGLE_NODE_IDM" "$single_node_idm"
      fi

      if [[ -e $IHOSTLIST ]]; then cat $IHOSTLIST >> $HOSTLIST; fi
      cat $HOSTLIST|sort|uniq > $HOSTLIST.2
      mv -f $HOSTLIST.2 $HOSTLIST
      grep -v "$localnode" $HOSTLIST > $HOSTLIST.2
      echo "$localnode" >$HOSTLIST
      cat $HOSTLIST.2|sort|uniq >> $HOSTLIST
      
      for disc_hname in `grep -v "$localnode" $HOSTLIST`
      do
        node_pingable "$disc_hname"
        if [[ -n "$pingable" && $pingable -eq "1" ]] ; then
          discover_fmw_env_remote "$disc_hname"

          if [[ -n "$no_ssh_equivalency" && $no_ssh_equivalency -eq "0" ]]; then
            if [[ -e $RTEMPDIR/topology_kv.out ]]; then rm -f $RTEMPDIR/topology_kv.out >/dev/null; fi
            xml2kv "$RTEMPDIR/discovery/bin/topology.xml" "$RTEMPDIR/topology_kv.out"

            nhname_cnt=0
            for ndisc_hname in `grep 'topology.machines.machine.id=".*".name = ' $RTEMPDIR/topology_kv.out | grep -v instances | grep name |grep -v $localnode |sort -u | sed 's/.* = //' |cut -d. -f1`
            do
              nhname[$nhname_cnt]=$ndisc_hname 
              nhname_cnt=$(expr $nhname_cnt + 1)
            done
      
            OLD_IFS=$IFS
            IFS=$'\n'
            for namel in `grep -n 'Replica' $RTEMPDIR/topology_kv.out | awk -F':' '{print $1}'`
            do
              valuel=$(expr $namel + 1)
              nhname[$nhname_cnt]=$(sed -n ${valuel}p $RTEMPDIR/topology_kv.out | awk -F"=" '{print $NF}'|sed 's/ //g'|cut -d. -f1)
              replica_hname="$replica_hname ${nhname[$nhname_cnt]}"
            
              nhname_cnt=$(expr $nhname_cnt + 1) 
            done
            IFS=$OLD_IFS

            for ndisc_hname in "${nhname[@]}"
            do
              if [[ `grep -icw "$ndisc_hname" $HOSTLIST` -eq "0" ]]; then
                if [[ -e $HOSTLIST.ndh && `grep -icw "$ndisc_hname" $HOSTLIST.ndh` -eq "0" ]]; then
                  node_pingable "$ndisc_hname"
                  if [[ -n "$pingable" && $pingable -eq "1" ]] ; then
                    discover_fmw_env_remote "$ndisc_hname"
            
                    if [[ -n "$no_ssh_equivalency" && $no_ssh_equivalency -eq "0" ]]; then
                      echo "$ndisc_hname" >> $HOSTLIST.ndh
                    fi
	  	  fi
                fi
              fi
            done
            echo "$disc_hname" >> $HOSTLIST.ndh
          fi
	fi
      done 

      rm -f $IHOSTLIST >/dev/null 2>&1
      rm -f $HOSTLIST.ndh >/dev/null 2>&1
      rm -f $HOSTLIST >/dev/null 2>&1
      rm -f $RTEMPDIR/topology_kv.out >/dev/null 2>&1

      cp -rf $RTEMPDIR/discovery/ $OUTPUTDIR

      if [[ -e $WRKDIR/idmlogs_${FDS} ]]; then
	cp -rf $WRKDIR/idmlogs_${FDS}/* $OUTPUTDIR/idmlogs/	
        rm -rf $WRKDIR/idmlogs_${FDS}/ >/dev/null 2>&1
      fi

      if [[ -e $IDMPATH/discovery ]]; then rm -rf $IDMPATH/discovery >/dev/null 2>&1; fi
      cp -rf $RTEMPDIR/discovery/ $IDMPATH/

      export fmw_topology="$RTEMPDIR/discovery/bin/topology.xml"
      export fmw_credconfig="$RTEMPDIR/discovery/bin/credconfig"
      fi
    fi
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ $fmw_runmode = "pre" ]]; then 
    IHOSTLIST=$OUTPUTDIR/i_o_host_list.out
    if [[ ! -e $OUTPUTDIR/idmlogs/healthcheck/ ]]; then 
      mkdir -p $OUTPUTDIR/idmlogs/healthcheck/ >/dev/null 2>&1
    fi
    prompt_fmw_preinput
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ "$RAT_RUNMODE_INTERNAL" != "slave" ]]; then
    echo -e ${RED}"Either Identity Management Discovery plugin is missing or topology.xml and credconfig details not passed."${NORM}
    echo -e ${RED}"It is highly recommended that you download the latest Identity Management specific version of ${program_name} from my oracle support to ensure that Identity Management related data contained within the report or use -topology <topology.xml> -credconfig <credconfig>"${NORM}
    echo ""
    echo -e ${RED}"${program_name} is exiting.."${NORM}
    echo ""
    exit 1
  fi

  if [[ -z $EM_PROBE_MODE ]] || [[ $EM_PROBE_MODE -eq 0 ]]; then
  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ -n "$fmw_dbrunonly" && $fmw_dbrunonly -eq "1" ]]; then
    echo ""
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ -e $IDMPATH/healthcheck.zip || -e $IDMPATH/healthcheck ]] && [[ "$RAT_RUNMODE_INTERNAL" != "slave" ]] ; then
    if [[ -e $IDMPATH/healthcheck.zip ]]; then
      unzip -o $IDMPATH/healthcheck.zip -d $RTEMPDIR >/dev/null 2>&1

      if [[ ! -e $RTEMPDIR/discovery/lib ]]; then
        discover_fmw_env "copy_idmdiscovery"
      fi

      curr_dir=$(pwd);
      cd $RTEMPDIR/discovery/lib
      cp -f topology.jar oracle-idmprovisioning-credstore.jar ojdl.jar ojdbc6.jar commons-cli-1.1.jar common.jar ant-launcher.jar ant.jar $RTEMPDIR/healthcheck/lib >/dev/null 2>&1 
      cd $curr_dir
    elif [[ -e $IDMPATH/healthcheck ]]; then
      cp -rf $IDMPATH/healthcheck/ $RTEMPDIR >/dev/null 2>&1
      curr_dir=$(pwd);
      cd $RTEMPDIR/discovery/lib
      cp -f topology.jar oracle-idmprovisioning-credstore.jar ojdl.jar ojdbc6.jar commons-cli-1.1.jar common.jar ant-launcher.jar ant.jar $RTEMPDIR/healthcheck/lib >/dev/null 2>&1 
      cd $curr_dir
    else
      if [[ -z $RAT_IDMHC ]]; then
        echo -e ${RED}"Identity Management Healthcheck plugin is missing."${NORM}
        echo ""
        echo -e ${RED}"${program_name} is exiting.."${NORM}
        echo ""
        exit
      fi
    fi
  elif [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ "$RAT_RUNMODE_INTERNAL" != "slave" ]]; then
    if [[ -z $RAT_IDMHC ]]; then
      echo -e ${RED}"Identity Management Healthcheck  plugin is missing."${NORM}
      echo ""
      echo -e ${RED}"${program_name} is exiting.."${NORM}
      echo ""
      exit
    fi
  fi
  fi

  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]]; then
    if [[ -n "$run_profile" && $run_profile -eq "1" ]]; then
      fmw_run_comps=$(echo "$profiles2run"|sed 's/,/:/g')
      export fmw_run_comps=$fmw_run_comps
    fi
    if [[ -n "$exclude_profile" && $exclude_profile -eq "1" ]]  ; then
      fmw_exclude_comps=$(echo "$profiles2exclude"|sed 's/,/:/g')
      export fmw_exclude_comps=$fmw_exclude_comps
    fi
  fi
fi

if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 ]]; then
  if [ $is_windows -eq "0" ] ; then 
    ORACLE_SID=$(echo "$bgproc"|head -1|sed 's/ora_pmon_//g'|sed 's/ //g')
    ORACLE_HOME=${mb_oracle_homes[0]}
  else
    echo ''
  fi
  export ORACLE_SID=${ORACLE_SID}
  export ORACLE_HOME=${ORACLE_HOME}
  db_up=`grep ${ORACLE_SID}_UP $MASTERFIL |awk '{print $3}' |head -1`
fi

if [[ -n "$run_acchk" || $run_acchk -eq "1" ]]
then
  echo `hostname|cut -d. -f1`>$HOSTLIST
fi

if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
then
if [[ $OFFLINE -eq "0" ]] && [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  # Node list
  # start -init
  if [[ -n "$setup_inittab" ]] && [[ $setup_inittab -ne "3" && $setup_inittab -ne "10" ]] ; 
  then    
    if [ $is_bda_machine -eq "1" ]
    then
     generate_bda_node_info
    fi
    if [[ $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
    then
      generate_exalogic_node_info
    fi
    if [ $is_exalytics_machine -eq "1" ]
    then
      generate_exalytics_node_info
    fi
    if [ $is_fmw_machine -eq "1" ]
    then
      read_fmw_topology
    fi
    if [ $is_zfssa_machine -eq "1" ]
    then
      generate_zfssa_node_info
    fi
    if [ $is_opc -eq "1" ] ; then
      read_opc_topology
    fi
    if [ -n "$RAT_TORSWITCHES" ] ; then
      components=TORSWITCH
    fi
    is_crs_up
    single_instance_run=0
    if [[ ${crs_up} -ne 1 || $oracle_restart -eq 1 ]]
    then
      is_db_up;
      #if [[ -n "$somedb_up" && $somedb_up -eq "1" && $is_exalogic_machine -eq "0" && $is_exalogic_foxtrot -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq 0 && $is_fmw_machine -eq "0" ]]
      if [[ -n "$somedb_up" && $somedb_up -eq "1" && $is_exalogic_machine -eq "0" && $is_exalogic_foxtrot -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq 0 && $is_zfssa_machine -eq 0 && $is_opc -eq 0 ]]
      then
        single_instance_run=1
      elif [[ -n "$somedb_up" && $somedb_up -eq "0" && $oracle_restart -eq 1 ]]
      then
        single_instance_run=1
      elif [[ $is_exalogic_machine -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq 0 && $is_exalogic_foxtrot -eq "0" && $is_fmw_machine -eq 0 && ! -e "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" && $is_zfssa_machine -eq 0 && $is_opc -eq 0 ]] ; then
      #elif [[ $is_exalogic_machine -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq 0 && $is_exalogic_foxtrot -eq "0" && ! -e "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]] ; then
        attempt_cnt=3
        while [[ $attempt_cnt -ge "0" ]] ; do
          if [ -z $SYS_TYPE ]
          then
       	    printf "This computer is for [S]ingle instance database or part of a [C]luster to run RAC database [S|C] [C]:"

            if [[ $EM_PROBE_MODE -eq 1 ]]
            then
              cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <text nls_id="orhc_exadata_n16_nlsid">
      This computer is for [S]ingle instance database or part of a [C]luster to run RAC database [S|C] [C]
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n39_nlsid">S</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n40_nlsid">C</text>
      </option>
    </options>
  </question>	
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
              single_instance_run=0	      
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      read_probe_xml "This computer is for [S]ingle instance database or part of a [C]luster to run RAC database [S|C] [C]"
	      uip=$xml_rvalue
            else
	      if [[ $daemon_init_mode -eq 1 ]]; then
		uip='C'
	      else
                $READ uip
	        read_code=`echo $?`;
	      fi

	      write_in_env "SYSTEM_TYPE_OPTION" "$uip" 
	      process_prompt "$read_code" "uip" "C"
              case "$uip" in
                C|c) single_instance_run=0;;
                S|s) single_instance_run=1;;
                *) single_instance_run=0;;
              esac
            fi
          else
       	    single_instance_run=0;
       	    if [ `echo $SYS_TYPE |grep -ic 'single'` -gt 0 ]
       	    then
       	      single_instance_run=1;
       	    fi	
          fi

          if [[ $single_instance_run -eq "2" ]] ; then
            echo "Invalid input. Try again ($attempt_cnt attempts remaining)"
            attempt_cnt=$(expr $attempt_cnt - 1)
          else
            attempt_cnt=-1
          fi
        done
        if [[ $single_instance_run -eq "2" ]] ; then
          single_instance_run=0
          echo "Running as a cluster node";
        fi
      fi
   
      if [[ $single_instance_run -eq "1" ]] ; then   
        case `/bin/uname` in
         Linux)
           v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $8}'|head -1)
         ;; 
         SunOS)
           v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $9}'|head -1)
           if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]; then v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $8}'|head -1);fi
         ;;
         HP-UX)
           v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $9}'|head -1)
           if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]
           then
             v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $8}'|head -1)
           fi
         ;;
         AIX)
           v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $9}'|head -1)
           if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]
           then
             v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $8}'|head -1)
           fi
         ;;
         CYGWIN_NT-[0-9].[0-9])
           windiscover=$OUTPUTDIR/windiscover.out
           v_crs_home_bin=$(grep CRS_HOME= $windiscover | sed 's/CRS_HOME=//')
           v_crs_home_bin="$v_crs_home_bin/bin/crsd.exe"
         ;;
         *)
           /bin/echo "ERROR: Unknown Operating System"
           exit -1
         ;;
        esac 
      fi

      if [[ $single_instance_run -eq "1" && $upgrade_mode -eq 0 ]] ; then
        DOROOT=0
        components="SIDB:SIDBMAA"
        echo "$localnode" > $HOSTLIST
      fi

      #echo "components=$components"
      if [[ $single_instance_run -eq "1" &&  $upgrade_mode -gt 0 ]]
      then
        DOROOT=0
        echo "$localnode" > $HOSTLIST
        if [ $upgrade_mode -eq 2 ]
        then 
          components="PREUPGRSIDB"
        elif  [ $upgrade_mode -eq 3 ]
        then 
          components=$(echo ${components}|sed 's/POSTUPGR://g'|sed 's/:POSTUPGR//g'|sed 's/:POSTUPGR://g'|sed 's/POSTUPGR//g')
          components=$(echo ${components}:POSTUPGRSIDB)
          components=$(echo ${components}|sed 's/RACCHECK://g'|sed 's/:RACCHECK//g'|sed 's/:RACCHECK://g'|sed 's/RACCHECK//g')
          components=$(echo ${components}:SIDB)
          components=$(echo ${components}|sed 's/MAA://g'|sed 's/:MAA//g'|sed 's/:MAA://g'|sed 's/MAA//g')
          components=$(echo ${components}:SIDBMAA)
        fi
      fi
    fi

    #$READ -p "stop"     
    if [ -n "$ORA_CRS_HOME" ]
    then
      CRS=$ORA_CRS_HOME
    elif [ -n "$CRS_HOME" ]
    then
      CRS=$CRS_HOME
    elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" && -n "$single_instance_run" && $single_instance_run -eq 0 && -n "$is_bda_machine" && $is_bda_machine -eq "0" && -n "$single_instance_run" && $single_instance_run -eq 0 && $is_exadata_dom0_machine -eq 0 && $is_ssc_globalzone_machine -eq 0 && -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "0" && $is_opc -eq 0 && $is_zfssa_machine -eq 0 ]] || [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] 
    then
      if [ ${crs_up} -eq 1 ]
      then
        v_crs_home_bin=$(dirname $v_crs_home_bin 2>/dev/null)
        v_crs_home=$(echo $v_crs_home_bin|sed 's/\/bin//g')
        echo ""
        if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 && -f ${v_crs_home_bin}/crsd.$BIN && $daemon_init_mode -eq 0 ]]
        then   
          if [[ -n "$setup_inittab" && $setup_inittab -gt "0" ]] || [[ -n "$prepare_init" && $prepare_init -eq "1" ]]; then
            setCRSHome=Yes
          else
            if [[ $EM_PROBE_MODE -eq 1 ]]
            then
              cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" defaultId="$v_crs_home" outcome="No">
    <text nls_id="orhc_exadata_n23_nlsid">
      CRS Home 
    </text>
  </question>
</group>
EOF

	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

              echo -e "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME to "$v_crs_home"?[y/n][y]"
	      setCRSHome='Yes'
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
              echo -e "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME to "$v_crs_home"?[y/n][y]"

	      read_probe_xml "n23_nlsid"
	      setCRSHome='Yes'
 	      v_crs_home=$xml_rvalue
	    else
              if [[ $program_name != "exachk" && -z $wallet_upload && -z $cmdline_cm_upgrade ]];
              then 
		  exec 3<&2; exec 2<&0
		  $READ -p "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME to "$v_crs_home"?[y/n][y]" setCRSHome
		  read_code=`echo $?`;
		  exec 2<&3
		  process_prompt "$read_code" "setCRSHome" "y"
              else
                  setCRSHome=Yes 
              fi
            fi
          fi
        elif [[ -n "$NOQUESTION" && $NOQUESTION -eq 1 && -f ${v_crs_home_bin}/crsd.$BIN ]] || [ $daemon_init_mode -eq 1 ]
        then
          setCRSHome=Yes
        else
          setCRSHome=No
        fi 
        case $setCRSHome in
          y|Y|yes|YES|Yes)
     	    write_in_env "CRS_OPTION" "$v_crs_home"
            export CRS=$v_crs_home
            ;;
          n|N|No|NO)
	    if [[ $EM_XMLD_MODE -eq 1 ]]
	    then
              echo -e "Enter path for clusterware home: "

	      read_probe_xml "Enter path for clusterware home"
	      cHome=$xml_rvalue
	    else
              echo ""
              exec 3<&2; exec 2<&0
              $READ -p "Enter path for clusterware home:  " cHome
              exec 2<&3
     	      write_in_env "CRS_OPTION" "$cHome"
	    fi
            export CRS=$cHome
            ;;
          *)
     	    write_in_env "CRS_OPTION" "$v_crs_home"
            export CRS=$v_crs_home
            ;;
        esac
      elif [ -n "$local_invntr_CH" ]
      then
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
          cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n25_nlsid">
        CRS binaries found at {1}
      </text>
      <tokens>
        <token index="1">$local_invntr_CH</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n17_nlsid">
      Do you want to set CRS_HOME to {1}?
    </text>
    <tokens>
      <token index="1">$local_invntr_CH</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n24_nlsid">
      Enter value for ORA_CRS_HOME environment variable
    </text>
  </question>
</group>
EOF
	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

          echo -e "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]"
	  setCRSHome="Yes"
	elif [[ $EM_XMLD_MODE -eq 1 ]]
	then
          echo -e "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]"

	  read_probe_xml "Do you want to set CRS_HOME to {1}?"
	  setCRSHome=$xml_rvalue
	else
          exec 3<&2; exec 2<&0
          $READ -p "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]" setCRSHome
	  read_code=`echo $?`;
          exec 2<&3
	  process_prompt "$read_code" "setCRSHome" "y"
        fi
        case $setCRSHome in
          y|Y|yes|YES|Yes)
      	    write_in_env "CRS_OPTION" "$local_invntr_CH"
            export CRS=$local_invntr_CH
            ;;
          n|N|No|NO)
	    if [[ $EM_XMLD_MODE -eq 1 ]]
	    then
              echo -e "Enter value for ORA_CRS_HOME environment variable: "

	      read_probe_xml "Enter value for ORA_CRS_HOME environment variable"
	      cHome=$xml_rvalue
	    else
              echo ""
              exec 3<&2; exec 2<&0
              $READ -p "Enter value for ORA_CRS_HOME environment variable:  " cHome
              exec 2<&3
      	      write_in_env "CRS_OPTION" "$cHome"
	    fi
            export CRS=$cHome
            ;;
          *)
      	    write_in_env "CRS_OPTION" "$local_invntr_CH"
            export CRS=$local_invntr_CH
            ;;
        esac
      else    
        echo "Clusterware home not set so CRS related audit check will be skipped.\n" >>$LOGFIL
      fi
    fi
 
    #Following section is used to set, unset, get and check wallet variables through command line
    if [[ $wallet_upload -eq 1 ]];then
      setEnvInWallet
      exit;
    fi

    if [[ $wallet_upload -eq 2 ]];then
      unsetEnvInWallet
      exit;
    fi

    if [[ $wallet_upload -eq 3 ]];then
      getEnvFromWallet
      upload_result_env_check $RAT_ZIP_UPLOAD_TABLE
      if [[ $raccheck_upload_env_set -eq 0 ]];then
        echo -e "\nEnvironment is not set for uploading results to database.\n"
      fi
      upload_result_conn_check
      print_conn_check_msg
      conn_check_return_status=$?
      if [[ $conn_check_return_status -eq 1 ]];then
        exit 1;
      else
        echo -e "\nConfiguration is good to upload result to database.\n";
        exit 0;
      fi
    fi

    if [[ $wallet_upload -eq 4 ]];then
      getEnvFromWallet
      exit;
    fi

    getEnvFromWallet

    #Following piece of code is used to upgrade collection manager from command line using -cmupgrade
    if [[ -n $cmdline_cm_upgrade && $cmdline_cm_upgrade -eq 1 ]];then
      setdbHomeforWallet
      export ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
      check_flag_status
      if [[ -n $cm_upgrade_flag ]];then
        upgrade_cm
        cm_upgrade_status=$?
      else
        echo -e "\nUnable to upgrade the Collection Manager because version table RCA13_INTRACK_PREFERENCES does not present in collection manager.\n";
        cm_upgrade_status=1
      fi
      cm_upgrade_status=$?
      if [[ $cm_upgrade_status -eq 0 ]];then
        exit 0;
      else  
        exit 1;
      fi     
    fi

    upload_result_env_check $RAT_ZIP_UPLOAD_TABLE
    if [[ $raccheck_upload_env_set -eq 0 ]];then
      DATABASE_UPLOAD_SETUP=0
      echo "DATABASE_UPLOAD_SETUP = $DATABASE_UPLOAD_SETUP" >> $MASTERFIL
    else
      DATABASE_UPLOAD_SETUP=1
      echo "DATABASE_UPLOAD_SETUP = $DATABASE_UPLOAD_SETUP" >> $MASTERFIL
    fi


    if [[ $check_failed_uploads -eq 1 ]];then
      get_failed_uploads 
      if [[ -n $unsuccess_coll ]];then
        unsuccess_coll=$(echo $unsuccess_coll| sed 's/ /.zip\\n/g')
        echo -e "\nList of failed upload collections\n";
        echo -e "\n${unsuccess_coll}.zip\n"
      else
        echo -e "\nFailed upload collection does not exist\n";
      fi 
      exit 0;
    fi

    if [[ -z $RAT_DBUPLOAD_SIZE ]];then
      RAT_DBUPLOAD_SIZE=500;
    fi

    if [[ $upload_failed -eq 1 ]];then
      if [[ $raccheck_upload_env_set -eq 0 ]];then
        echo -e "\n${RED}Environment is not set for uploading results to database.${NORM}\n" 
        echo -e "${RED}${program_name} is exiting...\n$NORM";
        exit 1;     
      else
        upload_result_conn_check
        print_conn_check_msg
        conn_check_return_status=$?
        if [[ $conn_check_return_status -eq 1 ]];then
          exit 1;
        fi  
      fi
      unsuccess_coll_arg=$(echo "$command_arguments" | $AWK '{for(i=1;i<=NF;i++) if ($i=="-uploadfailed") print $(i+1)}')
      if [[ -n $unsuccess_coll_arg && $unsuccess_coll_arg == "all" ]];then
        get_failed_uploads    
      else
        unsuccess_coll=`echo $unsuccess_coll_arg|sed 's/.zip//g'` 
        unsuccess_coll=`echo $unsuccess_coll|sed 's/,/ /g'`
      fi
      if [[ -n $unsuccess_coll ]];then
        OLD_ORACLE_HOME=$ORACLE_HOME
        if [[ -n $RAT_UPLOAD_ORACLE_HOME ]];then
          ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
        else
          ORACLE_HOME="$CRS"
        fi
        export ORACLE_HOME="$ORACLE_HOME"
        #export TWO_TASK="$RAT_UPLOAD_CONNECT_STRING"
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
        free_space_in_db=$(echo -e "set heading off feedback off\n SELECT round(sum(bytes)/1048576) FROM user_free_space  where tablespace_name = (SELECT nvl(tablespace_name,'XXX') from user_tables where table_name = 'RCA13_DOCS');"|$ORACLE_HOME/bin/sqlplus -s  $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING") >/dev/null 2>&1;
        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
        #unset ORACLE_HOME
        ORACLE_HOME=$OLD_ORACLE_HOME
        CM_OUTPUTDIR=$OUTPUTDIR
        for UPLOADFIL in $unsuccess_coll
        do 
          if [[ $free_space_in_db -gt $RAT_DBUPLOAD_SIZE ]];then
            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              OLD_OH=$ORACLE_HOME
              if [[ -n $RAT_UPLOAD_ORACLE_HOME ]];then
                ORACLE_HOME="$RAT_UPLOAD_ORACLE_HOME"
              elif [[ -n $CRS ]];then
                ORACLE_HOME="$CRS"
              fi  
              get_dbOwner
              OLD_UPLOADFIL=$UPLOADFIL
              OLD_UPLOADFIL_ZIP="${OLD_UPLOADFIL}.zip"
              user_home_dir=$dbhome_dir
              if [[ ! -d ${user_home_dir}/.${program_name} ]];then
                mkdir ${user_home_dir}/.${program_name} >/dev/null 2>&1
              fi
              mv -if ${UPLOADFIL}.zip ${user_home_dir}/.${program_name} >/dev/null 2>&1
              mv -if ${UPLOADFIL} ${user_home_dir}/.${program_name} >/dev/null 2>&1
              bname_uploadfil=$(basename "${UPLOADFIL}.zip")
              ZIP_UPLOADFIL=${user_home_dir}/.${program_name}/$bname_uploadfil
              #unzip -o ${ZIP_UPLOADFIL} >/dev/null 2>&1
              UPLOADFIL=$(echo $ZIP_UPLOADFIL |sed 's/.zip//g') 
              ORACLE_HOME=$OLD_OH
              upload_zip_file "${UPLOADFIL}.zip"
              OLD_UPLOADFIL_DIR=$(dirname "${OLD_UPLOADFIL_ZIP}")
              mv -if $UPLOADFIL $OLD_UPLOADFIL_DIR >/dev/null 2>&1
              mv -if ${ZIP_UPLOADFIL} $OLD_UPLOADFIL_DIR >/dev/null 2>&1
	      write_del_rolbk_tmpoutput
            else
              upload_zip_file "${UPLOADFIL}.zip"
            fi
            if [ $zip_data_upload_status -eq  1 ]
            then
              echo -e "Required environment variables are not set to upload zip file to database">>$LOGFIL
            elif [ $zip_data_upload_status -eq 2 ]
            then
              echo -e $RED"${program_name} was not able to make successfull connection to database to upload "${UPLOADFIL}.zip".\nPlease run ${LDRCTLFIL_NEW} script manually to upload "${UPLOADFIL}.zip" to database\n$NORM"|tee -a $LOGFIL
            elif [ $zip_data_upload_status -eq 3 ]
            then
              echo -e "$zip_upload_message"|tee -a $LOGFIL
            else
              echo -e "$zip_upload_message"|tee -a $LOGFIL
            fi
          else
            echo -e "\n${RED}Available free memory space in database is less than $RAT_DBUPLOAD_SIZE MB. File upload to database has been skipped.\n${NORM}"|tee -a $LOGFIL;
            echo -e "${RED}${program_name} is exiting...\n$NORM";
            exit 1;
          fi 
        done
      else
        echo -e "\n${RED}There is no unsuccessful collections to upload.\n${NORM}";
        echo -e "${RED}${program_name} is exiting...\n$NORM";
        cleanup
        exit 1;
      fi
      cleanup
      exit 0;
    fi
     
    save_crs

    if [ ${crs_up} -eq 1 ]
    then
      set_rat_legacy_discovery
      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then dump_ocr_data; fi

      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]
      then      
        check_crs_stat=0
        crs112=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "11.2"`
        crs121=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "12.1"`
        crs122=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "12.2"`
      else
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            check_crs_stat=`su $dbOwner -c "$CRS/bin/crsctl status resource -t >/dev/null 2>&1";echo $?`
          else
            check_crs_stat=`su $dbOwner -c "$CRS/bin/crs_stat -t >/dev/null 2>&1";echo $?`
          fi
    	  write_del_rolbk_tmpoutput
          cd $OLD_DIR
          unset OLD_DIR
        else
          if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            check_crs_stat=`$CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
          else
            check_crs_stat=`$CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?`
            if [[ $check_crs_stat -ne 0 ]];then
              check_crs_stat=`$CRS/bin/crsctl check crs  >/dev/null 2>&1;echo $?`
            fi
          fi
        fi
        #check_crs_stat=$($CRS/bin/crs_stat -t >/dev/null 2>&1;echo $?)
        if [ $check_crs_stat -eq 0 ]
        then
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            OLD_OH=$ORACLE_HOME
            ORACLE_HOME=$CRS
            get_dbOwner
            ORACLE_HOME=$OLD_OH
            crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '11.2'"`
            crs121=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.1'"`
            crs122=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.2'"`
            if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.1'"`;fi
            if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.2'"`;fi
    	    write_del_rolbk_tmpoutput
            cd $OLD_DIR
            unset OLD_DIR
          else
            crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "11.2"`
            crs121=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`
            crs122=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.2"`
            if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`;fi
            if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.2"`;fi
          fi
        fi
      fi
    fi

    #if [[ -z "$RAT_CLUSTERNODES" && $is_exalogic_machine -eq "0" && $single_instance_run -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq "0"  && $is_fmw_machine -eq 0 && $is_exadata_dom0_machine -eq "0" && $is_ssc_globalzone_machine -eq 0 && $is_exalogic_foxtrot -eq "0" ]]; then
    if [[ -z "$RAT_CLUSTERNODES" && $is_exalogic_machine -eq "0" && $single_instance_run -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq "0" && $is_exadata_dom0_machine -eq "0" && $is_ssc_globalzone_machine -eq 0 && $is_exalogic_foxtrot -eq "0" && $is_opc -eq 0 ]]; then
      if [ ${crs_up} -eq 1 ]
      then 
        if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" ]]; then
          check_crs_stat=0
          crs112=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "11.2"`
          crs121=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "12.1"`
          crs122=`grep CRS_ACTIVE_VERSION $MASTERFIL | head -1 |grep -c "12.2"`

          if [[ -n "$localonly" && $localonly -eq 1 ]] 
          then
            echo `hostname|cut -d. -f1`>$HOSTLIST 
          else    
            OLSNODES=`grep OLSNODES $MASTERFIL | head -1 | awk -F'=' '{print $2}'`
	    if [[ -z $OLSNODES || `echo "$OLSNODES"|sed 's/ //g'` = "" ]]; then
	      if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then 
                nodelist_without_olsnodes
	      fi
	    else
              for i in `echo "$OLSNODES"`
              do   
               echo $i|tr "[A-Z]" "[a-z]">>$HOSTLIST
              done
	    fi
          fi  
	else
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            OLD_OH=$ORACLE_HOME
            ORACLE_HOME=$CRS
            get_dbOwner
            ORACLE_HOME=$OLD_OH
            check_crs_stat=$(su $dbOwner -c "$CRS/bin/crs_stat -t >/dev/null 2>&1";echo $?)
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            if [[ $crs112 -ge 1 ]];then
              check_crs_stat=$($CRS/bin/crsctl check crs >/dev/null 2>&1;echo $?)
            else
              check_crs_stat=$($CRS/bin/crs_stat -t >/dev/null 2>&1;echo $?)
            fi
	  fi
          if [ $check_crs_stat -eq 0 ] 
          then  
            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              OLD_OH=$ORACLE_HOME
              ORACLE_HOME=$CRS
              get_dbOwner
              crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '11.2'"`
              crs121=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.1'"`
              crs122=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.2'"`
              if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.1'"`;fi
              if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.2'"`;fi

              for i in `su $dbOwner -c "$CRS/bin/olsnodes"`
              do   
               echo $i|tr "[A-Z]" "[a-z]">>$HOSTLIST
              done
              ORACLE_HOME=$OLD_OH
    	      write_del_rolbk_tmpoutput
              cd $OLD_DIR
              unset OLD_DIR
            else
              crs112=`$CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "11.2"`
              crs121=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`
              crs122=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.2"`
              if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`;fi
              if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.2"`;fi

              for i in `$CRS/bin/olsnodes`
              do   
               echo $i|tr "[A-Z]" "[a-z]">>$HOSTLIST
              done
	    fi
          else
            if [[ -n "$localonly" && $localonly -eq 1 ]] 
            then
              echo `hostname|cut -d. -f1`>$HOSTLIST 
            else    
	      if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then 
                nodelist_without_olsnodes
	      fi
            fi
          fi
	fi
      else
        if [[ -n "$localonly" && $localonly -eq 1 ]] 
        then
          echo `hostname|cut -d. -f1`>$HOSTLIST 
        else    
	  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then 
            nodelist_without_olsnodes
	  fi
        fi  
      fi
    elif [[ -z "$RAT_CLUSTERNODES" ]] && [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]]
    then
      $IBHOSTS 2>/dev/null|$AWK '{if ( / S [0-9.,]* HCA\-/ ) print $6;}' |tr -d '"'|sort -u >>$HOSTLIST
      orig_localnode=$localnode
    elif [[ ! -z "$RAT_CLUSTERNODES" ]]
    then
      rm -f $HOSTLIST
      #Reassging localnode when node names are diffrent from hostname command and passed using clusternodes. fix for bug 18601262 
      orig_localnode=$localnode
      echo $localnode > $HOSTLIST
      for nodename in `echo $RAT_CLUSTERNODES`
      do
       if [[ "$localnode" = "$nodename" ]]; then continue; fi
       echo $nodename>>$HOSTLIST
      done  
    fi
    ret_crs

    if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ $fmw_runmode = "pre" ]]; then
      if [[ ! -e $HOSTLIST ]]; then
	if [[ -e $IHOSTLIST ]]; then
	  grep -v "$localnode" $IHOSTLIST > $HOSTLIST.2
	  echo "$localnode" > $HOSTLIST;
	  cat $HOSTLIST.2 >> $HOSTLIST;
	else
	  echo "$localnode" > $HOSTLIST;
	fi
      fi
    fi

    cat $HOSTLIST|sort|uniq > $HOSTLIST.2
    mv -f $HOSTLIST.2 $HOSTLIST
    #following code is to change the running node as first node in first and make it driving node
    #saved_localnode="$localnode"
    saved_localnode="$orig_localnode"

    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]]    
    then
      localnode=$(grep -iw "${localnode}" $HOSTLIST| head -1);
      if [ -z "$localnode" ] ; then localnode="$saved_localnode"; fi;

      if [[ `cat $HOSTLIST|head -1` != $localnode ]]
      then
        #sed "/${localnode}/Id" $HOSTLIST > $INPUTDIR/tmp_hostlist.out
        cat $HOSTLIST|sed 's/'${localnode}'//g'> $INPUTDIR/tmp_hostlist.out
        rm -f $HOSTLIST
        echo $localnode >$HOSTLIST
        cat $INPUTDIR/tmp_hostlist.out|sed '/^$/d' >>$HOSTLIST
        rm -f $INPUTDIR/tmp_hostlist.out
      fi
    else
      echo "$saved_localnode" >$HOSTLIST	
      for guestvm in "${el_guest_vms[@]}"
      do
        echo "$guestvm" >> $HOSTLIST
      done
    fi

    orig_localnode_fullname=$(hostname)
    hostmap=("${hostmap[@]}" $localnode:$orig_localnode_fullname);

    if [[ -n "$localonly" && $localonly -eq 1 ]]
    then
      localonly_nodename=$(cat $HOSTLIST|head -1)
      rm -f $HOSTLIST >/dev/null 2>&1
      echo $localonly_nodename >$HOSTLIST
    fi
    #ends here

    #Following code is change from top to here for handling user defined storage servers rather than reading from default cellip.ora
    if [[ -z "$RAT_CELLS" && -n $snlist_file && -e "$snlist_file" ]] 
    then # exalogic machine. list if already in file.
      for cellname in `cat $snlist_file`
      do
        echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
      done
      CELLIP=$INPUTDIR/cellip.ora
    elif [[ -z "$RAT_CELLS" && $is_exadata_dom0_machine -eq 0 && $is_ssc_globalzone_machine -eq 0 && $is_zfssa_machine -eq 0 && -e /etc/oracle/cell/network-config/cellip.ora ]]
    then
      #CELLIP=/etc/oracle/cell/network-config/cellip.ora   
      #cp -f /etc/oracle/cell/network-config/cellip.ora $INPUTDIR
      if [ -e /etc/oracle/cell/network-config/cellip.ora ]; then cat /etc/oracle/cell/network-config/cellip.ora|cut -d: -f1>$INPUTDIR/cellip.ora;fi    
      CELLIP=$INPUTDIR/cellip.ora
    elif [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]]
    then
      CELLIP=$ZFSIP
    elif [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]] && [[ -z "$RAT_CELLS" ]]
    then 
      $IBHOSTS 2>/dev/null|$AWK '{if ( / C[ 0-9.,]* HCA\-/ ) print "cell = " $6 "\"";}'|sort -u >>$INPUTDIR/cellip.ora 
      CELLIP=$INPUTDIR/cellip.ora
    else
      for cellname in `echo $RAT_CELLS`
      do
        echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
      done
      CELLIP=$INPUTDIR/cellip.ora
    fi
    # Following code is to add external storage to cellip.ora
    if [[ -z "$RAT_CELLS" && -n $extsnlist_file && -e "$extsnlist_file" ]]
    then # exalogic machine with external storage
      for cellname in `cat $extsnlist_file`
      do
        echo "cell=\"$cellname\"">>$INPUTDIR/extcellip.ora
      done
      EXTCELLIP=$INPUTDIR/extcellip.ora
    fi
    if [[ -e $CELLIP && ! -e $CELLDIR ]];then mkdir $CELLDIR >/dev/null 2>&1;fi; 
  fi 
  # end -init
fi
fi # not acchk

if [[ $OFFLINE -eq 0 ]]
then
  #what type of check are we doing?
  #echo "DEBUG MSG - CHECK TYPE = "$TYP
  #if [ $userid -eq 0 ]
  #then
  #  echo -e $RED"\nYou can not run using root user.Login as Oracle software owner and run it again"$NORM
  #  echo "\nYou can not run using root user.Login as Oracle software owner and run it again">>$LOGFIL
  #  exit -1
  #fi
  #record localnode name to execute checks without ssh on localnode
  #Below code is to remoe all control-M from both data files
  if [[ -f $REFFIL && `echo $GREP|grep -ci cgrep` -lt 1 ]]
  then
    cat $REFFIL | tr -d '\r' > $INPUTDIR/collections.dat
    if [ -n "$RAT_OUTPUT" ]
    then
      cp -f $INPUTDIR/collections.dat $RAT_OUTPUT
      REFFIL=$RAT_OUTPUT/collections.dat
    else
      cp -f $INPUTDIR/collections.dat $REFFIL
    fi
    rm -f $INPUTDIR/collections.dat
  fi
  if [[ -f $REFFIL1 && `echo $GREP|grep -ci cgrep` -lt 1 ]] 
  then
    cat $REFFIL1|tr -d '\r' > $INPUTDIR/rules.dat
    if [ -n "$RAT_OUTPUT" ]
    then
      cp -f $INPUTDIR/rules.dat $RAT_OUTPUT
      REFFIL1=$RAT_OUTPUT/rules.dat
    else
      cp -f $INPUTDIR/rules.dat $REFFIL1  
    fi 
    rm -f $INPUTDIR/rules.dat
  fi
  #check inventory to see if this is a 10g or 11g database
  #version=v`grep "<COMP NAME=\"oracle.server\" VER=\"1" $ORACLE_HOME/inventory/ContentsXML/comps.xml |awk {'print $3'}`
  #echo $version

  #if [ "$version" = "v" ]
  #then
  #    echo -e $RED"The inventory in the current oracle_home indicates that the"$NORM
  #    echo "The inventory in the current oracle_home indicates that the" >>$LOGFIL
  #    echo -e $RED"database is an earlier version than 10g which is not supported"$NORM
  #    echo "database is an earlier version than 10g which is not supported" >>$LOGFIL
  #    echo -e $RED"by this utility.  please check your environment and try again."$NORM
  #    echo "by this utility.  please check your environment and try again." >>$LOGFIL
  #    exit 1
  #fi

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ $fmw_runmode = "pre" ]]; then 
    if [[ -e $HOSTLIST ]]; then cat $HOSTLIST > $HOSTLIST.1; fi
    if [[ -e $IHOSTLIST ]]; then cat $IHOSTLIST >> $HOSTLIST.1; fi
    if [[ -e $HOSTLIST.1 ]]; then 
      grep -v "$localnode" $HOSTLIST.1|sort|uniq > $HOSTLIST.2
    fi
    echo "$localnode" >$HOSTLIST
    cat $HOSTLIST.2 >> $HOSTLIST
    if [[ -e $HOSTLIST.1 ]]; then rm -f $HOSTLIST.1; fi
    if [[ -e $HOSTLIST.2 ]]; then rm -f $HOSTLIST.2; fi
  fi

  #if [[ -n "$profiles2run" && $profiles2run = "pdit" ]]; then
  #  echo 
  #  echo "Skipping ssh user equivalency settings on all nodes in cluster as $profiles2run profile is in use.";
  #  echo
  if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]; then search_invntr_platform "localonly"; fi
  if [[ -n $RAT_SKIP_SSHSETUP && $RAT_SKIP_SSHSETUP -eq "1" ]]; then
    echo 
    echo "Skipping ssh user equivalency settings on all nodes in cluster as RAT_SKIP_SSHSETUP is set.";
    echo
    if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]; then search_invntr_platform "localonly"; fi
  else
    if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]]; then remove_dup_hostlist; fi 
    ssh_setup_remotenodes
  fi
  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then query_crs_active_version_update_env; fi

  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] && [[ $EM_PROBE_MODE -eq "0" ]]; then 
    if [[ $fmw_runmode = "pre" ]]; then
      for prehname in `cat $HOSTLIST`
      do
        if [ -z "$RAT_JAVA_HOME" ]; then
          create_rtemp_dir "$prehname"
          set_java_home "$prehname"
        fi
      done
    else
      for ihname in `cat $HOSTLIST`
      do
        node_ssh_user=$usern
        if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
          if [[ `echo "$ea_dom0_nodes" | grep -ic "$ihname"` -le 0 ]]; then
            node_ssh_user="${root_user}"
          else
            node_ssh_user="${foxtrot_dom0_user}"
          fi
          if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$rnode "echo \"\$HOME\""); fi
          l_RTEMPDIR=${l_TMPDIR}/.${program_name}
        else
          l_TMPDIR=$TMPDIR
          l_RTEMPDIR=$RTEMPDIR
        fi

	if [[ `grep -ic "$ihname\.JAVA_HOME =" $MASTERFIL` -eq "0" ]]; then 
          create_rtemp_dir "$ihname"
          set_java_home "$ihname"
          cp -rf $RTEMPDIR/discovery/ $OUTPUTDIR

          if [[ -e $IDMPATH/discovery ]]; then rm -rf $IDMPATH/discovery >/dev/null 2>&1; fi
          cp -rf $RTEMPDIR/discovery/ $IDMPATH/
        fi
      done
    fi
  fi

  if [[ $EM_PROBE_MODE -eq 1 ]]
  then
    if [[ $single_instance_run -eq "0" && $is_exalytics_machine -eq 0 && ${#emhostlist[@]} -gt 0 ]] ; then
      print_xml_usern=$usern
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then print_xml_usern='user'; fi
      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <text nls_id="orhc_exadata_n42_nlsid">
      For evaluating audit checks on the remote compute nodes of a cluster, SSH equivalency needs to be set up. Select one of the following options: 
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
          <text nls_id="orhc_exadata_n68_nlsid">Specify {1} password for each remote compute node</text>
	  <tokens>
	    <token index="1">$print_xml_usern</token>
	  </tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n26_nlsid">Skip audit checks evaluation on remote compute nodes</text>
      </option>
    </options>
  </question>
EOF
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
      then
	cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
    <context id="q${PROBE_QUES_CNT}o1q1c">
      <text nls_id="orhc_exadata_n74_nlsid">
	SSH can be configured on all nodes, without prompting for password
      </text>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n75_nlsid">Use the same {1} password on all nodes</text>
    <tokens><token index="1">$usern</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n67_nlsid">Enter {1} password</text>
    <tokens><token index="1">$usern</token></tokens>
    </tokenizedtext>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <context id="q${PROBE_QUES_CNT}o1q1o2q1c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n43_nlsid">
        Set up SSH user({1}) equivalency on following nodes in cluster 
      </text>
      <tokens>
        <token index="1">$usern</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n44_nlsid">
      Enter passwords for the following nodes 
    </text>
    <multipart-question>
EOF
      else
	cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="MULTIPART_QUESTION" outcome="No">
    <context id="q${PROBE_QUES_CNT}o1q1c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n43_nlsid">
        Set up SSH user({1}) equivalency on following nodes in cluster
      </text>
      <tokens>
        <token index="1">$print_xml_usern</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n44_nlsid">
      Enter passwords for the following nodes 
    </text>
    <multipart-question>
EOF
      fi

      host_counter=1
      for hname in ${emhostlist[@]}
      do 
	if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
	then
          cat >> ${PROBE_XML}.tmp <<EOF
      <question id="q${PROBE_QUES_CNT}o1q1o2q1q${host_counter}" questionType="SECRET" outcome="No">
        <text>$hname</text>
      </question>
EOF
	elif [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]
	then
          node_ssh_user=$usern
          if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
          then
            if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
              node_ssh_user="${root_user}"
            else
              node_ssh_user="${foxtrot_dom0_user}"
            fi
          fi
          cat >> ${PROBE_XML}.tmp <<EOF
      <question id="q${PROBE_QUES_CNT}o1q1o2q1q${host_counter}" questionType="SECRET" outcome="No">
        <text>$hname($node_ssh_user)</text>
      </question>
EOF
	else
          cat >> ${PROBE_XML}.tmp <<EOF
      <question id="q${PROBE_QUES_CNT}o1q1q${host_counter}" questionType="SECRET" outcome="No">
        <text>$hname</text>
      </question>
EOF
	fi
        host_counter=$(expr ${host_counter} + 1);
      done

      cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
    fi
  fi
  call_func_check_space 
  fi

  #space checking ends here
  for hname in `cat $HOSTLIST`
  do
    if [ $hname != $localnode ]
    then
      node_ssh_user=$usern
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
      then
        if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
          node_ssh_user="${root_user}"
	else
	  node_ssh_user="${foxtrot_dom0_user}"
        fi
      fi
      check_tmp_status "$hname"
    fi
  done

  RATENV_FIL=$TMPDIR/.${program_name}.env.tmpl
  TMP_RATENV_FIL=$TMPDIR/.env.tmpl

  if [[ -n "$prepare_init" && $prepare_init -eq "1"  ]]
  then 
    prepare_initsetup
  
    if [[ -n "$setup_status" && "$setup_status" -eq "0" ]]
    then
      echo -e ${RED}"\n$usern user equivalence is not setup on $hname"${NORM}
      echo -e ${RED}"\n\n${program_name} is exiting..\n"${NORM}

      remove_preinitsetup
      if [ -e "$INITDMP" ]; then rm -f $INITDMP >/dev/null 2>&1; fi;
    else
      echo -e "\n\nPre installation successfully completed on $localnode"
    fi
    exit 0;
  fi

  if [[ -n "$setup_inittab" && $setup_inittab -gt "0" ]] ; then
    if [ -z "$localnode" ]; then localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`; fi
  
    case `/bin/uname` in
      Linux)
        inittab_string="hock:35:respawn:/etc/init.d/init.$program_name run >/dev/null 2>\&1 </dev/null"
        init_dir=/etc/init.d
      ;;
      SunOS)
        inittab_string="hock:3:respawn:/etc/init.d/init.$program_name run >/dev/null 2>\&1 </dev/null"
        init_dir=/etc/init.d
      ;;
      HP-UX)
        inittab_string="hock:35:respawn:/sbin/init.d/init.$program_name run >/dev/null 2>\&1 </dev/null"
        init_dir=/sbin/init.d
      ;;
      AIX)
        inittab_string="hock:2:respawn:/etc/init.$program_name run >/dev/null 2>\&1 </dev/null"
        init_dir=/etc
      ;;
      *)
        echo -e "\nPlatform not supported.. exiting\n\n";
        exit 1;
      ;;
    esac
  fi

  initexit=0
  if [[ -n "$setup_inittab" && $setup_inittab -eq "10" ]]
  then
    SYSTEMD_USED=0 
    SYSTEMD_USED=`ps -ef |grep systemd|grep -v grep|head -1|awk '{print $2}'|sed 's/ //g'`
    if [[ -n $SYSTEMD_USED && $SYSTEMD_USED -gt 0 ]]; then RESTART_TYPE="systemd"; else RESTART_TYPE="inittab"; fi 

    if [[ ! -z "$RAT_CLUSTERNODES" ]]
    then
      rm -f $HOSTLIST
      orig_localnode=$localnode
      echo $localnode > $HOSTLIST
      for nodename in `echo $RAT_CLUSTERNODES`
      do
       if [[ "$localnode" = "$nodename" ]]; then continue; fi
       echo $nodename>>$HOSTLIST
      done  
    else
      if [[ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" && `uname -p 2>/dev/null` != "sparc" ]];then check_hostname_mismatch;fi
      localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
    fi

    if [[  -e $WRKDIR/cgrep || -d $WRKDIR/cgrep ]] && [[  -z "$RAT_RUNMODE_INTERNAL" ]]; then rm -rf $WRKDIR/cgrep; fi
    if [ ! -r "$init_dir" ] ; then
      unset root_ssh_setup_status
      /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l ${root_user} $localnode ls 2>/dev/null 1>/dev/null
      root_ssh_setup_status=$?
      if [ $root_ssh_setup_status -ne 0 ]
      then
        echo -e "\nAuto restart functionality is not configured. Use -initsetup or -initdebugsetup flag to configure.\n\n";
        initexit=-1
        exit 1;		   	
      else
        $SSHELL ${root_user}@$localnode "if [ ! -e "$init_dir/init.$program_name" ] ; then  echo -e \"Auto restart functionality is not configured. Use -initsetup or -initdebugsetup flag to configure.\"; else /bin/sh $init_dir/init.$program_name shutdown; rm -f $init_dir/init.$program_name;  if [ -e "${TMP_RATENV_FIL}" ]; then rm -f ${TMP_RATENV_FIL} >/dev/null 2>&1;fi; if [ -e "${RATENV_FIL}" ]; then rm -f ${RATENV_FIL} >/dev/null 2>&1;fi; echo \"Removed $program_name from ${RESTART_TYPE}\"; fi;"

        echo -e "\n"
        initexit=1	
      fi
    else
      if [ ! -e "$init_dir/init.$program_name" ] ; then
        echo -e "\nAuto restart functionality is not configured. Use -initsetup or -initdebugsetup flag to configure.\n\n";
        initexit=-1
        exit 1
      fi
      $SSHELL ${root_user}@$localnode "/bin/sh $init_dir/init.$program_name shutdown; rm -f $init_dir/init.$program_name;"
      echo "Removed $program_name from ${RESTART_TYPE}"
      initexit=1	
    fi	    

    remove_preinitsetup
    if [ -e "$INITDMP" ]; then rm -f $INITDMP >/dev/null 2>&1; fi;
    exit 0
  fi

  if [[ -n "$setup_inittab" && $setup_inittab -eq "3" ]]
  then
    if [ ! -r "$init_dir" ] ; then
      unset root_ssh_setup_status
      /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l ${root_user} $localnode ls 2>/dev/null 1>/dev/null
      root_ssh_setup_status=$?
      if [ $root_ssh_setup_status -ne 0 ]
      then
        echo -e "\nAuto restart funtionality is not configured. Use -initsetup or -initdebugsetup flag to configure.\n\n";
        initexit=-1
        exit 1
      else
        checkstatus=0
        checkstatus=`$SSHELL ${root_user}@$localnode "if [ ! -e "$init_dir/init.$program_name" ] ; then echo '1'; fi;"`
        if [[ "$checkstatus" -eq "1" ]] ; then
          echo -e "\nAuto restart functionality is not configured. Use -initsetup or -initdebugsetup flag to configure.\n\n";
          initexit=-1
          exit 1
        fi	
      fi
    else
      if [ ! -e "$init_dir/init.$program_name" ] ; then
        echo -e "\nAuto restart functionality is not configured. Use -initsetup or -initdebugsetup flag to configure.\n\n";
        exit 1
      fi
    fi
  
    echo -e "\nAuto restart functionality is configured.\n\n";
    if [[ $daemon_running -eq "1" ]] ; then
      echo -e "$program_name daemon is running. PID : $dpid\n\n";
    else
      echo -e "$program_name daemon is not running.\n\n";
    fi
    exit 1;
  fi
    
  if [[ -n "$setup_inittab" && $setup_inittab -eq "1" ]] || [[ -n "$setup_inittab" && $setup_inittab -eq "7" ]]; then
    if [[ -f "$RTEMPDIR_D/daemon.pid" ]] 
    then
      echo -e ${RED}"\n${program_name} daemon is already running. Please stop daemon and run $program_name -initsetup or -initdebugsetup again.\n"${NORM}
      echo -e ${RED}"\n${program_name} is exiting..\n"${NORM}

      exit 1
    fi

    prepare_init=1
    prepare_initsetup

    if [[ -n "$setup_status" && "$setup_status" -eq "0" ]]
    then
      echo -e ${RED}"\n$usern user equivalence is not setup on $hname"${NORM}
      echo -e ${RED}"\n\n${program_name} is exiting..\n"${NORM}

      remove_preinitsetup
      if [ -e "$INITDMP" ]; then rm -f $INITDMP >/dev/null 2>&1; fi;
      exit 0
    fi

    SYSTEMD_USED=0 
    SYSTEMD_USED=`ps -ef |grep systemd|grep -v grep|head -1|awk '{print $2}'|sed 's/ //g'`
    if [[ -n $SYSTEMD_USED && $SYSTEMD_USED -gt 0 ]]; then RESTART_TYPE="systemd"; else RESTART_TYPE="inittab"; fi 

    echo -e "\nSetting up $program_name auto restart functionality using ${RESTART_TYPE}\n\n";
    SED_RATENV_FIL=$(echo "$RATENV_FIL"|sed s/\\//\\\\\\//g)
     
    export RAT_SKIP_MERGE_INTERNAL=1
    env|grep "^RAT_"|grep -v "^RAT_UPLOAD_CONNECT_STRING"|sed 's/^/echo /'|sed "s/$/ >>$SED_RATENV_FIL/g" > $TMP_RATENV_FIL 
    env|grep "^RAT_"|grep -v "^RAT_UPLOAD_CONNECT_STRING"|sed 's/^/echo export /'|sed 's/=.*$//g'|sed "s/$/ >>$SED_RATENV_FIL/g" >> $TMP_RATENV_FIL
    echo "echo RAT_UPLOAD_CONNECT_STRING="\"$RAT_UPLOAD_CONNECT_STRING\"">> $RATENV_FIL" >> $TMP_RATENV_FIL
    echo "echo export RAT_UPLOAD_CONNECT_STRING >> $RATENV_FIL" >> $TMP_RATENV_FIL
    
    echo  "RATENV_FIL=$RATENV_FIL" >> $TMP_RATENV_FIL
    echo  "export RATENV_FIL" >> $TMP_RATENV_FIL
    echo  "sed -e 's/^RAT_UPLOAD_CONNECT_STRING=/RAT_UPLOAD_CONNECT_STRING=\"/g' -e 's/^RAT_UPLOAD_CONNECT_STRING.*$/&\"/g' $RATENV_FIL > $RATENV_FIL.new" >> $TMP_RATENV_FIL
    echo  "mv -f $RATENV_FIL.new $RATENV_FIL" >> $TMP_RATENV_FIL
    echo  "" >> $TMP_RATENV_FIL
    
    head -1 $TMP_RATENV_FIL |sed 's/>>/> /g' > ${TMP_RATENV_FIL}.2
    sed 1d $TMP_RATENV_FIL >> ${TMP_RATENV_FIL}.2
    mv -f ${TMP_RATENV_FIL}.2 ${TMP_RATENV_FIL}

    DAEMON_DEBUG=0
    if [[ -n "$setup_inittab" && $setup_inittab -eq "7" ]]; then DAEMON_DEBUG=1; fi

    # create init.orachk
    install_loc=$(dirname $ABSTPATH)
    orachk_flags=$(echo "$argsaved" | sed 's/-initsetup//' | sed 's/-initdebugsetup//' | sed 's/-d *start//g')
    sed 's|ORACHK_HOME=edit|ORACHK_HOME='$install_loc'|' $install_loc/.cgrep/init.tmpl | sed 's/PROGRAM_NAME=edit/PROGRAM_NAME='$program_name'/' | sed 's/USER_NAME=edit/USER_NAME='$usern'/' | sed "s|ORACHK_FLAGS=edit|ORACHK_FLAGS=\"$orachk_flags\"|" | sed "s|INITTAB_STRING=edit|INITTAB_STRING=\"$inittab_string\"|" | sed 's|ORACHK_WRKDIR=edit|ORACHK_WRKDIR='$WRKDIR'|' | sed 's|TMPDIR=edit|TMPDIR='$TMPDIR'|' | sed 's|DAEMON_DEBUG=edit|DAEMON_DEBUG='$DAEMON_DEBUG'|' > $TMPDIR/$$.init.tmpl

    echo "#!/bin/sh" > $TMPDIR/$$.init.tmpl.new
    cat $TMP_RATENV_FIL $TMPDIR/$$.init.tmpl >> $TMPDIR/$$.init.tmpl.new
    mv -f $TMPDIR/$$.init.tmpl.new $TMPDIR/$$.init.tmpl
  
    if [[  -e $WRKDIR/cgrep || -d $WRKDIR/cgrep ]] && [[  -z "$RAT_RUNMODE_INTERNAL" ]]; then rm -rf $WRKDIR/cgrep; fi
    if [[ -n "$setup_inittab" && $setup_inittab -eq "7" ]]; then
      $SSHELL ${root_user}@$localnode "cp -f $TMPDIR/$$.init.tmpl $init_dir/init.$program_name; chmod 544 $init_dir/init.$program_name; /bin/sh $init_dir/init.$program_name start_debug"
    else
      $SSHELL ${root_user}@$localnode "cp -f $TMPDIR/$$.init.tmpl $init_dir/init.$program_name; chmod 544 $init_dir/init.$program_name; /bin/sh $init_dir/init.$program_name start"
    fi
    rm -f $TMPDIR/$$.init.tmpl
    rm -f $TMP_RATENV_FIL
    exit 0;
  fi

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  if [[ ! -z "$phy_nodes" ]]
  then
    phy_nodes_hostname=""
    for mapping in ${hostmap[@]}
    do
      management_host=${mapping%%:*}
      client_host=${mapping#*:}

      if [ `echo "$phy_nodes"| grep -icw "$management_host"` -gt 0 ]
      then
        client_host=$(echo "$client_host"| tr "[A-Z]" "[a-z]" |cut -d. -f1)
        phy_nodes_hostname="${phy_nodes_hostname},${client_host}"
      fi	
    done
    phy_nodes_hostname=$(echo "$phy_nodes_hostname" | sed 's/,,/,/g' | sed 's/^,//g' | sed 's/,$//g');

    sed /phy_nodes/d $EAOUT > $EAOUT.new
    echo "phy_nodes=$phy_nodes_hostname" >> $EAOUT.new
    mv -f $EAOUT.new $EAOUT

    phy_nodes=$phy_nodes_hostname;

    echo "PHYSICAL_NODES = $phy_nodes" >> $MASTERFIL
    printf ". "
  fi
	
  if [[ -n "$is_bda_machine" && $is_bda_machine -eq "1"  ]];
  then
    if [ -z "$RAT_IBSWITCHES" ];
    then
      TMP_SL="$OUTPUTDIR/tmp_slist";
      if [[ -f /opt/oracle/bda/BdaDeploy.json ]];
      then
        SWITCH_CMD="echo SPINE_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select; echo LEAF1_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select; echo LEAF2_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select";
      elif [[ -f /opt/oracle/bda/network.json ]];
      then   
        SWITCH_CMD="echo BDADEPLOY/SPINE/NAME/@bash@ | cat - /opt/oracle/bda/network.json | json-select; echo BDADEPLOY/LEAF1/NAME/@bash@ | cat - /opt/oracle/bda/network.json | json-select; echo BDADEPLOY/LEAF2/NAME/@bash@ | cat - /opt/oracle/bda/network.json | json-select";
      fi
      rm -f $swlist_file;
      touch $swlist_file;
      for hname in `cat $HOSTLIST`
      do
        swlist=""
        if [ $hname = $localnode ];
        then
          eval $SWITCH_CMD >> $TMP_SL
        else
          ($SSHELL $hname $SWITCH_CMD) >> $TMP_SL
        fi
      done
      cat $TMP_SL|sort|uniq > $swlist_file
    fi
  fi

  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]]; then
    for hname in `cat $HOSTLIST`
    do # get actual names
      unset noden
      if [ $hname = $localnode ]
      then
        node=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
      else
        noden=`$SSHELL $hname hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
	isDNSconfigured "$noden" "$usern"
	if [[ $DNSconfigured -eq 0 ]]; then noden=$hname; fi
      fi

      node_pingable $noden
      if [[ $pingable -eq "0" ]] ; then
        noden="$hname"
      else # Change association
	if [[ -z $noden ]]; then noden=$node; fi

        case "$hname" in 
          "$ea_db_node") ea_db_node=$noden;;
          "$ea_ec1_node") ea_ec1_node=$noden;;
          "$ea_ovmm_node") ea_ovmm_node=$noden;;
          "$ea_pc1_node") ea_pc1_node=$noden;;
          "$ea_pc2_node") ea_pc2_node=$noden;;
        esac
      fi
      echo "$noden" >> $HOSTLIST.new
    done
    mv -f $HOSTLIST.new $HOSTLIST
  fi
  fi

  #Following code is check that other instance of tool is not running in cluster
  check_another_instance

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  if [[ -n "$localonly" && $localonly -eq 1 ]];then echo "localonly=$localonly">$LOCKFIL;fi
  echo $$>$LOCKFIL

  echo "PRINT_SCORE_IN_REPORT = $print_score_in_report">>$MASTERFIL
  echo "CURRENT_USER = $usern">>$MASTERFIL
  fi

  create_rtemp_dir # gadiga Creates /tmp/.program in all nodes to store temp files

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
    root_user_allowed=1
    #oumask=$(umask)
    #umask 0000
    #chmod 777 $OUTPUTDIR
    #chmod 777 $INPUTDIR
    #if [ -e $ERRFIL ]; then rm -f $ERRFIL; fi; touch $ERRFIL; chmod 777 $ERRFIL;
  fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" ]] && [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "0" ]] && [[ -n "$is_bda_machine" && $is_bda_machine -eq "0" && $is_exadata_dom0_machine -eq 0 && $is_ssc_globalzone_machine -eq 0 ]] && [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "0" ]] && [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq "0" ]] && [[ -n "$is_opc" && $is_opc -eq "0" ]]
  then #skip space check, stack check for exalogic 
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
    olsnodes_ssh_disabled=0
    if [[ ! -z "$RAT_CLUSTERNODES" && `echo $RAT_CLUSTERNODES|grep -icw "$orig_localnode"` -lt 1 ]]
    then
      olsnodes_ssh_disabled=1
      echo "OLSNODES_SSH_DISABLED = 1" >>$MASTERFIL
      if [ ${crs_up} -eq 1 ];then 
	if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	  printf "."	
	else
 	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then	
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    olsnodes_ssh_disabled_nodes=$(su $dbOwner -c "$CRS/bin/olsnodes");
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    olsnodes_ssh_disabled_nodes=$($CRS/bin/olsnodes);
	  fi
	fi
      fi  
      old_localnode=$(cat $HOSTLIST| head -1)    
    fi
    if [[ $olsnodes_ssh_disabled -eq 1 ]]
    then
      for hname in `cat $HOSTLIST`
      do
        if [ $hname != "$orig_localnode" ];
        then
          echo $hname >> $HOSTLIST.new
        elif [[ -n $profiles2run && ($profiles2run =~ "storage" || $profiles2run =~ "switch") ]];then
          echo $hname >> $HOSTLIST.new
        fi
      done
      rm -rf $HOSTLIST
      mv -f $HOSTLIST.new $HOSTLIST

      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*}
        client_host=${mapping#*:}

        echo "MAP:$management_host = $client_host" >> $MASTERFIL
      done
      localnode=$(cat $HOSTLIST| head -1)
    fi

    if [[ -n $file_checker && $file_checker -eq 1 ]];then
      get_current_epoch "1"
      start_time=$epoch_time

      start_file_checker
      if [[ $file_check_only -eq 1 ]];then
        if [[ -z $cluster_name ]];then
          cluster_name=`uname -n`;
        fi
        collection_date=`date '+%d-%b-%Y %H:%M:%S'`;
        if [[ -z $os_version_print ]];then
          os_version_print=`uname -srm`;
        fi

        get_current_epoch "1"
        end_time=$epoch_time

        let chk_dur=$end_time-$start_time
        let dh=$chk_dur/3600
        let dm=($chk_dur-3600*$dh)/60
        let ds=($chk_dur-3600*$dh)-60*$dm
        dsec=$(echo "$ds" | awk '{printf("%d\n",$1 + 0.5)}')

        if [ $dh -gt 0 ]; then
          checks_duration="$dh Hours, $dm mins, $dsec seconds";
        else
          if [ $dm -gt 0 ]; then
            checks_duration="$dm mins, $dsec seconds";
          else
            checks_duration="$dsec seconds";
          fi
        fi
        top_consumers
        create_raccheck_html
        exit 0
      fi
    fi

    if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
    then
      if [ $single_instance_run -eq "0" ] ; then
        is_crs_installed
        is_asm_installed_crs
        #is_rdbms_installed
        is_rdbms_installed_crs
      fi

      if [[ $single_instance_run -eq "1" ]] ; then
        search_invntr_platform
        is_rdbms_installed_si
        if [[ -n "$oracle_restart" && $oracle_restart -eq "1" ]] ; then
          is_asm_installed
        fi
        is_rdbms_installed_crs
      else
        echo SINGLE_INSTANCE_RUN = 0 >> $MASTERFIL
      fi
    fi #not acchk

    echo "TARGET_VERSION = $targetversion">>$MASTERFIL
    offline_counter=0

    for node in `cat $HOSTLIST`
    do
      crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
      rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
      asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
      stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
      stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
      stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_dbinst_up[$offline_counter]=`grep -i "$node.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
      stack_dbinst_name[$offline_counter]=`grep -i "$node.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
      offline_counter=`expr $offline_counter + 1`  
    done
    offline_counter=0
    fi

    if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
    then
      is_oms_installed=0
      if [[ `grep -wic "$localnode.OMS_INSTALLED = 1" $MASTERFIL` -gt 0 ]]; then 
	is_oms_installed=1
      fi
      if [[ ${crs_installed[$stack_counter]} -eq 0 && ${rdbms_installed[$stack_counter]} -eq 0 && $is_oms_installed -eq "1" ]] && [[ $TYP = "-a" || $TYP = "-p" ]]
      then
        if [[ -n $run_profile && $run_profile -eq "0" ]]; then 
          run_profile=1      
	  internal_profile_set=1
          profiles2run="emoms,em,emagent" 
 	
	  set_profile_run
	fi
      fi

      if [[ ${crs_installed[$stack_counter]} -eq 0 || ${rdbms_installed[$stack_counter]} -eq 0 ]] && [[ $TYP = "-a" || $TYP = "-p" ]]
      then
        if [[ ${crs_installed[$stack_counter]} -eq 0 && $single_instance_run -eq "0" ]] ; then
	  if [[ ! -n "$is_fmw_machine" ]] || [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
            if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then 
	      echo ""
	    else
              echo -e $RED"Since no CRS and RDBMS binaries could be found, the script will check only `uname` best practices. Oracle patch checking will also be skipped. $NORM \n"
	    fi
	  fi
          TYP="-b"
          old_typ=$TYP
        fi
      fi
    fi

    #fi # this if was a kind of problem and because of this, complete offline run was breaking
    #check ORACLE_HOME, ORACLE_SID and ORA_CRS_HOME settings.
    if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
    then
      if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
      if [[ -z "$CRS" && -n "$local_invntr_CH" ]]
      then
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
	  cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n25_nlsid">
        CRS binaries found at {1}
      </text>
      <tokens>
        <token index="1">$local_invntr_CH</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n17_nlsid">
      Do you want to set CRS_HOME to {1}?
    </text>
    <tokens>
      <token index="1">$local_invntr_CH</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n24_nlsid">
      Enter value for ORA_CRS_HOME environment variable
    </text>
  </question>
</group>
EOF
	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

          echo -e "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]"
          setCRSHome="Yes"
        elif [[ $EM_XMLD_MODE -eq 1 ]]
        then
          echo -e "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]"

          read_probe_xml "Do you want to set CRS_HOME to {1}?"
          setCRSHome=$xml_rvalue
        else
          exec 3<&2; exec 2<&0
          $READ -p "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]" setCRSHome
          read_code=`echo $?`;
          exec 2<&3
          process_prompt "$read_code" "setCRSHome" "y"
        fi
        case $setCRSHome in
          y|Y|yes|YES|Yes)
      	    write_in_env "CRS_OPTION" "$local_invntr_CH"
            export CRS=$local_invntr_CH
            ;;
          n|N|No|NO)
            if [[ $EM_XMLD_MODE -eq 1 ]]
            then
              echo -e  "Enter value for ORA_CRS_HOME environment variable:  "

              read_probe_xml "Enter value for ORA_CRS_HOME environment variable"
              cHome=$xml_rvalue
            else
              echo ""
              exec 3<&2; exec 2<&0
              $READ -p "Enter value for ORA_CRS_HOME environment variable:  " cHome
              exec 2<&3
              write_in_env "CRS_OPTION" "$cHome"
            fi
            export CRS=$cHome
            ;;
          *)
            write_in_env "CRS_OPTION" "$local_invntr_CH"
            export CRS=$local_invntr_CH
            ;;
        esac
      fi
      fi

      if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
      if [[ $somedb_up -eq 1 && -z $ORACLE_HOME ]] || [[ ${rdbms_installed[$stack_counter]} -eq 1 &&  -z "$ORACLE_HOME" ]]
      then 
        echo ""
        if [ -n "$RAT_ORACLE_HOME" ] 
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
            cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n81_nlsid">
        RDBMS binaries found at {1} and ORACLE_HOME not set.
      </text>
      <tokens>
        <token index="1">$RAT_ORACLE_HOME</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n20_nlsid">
      Do you want to set ORACLE_HOME to "{1}"?
    </text>
    <tokens>
      <token index="1">$RAT_ORACLE_HOME</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n21_nlsid">
      Enter value for ORACLE_HOME environment variable
    </text>
  </question>
</group>
EOF
	    PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

            echo -e "RDBMS binaries found at $RAT_ORACLE_HOME and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$RAT_ORACLE_HOME"?[y/n][y]"
	    setOHHome="Yes"
          elif [[ $EM_XMLD_MODE -eq 1 ]]
          then
            echo -e "RDBMS binaries found at $RAT_ORACLE_HOME and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$RAT_ORACLE_HOME"?[y/n][y]"

	    read_probe_xml "Do you want to set ORACLE_HOME to"
	    setOHHome=$xml_rvalue
	  else
	    if [[ $daemon_init_mode -eq 1 || $daemon_init_mode_sudo -eq "1" ]] ; then
	      setOHHome="Y"
	    else
              exec 3<&2; exec 2<&0
              $READ -p "RDBMS binaries found at $RAT_ORACLE_HOME and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$RAT_ORACLE_HOME"?[y/n][y]" setOHHome
	      read_code=`echo $?`;
              exec 2<&3
	    fi
	    process_prompt "$read_code" "setOHHome" "y"
	  fi
        else
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
            cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n45_nlsid">
        RDBMS binaries found at {1} and ORACLE_HOME not set
      </text>
      <tokens>
        <token index="1">$local_invntr_OH</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n20_nlsid">
      Do you want to set ORACLE_HOME to "{1}"?
    </text>
    <tokens>
      <token index="1">$local_invntr_OH</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n21_nlsid">
      Enter value for ORACLE_HOME environment variable
    </text>
  </question>
</group>
EOF
 	    PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

            echo -e "RDBMS binaries found at $local_invntr_OH and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$local_invntr_OH"?[y/n][y]"
	    setOHHome="Yes"
          elif [[ $EM_XMLD_MODE -eq 1 ]]
          then
            echo -e "RDBMS binaries found at $local_invntr_OH and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$local_invntr_OH"?[y/n][y]"

	    read_probe_xml "Do you want to set ORACLE_HOME to"
	    setOHHome=$xml_rvalue
	  else
            exec 3<&2; exec 2<&0
            $READ -p "RDBMS binaries found at $local_invntr_OH and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$local_invntr_OH"?[y/n][y]" setOHHome
	    read_code=`echo $?`;
            exec 2<&3
	    process_prompt "$read_code" "setOHHome" "y"
	  fi
        fi

        case $setOHHome in
          y|Y|yes|YES|Yes) 
            if [ -n "$RAT_ORACLE_HOME" ]; then export ORACLE_HOME=$RAT_ORACLE_HOME; else export ORACLE_HOME=$local_invntr_OH;fi;
            write_in_env "ORACLE_HOME_OPTION" "$ORACLE_HOME"
            ;;
          n|N|No|NO)
            if [[ $EM_XMLD_MODE -eq 1 ]]
            then
              echo -e "Enter value for ORACLE_HOME environment variable:  "

              read_probe_xml "Enter value for ORACLE_HOME environment variable"
              oHome=$xml_rvalue
            else
              echo ""
              exec 3<&2; exec 2<&0
              $READ -p "Enter value for ORACLE_HOME environment variable:  " oHome
              exec 2<&3
              write_in_env "ORACLE_HOME_OPTION" "$oHome"
            fi
            export ORACLE_HOME=$oHome
            ;;
          *)
            if [ -n "$RAT_ORACLE_HOME" ]; then export ORACLE_HOME=$RAT_ORACLE_HOME; else export ORACLE_HOME=$local_invntr_OH;fi;
            write_in_env "ORACLE_HOME_OPTION" "$ORACLE_HOME"
            ;;
        esac          
      fi
      fi
      #$READ -p "DBVERSION=$DBVERSION"
      #$READ -p "Check the files now"
      #is_db_up 

      if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
      #following 19 lines of code were mode from up to here to accomdate DBVERSION variable
      RDBMS_INVENTORY=$ORACLE_HOME/inventory/ContentsXML/comps.xml
      CRS_INVENTORY=$CRS/inventory/ContentsXML/comps.xml
      echo "RDBMS_INVENTORY = $ORACLE_HOME/inventory/ContentsXML/comps.xml" >>$MASTERFIL

      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
        echo "CRS_INVENTORY = $CRS/inventory/ContentsXML/comps.xml" >>$MASTERFIL
      fi

      g112=`echo  $DBVERSION | grep -c 11.2`
      #$READ -p "g112=$g112 and DBVERSION=$DBVERSION"
      #remove this after this run
      #g112=1 
      #$READ -p "g112=$g112 and DBVERION=$DBVERSION"
      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
  	ASM_HOME=`grep ASM_HOME $MASTERFIL |awk '{print $3}'`
	ASM_INVENTORY=`grep ASM_INVENTORY $MASTERFIL | awk '{print $3}'`
      else
        if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]] 
        then
          if [[ -n "$crs112" && $crs112 -ge 1 ]]
          then
            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              OLD_OH=$ORACLE_HOME
              ORACLE_HOME=$CRS
              get_dbOwner
              ORACLE_HOME=$OLD_OH
              ASM_HOME=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm |head -1|cut -d: -f2"`
    	      write_del_rolbk_tmpoutput
              cd $OLD_DIR
              unset OLD_DIR
            else
              ASM_HOME=`$CRS/bin/srvctl$BAT config asm |head -1|cut -d: -f2`
            fi
            #To trim the blank spaces before path
            ASM_HOME=`echo $ASM_HOME | sed 's/^ *\(.*\) *$/\1/'`
            ASM_HOME="" 
            unset ASM_HOME
          else
            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              OLD_OH=$ORACLE_HOME
              ORACLE_HOME=$CRS
              get_dbOwner
              ORACLE_HOME=$OLD_OH
              ASM_HOME=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config asm | grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g'")
    	      write_del_rolbk_tmpoutput
              cd $OLD_DIR
              unset OLD_DIR
            else
              ASM_HOME=$($CRS/bin/srvctl$BAT config asm | grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g')
            fi
            ASM_INVENTORY=$ASM_HOME/inventory/ContentsXML/comps.xml
            echo "ASM_INVENTORY = $ASM_HOME/inventory/ContentsXML/comps.xml" >>$MASTERFIL
          fi
          echo "ASM_HOME=$ASM_HOME">>$LOGFIL 
        fi
      fi
      fi

      if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
      #if [[ $somedb_up -eq 1 && -z "$ORACLE_SID"  && ${rdbms_installed[$stack_counter]} -eq 1 && -z "$RAT_DBNAME" ]]
      if [[ ${rdbms_installed[$stack_counter]} -eq 1 && -z "$RAT_DBNAMES"   ]]
      then
        if [[ $db_counter -le 1 && -n "$db_name_to_check"  && $NOQUESTION -eq 0 && `cat $running_db_list|wc -l` -gt 1 ]] 
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
            cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n46_nlsid">
        $program_name found database {1} registered in OCR. 
      </text>
      <tokens>
        <token index="1">$db_name_to_check</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n47_nlsid">
      Is this the database to check best practices for?
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	    PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

            echo -e "$program_name found database $db_name_to_check registered in OCR. Is this the database to check best practices for?[y/n][y]"
	    ask_db_name_to_check="Yes"
          elif [[ $EM_XMLD_MODE -eq 1 ]]
          then
            echo -e "$program_name found database $db_name_to_check registered in OCR. Is this the database to check best practices for?[y/n][y]"

	    read_probe_xml "Is this the database to check best practices for?"
	    ask_db_name_to_check=$xml_rvalue
	  else
            echo ""
            exec 3<&2; exec 2<&0
            $READ -p "$program_name found database $db_name_to_check registered in OCR. Is this the database to check best practices for?[y/n][y]" ask_db_name_to_check
	    read_code=`echo $?`;
            exec 2<&3
	    process_prompt "$read_code" "ask_db_name_to_check" "y"
	  fi
          #ports_find_sid
          case $ask_db_name_to_check in
            y|Y|yes|YES|Yes)
              #ports_find_sid
	      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	       oSID=$(grep -i "$localnode\.$db_name_to_check\.INSTANCE_NAME" $MASTERFIL | awk '{print $3}');
	      else
                if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                  OLD_OH=$ORACLE_HOME
                  ORACLE_HOME=$CRS
                  get_dbOwner
                  ORACLE_HOME=$OLD_OH
	          oSID=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_name_to_check|grep $localnode|awk '{print \$2}'")
    	          write_del_rolbk_tmpoutput
                  cd $OLD_DIR
                  unset OLD_DIR
	        else
                  oSID=$($CRS/bin/srvctl$BAT status database -d $db_name_to_check|grep $localnode|awk '{print $2}')
	        fi
	      fi
     	      write_in_env "DB_BP_CHECK_OPTION" "$db_name_to_check"
              export ORACLE_SID=$oSID
              ;;
            n|N|No|NO)
              echo ""
              echo -e "${program_name} could not determine database to check best practices from OCR. So set environment variable RAT_DBNAMES to name of the database to analyse and re-run."
              exit 1;
              ;;
            *)
	      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	        oSID=$(grep -i "$localnode\.$db_name_to_check\.INSTANCE_NAME" $MASTERFIL | awk '{print $3}');
	      else
                if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                  OLD_OH=$ORACLE_HOME
                  ORACLE_HOME=$CRS
                  get_dbOwner
                  ORACLE_HOME=$OLD_OH
	          oSID=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_name_to_check|grep $localnode|awk '{print \$2}'")
    	          write_del_rolbk_tmpoutput
                  cd $OLD_DIR
                  unset OLD_DIR
	        else
                  oSID=$($CRS/bin/srvctl$BAT status database -d $db_name_to_check|grep $localnode|awk '{print $2}')
	        fi
	      fi
     	      write_in_env "DB_BP_CHECK_OPTION" "$db_name_to_check"
              export ORACLE_SID=$oSID
              #ports_find_sid
              #export ORACLE_SID=$oSID
              ;;
          esac
        else
          echo "Database pickedup for checking = $db_name_to_check">>$LOGFIL
	  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
	    oSID=$(grep -i "$localnode\.$db_name_to_check\.INSTANCE_NAME" $MASTERFIL | awk '{print $3}');
	    if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
	      if [[ -z $oSID ]]; then
	        unset mapped_host
                for mapping in ${hostmap[@]}
                do
                  management_host=${mapping%%:*}
                  client_host=${mapping#*:}
  
	          short_hostname=`echo "$localnode"| tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
                  if [[ `echo "$management_host" | grep -ic "$localnode"` -ge 1 ]] || [[ `echo "$management_host" | grep -ic "$short_hostname"` -ge 1 ]]; then
                    mapped_host=$client_host;
                  fi
                done
	      fi
	      oSID=$(grep -i "$mapped_host.$db_name_to_check.INSTANCE_NAME =" $MASTERFIL|awk '{print $3}')
	      if [[ -z $oSID ]]; then
	        short_mapped_host=`echo "$mapped_host"| tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
	        oSID=$(grep -i "$short_mapped_host.$db_name_to_check.INSTANCE_NAME =" $MASTERFIL|awk '{print $3}')
	      fi
	    fi
	  else
            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
              OLD_OH=$ORACLE_HOME
              ORACLE_HOME=$CRS
              get_dbOwner
              ORACLE_HOME=$OLD_OH
              oSID=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null|grep $localnode|awk '{print \$2}'")
    	      write_del_rolbk_tmpoutput
              cd $OLD_DIR
              unset OLD_DIR
	    else
              oSID=$($CRS/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null|grep $localnode|awk '{print $2}')
	    fi
	  fi
          export ORACLE_SID=$oSID
          #ports_find_sid
        fi
      else
        #db_name_to_check=$RAT_DBNAME
        #ports_find_sid
        #ORACLE_SID=$oSID
        #if [ -n "$CRS" ]; then oSID=$($CRS/bin/srvctl status database -d $db_name_to_check|grep $localnode|awk '{print $2}');fi;
        #export ORACLE_SID=$oSID
        #multiple_db=0
        echo "Database pickedup for checking = $db_name_to_check ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID">>$LOGFIL
      fi
      echo "IS_WINDOWS = $is_windows" >>$MASTERFIL

      #$READ -p "ORACLE_HOME=$ORACLports_find_sidE_HOME and ORACLE_SID=$ORACLE_SID db_name_to_check=$db_name_to_check"
      #ports_find_sid
      #is_db_up
      #if [ $db_up -eq 1 ];  then checksysdba; fi

      if [[ `grep -ic "CRS_HOME =" $MASTERFIL` -eq "0" ]]; then echo "CRS_HOME = $CRS" >>$MASTERFIL; fi

      func_stack_status
      fi

      if [[ -n "$crs112" && $crs112 -gt 0 ]] || [[ -n "$crs121" && $crs121 -gt 0 ]] || [[ -n "$crs122" && $crs122 -gt 0 ]]; then gi112=1;else gi112=0;fi
      
      if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then gi112=0; fi

      if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
      then
        func_stack_print_aix
      else
        func_stack_print
      fi

      if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
      if [[ $set_db_par_limit -eq 1 && -z $RAT_DB_PAR_LIMIT && $OFFLINE -eq 0 ]]
      then
        export RAT_DB_PAR_LIMIT=${#mb_db_names[@]}
      fi
      calculate_no_of_child_proc

      if [[ $OFFLINE -eq 0 && $upgrade_mode -gt 0 ]]; then func_print_homes; fi

      if [ $op_mode -eq 1 ] 
      then 
        if [ -z "$RAT_DB" ]
        then
          func_what_db
          if [[ -z  "$what_db" || -z "$DBVERSION" ]] 
          then 
            if [[ $EM_PROBE_MODE -eq 1 ]]
            then
              EMSG="${program_name} could not find database version from enviornment so set RAT_DB environment varaiable to database version like 11.2.0.1.0 and re-run it."
              update_probe_xml "ERROR" "GENERIC" "$EMSG"
            fi
            echo -e "$RED ${program_name} could not find database version from enviornment so set RAT_DB environment varaiable to database version like 11.2.0.1.0 and re-run it.$NORM"
            exit 1
          fi
        else
          DBVERSION=$RAT_DB
          what_db=$(echo $RAT_DB|sed 's/\.//g')
        fi
        func_create_small_files
      fi 

      #if [ "$usern" != "root" ]; then write_asm_version_master;else echo "Not calling write_asm_version_master for root user">>$LOGFIL;fi
      write_asm_version_master
    fi #not acchk

    fi
    if [[ -n "$run_acchk" && $run_acchk -eq "1" ]]
    then
      func_create_small_files
    fi

    copy_utl_script_to_tmp
    
    #generate an environment file and copy file to all hosts in cluster
    echo "#!$bash_scr">>$ORCLENVFIL
    #echo "$bash_source">>$ORCLENVFIL
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      cat >> $ORCLENVFIL << EOF
PROFILE="\$HOME/.profile"
case `/bin/uname` in
  Linux)  PROFILE="\$HOME/.bash_profile"  ;;
  CYGWIN_NT-[0-9].[0-9]) PROFILE="\$HOME/.bash_profile" ;;
esac
if [ -e "\$PROFILE" ]; then . \$PROFILE>/dev/null 2>&1;fi
EOF
    else
      echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$ORCLENVFIL
    fi
    echo "export ORACLE_HOME=$ORACLE_HOME">>$ORCLENVFIL
    echo "export ORACLE_SID=$ORACLE_SID">>$ORCLENVFIL
    echo "export CRS_HOME=$CRS">>$ORCLENVFIL
    echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL 
    get_winpath "TMPDIR"
    get_winpath "RTEMPDIR"
    #echo "export TMPDIR=$TMPDIR">>$ORCLENVFIL 
    echo "export TMPDIR=$RTEMPDIR">>$ORCLENVFIL
    echo "export RTEMPDIR=$RTEMPDIR">>$ORCLENVFIL 
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then echo "export TMP_OUTPUT=$TMP_OUTPUT">>$ORCLENVFIL; fi
    echo "set +u">>$ORCLENVFIL
    restore_winpath "TMPDIR"
    restore_winpath "RTEMPDIR"
     
    #echo "export ORA_CRS_HOME=$CRS">>$ORCLENVFIL
    if [ -n "$TNS_ADMIN" ]; then echo "export TNS_ADMIN=$TNS_ADMIN">>$ORCLENVFIL;fi;
    echo "if [[ \"\${LD_LIBRARY_PATH:-unset}\"  = \"unset\" ]] ; then LD_LIBRARY_PATH=\"\"; fi">>$ORCLENVFIL
    echo "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:$ORACLE_HOME/lib" >>$ORCLENVFIL
    echo "export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:$ORACLE_HOME/lib:$CRS/lib">>$ORCLENVFIL
  elif [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]]
  then
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
    is_this_db_machine $localnode
    check_maa_scorecard
    check_hacheck
    func_init_arrays
    add_maa_scorecard
    add_hacheck
    func_create_small_files
    copy_utl_script_to_tmp
    fi
    echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL
    #echo "export TMPDIR=$TMPDIR">>$ORCLENVFIL
    echo "export TMPDIR=$RTEMPDIR">>$ORCLENVFIL
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then echo "export TMP_OUTPUT=$TMP_OUTPUT">>$ORCLENVFIL; fi  
  else
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
    func_init_arrays
    func_create_small_files
    copy_utl_script_to_tmp 
    fi
    echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL 
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then echo "export TMP_OUTPUT=$TMP_OUTPUT">>$ORCLENVFIL; fi
    #echo "export TMPDIR=$TMPDIR">>$ORCLENVFIL 
    cat >> $ORCLENVFIL << EOF
node_ssh_user=$usern
if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
  hname=\$(hostname) 
  if [[ `echo "$ea_dom0_nodes" | grep -ic "\$hname"` -le 0 ]]; then
    node_ssh_user="${root_user}"
  else
    node_ssh_user="${foxtrot_dom0_user}"
  fi
  if [[ -n \"$RAT_TMPDIR\" ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=\$($SSHELL \${node_ssh_user}@\$hname "echo \"\$HOME\""); fi
  l_RTEMPDIR=\${l_TMPDIR}/.${program_name}
else
  l_TMPDIR=$TMPDIR
  l_RTEMPDIR=$RTEMPDIR
fi
export TMPDIR=\$l_RTEMPDIR
export RTEMPDIR=\$l_RTEMPDIR
EOF
  fi #is_exalogic_machine

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  if [[ $is_exalytics_machine -eq 1 || $is_exalogic_machine -eq 1 || $db_machine_compute -eq 1 || $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 || $is_bda_machine -eq 1 || $is_exalogic_foxtrot -eq 1 || $is_ssc_localzone_machine -eq 1 || $is_ssc_globalzone_dbmachine -eq 1 || $is_ssc_globalzone_dbmachine -eq 1 || $is_opc -eq 1 || $is_minicluster -eq 1 ]] 
  then
    is_engineered_system=1
  else
    if [[ -z $is_engineered_system ]]; then is_engineered_system=0; fi
  fi
  echo "IS_ENGINEERED_SYSTEM = $is_engineered_system" >>$MASTERFIL
  #code to run orachk on generic system and exachk on Engineered systems. otherwise exit
  if [[ -n $EM_PROBE_MODE && $EM_PROBE_MODE -eq 1 || -n $EM_XMLD_MODE && $EM_XMLD_MODE -eq 1 ]]; then
    export RAT_TOOLNAME_VALIDATION_INTERNAL=1
  fi

  if [[ -z "$RAT_TOOLNAME_VALIDATION_INTERNAL" ]]
  then
    if [[ -n "$is_engineered_system" && $is_engineered_system -eq 1 &&  $program_name != "exachk" ]]
    then
      echo -e $RED"${program_name} is not supported on Oracle Engineered systems.Please run exachk.\n\n${program_name} is exiting...\n\n"$NORM
      sleep 1
      exit 1
    elif [[ -n "$is_engineered_system" && $is_engineered_system -eq 0 &&  $program_name = "exachk" ]]         
    then
      echo -e "\n${RED}${program_name} is supported only on Oracle Engineered systems.Please run orachk.\n\n${program_name} is exiting...\n\n"$NORM
      sleep 1
      exit 1
    fi
  fi
  fi

  #Code to discover Oracle Golden Gate Homes and Versions
  OGGHOMESVERSIONFIL=$OUTPUTDIR/ogg_homes_version.out
  DISCOVEROGGHOMES=$RTEMPDIR/ggdiscovery.sh

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  if [ -e $SCRIPTPATH/.cgrep/ggdiscovery.sh ]; then cp -rf $SCRIPTPATH/.cgrep/ggdiscovery.sh $RTEMPDIR >/dev/null 2>&1;chmod 755 $RTEMPDIR/ggdiscovery.sh >/dev/null 2>&1;fi
  if [ "$bash_scr" != "/bin/env bash" ] ; then
    chmod +w $RTEMPDIR/ggdiscovery.sh
    cp -f $RTEMPDIR/ggdiscovery.sh $RTEMPDIR/ggdiscovery.sh.org
    sed 's%/bin/env bash%'$bash_scr'%' $RTEMPDIR/ggdiscovery.sh.org > $RTEMPDIR/ggdiscovery.sh
    rm -f $RTEMPDIR/ggdiscovery.sh.org
  fi
  echo "if [[ \"\${LD_LIBRARY_PATH:-unset}\"  = \"unset\" ]] ; then LD_LIBRARY_PATH=\"\"; fi">>$DISCOVEROGGHOMES
  echo "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:$ORACLE_HOME/lib" >>$DISCOVEROGGHOMES
  echo "export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:$ORACLE_HOME/lib:$CRS/lib">>$DISCOVEROGGHOMES
  if [ -n "$RAT_OGG_HOMES" ]; then echo "export RAT_OGG_HOMES=\"$RAT_OGG_HOMES\"" >>$DISCOVEROGGHOMES;fi
  echo "findogghome4">>$DISCOVEROGGHOMES

  for ogg_hosts in `cat $HOSTLIST`
  do
    if [ "$ogg_hosts" = "$localnode"  ]
    then
      security_fix "fix_plugin_or_rtscript_attributes" "$RTEMPDIR/ggdiscovery.sh" "" "540"

      $bash_scr -c " $DISCOVEROGGHOMES >$OUTPUTDIR/ogg_homes_version_$ogg_hosts.out"
      if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then grep -w RAT_OGG_HOMES $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out >>$OGGHOMESVERSIONFIL;fi
      if [ `grep -wic prompt $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out` -ge 1 ]
      then
        echo -e "${program_name} did not find GoldenGate homes for all running manager processes on $ogg_hosts"

        if [[ $EM_PROBE_MODE -eq 1 ]]
	then
          cat >> ${PROBE_XML}.tmp << EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" defaultId="" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n48_nlsid">
        ${program_name} did not find GoldenGate homes for all running manager processes on {1}
      </text>
      <tokens>
        <token index="1">$ogg_hosts</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n49_nlsid">
      Enter GoldenGate Homes installed on {1} separated by comma (for example: /u01/ogg_home1, /u01/ogg_home2, and so on)
    </text>
    <tokens>
      <token index="1">$ogg_hosts</token>
    </tokens>
    </tokenizedtext>
  </question>
</group>
EOF
          echo -e "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc"

 	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
        elif [[ $EM_XMLD_MODE -eq 1 ]]
        then
          echo -e "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc"

	  read_probe_xml "${program_name} did not find GoldenGate homes for all running manager processes on {1}"
	  RAT_OGG_HOMES=$xml_rvalue
	else
          exec 3<&2; exec 2<&0
          $READ -p "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc" RAT_OGG_HOMES
          exec 2<&3
	fi
        echo "export RAT_OGG_HOMES=$RAT_OGG_HOMES" >>$DISCOVEROGGHOMES
        $bash_scr -c "$DISCOVEROGGHOMES >$OUTPUTDIR/ogg_homes_version_$ogg_hosts.out"
        if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then grep -w RAT_OGG_HOMES $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out >>$OGGHOMESVERSIONFIL;fi
      fi
    else
      node_ssh_user=$usern
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        if [[ `echo "$ea_dom0_nodes" | grep -ic "$ogg_hosts"` -le 0 ]]; then
          node_ssh_user="${root_user}"
        else
          node_ssh_user="${foxtrot_dom0_user}"
        fi
        if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$ogg_hosts "echo \"\$HOME\""); fi
        l_RTEMPDIR=${l_TMPDIR}/.${program_name}
      else
        l_TMPDIR=$TMPDIR
        l_RTEMPDIR=$RTEMPDIR
      fi

      $SCOPY $DISCOVEROGGHOMES $node_ssh_user@$ogg_hosts:$l_RTEMPDIR >/dev/null 2>&1
      $SSHELL $node_ssh_user@$ogg_hosts "$bash_scr -c \"chmod 544 $l_RTEMPDIR/ggdiscovery.sh >/dev/null 2>&1\""
      $SSHELL $node_ssh_user@$ogg_hosts "$bash_scr -c \"$l_RTEMPDIR/ggdiscovery.sh >$l_RTEMPDIR/ogg_homes_version_$ogg_hosts.out\""
      $SCOPY $node_ssh_user@$ogg_hosts:$l_RTEMPDIR/ogg_homes_version_$ogg_hosts.out $OUTPUTDIR >/dev/null 2>&1
      if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then grep -w RAT_OGG_HOMES $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out >>$OGGHOMESVERSIONFIL;fi
      if [[ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out && `grep -wic prompt $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out` -ge 1 ]]
      then
        echo -e "${program_name} did not find GoldenGate homes for all running manager processes on $ogg_hosts"

        if [[ $EM_PROBE_MODE -eq 1 ]]
	then
          cat >> ${PROBE_XML}.tmp << EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT"  defaultId="" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n48_nlsid">
        ${program_name} did not find GoldenGate homes for all running manager processes on {1}
      </text>
      <tokens>
        <token index="1">$ogg_hosts</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n49_nlsid">
      Enter GoldenGate Homes installed on {1} separated by comma (for example: /u01/ogg_home1, /u01/ogg_home2, and so on)
    </text>
    <tokens>
      <token index="1">$ogg_hosts</token>
    </tokens>
    </tokenizedtext>
  </question>
</group>
EOF
          echo -e "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc"

 	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
        elif [[ $EM_XMLD_MODE -eq 1 ]]
        then
          echo -e "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc"

	  read_probe_xml "${program_name} did not find GoldenGate homes for all running manager processes on {1}"
	  RAT_OGG_HOMES=$xml_rvalue
	else
          exec 3<&2; exec 2<&0
          $READ -p "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc" RAT_OGG_HOMES
          exec 2<&3
	fi
        echo "export RAT_OGG_HOMES=$RAT_OGG_HOMES" >>$DISCOVEROGGHOMES
        $SCOPY $DISCOVEROGGHOMES $node_ssh_user@$ogg_hosts:$l_RTEMPDIR >/dev/null 2>&1
        $SSHELL $node_ssh_user@$ogg_hosts "chmod 544 $l_RTEMPDIR/ggdiscovery.sh >/dev/null 2>&1"
        $SSHELL $node_ssh_user@$ogg_hosts "$bash_scr -c \"$l_RTEMPDIR/ggdiscovery.sh >$l_RTEMPDIR/ogg_homes_version_$ogg_hosts.out\""
        $SCOPY $node_ssh_user@$ogg_hosts:$l_RTEMPDIR/ogg_homes_version_$ogg_hosts.out $OUTPUTDIR >/dev/null 2>&1
      fi
    fi
  done
  fi
  #Code to discover Oracle Golden Gate Homes and Versions ends here

  if [[ $OFFLINE -eq 0 && `echo $components|grep -icw dbm` -ge 1 && $db_machine_compute -eq 0 && $is_exalogic_machine -eq 0 && $is_exalogic_foxtrot -eq 0 ]] && [ $components != "RDBMS" ]
  then
    echo -e "\nDBM module not applicable on this cluster. ${program_name} will run without any module specific\n"|tee -a $LOGFIL
    components=NONE
    it_is_rac=1  
    if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then 
      exec 3<&2; exec 2<&0; 
      $READ -p "Press any key to continue ..."; 
      exec 2<&3; 
    fi
  elif [[ $OFFLINE -eq 0 && `echo $components|grep -icw dbm` -ge 1 && `echo $components|grep -ic rdbms` -lt 1 && $db_machine_compute -eq 1 ]]
  then
    components=EXADATA
  fi
  if [[ $OFFLINE -eq 0 && `echo $components|grep -ic ovm` -ge 1 && $VMTYPE != "PVM" ]]
  then
    echo -e "\nOVM module not applicable on this cluster. ${program_name} will run without any module specific\n"|tee -a $LOGFIL
    components=NONE
    it_is_rac=1  
    if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then 
      exec 3<&2; exec 2<&0; 
      $READ -p "Press any key to continue ..."; 
      exec 2<&3; 
    fi
  elif [[ $OFFLINE -eq 0 && `echo $components|grep -ic ovm` -ge 1 && $VMTYPE = "PVM" ]]
  then
    TYP="-b"
  fi

  #Find out that will any command in this audit check will require root or not.
  if [ $op_mode -eq 1 ]
  then  
    #REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
    REQUIRE_ROOT=`grep  "REQUIRES_ROOT_COUNT" $REFFIL|sed  -n 's/.*REQUIRES_ROOT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
    if [[ -z $REQUIRE_ROOT && $run_check -eq 1 ]]
    then
      REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
    fi
  else
    REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
  fi

  exa_machine=0
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq 1 ]]; then exa_machine=1; fi
  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] ; then exa_machine=1; fi

  bda_machine=0
  if [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] ; then bda_machine=1; fi

  root_all_prompt=0
  #echo "******** $db_machine_compute  $is_exalogic_machine  Looking for cells in $CELLIP"
  #cat  $CELLIP
  #echo "==================="

  ask_cell_password=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_cell_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_cell_checks -eq "0" ]] || [[ -n "$dbm_vm" && "$dbm_vm"  -eq 1 ]] || [[ -n "$is_ssc_localzone_machine" && "$is_ssc_localzone_machine"  -eq 1 ]] ; then
    ask_cell_password=0
  fi
  if [[ -n "$debug_in_profile" && $debug_in_profile -gt 0 ]]; then ask_cell_password=1;fi 
  if [[ $db_machine_compute -eq 1  || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1  || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]] && [ $TYP != "-p" ] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ "$upgrade_mode" -ne "3" ] && [ $only_hacheck_run -eq 0 ] && [ $ask_cell_password -eq "1" ] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] && [ -e "$CELLIP" ]
  then
    #unlock the cells
    if [[ -z $RAT_EXACLI_ENABLED ]] || [[ -n $RAT_EXACLI_ENABLED && $RAT_EXACLI_ENABLED -eq "1" ]]; then
      unlock_storage_cells  
    fi 

    if [[ -s $CELLIP ]];then 
      echo 
    else
      cell_password_status=3;
    fi     
     

    # First check if root password is same on all components. only for exa
    # The root password is stored in global_root_password
    root_all_prompt=0
    set_root_all_prompt
    set_root_all_prompt_called=1
    cell_type="normal"
    if [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
    then
      cell_type="zfscell"
    fi
    cell_root_command=$(grep -icw "NEEDS_RUNNING STORAGE_CELL" $REFFIL)
    if [[ "$RAT_CELL_SSH_USER" = "root" ]] ; then unset RAT_CELL_SSH_USER; fi
    if [ -z "$RAT_CELL_SSH_USER" ];then cell_ssh_user="root"; else cell_ssh_user=$RAT_CELL_SSH_USER;fi
    first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)

    for cell_ip in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
    do
      #cellPingStatus=$($PING -c 1 $PING_W_FLAG $cell_ip >/dev/null 2>&1;echo $?)
      test_node_reachability $cell_ip $cell_ssh_user;
      if [ $el_node_ping -eq "1" ] ; then
        cellPingStatus=0;
      else
        cellPingStatus=1;
      fi

      if [ $cellPingStatus -eq 0 ]
      then 
        cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cell_ip ls >/dev/null 2>&1;echo $?);
        cell_password_status=0
        cellname_full=$(grep -w "$cell_ip" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)
        storage_cells=$(cells1=`cat $CELLIP|cut -d\" -f2|cut -d\; -f2`;echo $cells1|sed 's/ /,/g');

        if [[ $daemon_init_mode -eq 1 && -n "$cell_ssh_status" && $cell_ssh_status -ne 0 ]]
        then
          echo -e "\n${cell_ssh_user} user equivalence is not setup between $localnode and ${BLINK}STORAGE SERVER${NORM} ${cellname_full}."
          log_daemon "\n${cell_ssh_user} user equivalence is not setup between $localnode and ${BLINK}STORAGE SERVER${NORM} ${cellname_full}."
          echo -e "\n\n${program_name} is exiting.."   
          log_daemon "\n\n${program_name} is exiting.."   
          exit 1
        fi   

	if [[ -n "$cell_ssh_status" && $cell_ssh_status -eq 0 ]]
	then
	  echo -e "\n$GREEN $cellname_full is configured for ssh user equivalency for $cell_ssh_user user $NORM\n";
	fi

        if [[ -n "$cell_ssh_status" && $cell_ssh_status -ne 0 ]]
        then
          if [ $root_all_prompt -eq "1" ] ; then
            echo "Validating ${cell_ssh_user} password on STORAGE SERVER"
            echo 
            cellssh_YesNo=1
          else
            echo -e "\n${cell_ssh_user} user equivalence is not setup between $localnode and ${BLINK}STORAGE SERVER${NORM} ${cellname_full} ($cell_ip)." 
            echo -e "\n1. Enter 1 if you will enter ${cell_ssh_user} password for each ${BLINK}STORAGE SERVER${NORM} when prompted."
            echo -e "\n2. Enter 2 to exit and configure $cell_ssh_user user equivalence manually and re-run ${program_name}."
            echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}STORAGE SERVER${NORM}.\n"

	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
              cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_CC}" groupHeader="${GID_CC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <text nls_id="orhc_exadata_n50_nlsid">For evaluating best practices on the storage cells of a cluster, root level privileges are required on the cells. Select one of the following options:</text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n51_nlsid">Specify {1} password for each storage cell</text>
	  <tokens><token index="1">$cell_ssh_user</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" isTerminal="Y">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n53_nlsid">Exit and configure root user equivalence manually and retry</text>
	<tokens><token index="1">$cell_ssh_user</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o3">
        <text nls_id="orhc_exadata_n52_nlsid">Skip checking best practices on storage cells</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n54_nlsid">Use the same {1} password on all storage cells</text>
    <tokens><token index="1">$cell_ssh_user</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n82_nlsid">Enter {1} password</text>
    <tokens><token index="1">$cell_ssh_user</token></tokens>
    </tokenizedtext>
  </question>
EOF
	      echo -e "\n\n"
   	      echo -e "Please indicate your selection from one of the above options for STORAGE SERVER[1-3][1]:- "
	      cellssh_YesNo=3 
            elif [[ $EM_XMLD_MODE -eq 1 ]]
            then
   	      echo -e "Please indicate your selection from one of the above options for STORAGE SERVER[1-3][1]:- "

	      read_probe_xml "For evaluating best practices on the storage cells of a cluster, root level privileges are required on the cells" "1"
	      cellssh_YesNo=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p  "Please indicate your selection from one of the above options for STORAGE SERVER[1-3][1]:- " cellssh_YesNo
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "cellssh_YesNo" "3"
	    fi
          fi

          case $cellssh_YesNo in
            1)
              cell_password_status=1
              if [ $root_all_prompt -eq "1" ] ; then
                cell_samerootpassword_YesNo="y"
              else
        	if [[ $EM_XMLD_MODE -eq 1 ]]
        	then
                  echo -e "Is ${cell_ssh_user} password same on all STORAGE SERVER?[y/n][y]"

		  read_probe_xml "Use the same {1} password on all storage cells"
		  cell_samerootpassword_YesNo=$xml_rvalue
		else
                  echo -e "\n"
      	 	  exec 3<&2; exec 2<&0
                  $READ -p  "Is ${cell_ssh_user} password same on all STORAGE SERVER?[y/n][y]" cell_samerootpassword_YesNo
		  read_code=`echo $?`;
      	          exec 2<&3
		  process_prompt "$read_code" "cell_samerootpassword_YesNo" "y"
		fi
              fi
              case $cell_samerootpassword_YesNo in
      	        y|Y|Yes|YES|yes)
      	          cell_samerootpassword=1
                  if [ $root_all_prompt -eq "1" ] ; then
                    cell_rootpassword="$global_root_password"
                  else
      	            echo -e "\n"
      	            printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
		    if [[ $EM_XMLD_MODE -eq 1 ]]
		    then
		      read_probe_xml "n82_nlsid"
		      cell_rootpassword=$xml_rvalue 
		    else
      	              tty -s && stty -echo
      	              $READ -r cell_rootpassword
      	              tty -s && stty echo
		    fi
      		    printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
                  fi
      	          root_hostname=$cell_ip
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	          checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	          printf ". ";
      	          if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	          then
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	            find_switch_root_password=$passwordToCheck
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	            first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)  
      	          fi
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	          cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	          ;;
      	        n|N|No|NO|no)
      	          cell_samerootpassword=0
      	          root_cell_counter=0
      	          echo -e "\n"
      	          for cellname in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
      	          do
                    cell_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
                    if [[ -n "$cell_ssh_status2" && $cell_ssh_status2 -eq 0 ]]
                    then
			echo -e "\n$GREEN $cellname is configured for ssh user equivalency for $cell_ssh_user user $NORM\n";
                      echo "$cell_ssh_user password not checked on $cellname because ssh user equivalence found for $cell_ssh_user">>$LOGFIL
                    else
      	              if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
      	              then
      	                cellname_full=$cellname
      	              else
      	                #cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)  
      	                cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)  
      	              fi
      	              printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname) :- "
		      if [[ $EM_XMLD_MODE -eq 1 ]]
		      then
			echo -e "\n"	
			read_probe_xml "<text>$cellname_full</text>"
			cell_rootpassword=$xml_rvalue
		      else
      	                tty -s && stty -echo
      	                $READ -r cell_rootpassword
      	                tty -s && stty echo
		      fi

      	              printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	              checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	              printf ". ";
      	              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	              then
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	                find_switch_root_password=$passwordToCheck
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	                first_cell_ip=$cellname
      	              fi
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	              cell_rootpassword=$passwordToCheck
      	              a_cell_rootpassword[$root_cell_counter]=$cell_rootpassword
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                    fi
      	            root_cell_counter=$(expr $root_cell_counter + 1 )
      	          done
      	          ;;
      	        *)
      	          cell_samerootpassword=1
      	          echo -e "\n"
      	          printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
      	          tty -s && stty -echo
      	          $READ -r cell_rootpassword
      	          tty -s && stty echo
      	          printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
      	          root_hostname=$cell_ip
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	          checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	          printf ". ";
      	          if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	          then
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	            find_switch_root_password=$passwordToCheck
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	            first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)  
      	          fi
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	          cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	          ;;
              esac 
              ;;
            2)
              echo -e "\nLogin as $cell_ssh_user user on $localnode\n\nA. Generate $cell_ssh_user ssh keys.\n\ta. ssh-keygen -t $ENCR\n\tb. ssh-keygen -t $ENCR\nAccept defaults so the ssh keys are created for $cell_ssh_user user\n\nB. Push ssh keys to set up ssh equivalence using following command. Enter $cell_ssh_user password when prompted for.\ndcli -c $storage_cells -l $cell_ssh_user -k\n\n"
              exit 1;
              ;; 
            3)
	      if [[ $EM_PROBE_MODE -eq 1 ]]
	      then
		cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n56_nlsid">Enter the component's {1} user password</text>
    <tokens><token index="1">$cell_ssh_user</token></tokens>
    </tokenizedtext>
    <multipart-question>
EOF
	        cell_counter=1
      	        for cellname in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
      	        do
                  cell_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
                  if [[ -n "$cell_ssh_status2" && $cell_ssh_status2 -eq 0 ]]
                  then
		    echo 
                  else
      	            if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
      	            then
      	              cellname_full=$cellname
      	            else
      	              cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)  
      	            fi
		    cat >> ${PROBE_XML}.tmp <<EOF
    <question id="q${PROBE_QUES_CNT}o1q1o2q1q${cell_counter}" questionType="SECRET" outcome="No">
      <text>$cellname_full</text>
    </question>
EOF
		    cell_counter=$(expr $cell_counter + 1 )
                  fi
      	        done
		cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
		PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	      fi 
              cell_password_status=3
              break
              ;;
            *)
              cell_password_status=1
              echo -e "\n"
              exec 3<&2; exec 2<&0
              $READ -p  "Is ${cell_ssh_user} password same on all STORAGE SERVER[y/n][y]" cell_samerootpassword_YesNo
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "cell_samerootpassword_YesNo" "y"

              case $cell_samerootpassword_YesNo in
      	        y|Y|Yes|YES|yes)
      	          cell_samerootpassword=1
      	          echo -e "\n"
      	          printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
      	          tty -s && stty -echo
      	          $READ -r cell_rootpassword
      	          tty -s && stty echo
      	          printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
      	          root_hostname=$cell_ip
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	          checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	          printf ". ";
      	          if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	          then
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	            find_switch_root_password=$passwordToCheck
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	            first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)  
      	          fi
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	          cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	          ;;
      	        n|N|No|NO|no)
      	          cell_samerootpassword=0
      	          root_cell_counter=0

      	          for cellname in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
      	          do
                    cell_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
                    if [[ -n "$cell_ssh_status2" && $cell_ssh_status2 -eq 0 ]]
                    then
			echo -e "\n$GREEN $cellname is configured for ssh user equivalency for $cell_ssh_user user $NORM\n";
                      echo "$cell_ssh_user password not checked on $cellname because ssh user equivalence found for $cell_ssh_user">>$LOGFIL
                    else
                      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
                      then 
                        cellname_full=$cellname
                      else
          	        #cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)  
			cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)
                      fi 
      		      printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname) :- "
      		      tty -s && stty -echo
      		      $READ -r cell_rootpassword
      		      tty -s && stty echo
      	      	      printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      		      checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	      	      printf ". ";
      		      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      		      then
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      		        find_switch_root_password=$passwordToCheck
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      		        first_cell_ip=$cellname
      		      fi
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      		      cell_rootpassword=$passwordToCheck
      		      a_cell_rootpassword[$root_cell_counter]=$cell_rootpassword
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                    fi
      		    root_cell_counter=$(expr $root_cell_counter + 1 )
      	          done
      	          ;;
      	        *)
      	          cell_samerootpassword=1
      	          echo -e "\n"
      	          printf  "Enter $cell_ssh_user password for ${BLINK}STORAGE SERVER${NORM} :- "
      	          tty -s && stty -echo
      	          $READ cell_rootpassword
      	          tty -s && stty echo
      	          printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
      	          root_hostname=$cell_ip
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	          checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	          printf ". ";
      	          if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	          then
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	            find_switch_root_password=$passwordToCheck
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	            first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)  
      	          fi
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      	          cell_rootpassword=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      	     	  ;;
              esac
              ;; 
          esac
          break
          #"\nso setup user equivalence between $localnode and all storage cells for root user and re-run $program_name."
        elif [[ -n "$cell_ssh_status" && $cell_ssh_status -ne 0 ]]
        then
          cell_password_status=3 
        fi
      else
        cell_password_status=3 
        if [[ $ssh_go_ahead = 0 ]]
        then
          add_to_skipped_nodes "$cell_ip" "Network latency issue: Storage server is pingable but ssh took too long";
        else
          add_to_skipped_nodes "$cell_ip" "Storage server is not reachable";
        fi
      fi 
      printf ". ";
    done 

    get_files_for_mixedcellhw

    if [[ -n "$cell_password_status" && $cell_password_status -eq 1 && "$cell_ssh_user" = "root" && -z "$RAT_IBSWITCHES" ]]
    then
      printf ". ";
      # gadiga - create /tmp/.program first
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      fixRootPassword "$find_switch_root_password"
      $EXPECT -f - << IBEOF
                               #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
                               log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }    
                               spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip rm -rf ${CELLRTEMPDIR} >/dev/null 2>&1
                               match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while deleting ${CELLRTEMPDIR} on $first_cell_ip\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
                               #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
                               log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }    
                               spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip mkdir ${CELLRTEMPDIR} >/dev/null 2>&1
                               match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while running mkdir on $first_cell_ip\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "ibswitches 2>/dev/null >${CELLRTEMPDIR}/o_ibswitches_full.out"
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while running ibswitches command \n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SCOPY $cell_ssh_user@$first_cell_ip:${CELLRTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR}
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while copying ${CELLRTEMPDIR}/o_ibswitches_full.out file from $first_cell_ip\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
                               spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "cellcli -e \"list cell attributes makeModel,eighthrack\" 2>/dev/null>${SYSTEM_DESC_FIL}"
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while running cellcli command\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SCOPY $cell_ssh_user@$first_cell_ip:${SYSTEM_DESC_FIL} ${RTEMPDIR}
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while copying ${SYSTEM_DESC_FIL} file from $first_cell_ip\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";	
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }   
			       spawn $SSHELL $cell_ssh_user@$first_cell_ip rm -f ${CELLRTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL}
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while removing ${CELLRTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL}\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      printf ". ";	
    elif [[ -n "$cell_password_status" && $cell_password_status -eq 0 && "$cell_ssh_user" = "root" && -z "$RAT_IBSWITCHES" ]]
    then
      printf ". ";	
      # gadiga -cell ssh is setup. create /tmp/.program
      #Commented this and created directory as needed rather than createing here on all cells. thats how if user presses ctrl+c, we will eave directory only on 1 cell and not on all
      #create_rtemp_dir_in_cells 
      first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)         
      $SSHELL $cell_ssh_user@$first_cell_ip "rm -rf ${CELLRTEMPDIR} >/dev/null 2>&1"
      $SSHELL $cell_ssh_user@$first_cell_ip "mkdir ${CELLRTEMPDIR} >/dev/null 2>&1"
      $SSHELL $cell_ssh_user@$first_cell_ip "ibswitches 2>/dev/null >${CELLRTEMPDIR}/o_ibswitches_full.out"
      $SSHELL $cell_ssh_user@$first_cell_ip "cellcli -e \"list cell attributes makeModel,eighthrack\" 2>/dev/null>${SYSTEM_DESC_FIL}"
      $SCOPY $cell_ssh_user@$first_cell_ip:${CELLRTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
      $SCOPY $cell_ssh_user@$first_cell_ip:${SYSTEM_DESC_FIL} ${RTEMPDIR} >/dev/null 2>&1
      $SSHELL $cell_ssh_user@$first_cell_ip rm -f ${CELLRTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL} >/dev/null 2>&1
      $SSHELL $cell_ssh_user@$first_cell_ip "rmdir ${CELLRTEMPDIR}"
      printf ". ";	
    elif [ -n  "$RAT_IBSWITCHES" ]
    then
      printf ". ";
      for switchname in `echo $RAT_IBSWITCHES`
      do
        echo $switchname >>${RTEMPDIR}/o_ibswitches_full.out
      done
    fi
  else
    cell_ssh_status=0 
  fi

  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then 
    echo "$localnode" > $CELLIP
    get_files_for_mixedcellhw; 
  fi

  printf ". ";
  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
    echo "cell_ssh_status=$cell_ssh_status and cell_ssh_user=$cell_ssh_user">>$LOGFIL
    echo "CELL_SSH_USER = $cell_ssh_user" >>$MASTERFIL
    echo "CELL_PASSWORD_OPTION = $cell_password_status" >>$MASTERFIL
    echo "CELL_PASSWORD_OPTION = $cell_password_status" >>$LOGFIL  
  fi
    
  #following code is find infiniband switches from first cells   
  #Reassiging SYSTEM_DESC_FIL path back to compute node. initially it was cell temporory directory. now this file is available on compute node
  SYSTEM_DESC_FIL=${RTEMPDIR}/cell_system_description.out 
  #password prompt for ZFS cells for super cluster
  ask_zfs_password=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $zfs_in_profile -eq "0" && $ellite_in_profile -eq "0" && $elextensive_in_profile -eq "0" ]] ; then
    ask_zfs_password=0
  fi
  
  if [[ $is_ssc_machine -eq 1 || $is_exalogic_machine -eq 1 || $is_exalogic_foxtrot -eq 1 || $is_zfssa_machine -eq 1 ]] && [[  $TYP != "-p"  && -n "$skip_in_silent" && $skip_in_silent -eq 0  && "$upgrade_mode" -ne "3" && $only_hacheck_run -eq 0 && $ask_zfs_password -eq "1" ]] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] && [ -e "$CELLIP" ]
  then
    printf ". ";
    # First check if root password is same on all components. only for exa
    # The root password is stored in global_root_password
    if [ -z "$set_root_all_prompt_called" ] ; then
      root_all_prompt=0
      set_root_all_prompt
      set_root_all_prompt_called=1
      printf ". ";
    fi
    cell_type="zfscell"
    #cell_root_command=""
    if [ -z "$RAT_ZFS_SSH_USER" ];then zfs_ssh_user="root"; else zfs_ssh_user=$RAT_ZFS_SSH_USER;fi
    if [ $is_ssc_machine -eq 1 ]; then 
      discover_ssc_zfs_nodes
    elif [[ $is_exalogic_machine -eq 1 || $is_exalogic_foxtrot -eq 1 ]]; then
      ZFSIP=$CELLIP
      EXTZFSIP=$EXTCELLIP
    fi
    if [ $is_ssc_zfsnodes_passed -eq 1 ]; then
      cell_ips=`cat $ZFSIP|cut -d= -f2|sed 's/"//g'; if [[ -e $EXTZFSIP ]]; then cat $EXTZFSIP|cut -d= -f2|sed 's/"//g'; fi`
    fi
    for cell_ip in $cell_ips
    do
      printf ". ";
      #zfsPingStatus=$($PING -c 1 $PING_W_FLAG $cell_ip >/dev/null 2>&1;echo $?)
      test_node_reachability $cell_ip $zfs_ssh_user;
      if [ $el_node_ping -eq "1" ] ; then
        zfsPingStatus=0;
      else
        zfsPingStatus=1;
      fi

      #if [[ -n "$zfsPingStatus" && $zfsPingStatus -eq 0 ]] 
      #then
      #  check_ssh_speed $zfs_ssh_user $cell_ip
      #  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then zfsPingStatus=255; fi
      #fi
      if [ $zfsPingStatus -eq 0 ]
      then 
    	zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $cell_ip ls >/dev/null 2>&1;echo $?);
    	#cell_ssh_status=100
        if [[ $daemon_init_mode -eq 1 && -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]]
        then
          echo -e "\n${zfs_ssh_user} user equivalence is not setup between $localnode and ${BLINK}ZFS Storage Appliance${NORM} ${cell_ip}."
          echo -e "\n\n${program_name} is exiting.."   
          log_daemon "\n${zfs_ssh_user} user equivalence is not setup between $localnode and ${BLINK}ZFS Storage Appliance${NORM} ${cell_ip}."
          log_daemon "\n\n${program_name} is exiting.."   
          exit 1
        fi 
    	zfs_password_status=0
    	#if [ $cell_ssh_status -eq 255 ];then cell_ssh_status=0;fi
    	#zfsname_full=$(cat /etc/hosts|grep -w "$cell_ip"|awk '{print $NF}'|cut -d'-' -f1)
    	zfsname_full=$(grep -w "$cell_ip" /etc/hosts|awk '{print $NF}'|cut -d'-' -f1)
    	zfs_storage_cells=$(cells1=`cat $ZFSIP`;echo $cells1|sed 's/ /,/g');

        if [ $is_opc -eq 1 ] ; then set_zfs_arrays_in_opc; break; fi
	if [[ -n "$zfs_ssh_status" && $zfs_ssh_status -eq 0 ]]
        then
		echo -e "\n$GREEN $zfsname_full is configured for ssh user equivalency for $zfs_ssh_user user $NORM\n";
	fi

    	if [[ -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]]
    	then
        if [ $root_all_prompt -eq "1" ] ; then
          echo "Validating root password on ZFS Storage Appliance"
          echo 
          zfsssh_YesNo=1
        else
    	  echo -e "\n${zfs_ssh_user} user equivalence is not setup between $localnode and ${BLINK}ZFS Storage Appliance${NORM} ${cell_ip}." 
    	  echo -e "\n1. Enter 1 if you will enter ${zfs_ssh_user} password for each ${BLINK}ZFS Storage Appliance${NORM} when prompted."
    	  echo -e "\n2. Enter 2 to exit and configure $zfs_ssh_user user equivalence manually and re-run ${program_name}."
    	  echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}ZFS Storage Appliance${NORM}.\n"
	  
  	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
            cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_ZC}" groupHeader="$GID_ZC_HDR">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <text nls_id="orhc_exadata_n57_nlsid">For evaluating best practices on the Oracle ZFS Storage Appliance of a cluster, root level privileges are required on the appliances. Select one of the following options:</text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n58_nlsid">Specify {1} password for each ZFS Storage Appliance</text>
	<tokens><token index="1">$zfs_ssh_user</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" isTerminal="Y">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n60_nlsid">Exit and configure {1} user equivalence manually and re-run ${program_name}</text>
	<tokens><token index="1">$zfs_ssh_user</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o3">
        <text nls_id="orhc_exadata_n59_nlsid">Skip checking best practices on ZFS Storage Appliances</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n61_nlsid">Use the same {1} password on all ZFS Storage Appliances</text>
    <tokens><token index="1">$zfs_ssh_user</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n84_nlsid">Enter {1} password</text>
    <tokens><token index="1">$zfs_ssh_user</token></tokens>
    </tokenizedtext>
  </question>
EOF
	      echo -e "\n\n"
              echo -e "Please indicate your selection from one of the above options for ZFS Storage Appliance[1-3][1]:- "
              zfsssh_YesNo=3
	  elif [[ $EM_XMLD_MODE -eq 1 ]]
	  then
	    echo -e "\n\n"
            echo -e "Please indicate your selection from one of the above options for ZFS Storage Appliance[1-3][1]:- "
	
	    read_probe_xml "For evaluating best practices on the Oracle ZFS Storage Appliance of a cluster, root level privileges are required on the appliances" "1"
	    zfsssh_YesNo=$xml_rvalue
	  else
    	    exec 3<&2; exec 2<&0
    	    $READ -p  "Please indicate your selection from one of the above options for ZFS Storage Appliance[1-3][1]:- " zfsssh_YesNo
	    read_code=`echo $?`;
    	    exec 2<&3
	    process_prompt "$read_code" "zfsssh_YesNo" "3"
	  fi
        fi

    	case $zfsssh_YesNo in
    	1)
    	  zfs_password_status=1
    	  if [ $root_all_prompt -eq "1" ] ; then
    	    zfs_samerootpassword_YesNo="y"
    	  else
    	    echo -e "\n"
	    if [[ $EM_XMLD_MODE -eq 1 ]]
	    then
    	      echo -e "Is ${zfs_ssh_user} password same on all ZFS Storage Appliance?[y/n][y]"

	      read_probe_xml "Use the same {1} password on all ZFS Storage Appliances"
	      zfs_samerootpassword_YesNo=$xml_rvalue
	    else
    	      exec 3<&2; exec 2<&0
    	      $READ -p  "Is ${zfs_ssh_user} password same on all ZFS Storage Appliance?[y/n][y]" zfs_samerootpassword_YesNo
	      read_code=`echo $?`;
    	      exec 2<&3
	      process_prompt "$read_code" "zfs_samerootpassword_YesNo" "y"
	    fi
    	  fi
    	  case $zfs_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
    	      zfs_samerootpassword=1
    	      if [ $root_all_prompt -eq "1" ] ; then
    	        zfs_rootpassword="$global_root_password"
    	      else
		echo -e "\n" 
    	        printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
		if [[ $EM_XMLD_MODE -eq 1 ]]
		then
		  read_probe_xml "n84_nlsid"
		  zfs_rootpassword=$xml_rvalue
		else
    	          tty -s && stty -echo
    	          $READ -r zfs_rootpassword
    	          tty -s && stty echo
		fi
    	      fi
              printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
    	      root_hostname=$cell_ip
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              printf ". ";
    	      zfs_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	      ;;
    	    n|N|No|NO|no)
    	      zfs_samerootpassword=0
    	      root_zfs_counter=0
    	      echo -e "\n"
    	      for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
    	      do
                zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
                if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
                then
		  echo -e "\n$GREEN $zfsname is configured for ssh user equivalency for $zfs_ssh_user user $NORM\n";
                  echo "$zfs_ssh_user password not checked on $zfsname because ssh user equivalence found for $zfs_ssh_user">>$LOGFIL
                else
		  echo -e "\n" 
    	          printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} $zfsname :- "
		  if [[ $EM_XMLD_MODE -eq 1 ]]
		  then
		    read_probe_xml "<text>$zfsname</text>"
		    zfs_rootpassword=$xml_rvalue
		  else
    	            tty -s && stty -echo
    	            $READ -r zfs_rootpassword
    	            tty -s && stty echo
		  fi
                  printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	          checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  printf ". ";
    	          zfs_rootpassword=$passwordToCheck
    	          a_zfs_rootpassword[$root_zfs_counter]=$zfs_rootpassword
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                fi
    	        root_zfs_counter=$(expr $root_zfs_counter + 1 )
    	      done
    	      ;;
    	    *)
    	      zfs_samerootpassword=1
    	      echo -e "\n"
    	      printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
    	      tty -s && stty -echo
    	      $READ -r zfs_rootpassword
    	      tty -s && stty echo
              printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
    	      root_hostname=$cell_ip
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
              printf ". ";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	      zfs_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	      ;;
    	  esac 
    	  ;;
    	2)
    	  echo -e "\nLogin as $zfs_ssh_user user on $localnode\n\nA. Generate $zfs_ssh_user ssh keys.\n\ta. ssh-keygen -t $ENCR\n\tb. ssh-keygen -t $ENCR\nAccept defaults so the ssh keys are created for $zfs_ssh_user user\n\nB. Push ssh keys to set up ssh equivalence using following command. Enter $zfs_ssh_user password when prompted for.\ndcli -c $zfs_storage_cells -l $zfs_ssh_user -k\n\n"
    	  exit 1;
    	  ;; 
    	3)
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
 	    cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n56_nlsid">Enter the component's {1} user password</text>
    <tokens><token index="1">$zfs_ssh_user</token></tokens>
    </tokenizedtext>
    <multipart-question>
EOF
	    zfs_counter=1
            for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
            do
              zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
              then
                echo
              else
    		cat >> ${PROBE_XML}.tmp <<EOF
    <question id="q${PROBE_QUES_CNT}o1q1o2q1q${zfs_counter}" questionType="SECRET" outcome="No">
      <text>$zfsname</text>
    </question>
EOF
                zfs_counter=$(expr $zfs_counter + 1 )
              fi
            done
	    cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
	    PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	  fi
    	  zfs_password_status=3
    	  break
    	  ;;
    	*)
    	  zfs_password_status=1
    	  echo -e "\n"
    	  exec 3<&2; exec 2<&0
    	  $READ -p  "Is ${zfs_ssh_user} password same on all ZFS Storage Appliance[y/n][y]" zfs_samerootpassword_YesNo
	  read_code=`echo $?`;
    	  exec 2<&3
	  process_prompt "$read_code" "zfs_samerootpassword_YesNo" "y"
    	  case $zfs_samerootpassword_YesNo in
    	    y|Y|Yes|YES|yes)
    	      zfs_samerootpassword=1
    	      echo -e "\n"
    	      printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
    	      tty -s && stty -echo
    	      $READ -r zfs_rootpassword
	      read_code=`echo $?`;
    	      tty -s && stty echo
    	      printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
    	      root_hostname=$cell_ip
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	      printf ". ";
    	      zfs_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	      ;;
    	    n|N|No|NO|no)
    	      zfs_samerootpassword=0
    	      root_zfs_counter=0
    	      echo -e "\n"
    	      for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
    	      do
    	        printf ". ";	
                zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
                if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
                then
		  echo -e "\n$GREEN $zfsname is configured for ssh user equivalency for $zfs_ssh_user user $NORM\n";
                  echo "$zfs_ssh_user password not checked on $zfsname because ssh user equivalence found for $zfs_ssh_user">>$LOGFIL
                else
    	          printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} $zfsname :- "
    	          tty -s && stty -echo
    	          $READ -r zfs_rootpassword
    	          tty -s && stty echo
    	          printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	          checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	          zfs_rootpassword=$passwordToCheck
    	          printf ". ";
    	          a_zfs_rootpassword[$root_zfs_counter]=$zfs_rootpassword
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                fi
    	        root_zfs_counter=$(expr $root_zfs_counter + 1 )
    	        printf ". ";
    	      done
    	      ;;
    	    *)
    	      zfs_samerootpassword=1
    	      echo -e "\n"
    	      printf  "Enter $zfs_ssh_user password for ${BLINK}ZFS Storage Appliance${NORM} :- "
    	      tty -s && stty -echo
    	      $READ -r zfs_rootpassword
    	      tty -s && stty echo
    	      printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";	
    	      root_hostname=$cell_ip
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    	      printf ". ";
    	      zfs_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	      ;;
    	  esac
    	  ;; 
    	esac
    	break
        #"\nso setup user equivalence between $localnode and all storage cells for root user and re-run $program_name."
      elif [[ -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]]
      then
        zfs_password_status=3 
      fi
      else
        zfs_password_status=3 
        if [[ $ssh_go_ahead = 0 ]] 
        then
          add_to_skipped_nodes "$cell_ip" "Network latency issue: ZFS Storage Appliance is pingable but ssh took too long";
        else
          add_to_skipped_nodes "$cell_ip" "ZFS Storage Appliance is not reachable";
        fi
      fi 
    done 
  else
    zfs_ssh_status=0 
  fi
  # set OCM-Ethernet TOR switch array, similar to set_zfs_arrays_in_opc.
  if [[ -n "$RAT_TORSWITCHES" ]]
  then
    set_switch_arrays_in_ocm
  fi

  if [[ $is_exalogic_machine -eq 1 || $is_bda_machine -eq 1 || $is_exalogic_foxtrot -eq 1 ]] && [[ -n "$swlist_file" && -e "$swlist_file" ]]
  then # exalogic or BDA machine. read switch info from file
    printf ". ";
    for switchname in `cat $swlist_file`
    do
      printf ". ";
      test_node_reachability $switchname "root" "Infiniband switch";
      if [ $el_node_ping -eq "1" ] ; then
        switchping_status=0;
        echo $switchname>>${RTEMPDIR}/o_ibswitches.out
      else
        switchping_status=1;
	add_to_skipped_nodes "$switchname" "$tnr_note"
      fi
    done
    rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
    cp -f ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  fi
  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
    echo "zfs_ssh_status=$zfs_ssh_status and zfs_ssh_user=$zfs_ssh_user">>$LOGFIL
    echo "ZFS_PASSWORD_OPTION = $zfs_password_status" >>$MASTERFIL
    echo "ZFS_PASSWORD_OPTION = $zfs_password_status" >>$LOGFIL  
  fi

  #password prompts for zfs appliance for super cluster ends here
      
  #echo "Switches:"
  #cat ${OUTPUTDIR}/o_ibswitches.out 
  #echo "=============="

  if [ -e ${RTEMPDIR}/o_ibswitches_full.out ]
  then
    OIFS="${IFS}";
    NIFS=$'\n';
    IFS="${NIFS}";
    for switch_line in `cat ${RTEMPDIR}/o_ibswitches_full.out`
    do
      printf ". "
      switchname=$(echo "$switch_line"|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $1}'|sed 's/"$//g')
      is_ibswitch_ip=$(echo $switchname|grep -c '[A-Za-z]')
      if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
      then
        switchname_ip=$switchname   
        switchname=$(echo "$switch_line"|grep -vwi gw|cut -d'"' -f2|awk {'print $(NF-1)}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1)
      fi   
      if [ -n "$switchname" ]
      then 
        test_node_reachability "$switchname" "root" $switchname_ip "Infiniband switch";
        if [ $el_node_ping -eq "1" ] ; then
          switchping_status=0;
	  echo $switchname>>${RTEMPDIR}/o_ibswitches.out
        else
          switchping_status=1;
	  add_to_skipped_nodes "$switchname" "$tnr_note"
        fi
      fi
    done
    IFS="${OIFS}";
    mv -f ${RTEMPDIR}/o_ibswitches_full.out $OUTPUTDIR>/dev/null 2>&1
    cp -f ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  fi
  #code is find infiniband switches from first cells ends here
  #ssh setup on cells finished here

  #Following code is to extract EXADATA_VERSION when run from cell"
  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
    if [ -n "$RAT_EXADATA_VERSION" ]
    then
      current_exadata_version=$(echo $RAT_EXADATA_VERSION|sed 's/\.//g')
    else
      current_exadata_version=$(imageinfo -version 2>/dev/null);
      current_exadata_version=$(echo $current_exadata_version|sed 's/\.//g'|cut -c 1-6)
    fi
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then 
      echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
      echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL; 
    fi
    if [[ -z "$current_exadata_version" ]]
    then
      echo -e ""
      echo -e "${RED}${program_name} could not determine Exadata software version from environment. Set RAT_EXADATA_VERSION environment variable to Exadata software version and re-run it.$NORM\n"
      echo -e "eg export RAT_EXADATA_VERSION=11.2.2.4.0\n"
      exit 1
    fi
  fi

  #following code is to find exadata version by logging in as root on storage server because oracle can not run imageinfo.
  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 && $TYP != "-p" ]]
  then
    printf ". ";
    if [ -n "$RAT_EXADATA_VERSION" ]
    then
      current_exadata_version=$(echo $RAT_EXADATA_VERSION|sed 's/\.//g')
      if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
        echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
        echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL 
      fi
    else
      if [[ -n "$cell_password_status" && $cell_password_status -eq 1 && "$cell_ssh_user" = "root" ]]
      then
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	fixRootPassword "$find_switch_root_password"
	current_exadata_version=$($EXPECT -f - << IBEOF
				    #set timeout 1
                                    set timeout $passwordcheck_timeout
				    set le_find_switch_root_password "$fixedRootPassword"
				    #log_user 0
                                    if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                      exp_internal 1
                                    } 
				    spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "imageinfo -version"
				    match_max 100000
			       	    expect {
				      -nocase "permission denied *" {
				      exit 4;
			            }
			      	      -nocase "no)?" {
				      send -- "yes\n"
			            }
			              -nocase "*?assword:*" {
				      send -- "\$le_find_switch_root_password\n"
			            }
			      	      -nocase eof {
				      exit
			            }
			            }
			            # Look for passwd prompt
			            expect {
			              -nocase "*?assword:*" {
			                send -- "\$le_find_switch_root_password\n"
			              }
			              # Stop the on logon tests and if asked to connect to master switch choose no
			              -nocase eof {
			                exit
			              } -nocase timeout {
			                send_error "Timed out while running imageinfo command on $first_cell_ip\n";
			                exit
			              }
			            }
			            expect -nocase eof
IBEOF
)
	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  	printf ". ";
	if [ `echo "$current_exadata_version" | grep -ic "password:"` -gt 0 ]
	then
	  current_exadata_version=$(echo $current_exadata_version|$AWK 'BEGIN { FS = "password:" };{print $2}'|sed 's/ //g'|tr -d '\r')
	else
	  current_exadata_version=$(echo $current_exadata_version|sed 's/ //g'|tr -d '\r')
	fi
	current_exadata_version=$(echo $current_exadata_version|sed 's/\.//g'|cut -c 1-6)
	echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
	if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL; fi
      elif [[ -n "$cell_password_status" && $cell_password_status -eq 0 && "$cell_ssh_user" = "root" ]]
      then
  	printf ". ";
	current_exadata_version=$($SSHELL $cell_ssh_user@$first_cell_ip "imageinfo -version")
	current_exadata_version=$(echo $current_exadata_version|sed 's/\.//g'|cut -c 1-6)
	echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
	if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL; fi 
      fi
    fi

    if [[ -z "$current_exadata_version" &&  -n "$skip_in_silent" && $skip_in_silent -eq 0 && $cell_password_status -ne 3 && $upgrade_mode -ne 3 && $only_hacheck_run -eq 0  && $ask_cell_password -ne "0" ]]
    then
      echo -e ""
      echo -e "${RED}${program_name} could not determine Exadata software version from environment. Set RAT_EXADATA_VERSION environment variable to Exadata software version and re-run it.$NORM\n"
      echo -e "eg export RAT_EXADATA_VERSION=11.2.2.4.0\n"
      exit 1
    fi
  fi  

  #lock the cells using exacli
  if [[ -n $unlocked_storage_cell && $unlocked_storage_cell -eq 1 ]];then
    exacli_passwd_list_index=0
    echo -e "\n\nLocking the Storage Servers..."
    for (( exacli_passwd_list_index = 0; exacli_passwd_list_index < $cell_ip_max_index; exacli_passwd_list_index++ ))
    do
      cell_ip=${exacli_passwd_list[exacli_passwd_list_index]}
      exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      lock_storage_cell_exacli "$exacli_user" "$cell_ip" "${exacli_passwd_list[exacli_passwd_list_index]}"
      if [[ $? -eq "0" ]]; then
        echo -e "\n\n Unable to lock Storage Server $cell_ip"
        if [[ $EM_PROBE_MODE -eq 1 ]]
          then
          EMSG= "$EMSG Unable to lock Storage Server $cell_ip"
          unable_to_lock_cell=1
        fi
      fi
    done
    if [[ $EM_PROBE_MODE -eq 1 && $unable_to_lock_cell -eq 1 ]]
    then 
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      unable_to_lock_cell=0;
      exit
    fi
  fi

  #$READ -p "$current_exadata_version"
  #code to find out version ends here
  #calling is_this_db_machine again because some values will be available from storage server 
  bda_machine_type $localnode
  printf ". ";
  
  is_this_db_machine $localnode
  printf ". ";
  add_maa_scorecard
  printf ". ";
  add_hacheck
  printf ". ";
  
  write_db_machine_info_to_envfile $localnode
  printf ". ";
  
  db_root_ssh=1
  for db_root_ssh_host in `cat $HOSTLIST`
  do
    db_root_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $root_user $db_root_ssh_host ls >/dev/null 2>&1;echo $?);
    if [[ -n "$db_root_ssh_status" && $db_root_ssh_status -ne 0 ]]
    then
      if [[ $daemon_init_mode -eq 1 && -n "$db_root_ssh_status" && $db_root_ssh_status -ne 0 ]] || [[ $daemon_init_mode -eq 1 && -n "$daemon_init_mode_sudo" && $daemon_init_mode_sudo -eq 0 ]]
      then
        if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "serial" ]]; then
          echo -e "\n${root_user} user equivalence is not setup between $localnode and ${BLINK}DATABASE SERVER ${db_root_ssh_host}."
          echo -e "\n\n${program_name} is exiting.."
          log_daemon "\n${root_user} user equivalence is not setup between $localnode and ${BLINK}DATABASE SERVER ${db_root_ssh_host}."
          log_daemon "\n\n${program_name} is exiting.."
          exit 1
        fi
      fi    
      db_root_ssh=0
      db_root_with_nossh=$db_root_ssh_host
      echo -e "\nssh user equivalence not found for ${root_user} on ${db_root_ssh_host}\n">> $LOGFIL
      break
    else
	#echo -e "\n$GREEN ${db_root_ssh_host} is configured for ssh user equivalency for ${root_user} user $NORM\n";
      echo -e "\nssh user equivalence found for ${root_user} on ${db_root_ssh_host}\n">> $LOGFIL
    fi 
  done

  #$READ -p "components=$components"
  #$READ -p "TYP=$TYP REQUIRE_ROOT=$REQUIRE_ROOT"
  root_need_cell_ssh=0
  if [ -n "$db_machine_compute" ] && [[ $dbm_v1 -eq 1 ]] && [[  -n "$cell_password_status" && $cell_password_status -eq 3 ]]; then root_need_cell_ssh=1;fi

  ask_root_password=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_root_checks -eq "0" ]] ; then
    ask_root_password=0
  elif [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_root_checks -eq "0" ]] ; then
    ask_root_password=0
  fi
  if [[ -n "$debug_in_profile" && $debug_in_profile -gt 0 ]]; then ask_root_password=1;fi
  askrootp=0;
  if [ $is_windows -eq "0" ] ; then
    if [[ $single_instance_run -eq "0" || $db_machine_compute -eq 1 ]] || [[ $single_instance_run -eq "1" && $is_emagent_installed -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      askrootp=1;
    fi
  fi

  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then 
    SAVE_USERID=$userid;
    userid=1;

    db_root_ssh=1
    for hname in `cat $HOSTLIST`
    do
      node_ssh_user=$usern
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
        node_ssh_user="${root_user}"
        db_root_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $node_ssh_user $hname ls >/dev/null 2>&1;echo $?);
      else
        node_ssh_user="${foxtrot_dom0_user}"

        CONNECTTIMEOUT=$passwordcheck_timeout
        $EXPECT -f - << IBEOF
            set timeout $CONNECTTIMEOUT
            log_user 0
            if { "$RAT_EXPECT_DEBUG" == "-d" } {
              exp_internal 1
            }
            spawn -noecho $SSHELL -o NumberOfPasswordPrompts=0 -t -l $node_ssh_user $db_root_ssh_host "su - ${root_user}"
            match_max 100000
            expect {
              -nocase "no)?" {
                  send -- "yes\n"
              }
              -nocase "*?assword:*" {
                 exit 5;
              }
              -nocase "permission denied *" {
                 exit 4;
              }
              -nocase timeout {
                 exit 2;
              }
              -nocase eof {
                 exit 0;
              }
            }
            expect {
              -nocase "*?assword:*" {
                 exit 5;
              }
              -nocase "permission denied *" {
                 exit 4;
              }
              -nocase timeout {
                 exit 2;
              }
              -nocase eof {
                 exit 0;
              }
           }
         expect {
                 -nocase default {exit 0}
              }
         exit 0
IBEOF
        db_root_ssh_status=$(echo $?)
      fi

      if [[ -n "$db_root_ssh_status" && $db_root_ssh_status -ne 0 ]]
      then
        if [[ $daemon_init_mode -eq 1 && -n "$db_root_ssh_status" && $db_root_ssh_status -ne 0 ]] || [[ $daemon_init_mode -eq 1 && -n "$daemon_init_mode_sudo" && $daemon_init_mode_sudo -eq 0 ]]
        then
          if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "serial" ]]; then
            echo -e ""
            echo -e "\n\n${program_name} is exiting.."
            log_daemon ""
            log_daemon "\n\n${program_name} is exiting.."
            exit 1
          fi
        fi    
        db_root_ssh=0
        db_root_with_nossh=$db_root_ssh_host
        echo -e "">> $LOGFIL
        break
      else
        echo -e "">> $LOGFIL
      fi 
    done
  fi

  if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
  then
  if [[ -n "$REQUIRE_ROOT" && $REQUIRE_ROOT -ge 1 ]] && [ $TYP = "-a" -o $TYP = "-b"  -o $TYP = "-u" ] && [ $userid -ne 0 ] && [[ -z $privilegechk || "$privilegechk" != "addr" ]] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ "$components" != "OVM" ] && [ $root_need_cell_ssh -eq 0 ] && [ $upgrade_mode -ne 2 ] && [ $askrootp -eq 1 ] && [ $only_hacheck_run -eq 0 ] && [ $ask_root_password -eq 1 ] && [ $db_root_ssh -eq 0 ] && [ $daemon_init_mode_sudo -eq 0 ]
  then
    
    susern='oracle'
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then userid=$SAVE_USERID; susern=$foxtrot_dom0_user; fi

    if [ $root_all_prompt -eq "1" ] ; then
      rootYesNo=1
    else
      echo -e "\n"
      echo -e "\n$REQUIRE_ROOT of the included audit checks require ${root_user} privileged data collection ${print_compute_node}. If sudo is not configured or the ${root_user} password is not available, audit checks which require ${root_user} privileged data collection can be skipped.\n"|tee -a $LOGFIL
      echo -e "\n1. Enter 1 if you will enter ${root_user} password for each ${print_compute_node} host when prompted"
      if [[ -n "$is_minicluster" && $is_minicluster -eq "0" ]]
      then
          echo -e "\n2. Enter 2 if you have sudo configured for ${susern} user to execute root_${program_name}.sh script ${print_compute_node}" 
      fi
      echo -e "\n3. Enter 3 to skip the ${root_user} privileged collections ${print_compute_node}"
      echo -e "\n4. Enter 4 to exit and work with system administrator to configure sudo ${print_compute_node} or to arrange for ${root_user} access and run the ${program_name} later.\n"
   
      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
        xml_print_compute_node="";
	print_nodetype=""
      else
        xml_print_compute_node="DATABASE SERVER"
	print_nodetype="Database"
      fi

      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
        <text nls_id="orhc_exadata_n41_nlsid">
        {1} of the included audit checks require {2} privileged data collection {3}. If sudo is not configured or the {4} password is not available, audit checks which require {5} privileged data collection can be skipped. 
        </text>
	<tokens>
	  <token index="1">$REQUIRE_ROOT</token>
	  <token index="2">$root_user</token>
	  <token index="3">$xml_print_compute_node</token>
	  <token index="4">$root_user</token>
	  <token index="5">$root_user</token>
        </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
      <text nls_id="orhc_exadata_n62_nlsid">For evaluating best practices on the {1} Nodes of a cluster, root level privileges are required on the nodes. Select one of the following options:</text>
      <tokens><token index="1">$print_nodetype</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n63_nlsid">Specify {1} password for each {2} Node</text>
	<tokens>
	  <token index="1">${root_user}</token>
	  <token index="2">${print_nodetype}</token>
	</tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <tokenizedtext>
        <text nls_id="orhc_exadata_n64_nlsid">Use 'sudo' to allow the '{3}' user to execute the root_{1}.sh script on the {2} Node</text>
        <tokens>
	  <token index="1">${program_name}</token>
	  <token index="2">${print_nodetype}</token>
	  <token index="3">${susern}</token>
	</tokens>
        </tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o3">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n65_nlsid">Skip {1} privileged collections on {2} Node</text>
	<tokens>
	  <token index="1">${root_user}</token>
	  <token index="2">${print_nodetype}</token>
	</tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o4" isTerminal="Y">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n66_nlsid">Exit and contact your systems administrator to configure sudo on {1} Node or to arrange for root access. Then, run the tool later</text>
	<tokens><token index="1">${print_nodetype}</token></tokens>
	</tokenizedtext>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
EOF

        if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
	then
	  cat >> ${PROBE_XML}.tmp <<EOF
    <tokenizedtext>
    <text nls_id="orhc_exadata_n85_nlsid">Use the same {1} password on all Database Nodes</text>
    <tokens><token index="1">${root_user}</token></tokens>
    </tokenizedtext> 
EOF
	else
	  cat >> ${PROBE_XML}.tmp <<EOF
    <tokenizedtext>
    <text nls_id="orhc_exadata_n86_nlsid">Use the same {1} password on all nodes</text>
    <tokens><token index="1">${root_user}</token></tokens>
    </tokenizedtext>
EOF
	fi
	cat >> ${PROBE_XML}.tmp <<EOF
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n67_nlsid">Enter {1} passwords</text>
    <tokens><token index="1">${root_user}</token></tokens>
    </tokenizedtext>
  </question>
EOF
	echo -e "\n\n"
	echo "Please indicate your selection from one of the above options for ${root_user} access[1-4][1]:- "
 	rootYesNo=3	
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
	echo -e "\n\n"
	echo "Please indicate your selection from one of the above options for ${root_user} access[1-4][1]:- "
	
	read_probe_xml "For evaluating best practices on the {1} Nodes of a cluster, root level privileges are required on the nodes" "1"
	rootYesNo=$xml_rvalue
      else
        exec 3<&2; exec 2<&0
        $READ -p  "Please indicate your selection from one of the above options for ${root_user} access[1-4][1]:- " rootYesNo
	read_code=`echo $?`;
        exec 2<&3
	process_prompt "$read_code" "rootYesNo" "3"
      fi
    fi

    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      print_nodetype="";
    else
      print_nodetype="compute"
    fi

    case $rootYesNo in
      1) 
        rootYesNoint=1
        if [[ -e $EXPECT ]]
        then
          if [ $root_all_prompt -eq "1" ] ; then
            samerootpassword_YesNo="y"
          else
            echo -e "\n"
             
            if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
            then      
	      if [[ $EM_XMLD_MODE -eq 1 ]]
	      then
                echo -e  "Is ${root_user} password same on all ${print_nodetype} nodes?[y/n][y]"
		
		read_probe_xml "Use the same {1} password on all Database Nodes"
		samerootpassword_YesNo=$xml_rvalue
	      else
                exec 3<&2; exec 2<&0
                $READ -p  "Is ${1} password same on all ${print_nodetype} nodes?[y/n][y]" samerootpassword_YesNo
		read_code=`echo $?`;
                exec 2<&3
		process_prompt "$read_code" "samerootpassword_YesNo" "y"
	      fi
            else
	      if [[ $EM_XMLD_MODE -eq 1 ]]
	      then
                echo -e  "Is ${root_user} password same on all nodes?[y/n][y]" 
		
		read_probe_xml "Use the same {1} password on all nodes"
		samerootpassword_YesNo=$xml_rvalue
	      else
                exec 3<&2; exec 2<&0
                $READ -p  "Is ${root_user} password same on all nodes?[y/n][y]" samerootpassword_YesNo
		read_code=`echo $?`;
                exec 2<&3
		process_prompt "$read_code" "samerootpassword_YesNo" "y"
	      fi
            fi
          fi
          case $samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              samerootpassword=1
              if [ $root_all_prompt -eq "1" ] ; then
                compute_rootpassword="$global_root_password"
              else
                echo -e "\n"
                printf  "Enter ${root_user} password ${print_compute_node}:- "
		if [[ $EM_XMLD_MODE -eq 1 ]]
	   	then
		  read_probe_xml "n67_nlsid"
		  compute_rootpassword=$xml_rvalue
		else
                  tty -s && stty -echo
                  $READ -r compute_rootpassword
                  tty -s && stty echo
		fi
              fi
              root_hostname=$(cat $HOSTLIST|head -1)
	      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
		compute_ssh_status=1
	      else
                compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
	      fi
              if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
              then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for ${root_user} user $NORM\n";
                echo "${root_user} password not checked on $root_hostname because ssh user equivalence found for ${root_user} ">>$LOGFIL
              else
                printf "\n\nVerifying ${root_user} password.\n\n. . ";

  		if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then 
                  node_ssh_user=$usern
                  if [[ `echo "$ea_dom0_nodes" | grep -ic "$root_hostname"` -le 0 ]]; then
                    node_ssh_user="${root_user}"
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                    checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                  else
                    node_ssh_user="${foxtrot_dom0_user}"
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                    efCheckrootPassword "$root_hostname" "$node_ssh_user" "${root_user}" "$compute_rootpassword"
		  fi		
		else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" ]]; then set +x; fi
                  checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
		fi

                printf ". ";
                if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
                then
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  find_switch_root_password=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  first_compute_ip=$(cat $HOSTLIST|head -1)  
                fi
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                compute_rootpassword=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              fi
              ;;
            n|N|No|NO|no)
              samerootpassword=0
              root_hostname_counter=0
              echo -e "\n"
              for root_hostname in `cat $HOSTLIST`
              do
                printf ". ";
                compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
                if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                then
		  echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for ${root_user} user $NORM\n";
                  echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for ${root_user} ">>$LOGFIL 
                else
		  echo -e "\n"
                  printf  "Enter ${root_user} password ${print_compute_node} $root_hostname :- "
		  if [[ $EM_XMLD_MODE -eq 1 ]]
		  then
		    read_probe_xml "<text>$root_hostname</text>"
		    compute_rootpassword=$xml_rvalue
		  else
                    tty -s && stty -echo
                    $READ -r compute_rootpassword
                    tty -s && stty echo
		  fi

                  printf "\n\nVerifying ${root_user} password.\n\n. . ";
  		  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then 
                    node_ssh_user=$usern
                    if [[ `echo "$ea_dom0_nodes" | grep -ic "$root_hostname"` -le 0 ]]; then
                      node_ssh_user="${root_user}"
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                      checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                    else
                      node_ssh_user="${foxtrot_dom0_user}"
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                      efCheckrootPassword "$root_hostname" "$node_ssh_user" "${root_user}" "$compute_rootpassword"
		    fi		
		  else
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                    checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
		  fi
                  printf ". ";
                  if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
                  then
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                    find_switch_root_password=$passwordToCheck
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                    first_compute_ip=$root_hostname
                  fi
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  compute_rootpassword=$passwordToCheck
                  a_compute_rootpassword[$root_hostname_counter]=$compute_rootpassword
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                fi
                root_hostname_counter=$(expr $root_hostname_counter + 1)
              done 
              ;;
            *)
              samerootpassword=1
              echo -e "\n"
              printf  "Enter ${root_user} password ${print_compute_node}:- "
              tty -s && stty -echo
              $READ -r compute_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${root_user} password.\n\n. . ";
              root_hostname=$(cat $HOSTLIST|head -1)
	      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
		compute_ssh_status=1
	      else
                compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
	      fi
              if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
              then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for ${root_user} user $NORM \n";
                echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
              else
  		if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then 
                  node_ssh_user=$usern
                  if [[ `echo "$ea_dom0_nodes" | grep -ic "$root_hostname"` -le 0 ]]; then
                    node_ssh_user="${root_user}"
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                    checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                  else
                    node_ssh_user="${foxtrot_dom0_user}"
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                    efCheckrootPassword "$root_hostname" "$node_ssh_user" "${root_user}" "$compute_rootpassword"
		  fi		
		else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
		fi
                printf ". ";
                if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
                then
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  find_switch_root_password=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  first_compute_ip=$(cat $HOSTLIST|head -1)  
                fi
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                compute_rootpassword=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              fi
              ;;
          esac 
        fi  
        ;;
      2) 
        rootYesNoint=2
        #Chaning it to same as no root password if somebody enters value 2 even though its not an choice in menu for minicluster 
         if [[ -n "$is_minicluster" && $is_minicluster -eq "1" ]]; then rootYesNoint=3;fi
        ;;
      3) 
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
          first_compute_ip=$(cat $HOSTLIST|head -1)
	  cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n56_nlsid">Enter the component's {1} user password</text>
    <tokens><token index="1">$root_user</token></tokens>
    </tokenizedtext>
    <multipart-question>
EOF
	  db_counter=1
	  for root_hostname in `cat $HOSTLIST`
	  do
            compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
            then
              echo
            else
	      cat >> ${PROBE_XML}.tmp <<EOF
    <question id="q${PROBE_QUES_CNT}o1q1o2q1q${db_counter}" questionType="SECRET" outcome="No">
      <text>$root_hostname</text>
    </question>
EOF
	      db_counter=$(expr $db_counter + 1)
	    fi
	  done
	  cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
          PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	fi
        rootYesNoint=3
        ;;
      4) 
        rootYesNoint=4
        echo -e "\nif the intent is to set up sudo configuration please have a ${root_user} privileged user add the following line to the end of sudoers file using /usr/sbin/visudo on each node of cluster.\n"   
        echo -e "${usern} ALL=(root) NOPASSWD:$HOME/root_${program_name}.sh\n"
        exit 1
        ;;
      *)
        rootYesNoint=1
        #if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $dbm_v2 -eq 1 ]]
        if [[ -e $EXPECT ]]
        then
          echo -e "\n"
           
          if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
          then      
            exec 3<&2; exec 2<&0
            $READ -p  "Is ${root_user} password same on all compute nodes?[y/n][y]" samerootpassword_YesNo
	    read_code=`echo $?`;
            exec 2<&3
	    process_prompt "$read_code" "samerootpassword_YesNo" "y"
          else
            exec 3<&2; exec 2<&0
            $READ -p  "Is ${root_user} password same on all nodes?[y/n][y]" samerootpassword_YesNo
	    read_code=`echo $?`;
            exec 2<&3
	    process_prompt "$read_code" "samerootpassword_YesNo" "y"
          fi

          case $samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            samerootpassword=1
            echo -e "\n"
            printf  "Enter ${root_user} password ${print_compute_node}:- "
            tty -s && stty -echo
            $READ -r compute_rootpassword
            tty -s && stty echo
            printf "\n\nVerifying ${root_user} password.\n\n. . ";
            root_hostname=$(cat $HOSTLIST|head -1)
	    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	      compute_ssh_status=1
	    else
              compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
	    fi
            if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
            then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for ${root_user} user $NORM \n";
              echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for ${root_user} ">>$LOGFIL
            else
  	      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then 
                node_ssh_user=$usern
                if [[ `echo "$ea_dom0_nodes" | grep -ic "$root_hostname"` -le 0 ]]; then
                  node_ssh_user="${root_user}"
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                else
                  node_ssh_user="${foxtrot_dom0_user}"
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  efCheckrootPassword "$root_hostname" "$node_ssh_user" "${root_user}" "$compute_rootpassword"
	        fi		
	      else
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
	      fi
              printf ". ";
              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                find_switch_root_password=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                first_compute_ip=$(cat $HOSTLIST|head -1)  
              fi
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              compute_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi
            ;;
          n|N|No|NO|no)
            samerootpassword=0
            root_hostname_counter=0
            echo -e "\n"
            for root_hostname in `cat $HOSTLIST`
            do
              printf ". ";
              compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
              then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for ${root_user} user $NORM \n";
                echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for ${root_user} ">>$LOGFIL 
              else
                printf  "Enter ${root_user} password ${print_compute_node} $root_hostname :- "
                tty -s && stty -echo
                $READ -r compute_rootpassword
                tty -s && stty echo
                printf "\n\nVerifying ${root_user} password.\n\n. . ";
  	        if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then 
                  node_ssh_user=$usern
                  if [[ `echo "$ea_dom0_nodes" | grep -ic "$root_hostname"` -le 0 ]]; then
                    node_ssh_user="${root_user}"
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                    checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                  else
                    node_ssh_user="${foxtrot_dom0_user}"
		    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                    efCheckrootPassword "$root_hostname" "$node_ssh_user" "${root_user}" "$compute_rootpassword"
	          fi		
	        else
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
		fi
                printf ". ";
                if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
                then
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  find_switch_root_password=$passwordToCheck
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                  first_compute_ip=$(cat $HOSTLIST|head -1)  
                fi
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                compute_rootpassword=$passwordToCheck
                a_compute_rootpassword[$root_hostname_counter]=$compute_rootpassword
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              fi
              root_hostname_counter=$(expr $root_hostname_counter + 1)
            done 
            ;;
          *)
            samerootpassword=1
            echo -e "\n"
            printf  "Enter ${root_user} password ${print_compute_node}:- "
            tty -s && stty -echo
            $READ -r compute_rootpassword
            tty -s && stty echo
            root_hostname=$(cat $HOSTLIST|head -1)
	    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
	      compute_ssh_status=1
	    else
              compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
	    fi
            if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
            then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for ${root_user} user $NORM \n";
              echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
            else
              printf "\n\nVerifying ${root_user} password.\n\n. . ";
  	      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then 
                node_ssh_user=$usern
                if [[ `echo "$ea_dom0_nodes" | grep -ic "$root_hostname"` -le 0 ]]; then
                  node_ssh_user="${root_user}"
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                else
                  node_ssh_user="${foxtrot_dom0_user}"
		  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                  efCheckrootPassword "$root_hostname" "$node_ssh_user" "${root_user}" "$compute_rootpassword"
	        fi		
	      else
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
	      fi
              printf ". ";
              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                find_switch_root_password=$passwordToCheck
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                first_compute_ip=$(cat $HOSTLIST|head -1)  
              fi
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              compute_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi
            ;;
          esac 
        fi
      ;;
    esac
  else
    #if [ $NOQUESTION = "1" ]
    if [[ $NOQUESTION = "1" && $daemon_running -eq 0 ]] && [ $DOROOT = "1" ]
    then
      rootYesNoint=2
    elif [ $daemon_init_mode_sudo -eq 1 ]
    then 
      rootYesNoint=2    
    else
      if [[ $root_user_allowed -eq "1" ]] && [[ "$usern" = "${root_user}" || $userid -eq 0 ]] ; then
        rootYesNoint=1
      elif [ $db_root_ssh -eq 1 ]
      then
        rootYesNoint=1
        samerootpassword=1
      else
        rootYesNoint=3
      fi
    fi
  fi 
  fi #acchk

  #if [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq 1 || $is_exalogic_foxtrot -eq 1 ]] ; then rootYesNoint=1; fi;
  if [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq 1 ]] ; then rootYesNoint=1; fi;

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
    echo "ROOT_OPTION = $rootYesNoint" >>$MASTERFIL
    echo "$show_version_envfile">>$MASTERFIL
  fi
  #following code is to check that if data file does not have pathcing info, it should only check the best praotices
  #if [[ $SILENT -eq 0 || $SILENT -eq 1 ]]
  #if [[ -n "$rootYesNoint" && $rootYesNoint -eq 1 && ! -e /tmp/o_ibswitches.out && -n "$RAT_CELL_SSH" ]]

  if [[ -n "$rootYesNoint" && $rootYesNoint -eq 1 && ! -e ${RTEMPDIR}/o_ibswitches.out ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]] || [[ -n "$rootYesNoint" && $rootYesNoint -eq 1 &&  -e ${RTEMPDIR}/o_ibswitches.out && `cat ${RTEMPDIR}/o_ibswitches.out|wc -l` -eq 0 ]]
  then
    extract_ibswitches
  fi

  if [[ $EM_PROBE_MODE -eq 1 ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
  then
    eibsw="N"
    if [ ! -e ${RTEMPDIR}/o_ibswitches_full.out ]
    then
      eibsw="Y"
    else
      if [[ -s ${RTEMPDIR}/o_ibswitches_full.out ]] || [[ `cat ${RTEMPDIR}/o_ibswitches.out|wc -l` -eq 0 ]]
      then
        eibsw="Y"
      fi
    fi

    if [[ $eibsw = "Y" ]]
    then
      extract_ibswitches
    fi
  fi

  #following code is find infiniband switches from first cells   
  if [ -e ${RTEMPDIR}/o_ibswitches_full.out ]
  then
    for switchname in `grep -vwi gw ${RTEMPDIR}/o_ibswitches_full.out|cut -d'"' -f2|awk {'print $NF}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1`
    do	
      printf ". ";
      #$PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
      #switchping_status=$(echo $?)

      is_ibswitch_ip=$(echo $switchname|grep -c '[A-Za-z]')
      if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
      then
        switchname_ip=$switchname
        switchname=$(cat ${RTEMPDIR}/o_ibswitches_full.out|grep -w "$switchname_ip"|grep -vwi gw|cut -d'"' -f2|awk {'print $(NF-1)}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1)
      fi

      if [ -n "$switchname" ]
      then
        test_node_reachability $switchname "root" "$switchname_ip" "Infiniband switch";
        if [ $el_node_ping -eq "1" ] ; then
          switchping_status=0;
	  echo $switchname>>${RTEMPDIR}/o_ibswitches.out;
        else
          switchping_status=1;
	  add_to_skipped_nodes "$switchname" "$tnr_note"
        fi
      fi
    done
    rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
    cp -f ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  fi

  ask_switch_password=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_switch_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_switch_checks -eq "0" ]] || [[ -n "$dbm_vm" && "$dbm_vm"  -eq 1 ]] || [[ -n "$is_ssc_localzone_machine" && "$is_ssc_localzone_machine"  -eq 1 ]] || [[ -n $is_bda_dom0 && $is_bda_dom0 -eq "1" && $profiles2run != *"switch"* ]] || [[ -n $is_bda_domu && $is_bda_domu -eq "1" && $profiles2run != *"switch"* ]]; then
    ask_switch_password=0
  fi
  if [[ -n "$debug_in_profile" && $debug_in_profile -gt 0 ]]; then ask_switch_password=1;fi
  exa_or_bda_machine=0
  if [[ -n "$exa_machine" && $exa_machine -eq 1 ]] || [[ -n "$bda_machine" && $bda_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq 1 ]];
  then
    exa_or_bda_machine=1;
  fi
      
  if [[ -n "$exa_or_bda_machine" && $exa_or_bda_machine -eq 1 && -e ${RTEMPDIR}/o_ibswitches.out ]] && [[ $is_exalogic_machine -eq 1 || $dbm_v2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $is_bda_machine -eq 1 || $is_exalogic_foxtrot -eq 1 ]] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ $ask_switch_password -eq "1" ]
  then
    ibswitch_root_command=9
    if [ -z "$RAT_IBSWITCH_USER" ]
    then 
      if [[ $is_exalogic_machine -eq 1 || $is_bda_machine -eq 1 || $is_exalogic_foxtrot -eq 1 ]]
      then
        ibswitch_user="root"
        ibswitch_user_noformat=${root_user}
      else
        if [ "$usern" = "${root_user}" ]
        then 
          ibswitch_user="root"
          ibswitch_user_noformat=$ibswitch_user
          ibswitch_user=${RED}${ibswitch_user}${NORM}   
        else
          ibswitch_user="nm2user"
          ibswitch_user_noformat=$ibswitch_user
          ibswitch_user=${RED}${ibswitch_user}${NORM}   
        fi
      fi
    else 
      ibswitch_user=$RAT_IBSWITCH_USER
      ibswitch_user_noformat=$RAT_IBSWITCH_USER
    fi

    ibs_equivalency=1
    for switchname in `cat ${RTEMPDIR}/o_ibswitches.out`
    do
      ibs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user_noformat $switchname ls >/dev/null 2>&1;echo $?);
      if [[ -n "$ibs_ssh_status" && $ibs_ssh_status -ne 0 ]] 
      then 
        if [[ $daemon_init_mode -eq 1 && -n "$ibs_ssh_status" && $ibs_ssh_status -ne 0 ]]
        then
          echo -e "\n${ibswitch_user_noformat} user equivalence is not setup between $localnode and ${BLINK}InfiniBand switch ${switchname}."
          echo -e "\n\n${program_name} is exiting.."
          log_daemon "\n${ibswitch_user_noformat} user equivalence is not setup between $localnode and ${BLINK}InfiniBand switch ${switchname}."
          log_daemon "\n\n${program_name} is exiting.."
          exit 1
        fi  
        ibs_equivalency=0
        ibswitch_with_nossh=$switchname
        echo -e "\n ssh user equivalence not found for $ibswitch_user_noformat on ${switchname}\n">> $LOGFIL  
      else
	echo -e "\n$GREEN ${switchname} is configured for ssh user equivalency for $ibswitch_user_noformat user $NORM \n";
        echo -e "\n ssh user equivalence found for $ibswitch_user_noformat on ${switchname}\n">> $LOGFIL
      fi
    done

    if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] ; then
      echo "Validating root password on INFINIBAND SWITCH"
      echo 
      ibswitch_YesNo=1
    else
      if [ $ibs_equivalency = 0 ]
      then
      	echo -e "\n"
        echo -e "\n${ibswitch_root_command} of the included audit checks require ${ibswitch_user} privileged data collection on ${BLINK}INFINIBAND SWITCH${NORM} .\n"|tee -a $LOGFIL
      	echo -e "\n1. Enter 1 if you will enter ${ibswitch_user} password for each ${BLINK}INFINIBAND SWITCH${NORM} when prompted"
        echo -e "\n2. Enter 2 to exit and to arrange for ${ibswitch_user} access and run the ${program_name} later."
        echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}INFINIBAND SWITCH${NORM}\n"
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_SC}" groupHeader="${GID_SC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <text nls_id="orhc_exadata_n70_nlsid">For evaluating best practices on the InfiniBand switches of a cluster, root level privileges are required on the switches. Select one of the following options:</text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n71_nlsid">Specify {1} password for each InfiniBand switch</text>
	<tokens><token index="1">$ibswitch_user_noformat</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" isTerminal="Y">
 	<tokenizedtext>
        <text nls_id="orhc_exadata_n60_nlsid">Exit and configure {1} user equivalence manually and re-run ${program_name}</text>
	<tokens><token index="1">$ibswitch_user_noformat</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o3">
        <text nls_id="orhc_exadata_n72_nlsid">Skip checking best practices on Infiniband switch</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n73_nlsid">Use the same {1} password on all Infiniband switches</text>
    <tokens><token index="1">$ibswitch_user_noformat</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n83_nlsid">Enter {1} password</text>
    <tokens><token index="1">$ibswitch_user_noformat</token></tokens>
    </tokenizedtext>
  </question>
EOF
	  echo -e "\n\n"
	  echo -e "Please indicate your selection from one of the above options for INFINIBAND SWITCH[1-3][1]:- "
	  ibswitch_YesNo=3
	elif [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  echo -e "\n\n"
	  echo -e "Please indicate your selection from one of the above options for INFINIBAND SWITCH[1-3][1]:- "
		    
	  read_probe_xml "For evaluating best practices on the InfiniBand switches of a cluster, root level privileges are required on the switches" "1"
	  ibswitch_YesNo=$xml_rvalue
	else
      	  exec 3<&2; exec 2<&0
          $READ -p  "Please indicate your selection from one of the above options for INFINIBAND SWITCH[1-3][1]:- " ibswitch_YesNo
	  read_code=`echo $?`;
      	  exec 2<&3
	  process_prompt "$read_code" "ibswitch_YesNo" "3"
	fi
      else
      	ibswitch_YesNo=1			
      fi
    fi

    if [ -n "$ibswitch_user_noformat" ]; then ibswitch_user=$ibswitch_user_noformat;fi 

    case $ibswitch_YesNo in
      1)
        ibswitch_password_status=1
        if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] || [[ $ibs_equivalency -eq 1 ]]; then
          ib_samerootpassword_YesNo="y"
        else
          echo -e "\n"
	  if [[ $EM_XMLD_MODE -eq 1 ]]
	  then
            echo -e  "Is $ibswitch_user password same on all INFINIBAND SWITCH ?[y/n][y]"
	
	    read_probe_xml "Use the same {1} password on all Infiniband switches"
	    ib_samerootpassword_YesNo=$xml_rvalue
	  else
            exec 3<&2; exec 2<&0
            $READ -p  "Is $ibswitch_user password same on all INFINIBAND SWITCH ?[y/n][y]" ib_samerootpassword_YesNo
	    read_code=`echo $?`;
            exec 2<&3
	    process_prompt "$read_code" "ib_samerootpassword_YesNo" "y"
	  fi
        fi
        case $ib_samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            ib_samerootpassword=1
            echo -e "\n"
            if [ -n "$ibswitch_with_nossh" ]; then root_hostname=$ibswitch_with_nossh;else root_hostname=$(cat ${RTEMPDIR}/o_ibswitches.out|head -1);fi
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);

            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for $ibswitch_user user $NORM \n";
              echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n">> $LOGFIL
            else
              if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] ; then
                switch_rootpassword="$global_root_password"
              else
                printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
		if [[ $EM_XMLD_MODE -eq 1 ]]
		then
		  read_probe_xml "n83_nlsid"
		  switch_rootpassword=$xml_rvalue
		else
                  tty -s && stty -echo
                  $READ -r switch_rootpassword
                  tty -s && stty echo
		fi
                printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
              fi
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch"
              printf ". ";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              switch_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi  
            ;;
          n|N|No|NO|no)
            ib_samerootpassword=0
            ib_root_counter=0
            echo -e "\n"  
            for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
            do
              printf ". ";
              switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
              then
		echo -e "\n$GREEN $switchname is configured for ssh user equivalency for $ibswitch_user user $NORM \n";
                echo -e "\n$ibswitch_user password not checked on $switchname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
              else
                printf "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} ${switchname} :- "
		if [[ $EM_XMLD_MODE -eq 1 ]]
		then
		  read_probe_xml "<text>$switchname</text>"
		  switch_rootpassword=$xml_rvalue
		else
                  tty -s && stty -echo
                  $READ -r switch_rootpassword
                  tty -s && stty echo
		fi

                printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
                printf ". ";
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                switch_rootpassword=$passwordToCheck
                a_ib_switch_root_password[$ib_root_counter]=$switch_rootpassword
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
              fi
              ib_root_counter=$(expr $ib_root_counter + 1 )
            done
            ;;
          *)
            ib_samerootpassword=1
            echo -e "\n"
            if [ -n "$ibswitch_with_nossh" ]; then root_hostname=$ibswitch_with_nossh;else root_hostname=$(cat ${RTEMPDIR}/o_ibswitches.out|head -1);fi
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for $ibswitch_user user $NORM \n";
              echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
            else
              printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
              printf ". ";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              switch_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi 
            ;;
        esac 
        ;;
      2)
        ibswitch_password_status=2
        exit 1 
        ;;
      3)
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  ib_counter=1
	  cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n56_nlsid">Enter the component's {1} user password</text>
    <tokens><token index="1">$ibswitch_user</token></tokens>
    </tokenizedtext>
    <multipart-question>
EOF
	  qib_counter=1
          for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
          do
            printf ". ";
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
              echo
            else
	      cat >> ${PROBE_XML}.tmp <<EOF
    <question id="q${PROBE_QUES_CNT}o1q1o2q1q${qib_counter}" questionType="SECRET" outcome="No">
    <text>$switchname</text>
  </question>
EOF
            fi
            qib_counter=$(expr $qib_counter + 1 )
            ib_counter=$(expr $ib_counter + 1 )
          done
          cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
          PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	fi
        ibswitch_password_status=3
        ;;
      *)
        ibswitch_password_status=1
        echo -e "\n"
        exec 3<&2; exec 2<&0
        $READ -p  "Is $ibswitch_user password same on all INFINIBAND SWITCH ?[y/n][y]" ib_samerootpassword_YesNo
	read_code=`echo $?`;
        exec 2<&3
	process_prompt "$read_code" "ib_samerootpassword_YesNo" "y"
        case $ib_samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            ib_samerootpassword=1
            echo -e "\n"
            if [ -n "$ibswitch_with_nossh" ]; then root_hostname=$ibswitch_with_nossh;else root_hostname=$(cat ${RTEMPDIR}/o_ibswitches.out|head -1);fi
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for $ibswitch_user user $NORM \n";
              echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
            else
              printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
              printf ". ";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              switch_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi
            ;;
          n|N|No|NO|no)
            ib_samerootpassword=0
            ib_root_counter=0
            echo -e "\n"  
            for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
            do
              switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
              then
		echo -e "\n$GREEN $switchname is configured for ssh user equivalency for $ibswitch_user user $NORM \n";
                echo -e "\n$ibswitch_user password not checked on $switchname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
              else
                printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} ${switchname} :- "
                tty -s && stty -echo
                $READ -r switch_rootpassword
		read_code=`echo $?`;
                tty -s && stty echo
                printf "\nVerifying $ibswitch_user password.\n\n. . ";
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP"  ]]; then set +x; fi
                checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
                printf ". ";
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP"  ]]; then set +x; fi
                switch_rootpassword=$passwordToCheck
                a_ib_switch_root_password[$ib_root_counter]=$switch_rootpassword
		if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP"  ]]; then set -x; fi
              fi
              ib_root_counter=$(expr $ib_root_counter + 1 )
            done
            ;;
          *)
            ib_samerootpassword=1
            echo -e "\n"
            if [ -n "$ibswitch_with_nossh" ]; then root_hostname=$ibswitch_with_nossh;else root_hostname=$(cat ${RTEMPDIR}/o_ibswitches.out|head -1);fi
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
		echo -e "\n$GREEN $root_hostname is configured for ssh user equivalency for $ibswitch_user user $NORM \n";
              echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
            else
              printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
	      read_code=`echo $?`;
              tty -s && stty echo
	      process_prompt "$read_code" "switch_rootpassword" ""
              printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
              printf ". ";
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
              switch_rootpassword=$passwordToCheck
	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
            fi  
            ;;
        esac
        ;;
    esac
    if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
      echo "IBSWITCH_PASSWORD_OPTION = $ibswitch_password_status" >>$MASTERFIL
      echo "IBSWITCH_PASSWORD_OPTION = $ibswitch_password_status" >>$LOGFIL
    fi
  fi

  #echo "cell_ssh_status=$cell_ssh_status">>$LOGFIL
  #lets print the nodes where root passwords are not working and ask user what does he want to do.

  if [[ -n "$noRootScriptNode" && ${#noRootScriptNode[@]} -gt 0 ]]
  then
    echo -e "${RED}root passwords are incorrect or login to as root is disabled in ssh configuration for following nodes.\n\nYou can still continue but root privileged checks will not be executed on following nodes.\n${NORM}"
    nodesNoRootPasswordCounter=1
    for nodesNoRootPassword in ${noRootScriptNode[*]}
    do
      echo -e "$nodesNoRootPasswordCounter. $nodesNoRootPassword\n"
      echo "Incorrect ${root_user} password for $nodesNoRootPassword">>$LOGFIL
      nodesNoRootPasswordCounter=$(expr $nodesNoRootPasswordCounter + 1 )
    done
    nodesNoRootPasswordCounter=0
    printf "Do you want to continue[y/n][y]:- "
    $READ nodesNoRootPasswordYesNO
    read_code=`echo $?`;
    process_prompt "$read_code" "nodesNoRootPasswordYesNO" "y"
    case $nodesNoRootPasswordYesNO in
      y|Y|yes|YES|Yes) ;;
      n|N) 
	echo ""
        echo -e "${RED}\nPlease collect all ${root_user} passwords and run $program_name again.\n${NORM}"  
        exit 1
        ;;
      *)
       ;;
    esac    
    echo -e "\n" 
  fi 

  echo -e "\n" 
  #Stop here in daemon mode
  if [[ -n "$daemon_mode" && $daemon_mode -eq "1" ]] ; then
    mkdir $RTEMPDIR_D >/dev/null 2>&1;

    get_program_key
    export RAT_PROGRAM_KEY=$program_key
    if [ -n "$CRS" ] ; then export CRS_HOME=$CRS; fi
    export RAT_DAEMONDEB_INTERNAL=$DAEMONDEB

    ( 
      if [[ -n "$RAT_DAEMON_DEBUG" && $RAT_DAEMON_DEBUG -eq "1" ]] ; then set -x; fi

      keep_running=1 
      loop_cnt_autorun=0
      while [ $keep_running -eq "1" ] ;do
        loop_cnt_autorun=$(expr $loop_cnt_autorun + 1)
        if [ -e "$RTEMPDIR_D/commands" ] ; then
          handle_client_request;
        elif [ -e "$RTEMPDIR_D/stop" ] ; then
          stop_daemon_actual;
        elif [[ $loop_cnt_autorun -eq "10" ]] ; then
          loop_cnt_autorun=0
          started_autorun=0
          start_auto_run
          if [[ $started_autorun -eq "0" ]] && [[ $daemon_init_mode -eq "0" ]] ; then
            check_daemon_passwords
	    rotate_daemon_logs
          fi
	  if [[ $started_autorun -eq "0" ]] && [[ $daemon_init_mode -eq "1" ]]; then
	    upgrade_program_daemon
	  fi
        fi
        sleep 5;
      done
    ) >> $DAEMONDEB 2>&1 &
    dpid=$!
    echo $dpid > $RTEMPDIR_D/daemon.pid
    if [ "$daemon_init_mode" -eq "0" ] ; then
      rm -f $WRKDIR/${program_name}_daemon.log
    fi

    update_daemon_file

    echo "${program_name} daemon is started with PID : $dpid";
    log_daemon "${program_name} daemon is started with PID : $dpid";
    echo "Daemon log file location is : $WRKDIR/${program_name}_daemon.log";
    if [[ -n "$daemon_command" && $daemon_command = "start" && $RAT_DAEMON_DEBUG -eq "1" ]]
	then
	echo "Daemon debug log file location is : $WRKDIR/${program_name}_daemon_debug.log";
    fi
    cp -f $HOSTLIST $RTEMPDIR_D/.hosts.txt
    if [[ -n "$CELLIP" && -e "$CELLIP" ]] ; then cp -f $CELLIP $RTEMPDIR_D/.cells.txt; fi
    if [[ -n "$ZFSIP" && -e "$ZFSIP" ]] ; then cp -f $ZFSIP $RTEMPDIR_D/.zfs.txt; fi
    if [[ -n "${RTEMPDIR}/o_ibswitches.out" && -e "${RTEMPDIR}/o_ibswitches.out" ]] ; then cp -f ${RTEMPDIR}/o_ibswitches.out $RTEMPDIR_D/.ibs.txt; fi

    write_dnow_init

    if [[ -n "$run_args" ]] ; then
      argsaved=$run_args
      cleanup
      $PDIR/${program_name} $run_args
      exit 0
    else
      exit 0;
    fi
  fi

  if [[ $EM_PROBE_MODE -eq 1 ]] ; then finish_em_xml; fi

  if [ $SILENT -eq 0 ]
  then
    no_patch_rollup=0 
    no_patch_rollup=`grep -ic "NO Patch rollup selected" $REFFIL1`
    
    #$READ -p "TYP=$TYP no_patch_rollup=$no_patch_rollup REFFIL1=$REFFIL1"
  fi
  if [[ $TYP != "-b" && $no_patch_rollup -gt 0 ]]
  then
    no_patches=1
    echo -e $RED"\nThe driver file does not have information about either OS or database patches. Therefore it will check `uname` best practices only. $NORM \n"
    echo -e "\nThe script does not have information about either OS or database patches.  Therefore it will check `uname` best practices only.\n" >>$LOGFIL
    TYP="-b" 
  fi

  if [ $upgrade_mode -eq 2 ]
  then 
    echo -e "\nChecking Grid Infrastructure and RDBMS upgrade readiness to version ${targetversion}\n"
    #if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]; then $READ -p "Press enter to  continue.....";fi
  else
    if [ $TYP != "-p" ] 
    then
      echo -e "\n*** Checking Best Practice Recommendations ("$GREEN"PASS"$NORM"/"$ORANGE"WARNING"$NORM"/"$RED"FAIL"$NORM") ***\n"
      echo "*** Checking Best Practice Recommendations ***\n" >>$LOGFIL
    fi
  fi
  #echo -e $GREEN"Beginning data collection for RAC using current environment settings...\n"$NORM
  #echo "Beginning data collection for RACusing current environment settings...\n" >>$LOGFIL
  #CODE TO CHECK THAT CLUSTER IS UP ON LOCAL NODE AND IF NOT,SCRIPT WILL TERMINATE
  #is_crs_up

 if [[ -z "$run_acchk" || $run_acchk -eq "0" ]]
  then
  if [ $TYP != "-p" ]
  then
    if [ ${crs_up} -eq 1  ]
    then
      #echo -e $GREEN"CRS appears to be up on `hostname`.\n"$NORM
      echo "CRS appears to be up.\n" >>$LOGFIL
    else
      if [[ $crs_installed -eq 1 ]]
      then
        #echo -e $RED"CRS appears to be down.  Skipping all CRS related audit checks. $NORM \n"
        echo "CRS appears to be down.  Skipping all CRS related audit checks.\n" >>$LOGFIL
      fi
    fi
  fi
 fi
    
  #echo "SQLNUM = $SQLNUM"
  #echo "DEBUG just before grepping for DB_VERSION"
  #### Create a master file to store database about a run and store in master table
  #SCRIPTVER=`grep DB_VERSION $REFFIL |awk {'print $3'} |sed -n 's///p'`
  #SCRIPTVER=`grep DB_VERSION $REFFIL |awk {'print $3'}` 
  #### Create a master file to store database about a run and store in master table
  #FILEDATE=`grep FILE_DATE $REFFIL|sed -n 's///p'`

  if [ $op_mode -eq 0 ]
  then
    get_winpath "REFFIL"
    FILEID=`$GREP FILE_ID $REFFIL`
    FILEDATE=`$GREP FILE_DATE $REFFIL`
    FILESIG=`$GREP FILE_SIG $REFFIL`
    DBPLATFORM=`$GREP DB_PLATFORM $REFFIL`
    OSDISTRO=`$GREP OS_DISTRO $REFFIL`
    OSVERSION=`GREP OS_VERSION $REFFIL`
    OSKERNEL=`GREP OS_KERNEL $REFFIL`
    restore_winpath "REFFIL"
  elif [ $op_mode -eq 1 ]
  then
    get_winpath "reffil_old"
    FILEID=`$GREP FILE_ID $reffil_old`
    FILEDATE=`$GREP FILE_DATE $reffil_old`
    FILESIG=`$GREP FILE_SIG $reffil_old`
    restore_winpath "reffil_old"
    if [ `uname -s` = "HP-UX" ]
    then
      DBPLATFORM=$(echo DB_PLATFORM = $os_arch_env_file)
    elif [ $(uname -p 2>/dev/null) = "s390x" ]
    then
      DBPLATFORM=$(echo DB_PLATFORM = "Linux on System z")
    else
      DBPLATFORM=$(echo DB_PLATFORM = $os_name $os_arch_env_file|tr "[a-z]" "[A-Z]")
    fi
    OSDISTRO=$(echo OS_DISTRO = $os_type_full)
    OSVERSION=$(echo OS_VERSION = $os_version)
    OSKERNEL=$(echo OS_KERNEL = `uname -r`)
  fi

  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  echo $FILEID>>$MASTERFIL
  echo $FILEDATE>>$MASTERFIL
  echo $FILESIG>>$MASTERFIL
  #DBVERSION=`grep DB_VERSION $REFFIL`
  #echo "DB_VERSION=$DBVERSION">>$MASTERFIL
  echo $DBPLATFORM>>$MASTERFIL
  upload_dbplatform=$(echo $DBPLATFORM|cut -d= -f2|sed 's/^\s//g'|sed 's/\s$//g')
  echo $OSDISTRO>>$MASTERFIL
  upload_osdistro=$(echo $OSDISTRO|cut -d= -f2|sed 's/^\s//g'|sed 's/\s$//g')
  echo $OSVERSION>>$MASTERFIL
  upload_osversion=$(echo $OSVERSION|cut -d= -f2|sed 's/^\s//g'|sed 's/\s$//g')
  echo $OSKERNEL>>$MASTERFIL
  upload_oskernel=$(echo $OSKERNEL|cut -d= -f2|sed 's/^\s//g'|sed 's/\s$//g')
  #echo "COLLECTION DATE = `date '+%d-%b-%Y %H:%M:%S'`">>$MASTERFIL
  collection_date=`date '+%d-%b-%Y %H:%M:%S'` 
  echo "COLLECTION DATE = $collection_date">>$MASTERFIL
  echo "SILENT = $SILENT" >>$MASTERFIL
  echo "SWITCH = $TYP">>$MASTERFIL

  if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
    echo ""
  else
    echo "ASM_HOME = $ASM_HOME">>$MASTERFIL
  fi

  echo "${ORACLE_SID}_UP = $db_up">>$MASTERFIL
  echo "SOMEDB_UP = $somedb_up">>$MASTERFIL
  echo "LOCALNODE = $localnode">>$MASTERFIL
  if [ -n $cluster_name ]
  then
    echo "CLUSTER_NAME = $cluster_name">>$MASTERFIL
  fi  
  fi
   
  #put in the OS specific code in following block 

  #the database instance needs to be running in order to do the database checks
  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 0 ]]; then
  if [[ $TYP != "-p" && $multiple_db -eq 0 ]]
  then
    if [[ ${stack_dbinst_up[$stack_counter]} -ne 0 ]]
    then
      echo -e $GREEN"Database instance $ORACLE_SID appears to be up on `hostname`.  Running audit checks on $ORACLE_SID instance"$NORM>>$LOGFIL
      echo "Database instance $ORACLE_SID appears to be up on `hostname`.  Running audit checks on $ORACLE_SID instance" >>$LOGFIL
      echo ""
      singleSqlValue "version" "instance" "v"
      VERSION=$sqlValue
      VERSION=$(echo $VERSION|awk '{print $3}')
      if [ "$VERSION" != "$DBVERSION" ]
      then
        #echo -e $RED"Audit script version ($DBVERSION) and database version ($VERSION) do not match"$NORM
        echo "Audit script version ($DBVERSION) and database version ($VERSION) do not match" >>$LOGFIL
        #echo ""
        #echo -e $RED"terminating audit check..."$NORM
        #echo "terminating audit check..." >>$LOGFIL
        #exit 1
      fi
    else
      if [[ ${rdbms_installed[$stack_counter]} -eq 1 ]]
      then
        #echo -e $RED"Database $db_name_to_check appears to be down. Skipping database related audit checks.$NORM \n"
        echo "Database instance $db_name_to_check appears to be down.  Skipping database related audit cheks.\n">>$LOGFIL
      fi
    fi
  fi

  #$READ -p "$SQLNUM $db_up"
  SQLNUM=`grep -c SQL_COMMAND_START $REFFIL`
  SQLCOLNUM=`grep -c SQL_COLLECT_COMMAND_START $REFFIL`
  if [[ $SQLNUM -eq 0 && $run_check -eq 1 ]]
  then
    SQLNUM=1
  fi
  #for loop for muliple database sql collect to start here

  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do 
    mb_db_names_list=$db_name_to_check,$mb_db_names_list
    echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Initial SQL COllections started for $db_name_to_check\n">>$RACCHECK_TIMING
    sql_return_status=0
    SQLFIL=$OUTPUTDIR/d_check_${db_name_to_check}.sql
    UPDATEFIL=$OUTPUTDIR/db_update_${db_name_to_check}_$FDS.sql
    SPOOLFIL=$OUTPUTDIR/d_check_${db_name_to_check}.out      
    #if [[ $oracle_restart -eq "0" ]] ; then
    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
    export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
    DBUSR=${mb_sysdba_user[$mb_db_counter]}
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
    DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    #fi
    #if [[ "$SQLNUM" -gt 0 && $TYP != "-p" ]] && [[ ${stack_db_status[$mb_db_counter]} -ne 0 || ${stack_dbinst_up[$stack_counter]} -ne 0 ]]

    #if [[ "$SQLNUM" -gt 0 && $TYP != "-p" ]]
    if [[ "$SQLNUM" -gt 0 ]]
    then 
      #Collecting stuff fro MAA
      if [[ -z $ORACLE_HOME ]]; then continue; fi
      singleSqlValue "open_mode" "database" "v"
      openMode=$sqlValue
      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "0" && "${mb_database_type[$mb_db_counter]}" != "PDB" ]]; then
        VERSION=$(grep -w "DB_NAME = $db_name_to_check" $MASTERFIL|awk '{print $3}'|cut -d '|' -f2)
        mb_database_role[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_ROLE" $MASTERFIL|awk '{print $3}')
        dbRole="DATABASE_ROLE = ${mb_database_role[$mb_db_counter]}"
	DB=$db_name_to_check
      elif [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" && $CRS12 -eq "1" && "${mb_database_type[$mb_db_counter]}" != "PDB" ]]; then
        mb_database_role[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_ROLE" $MASTERFIL|awk '{print $3}')
        dbRole="DATABASE_ROLE = ${mb_database_role[$mb_db_counter]}"
	DB=$db_name_to_check
        singleSqlValue "version" "instance" "v"
        VERSION=$sqlValue
        VERSION=$(echo "$VERSION"|awk '{print $3}')
        sed -e "s,DB_NAME = $db_name_to_check||$ORACLE_HOME,DB_NAME = $db_name_to_check|$VERSION|$ORACLE_HOME," $MASTERFIL > $MASTERFIL.bak && mv -f $MASTERFIL.bak $MASTERFIL
      else
        singleSqlValue "database_role" "database" "v"
        dbRole=$sqlValue
        singleSqlValue "version" "instance" "v"
        VERSION=$sqlValue
        VERSION=$(echo "$VERSION"|awk '{print $3}')
        echo "DB_NAME = $db_name_to_check|$VERSION|$ORACLE_HOME">>$MASTERFIL
        #$READ -p " see DB_VERSION $VERSION in $MASTERFIL"
        DB=$db_name_to_check
        mb_database_role[$mb_db_counter]=$(echo "$dbRole"|$AWK -F"=" '{print $2}'|cut -d ' ' -f2-3|sed 's/ /_/')
        if [ -z "${mb_database_role[$mb_db_counter]}" ]; then mb_database_role[$mb_db_counter]=$(echo "$dbRole"|$AWK '{print $3}'|sed 's/ /_/');fi
        echo "${db_name_to_check}.DATABASE_ROLE = ${mb_database_role[$mb_db_counter]}">>$MASTERFIL
      fi
		
      if [ -z "${mb_database_type[$mb_db_counter]}" ]; then
      	mb_database_type[$mb_db_counter]="NORMAL"
      	multipleSqlValue "select upper(cdb) from v\$database"
      
      	if [ "$sqlValue" = "YES" ]
        then
      	  mb_database_type[$mb_db_counter]="CDB"
      	fi
      fi
      echo "${db_name_to_check}.DATABASE_TYPE = ${mb_database_type[$mb_db_counter]}">>$MASTERFIL

      if [ "$RAT_DB_APP_USER" = "apps" ]
      then
      	get_app_user "$db_name_to_check"
      else
	echo "${db_name_to_check}.DATABASE_APP_USER = $RAT_DB_APP_USER" >>$MASTERFIL
	mb_database_app_user[$mb_db_counter]=$RAT_DB_APP_USER;
      fi

      if [[ -z $RAT_LEGACY_DISCOVERY && $crs_up -eq "1" ]]; then
        mb_database_global_name[$mb_db_counter]=$(grep -w "${db_name_to_check}.GLOBAL_NAME" $MASTERFIL|awk '{print $3}')
	global_name=${mb_database_global_name[$mb_db_counter]}
      else
        if [[ ${#mb_database_role[@]} -gt 0 && ${mb_database_role[$mb_db_counter]} = "PRIMARY" ]]
        then
          singleSqlValue "global_name" "global_name" 
          global_name=$sqlValue
          mb_database_global_name[$mb_db_counter]=$(echo "$global_name"|awk '{print $3}')
        else
          singleSqlValue "db_unique_name" "database" "v"
          db_unique_name=$sqlValue
          mb_database_global_name[$mb_db_counter]=$(echo "$db_unique_name"|awk '{print $3}')
        fi   
        #echo "GlobalName = ${mb_database_global_name[$mb_db_counter]}"
        #mb_database_role[$mb_db_counter]=STANDBY
        #$READ -p " see $DB in $MASTERFIL"
        echo "${db_name_to_check}.GLOBAL_NAME = ${mb_database_global_name[$mb_db_counter]}">>$MASTERFIL
      fi

      if [[ ${#mb_checksysdba[@]} -gt 0 && ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
      then
        if [ $localnode = ${mb_running_host[$mb_db_counter]} ]
        then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"`
	    echo "$STORE_VAL" >>$MASTERFIL

            STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"`
	    echo "$STORE_VAL" >>$MASTERFIL
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi

    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            echo "set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$ >>$MASTERFIL
            echo "set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$ >>$MASTERFIL
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	  fi
        else #remote_database_code
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner "${mb_running_host[$mb_db_counter]}"
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;
            export ORACLE_SID=$ORACLE_SID; 
	    cd "$dbhome_dir"; 
            su $dbOwner -c "echo \"set feedback  off heading off
  select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"
            su $dbOwner -c "echo \"set feedback  off heading off
  select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"
EOF
)
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
            mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;
            export ORACLE_SID=$ORACLE_SID; 
            echo "set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$
            echo "set feedback off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$
EOF
)
	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	  fi
          echo "$mb_mode_line" >> $MASTERFIL
        fi
      else
        #following two lines were added to find out about standby like is there any logical or physical standby in use.
        if [[ ${#mb_running_host[@]} -gt 0 && $localnode = ${mb_running_host[$mb_db_counter]} ]]
        then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner

            STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba" | grep -v ^\$`
	    echo "$STORE_VAL" >>$MASTERFIL

            STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba" | grep -v ^\$`
	    echo "$STORE_VAL" >>$MASTERFIL
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            echo "set feedback off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$ >>$MASTERFIL
            echo "set feedback off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$ >>$MASTERFIL
	  fi
        else #remote_database_code
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner "${mb_running_host[$mb_db_counter]}"

            mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;
            export ORACLE_SID=$ORACLE_SID; 
	    cd "$dbhome_dir"; 
            su $dbOwner -c "$bash_scr -c \"echo \\\\\"set feedback  off heading off
  select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\\\\\\\\\\\\\$archive_dest_status a,gv\\\\\\\\\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\\\\\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$\""
            su $dbOwner -c "$bash_scr -c \"echo \\\\\"set feedback  off heading off
  select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\\\\\\\\\\\\\$archive_dest_status a,gv\\\\\\\\\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\\\\\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$\""
EOF
)
    	    write_del_rolbk_tmpoutput
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;
            export ORACLE_SID=$ORACLE_SID; 
            echo "set feedback off heading off
  select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$
            echo "set feedback off heading off
  select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$
EOF
)
	  fi
          echo "$mb_mode_line" >> $MASTERFIL
        fi
      fi
    fi
    #echo "database_mode : $mb_mode_line"
    mb_db_counter=$(expr $mb_db_counter + 1) 
  done
  mb_db_names_list=$(echo "$mb_db_names_list"|sed "s/,$//g"|sed "s/^,//g")
  fi 
  mb_db_counter=0
  #For loop for multiple database for sql collect to finish here
  #echo -e "\nLog file for collections and audit checks are at\n${LOGFIL}\n"
fi

    
#IF TO CHECK THE OFFLINE MODE ENDS HERE

#echo "%%%%%%%%%%%%%%%%%%%%%%$sqlValue%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
# singleSqlValue "sysdate" "dual"
# singleSqlValue "count(instance_name)" "instance" "gv"
#---------------------------------------------------------------------
#for i in `$CRS/bin/olsnodes`

#this is test code to write database files for every run but not to overwrite for each node.
# it should work in offline as well as 
if [[ "$TYP" != "-p" ]]
then
  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
  then
    DBACTUAL=/dev/null
    if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]] 
    then
      if [ $SILENT -eq 1 ]
      then
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_collect)
      else
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode})
      fi
      OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
      OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}${TAG}
      UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${FDS}${TAG}
    fi
  elif [ -n "$DB" ]
  then
    DBACTUAL=$OUTPUTDIR/d_actual_${DB}.out
    ent_naming=$DB
    #echo "" > $DBACTUAL 
    if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]]
    then
     if [ $is_windows -eq "0" ] ; then
      T_UPLOADFIL_VAR="$UPLOADFIL_VAR"
      if [ $SILENT -eq 1 ]
      then
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_${DB}_collect)
      else
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_${DB})
      fi
      if [[ -n "$db_name_to_check_none" && $db_name_to_check_none -eq 1 ]]
      then 
        UPLOADFIL_VAR=$(echo ${T_UPLOADFIL_VAR}_${localnode})
        OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
      else
        OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode}_${DB})
      fi
     fi
     UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${FDS}${TAG}
     OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}${TAG}
    fi 
  elif [ -n "${stack_asm_sid[0]}" ] 
  then
    if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]]
    then
      if [ $SILENT -eq 1 ]
      then
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_collect)
      else
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode})
      fi
      UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${FDS}${TAG}
      OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
      OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}${TAG}
    fi 
    #aName=$(echo ${stack_asm_sid[0]}|sed 's/[0-9]//g') 
    #DBACTUAL=$OUTPUTDIR/d_actual_${aName}.out
    #echo "" > $DBACTUAL 
  else
    DBACTUAL=/dev/null
    #To add hostname in collections name if database does not exists
    if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]] 
    then
      if [ $SILENT -eq 1 ]
      then
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_collect)
      else
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode})
      fi
      OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
      OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}${TAG}
      UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${FDS}${TAG}
    fi
  fi
fi

#user friendly collection name to insert into table
upload_collection_name=$(basename "$OUTPUTDIR_NEW")

if [[ "$TYP" != "-p" ]]; then
  if [ $OFFLINE -eq 0 ]; then echo -e "\nCollections and audit checks log file is \n${OUTPUTDIR_NEW}/log/${program_name}.log\n";fi
else
  if [ $OFFLINE -eq 0 ]; then echo -e "\nCollections and audit checks log file is \n${OUTPUTDIR}/log/${program_name}.log\n";fi
fi
#if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm -f $OUTPUTDIR/d_actual_*.out >/dev/null 2>&1;fi;
if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm -f $OUTPUTDIR/d_actual_*.out >/dev/null 2>&1;fi;
#if [[ -e $DBACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm -f $DBACTUAL >/dev/null 2>&1;fi;
#$READ -p "DB=$DB"
#$READ -p "UPLOADFIL=$UPLOADFIL OUTPUTDIR_NEW=$OUTPUTDIR_NEW"

#this is where xml for em plug gets initialized
#xml_prefix1="$program_name"
#xml_prefix2="$program_name"
#xml_prefix3="$program_name"
xml_prefix1="Exacheck"
xml_prefix2="ExaCheck"
xml_prefix3="exacheck"
if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
then
  rack_type=$EXALOGIC_RACK
  engs_machine="Exalogic"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]]
then
  rack_type=N/A
  engs_machine="Big Data Appliance"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
then
  rack_type=N/A
  engs_machine="Exalytics"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] 
then
  rack_type=$EXADATA_RACK
  engs_machine="Exadata"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
then
  rack_type=""
  engs_machine="Database Appliance"
else
  rack_type=""
  engs_machine="RAC"
fi

echo "<Checks>" > $XMLRECFIL

UTCTSTAMP=`date -u '+%Y %h %d %H:%m:%S'`

echo "<${xml_prefix1}Results modelVersion=\"$modelVersion\" RackType=\"$rack_type\" EngineeredSystems=\"$engs_machine\" RackIdentifier=\"$RackIdentifier\" TimeStamp=\"$UTCTSTAMP\" ExadataType=\"$EXADATA_VERSION\" xsi:noNamespaceSchemaLocation=\"${xml_prefix3}_result.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">" >$XMLREPFIL

echo "<${xml_prefix2}Exclusions modelVersion=\"$modelVersion\" RackType=\"$rack_type\" EngineeredSystems=\"$engs_machine\" RackIdentifier=\"$RackIdentifier\" ExadataType=\"$EXADATA_VERSION\" xsi:noNamespaceSchemaLocation=\"${xml_prefix3}_exclusion.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">" >$XMLSKIPFIL


if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] ||  [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]];
then
  touch $COLLECT_TIMING
fi

if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
then
  html_rack_type="System"
fi

if [ -z "$RAT_RUNMODE_INTERNAL" ] ; 
then
  RAT_RUNMODE_INTERNAL="master"
fi

parallel_run_feaible=0
if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] || [[ -e "$EXPECT" ]] || [[ $rootYesNoint -eq "3" ]] || [[ "$usern" = "${root_user}" || $userid -eq 0 ]] ; 
then
  parallel_run_feaible=1
fi

#echo "parallel_run_feaible=$parallel_run_feaible"

if [[ -z "$RAT_COMPUTE_RUNMODE" ]] ; then RAT_COMPUTE_RUNMODE="parallel"; fi;

if [[ $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $parallel_run_feaible -eq "0" && $localonly -eq "0" ]] ; 
then
  RAT_COMPUTE_RUNMODE="serial"
  echo -e "${RED}Running ${program_name} in $RAT_COMPUTE_RUNMODE mode because expect($EXPECT) is not available to supply ${root_user} passwords on remote nodes${NORM}" |tee -a $LOGFIL
  echo
  echo -e "${RED}NOTICE:  Installing the expect utility ($EXPECT) will allow ${program_name} to gather ${root_user} passwords at the beginning of the process and execute ${program_name} on all nodes in parallel speeding up the entire process. For more info - http://www.nist.gov/el/msid/expect.cfm.  Expect is available for all major platforms.  See User Guide for more details.${NORM}"
  echo;
fi

echo "Running in $RAT_COMPUTE_RUNMODE mode" >> $LOGFIL 

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] 
then
  #echo "#### $INPUTDIR $OUTPUTDIR $DUMPDIR";
  OFFLINE=0
  TYP=$RUNSWITCH
  #outdir=`dirname $MASTERFIL`
  #indir=$INPUTDIR
  #INPUTDIR=$(ls -d `pwd`/.input_*|tail -1)
  #cp -R $INPUTDIR $indir
  #cp -R $OUTPUTDIR $outdir
  localnode=$RAT_LOCALNODE_INTERNAL
  echo $localnode  > $HOSTLIST
  #hostname |cut -d"." -f1 > $HOSTLIST
  #localnode=$(hostname |cut -d"." -f1)

  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    l_oh=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
    mb_oracle_homes[$mb_db_counter]=$l_oh
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  cp -f $INPUTDIR/*.dat $DUMPDIR 2>/dev/null
  cp -f $INPUTDIR/*.sh $DUMPDIR
  REFFIL=$DUMPDIR/collections.dat
  REFFIL1=$DUMPDIR/rules.dat
  ORCLENVFIL=$DUMPDIR/set_orcl_env.sh
  #Reassiging SYSTEM_DESC_FIL path back to compute node. initially it was cell temporory directory. now this file is available on compute node
  node_ssh_user=$usern
  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
    if [[ `echo "$ea_dom0_nodes" | grep -ic "$hname"` -le 0 ]]; then
      node_ssh_user="${root_user}"
    else
      node_ssh_user="${foxtrot_dom0_user}"
    fi
    if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$rnode "echo \"\$HOME\""); fi
    l_RTEMPDIR=${l_TMPDIR}/.${program_name}
  else
    l_TMPDIR=$TMPDIR
    l_RTEMPDIR=$RTEMPDIR
  fi
  SYSTEM_DESC_FIL=${l_RTEMPDIR}/cell_system_description.out 
  #PROFILE="$HOME/.bash_profile"
  #if [ ! -f $PROFILE ]; then PROFILE="$HOME/.profile";fi
  #v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}')
  #usern=`whoami`
  root_need_cell_ssh=0
  if [ $op_mode -eq 1 ]
  then  
    REQUIRE_ROOT=`grep  "REQUIRES_ROOT_COUNT" $REFFIL|sed  -n 's/.*REQUIRES_ROOT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
    if [[ -z "$REQUIRE_ROOT" ]]
    then
      REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
    fi
  else
    REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
  fi
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
  compute_rootpassword="$root_pass";
  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
  if [[ -n "$RAT_COMPUTEPASSWORD_INTERNAL" && $RAT_COMPUTEPASSWORD_INTERNAL -ne "3" ]] ; then
    samerootpassword=1
  fi

  final_components=$components

  ea_db_node="$RAT_EA_DB_NODE_INTERNAL"
  ea_ec1_node="$RAT_EA_EC1_NODE_INTERNAL"
  ea_ovmm_node="$RAT_EA_OVMM_NODE_INTERNAL"
  ea_pc1_node="$RAT_EA_PC1_NODE_INTERNAL"
  ea_pc2_node="$RAT_EA_PC2_NODE_INTERNAL"
  print_pass_on_screen=$RAT_PRINT_PASS_ON_SCREEN_INTERNAL
 
  collection_date=$(grep "COLLECTION DATE = " $MASTERFIL| sed 's/COLLECTION DATE = //')
  upload_dbplatform=$(grep "DB_PLATFORM = " $MASTERFIL| sed 's/DB_PLATFORM = //'|sed 's/^\s//g'|sed 's/\s$//g')
  upload_osdistro=$(grep "OS_DISTRO = " $MASTERFIL| sed 's/OS_DISTRO = //'|sed 's/^\s//g'|sed 's/\s$//g')
  upload_oskernel=$(grep "OS_KERNEL = " $MASTERFIL| sed 's/OS_KERNEL = //'|sed 's/^\s//g'|sed 's/\s$//g')
  upload_osversion=$(grep "OS_VERSION = " $MASTERFIL| sed 's/OS_VERSION = //'|sed 's/^\s//g'|sed 's/\s$//g')
  DBVERSION=$DBVERSION_OFFLINE
  cluster_name=$(grep "CLUSTER_NAME = " $MASTERFIL| sed 's/CLUSTER_NAME = //')
  upload_collection_name=$RAT_UPLOAD_COLLECTION_NAME_INTERNAL
  cp -f $MASTERFIL $MASTERFIL.saved
fi

if [[ $OFFLINE -eq "0" && $is_exalogic_machine -eq 0 && $is_exalytics_machine -eq 0 && $is_bda_machine -eq 0 && $is_exalogic_foxtrot -eq 0 && $is_zfssa_machine -eq 0 && $RAT_RUNMODE_INTERNAL = "master" && -n $RAT_CACHE_RUN && $RAT_CACHE_RUN = 0 ]]  
then
  for prompt_host in `cat $HOSTLIST`
  do
    PRMPTORCLENVFIL="$RTEMPDIR/prmpt_set_orcl_env_file.sh"
    security_fix "check_and_fix_script_existence" "$PRMPTORCLENVFIL"
    cp -rf  $ORCLENVFIL $PRMPTORCLENVFIL >/dev/null 2>&1
    echo $bash_source_check >>$PRMPTORCLENVFIL
    echo "exit 0" >>$PRMPTORCLENVFIL
    check_cascade_prompt 
  done
fi

if [[ -z $MERGEFILES ]]; then
  for i in `cat $HOSTLIST`
    do
      if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] ; then
        fmw_machine_id=$(grep topology.machines.machine.id= $OUTPUTDIR/topology_kv.out |grep "\.name = $i" | cut -d\" -f2)
        if [ -z "$oimnode" ] ; then
          pickoimnode "$i" "$fmw_machine_id";
        fi
        if [ -z "$oamnode" ] ; then
          pickoamnode "$i" "$fmw_machine_id";
        fi
        if [ -z "$oudnode" ] ; then
          pickoudnode "$i" "$fmw_machine_id";
        fi
      fi
  done

  if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
    echo ""
  else
    if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]] || [[ -z $is_fmw_machine ]]; then
      if [[ -z $MERGEFILES ]]; then
        get_first_compute
        get_first_cell
        get_first_zfs
        get_first_ibswitch
      fi
    fi
  fi
fi

if [[ -n $MERGEFILES ]]; then unset RAT_LOAD_CHECK_ATTRIBUTES; fi   

if [[ $RAT_RUNMODE_INTERNAL != "slave" && $OFFLINE -eq 0 && -n $is_bda_domu ]]; then
  echo "is_bda_domu = $is_bda_domu" >> $MASTERFIL
fi
write_fmw_mapping

run_on_remote_nodes

if [[ -n "$RAT_LOAD_CHECK_ATTRIBUTES" && -z $MERGEFILES ]]; then load_checks_attributes; else unset RAT_LOAD_CHECK_ATTRIBUTES; fi   
echo ""
#if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then cp -f ${HOSTLIST} $TMP_OUTPUT; fi

#HOST LOOP Starts 
get_current_epoch "1"
start_time=$epoch_time

echo "Start Time:$start_time" >> $LOGFIL

if [[ $RAT_RUNMODE_INTERNAL != "slave" ]]; then
  if [ $OFFLINE -eq 0 ]; then
    if [[ -n "$CREATE_PENDING" ]]; then create_usr_dirs_on_remote; fi
  fi
fi

for i in `cat $HOSTLIST`
do
  if [ $OFFLINE -eq 0 ]
  then
    emfile=$MASTERFIL
  else
    emfile=$DUMPDIR/$CHKFIL
  fi
  if [[ `grep -wic "$i.EMAGENT_INSTALLED = 1" $emfile` -gt 0 ]] && [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
    is_emagent_installed=1;
    mb_emagent_home=`grep "$i.EMAGENT_HOME" $emfile|cut -d'=' -f2|sed 's/ //g'`;
    agent_inst=`grep "$i.EMAGENT_INST " $emfile|cut -d'=' -f2|sed 's/ //g'`;
    is_agent_up=`grep "$i.EMAGENT_UP " $emfile|cut -d'=' -f2|sed 's/ //g'`;
  else
    is_emagent_installed=0;
  fi

  is_oms_installed=0
  is_oms_up=0
  if [[ `grep -wic "$i.OMS_INSTALLED = 1" $emfile` -gt 0 ]] && [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "0" ]]; then
    is_oms_installed=1;
    if [[ `grep -ic "$i:.*:OMS_UP = 1" $emfile` -gt 0 ]];then
      is_oms_up=1
    fi

    oms_counter=0
    for oms_home in `grep -i "$i:.*:OMS_UP = 1" $emfile|awk -F":" '{print $2}'|sed 's/ //g'`
    do
      	oms_homes[$oms_counter]=$oms_home
     	oms_counter=$(expr $oms_counter + 1)
    done
    oms_counter=0
    unset oms_home
  fi

  if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]]  
  then
    OSCHECKRESULT=$OUTPUTDIR/o_audit_result_${i}.out
    skipnode=`grep LOCALNODE $MASTERFIL |awk '{print $3}'`
    if [ $i = $skipnode ]
    then
      continue
    fi
  fi 

  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] ; then
    if [[ -n "$idm_db_components" ]]; then
      components=$idm_db_components;
    elif [[ $fmw_components != $components ]]; then
      components=$(echo "${components}:${fmw_components}")
      echo 
      echo "Running DB healthchecks as well..";
      echo 
    fi
    if [[ $OFFLINE -eq "0" ]]; then echo "$i.ACTUAL_COMPONENT = $components">>$MASTERFIL; fi
  elif [[ -n "$idm_db_components" ]]; then
    components=$idm_db_components;
    if [[ $OFFLINE -eq "0" ]]; then echo "$i.ACTUAL_COMPONENT = $components">>$MASTERFIL; fi
  fi    
  #Not to print localhost name when executing checks on zfssa
  if [ $is_zfssa_machine -eq 0 ]
  then

  echo "=============================================================" |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS
  echo "                    Node name - $i                                " |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS
  echo "=============================================================" |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS
  fi
  #tried to fix not to execute opatch if another nodes does not have oracle binaries.
  if [[ ${crs_installed[$stack_counter]} -eq 0 && $single_instance_run -eq "0" ]]; then TYP="-b";fi;
  if [[ ${crs_installed[$stack_counter]} -eq 0 && ${rdbms_installed[$stack_counter]}  -eq 0 ]]; then TYP="-b";fi;
  
  if [ $i = $localnode ]
  then
    if [ -f $SKIPFIL ]
    then
      `sed  -i 's/on .* as it is invalid/on '$i' as it is invalid/' $SKIPFIL`;
    fi
  
    if [ -f $EXCLUDELOG ]
    then
      `sed  -i 's/on .* because its excluded/on '$i' because its excluded/' $EXCLUDELOG`;
    fi
  fi

  #calling Exa functions to re-assign modules for each not to support hybrid racks
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then  assign_exalogic_module "$i" ;fi
  #this fucction will check either its a db machine or not for each node
  if [[ "$i" != "$localnode" || $RAT_RUNMODE_INTERNAL = "slave" ]] ; then 
    is_this_db_machine $i; bda_machine_type $i;add_maa_scorecard;add_hacheck; write_db_machine_info_to_envfile $i;
    if [[ $OFFLINE -eq "0" ]] || [[ -n "$MERGEFILES" ]] ; then echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL; fi
  fi 
  
  is_bda_domu=`grep "is_bda_domu =" $MASTERFIL | sed 's/is_bda_domu = //' | tr -d '\n'`;
  
  # Set components for FMW
  if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] ; then
    fmw_comps_running=""
    
    unset VHNMAP
    read_fmw_mapping;
 
    get_fmw_comps_running;
    pickedoim=`grep "OIMNODE =" $MASTERFIL | sed 's/OIMNODE = //' | tr -d '\n'`;
    pickedoam=`grep "OAMNODE =" $MASTERFIL | sed 's/OAMNODE = //' | tr -d '\n'`;
    pickedoud=`grep "OUDNODE =" $MASTERFIL | sed 's/OUDNODE = //' | tr -d '\n'`;
  fi
  mixed_hardware=0 
  if [[ "$i" = "$localnode" && $RAT_RUNMODE_INTERNAL = "master" ]];then mixed_hardware_cells_discovery; fi

  if [[ -z $RAT_NO_COMPONENTS_FILTER ]]; then component_match_count=1; host_specific_collections "$i" "$components"; else export RAT_NO_COMPONENTS_FILTER=1; fi

  dirlist=$(echo "$USR_DIRS"|sed "s/^\s*//g"|sed "s/\s*$//g")
  for utildir in `echo "$dirlist"`
  do
    oldTMP_OUTPUT=$TMP_OUTPUT
    TMP_OUTPUT=$utildir
    copy_localonly "CHECK"
    TMP_OUTPUT=$oldTMP_OUTPUT
    unset oldTMP_OUTPUT
  done

  #assign the right status for stack variables
  assign_stack_status;

  ACREPCOUNT=0
  call_zfs_collection=1

  #In profile run call zfs collection only if zfs profile is selected
  if [[ -n "$run_profile" && $run_profile -eq "1" && $zfs_in_profile -eq "0" && $ellite_in_profile -eq "0" && $elextensive_in_profile -eq "0" ]] ; then
    call_zfs_collection=0
  fi

  if [[ $call_zfs_collection -eq "1" ]]
  then
    if [[ -n "$is_ssc_machine" && $is_ssc_machine -eq 1 && -n "$is_ssc_zfsnodes_passed" &&  $is_ssc_zfsnodes_passed -eq 1  ]]
    then
      generate_zfs_aksh ZFS
      execute_zfs_collection "$ZFSIP" "$ZFSAKSHSCRIPT"
    elif [[ -n "$is_zfssa_machine" && $is_zfssa_machine -eq 1 ]]
    then
      generate_zfs_aksh ZFS
      execute_zfs_collection "$ZFSIP" "$ZFSSAAKSHSCRIPT"
    elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]
    then
      if [ -e "$CELLIP" ]
      then
          generate_zfs_aksh ZFS
          execute_zfs_collection "$CELLIP" "$ZFSAKSHSCRIPT"
      fi
      if [ -e "$EXTCELLIP" ]; then 
          generate_zfs_aksh EXTERNAL_ZFS
          execute_zfs_collection "$EXTCELLIP" "$EXTZFSAKSHSCRIPT"
      fi
    fi
    if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "parallel" ]]; then wait_for_cell_completion; copy_cellfiles_to_remotenodes; fi
    echo -e ""
  fi
  
  # if RAT_TORSWITCHES is not empty, run checks on ocm switches similar to zfs.
  if [[ -n "$RAT_TORSWITCHES" ]]; then
    OCMSWGENERATEDSCRIPT=$OUTPUTDIR/ocm_sw_generated_script.sh
    write_var OUTPUTDIR EXCLUDEFIL INPUTDIR OCMSWGENERATEDSCRIPT RAT_TORSWITCHES OFFLINE LOGFIL zfs_aksh_timeout opc_credfile
    python_exe=$(which python)
    $python_exe -W ignore $SCRIPTPATH/.cgrep/ocm_switch.py -f $TOR_SWITCH_VAR_FILE -g -e
  fi

  if [ $RUNSWITCH != "-p" ]
  then
    case $TYP in
      -a|-b|-f|-u)
        current_check=1
        CUR_LEVEL=1   
        #following if is to set L1 to 1 in offline if there are no OS_COLLECT in data file and osCheckIndexNo has value like -OSCOLLECTCOUNT 0. did this chage for Exalytics 
        if [[ $OFFLINE -eq 1 && `echo $osCheckIndexNo|grep -c [A-Z]` -ge 1 ]];then osCheckIndexNo=1;fi
        #this is to skip collections in offline
        if [ $OFFLINE -eq 0 ];then L1=1;else L1=$osCheckIndexNo;fi
        L2=0;L3=0;L4=0;L5=0;L6=0;L7=0;L8=0;L9=0;L10=0;
        ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
        OSSPOOLFIL="$OSOUTFIL"_"$i".out
        #ROOTSCRPT="$INPUTDIR/root_${program_name}".sh
        IBSWITCHSCRPT="$INPUTDIR/${program_name}_ibswitch".sh
        CELLSSCRPT="$INPUTDIR/${program_name}_cells".sh
        if [ -f $ROOTSCRPT ];then #rm -f $ROOTSCRPT; 
    	  security_fix "check_and_fix_script_existence" "$ROOTSCRPT"
	fi
        if [[ $op_mode -eq 1 && $run_check -ne 1 ]]
        then
          OSCOLLECTSUM=`grep  "OS_COLLECT_COUNT" $REFFIL|sed  -n 's/.*OS_COLLECT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
	  if [ -z "$OSCOLLECTSUM" ]
          then
            OSCOLLECTSUM=`grep -c "OS_COLLECT_COMMAND_START" $REFFIL`
          fi
        else
          OSCOLLECTSUM=`grep -c "OS_COLLECT_COMMAND_START" $REFFIL`
        fi
        #$READ -p "OSCOLLECTSUM=$OSCOLLECTSUM"
        OSCOLLECTCNT=0
        OSCHECKRESULT=$OUTPUTDIR/o_audit_result_${i}.out
        OSPKGSILENT=$OUTPUTDIR/o_pkg_status_silent_${i}.out
        OSACTUAL=$OUTPUTDIR/o_actual_${i}.out
        AACTUAL=$OUTPUTDIR/a_actual_${i}.out
        if [[ -e $OSACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm -f $OSACTUAL >/dev/null 2>&1;fi;
        if [[ -e $AACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm -f $AACTUAL >/dev/null 2>&1;fi;

        # store the old value for clusterware_check_count for previous compute node because if current node is control VM than clusterware_check_count will not increase
        if [[ -n "$clusterware_check_count" &&  $clusterware_check_count -gt 0 ]]; then clusterware_check_count_old=$clusterware_check_count;fi
        #$READ -p "clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"
        clusterware_check_count=0
        collect_file_counter=0
        cls_check_host_list[$stack_counter]=$i
        if [[ -e $OGGHOMESVERSIONFIL && `grep -wic $i $OGGHOMESVERSIONFIL` -gt 0 ]];then is_goldengate_installed=1;else is_goldengate_installed=0;fi
        echo "is_goldengate_installed =$is_goldengate_installed on $i and file is $OGGHOMESVERSIONFIL">>$LOGFIL
        #echo "" >$OSACTUAL

        if  [ $OFFLINE -eq 0 ]
        then
	  OLD_TMPDIR=$TMPDIR
	  TMPDIR=$RTEMPDIR
          echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Execution started on $i\n">>$RACCHECK_TIMING
          if [[ $SUDOCMD != "/usr/bin/sudo" ]]
          then
            # A valid sudo command was set up, so I know this is being run by Oracle and I don't need the below environment variables.  I need the
            # root_raccheck.sh script to look exactly the same in every instance so that the Dell sudo command works and adding specific system
            # environment variables will mess that up!
            ORACLEENVVARS=SetOracleEnvVars
            if [ -f $TMPDIR/$ORACLEENVVARS ];then security_fix "check_and_fix_script_existence" "$TMPDIR/$ORACLEENVVARS"; fi

            echo "#!$bash_scr">>$TMPDIR/$ORACLEENVVARS
            echo "$bash_source">>$TMPDIR/$ORACLEENVVARS
            echo "$RAT_DEBUG_FLG">>$TMPDIR/$ORACLEENVVARS	   
            echo "export ORACLE_HOME=$ORACLE_HOME">>$TMPDIR/$ORACLEENVVARS
            echo "export CRS_HOME=$CRS">>$TMPDIR/$ORACLEENVVARS
            echo "export ORACLE_SID=$ORACLE_SID">>$TMPDIR/$ORACLEENVVARS
            echo "">>$ROOTSCRPT
            echo ". $TMPDIR/$ORACLEENVVARS">>$ROOTSCRPT
            echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\" >>${RTEMPDIR}/o_root_collect_timing.out" >>$ROOTSCRPT
          else
            ORACLEENVVARS=SetOracleEnvVarsPlaceHolder
            echo "#!$bash_scr">>$ROOTSCRPT
            echo "$bash_source">>$ROOTSCRPT
            echo "$RAT_DEBUG_FLG">>$ROOTSCRPT
            echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$ROOTSCRPT   
            echo "export ORACLE_HOME=$ORACLE_HOME">>$ROOTSCRPT
            echo "export CRS_HOME=$CRS">>$ROOTSCRPT
            echo "export TMPDIR=$TMPDIR">>$ROOTSCRPT   
            echo "export RTEMPDIR=$RTEMPDIR">>$ROOTSCRPT   
            echo "export OUTPUTDIR=${OUTPUTDIR}">>$ROOTSCRPT
            #echo "export ORA_CRS_HOME=$CRS">>$ROOTSCRPT
            echo "export ORACLE_SID=$ORACLE_SID">>$ROOTSCRPT
            echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${RTEMPDIR}/o_root_collect_timing.out" >>$ROOTSCRPT
            if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]
            then 
              echo "export PATH=\$PATH:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/opt/MegaRAID/MegaCli/:/opt/oracle/cell/cellsrv/bin">>$ROOTSCRPT
              echo "export OSS_BIN=/opt/oracle/cell/cellsrv/bin">>$ROOTSCRPT
            fi
          fi
          if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 ]]
          then 
            if [ -f $IBSWITCHSCRPT ];then security_fix "check_and_fix_script_existence" "$IBSWITCHSCRPT"; fi

            echo "#!/bin/env bash">>$IBSWITCHSCRPT
            echo "$RAT_DEBUG_FLG">>$IBSWITCHSCRPT
            echo "export RTEMPDIR=$IBRTEMPDIR">>$IBSWITCHSCRPT
            echo "export TMPDIR=$TMPDIR">>$IBSWITCHSCRPT
            echo "export IBTMPDIR=$IBTMPDIR">>$IBSWITCHSCRPT
            echo "export SWITCH_TYPE_FIL=${IBRTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}">>$IBSWITCHSCRPT
            echo "SWITCHNAME=\`hostname|cut -d. -f1\`">>$IBSWITCHSCRPT
            echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${IBRTEMPDIR}/s_root_collect_timing.out" >>$IBSWITCHSCRPT
          fi
          if [[ $root_need_cell_ssh -eq 0 ]]
          then 
            if [ -f $CELLSSCRPT ];then security_fix "check_and_fix_script_existence" "$CELLSSCRPT"; fi

            echo "#!/bin/env bash">>$CELLSSCRPT
            echo "$RAT_DEBUG_FLG">>$CELLSSCRPT
            echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$CELLSSCRPT
            echo "export PATH=\$PATH:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/opt/MegaRAID/MegaCli/:/opt/oracle/cell/cellsrv/bin">>$CELLSSCRPT
            echo "export OSS_BIN=/opt/oracle/cell/cellsrv/bin">>$CELLSSCRPT
            echo "export RTEMPDIR=$CELLRTEMPDIR">>$CELLSSCRPT
            echo "export TMPDIR=$TMPDIR">>$CELLSSCRPT
    	    if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
              echo "export CELLTMPDIR=$RTEMPDIR">>$CELLSSCRPT
	    else
              echo "export CELLTMPDIR=$CELLTMPDIR">>$CELLSSCRPT
	    fi
            echo "CELLNAME=\`hostname|cut -d. -f1\`">>$CELLSSCRPT 
            echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${CELLRTEMPDIR}/c_root_collect_timing.out" >>$CELLSSCRPT
          fi
          if [[ -e $ORCLENVFIL ]]; then chmod 744 $ORCLENVFIL; fi
          if [ $i = $localnode ]
          then
            cp -f $ORCLENVFIL $TMPDIR/ 2>/dev/null
            cp -f $MASTERFIL $TMPDIR/ 2>/dev/null
          else
            #following code is to put the correct ORACLE_SID in ORAENVFIL which is used to set the environment on each host
            sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
            cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
            rm -f $INPUTDIR/tmp_env_file.out
            echo "export ORACLE_SID=${stack_dbinst_name[$stack_counter]}">>$ORCLENVFIL
            if [ $is_windows -eq "1" ] ; then
              scp_ORCLENVFIL=$(cygpath $ORCLENVFIL)
              scp_MASTERFIL=$(cygpath $MASTERFIL)
              $SCOPY $scp_ORCLENVFIL $i:$TMPDIR/ >/dev/null
              $SCOPY $scp_MASTERFIL $i:$TMPDIR/ >/dev/null 
            else
              $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null
              $SCOPY $MASTERFIL $i:$TMPDIR/ >/dev/null 
            fi
          fi
          TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`
        #end here
	  TMPDIR=$OLD_TMPDIR
	  unset OLD_TMPDIR
        fi

        #ROOTFLG=0
        #no_of_checks_to_execute=$(grep -c "CHECK_ID" $REFFIL)
        #last_check_in_dat=$(cat $REFFIL|sed -n ''${no_of_checks_to_execute}'p'|cut -d\. -f1|cut -d_ -f2) 
        #$READ -p "no_of_checks_to_execute=$no_of_checks_to_execute last_check_in_dat=$last_check_in_dat"
        #db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check}'p') 

        IDMHCEXECNT=0

        while [ -n "$ROW" ]
        #while [ "$ROW" -le $last_check_in_dat ]
        do
          #$READ -p "ROW=$ROW"
          while [[ -z "$LEVEL" && $CUR_LEVEL -gt 0 ]]
          do
            #LEVEL=`grep _$ROW\-LEVEL $REFFIL |awk {'print $2'}`
            LEVEL=`grep _$ROW\-LEVEL $REFFIL |cut -d- -f2|awk '{print $2}'`
            #LEVEL=`grep _$ROW $REFFIL |awk {'print $2'}`
            #echo "ROW=$ROW, LEVEL=$LEVEL"
            if [[ -z "$LEVEL" && $L1 -gt 0 ]]
            then
              #we didn't find anything for the current ROW
              #that being the case we need to traverse up a level and keep looking
              #until we have nowhere else to look
              case $CUR_LEVEL in
               10) L10=0; L9=$(($L9+1)); CUR_LEVEL=9 ;;
                9) L9=0; L8=$(($L8+1)); CUR_LEVEL=8 ;;
                8) L8=0; L7=$(($L7+1)); CUR_LEVEL=7 ;;
                7) L7=0; L6=$(($L6+1)); CUR_LEVEL=6 ;;
                6) L6=0; L5=$(($L5+1)); CUR_LEVEL=5 ;;
                5) L5=0; L4=$(($L4+1)); CUR_LEVEL=4 ;;
                4) L4=0; L3=$(($L3+1)); CUR_LEVEL=3 ;;
                3) L3=0; L2=$(($L2+1)); CUR_LEVEL=2 ;;
                2) L2=0; L1=$(($L1+1)); CUR_LEVEL=1 ;;
                1) L1=0; CUR_LEVEL=0 ;;
              esac

              if [ $L1 -gt 0 ]
              then
                ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
              else
		if [[ `grep "_$ROW\-" $REFFIL|grep -c 'OS_COLLECT_COUNT'` -gt "0" && `grep -ic "_$ROW\-" $REFFIL` -eq "2" ]]; then
		  fnd_index=$(echo "$ROW"|awk -F'.' '{print $1}')
		  fnd_index=$(expr $fnd_index + 1)
		  ROW="${fnd_index}.0.0.0.0.0.0.0.0.0"; CUR_LEVEL=1; L1=${fnd_index}; 
		  continue; 
		fi
		if [[ "$ROW" = "1.0.0.0.0.0.0.0.0.0" && `grep -c "^_.*\-OS_COLLECT_COUNT 0" $REFFIL` -gt "0" && `grep -c "^_.*\-_REQUIRES_ROOT_COUNT 0" $REFFIL` -gt "0" ]]; then ROW="2.0.0.0.0.0.0.0.0.0"; CUR_LEVEL=1; L1=2; continue; fi
                ROW=
              fi
              #echo "CURRENT LEVEL MAIN LOOP = $CUR_LEVEL"
            fi
            #echo "LOOP ROW = $ROW" 
          done
          unset execute_once COMTYPE PARAM_PATH ISBRANCH REQUIRES_ROOT_OS PARAM NEEDS_RUNNING OP COMP ALVL PMSG FMSG SF CAT SUBCAT COM_REPORT SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW audit_check_name OPSTAT database_mode check_exadata_version check_database_role check_database_type FILVAL VAL OUTFIL OUTFIL_REPORT

   	  # _1.0.0.0.0.0.0.0.0.0-LEVEL 1-CHECK_ID 5ADE41BF1E15571AE0401490CACF3E60 
   	  # gadiga added multiple version support whcih appends version to end
 
          if [ $op_mode -eq 1 ] 
          then
            CHECK_ID=`grep "_${ROW}-LEVEL ${LEVEL}-CHECK_ID" $REFFIL|sed  -n 's/.*CHECK_ID //p'| sed 's/^ *\(.*\) *$/\1/'`
          else
            CHECK_ID=`grep "_${ROW}-CHECK_ID" $REFFIL|sed  -n 's/.*CHECK_ID //p'| sed 's/^ *\(.*\) *$/\1/'`
          fi    
	
          run_in_multiple_versions=0
          versions_to_run=""
          if [ `echo "$CHECK_ID" | grep -c " "` -gt 0 ]
          then
            run_in_multiple_versions=1
            versions_to_run="$CHECK_ID";
            CHECK_ID=$(echo "$CHECK_ID" | awk '{print $1}')
            versions_to_run=$(echo $versions_to_run | sed 's/'$CHECK_ID' //')
            if [ -n "$RAT_DEBUG_V" ] ; then echo "$ROW $CHECK_ID runs only on $versions_to_run"; fi;
          else
            if [ -n "$RAT_DEBUG_V" ] ; then echo "$ROW $CHECK_ID is running"; fi;
          fi
          #run_in_multiple_versions=0
          #$READ -p "CHECK_ID=$CHECK_ID $REFFIL $REFFIL1 ROW=$ROW LEVEL=$LEVEL"
          CLUSTERCHECK_FIL=${OUTPUTDIR}/${CHECK_ID}.out
          #reading audit_checK_name and collection_name here to support skipping checks based on name

	  TAG3=0
	  if [[ -n "$RAT_LOAD_CHECK_ATTRIBUTES" && $op_mode -ne 0 && -n $CHECK_ID ]]; then
	    . $INPUTDIR/${CHECK_ID}_load_checks_attributes.sh 2>>$ERRFIL
	  else	   
            if [ $op_mode -eq 0 ]
            then 
              COMTYPE=`grep _$ROW\-TYPE $REFFIL |awk {'print $2'}` 
              PARAM_PATH=`grep _$ROW\-PARAM_PATH $REFFIL |awk {'print $2'}` 
              HOME_PATH=`grep _$ROW\-HOME_PATH $REFFIL |awk {'print $2'}` 
              ISBRANCH=`grep _$ROW\-IS_BRANCH $REFFIL |awk {'print $2'} `
              REQUIRES_ROOT_OS=`grep _$ROW\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
              PARAM=`grep "_"$ROW"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
              NEEDS_RUNNING=`grep "_"$ROW"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
              TARGET_TYPE=`grep "_"$ROW"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'| sed 's/^ *\(.*\) *$/\1/'`
              execute_once=`grep "_"$ROW"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
              SF=`grep "_"$ROW"-SF" $REFFIL |sed  -n 's/.*-SF //p'` 
              check_components=`grep "_"$ROW"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
              OP=`grep _$ROW\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
              if [[ -z "$OP && -e $REFFIL1 ]];then OP=`grep _$ROW\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
              COMP=`grep "_"$ROW"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'` 
              if [[ -z "$COMP && -e $REFFIL1 ]];then COMP=`grep "_"$ROW"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
              check_exadata_version=$(grep "_"$ROW"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
              check_database_role=$(grep "_"$ROW"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
              check_database_type=$(grep "_"$ROW"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
              check_database_mode=$(grep "_"$ROW"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
              audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
              COLLECTION_NAME=`grep "_"$ROW"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`     
              COLLECTION_DIFF_CANDIDATE=`grep _$ROW\-COLLECTION_DIFF_CANDIDATE $REFFIL |awk {'print $2'}`
	      PROFILE_ONLY=`grep _$ROW\-PROFILE_ONLY $REFFIL |awk {'print $2'}`
	      LOGIC=`grep _$ROW\-LOGIC $REFFIL |awk {'print $2'}`
	      OUTFILVAL=`grep _$ROW\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
            else
              COMTYPE=`grep _$CHECK_ID\-TYPE $REFFIL |awk {'print $2'}` 
              #$READ -p "COMTYPE =$COMTYPE"
              PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}` 
              HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}` 
              ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
              REQUIRES_ROOT_OS=`grep _$CHECK_ID\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
              PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
              NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
              TARGET_TYPE=`grep "_"$CHECK_ID"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'| sed 's/^ *\(.*\) *$/\1/'`
              execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
              check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
              check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
              check_database_type=$(grep "_"$CHECK_ID"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
              check_database_mode=$(grep "_"$CHECK_ID"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
              SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'` 
              check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
              OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
              if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
              COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'` 
              if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
              audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'` 
              COLLECTION_NAME=`grep "_"$CHECK_ID"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
	      COLLECTION_DIFF_CANDIDATE=`grep _$CHECK_ID\-COLLECTION_DIFF_CANDIDATE $REFFIL |awk {'print $2'}`
	      PROFILE_ONLY=`grep _$CHECK_ID\-PROFILE_ONLY $REFFIL |awk {'print $2'}`
	      LOGIC=`grep _$CHECK_ID\-LOGIC $REFFIL |awk {'print $2'}`
	      OUTFILVAL=`grep _$CHECK_ID\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
            fi
	  fi
	  #assign_execute_once

          audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'` 

	  if [[ -n "$COLLECTION_DIFF_CANDIDATE" && "$COLLECTION_DIFF_CANDIDATE" = "Y" ]]
	  then
	    echo "$CHECK_ID|$COLLECTION_NAME|$NEEDS_RUNNING|$OUTFILVAL|$COMTYPE" >> $COLLDIFFFIL
	  fi 

          get_current_epoch 
          echo -e "[CHECK:$CHECK_ID][HOST: $i][TYPE: $COMTYPE][COLLECTION_NAME: $COLLECTION_NAME][AUDIT_CHECK_NAME: $audit_check_name] Check Start Time: $epoch_time" >> $CHK_TIMINGS
     
          if [[ -n "$LEVEL" &&  $LEVEL -eq "1" ]]
          then  
	    # Unset array used for holding OPSTAT values in multi db case
            # $m_opstat[$CUR_LEVEL]=db1,db2,db3 where opstat=1
            unset m_opstat 
          fi 

	  if [[ -n $RAT_NO_COMPONENTS_FILTER ]]; then 
	    #code to handle mixed hardware storage cells   
            if [[ $mixed_hardware -gt 1 && "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" && "$i" = "$localnode" && $RAT_RUNMODE_INTERNAL = "master" ]]
            then
              old_components=$components
              if [[ $mixed_hardware_v2 -ge 1 && `echo $check_components|grep -wc "DBM"` -ge 1 && `echo $components|grep -wc "EXADATA"` -eq 0 ]]
              then
                components=$(echo $components:EXADATA)
              fi   
              if [[ $mixed_hardware_x2_2 -ge 1 && `echo $check_components|grep -wc "X2-2"` -ge 1 && `echo $components|grep -wc "X2-2"` -eq 0 ]]
              then
                components=$(echo $components:X2-2)
              fi  
              if [[ $mixed_hardware_x3_2 -ge 1 && `echo $check_components|grep -wc "X3-2"` -ge 1 && `echo $components|grep -wc "X3-2"` -eq 0 ]]
              then
                components=$(echo $components:X3-2)
              fi  
              if [[ $mixed_hardware_x4_2 -ge 1 && `echo $check_components|grep -wc "X4-2"` -ge 1 && `echo $components|grep -wc "X4-2"` -eq 0 ]]
              then
                components=$(echo $components:X4-2)
              fi
              if [[ $mixed_hardware_x5_2 -ge 1 && `echo $check_components|grep -wc "X5-2"` -ge 1 && `echo $components|grep -wc "X5-2"` -eq 0 ]]
              then
                components=$(echo $components:X5-2)
              fi
              if [[ $mixed_hardware_x6_2 -ge 1 && `echo $check_components|grep -wc "X6-2"` -ge 1 && `echo $components|grep -wc "X6-2"` -eq 0 ]]
              then
                components=$(echo $components:X6-2)
              fi
              if [[ $mixed_hardware_x7_2 -ge 1 && `echo $check_components|grep -wc "X7-2"` -ge 1 && `echo $components|grep -wc "X7-2"` -eq 0 ]]
              then
                components=$(echo $components:X7-2)
              fi
            fi
            #code to handle mixed hardware storage cells   

            #if [ -n "$it_is_rac_old" ]; then it_is_rac=$it_is_rac_old;fi
            if [ `echo $components|grep -iwc EXADATA` -ge 1 ] && [[ `echo $check_components|grep -wc "DBM"` -ge 1 ]]; then check_components=$(echo $check_components|sed 's/:/ /g'|sed 's/\<DBM\>/EXADATA/g'|sed 's/ /:/g');fi
            if [ "$components" = "RDBMS" ] && [[ $old_check_components = "DBM:RDBMS" || $old_check_components = "DBM:RDBMS:UPGR" ]]; then check_components=RDBMS;fi 
            old_check_components=$check_components
            component_match_count=0 
            loop_check_components=$(echo $check_components|sed 's/:/ /g')
            for check_component in $loop_check_components
            do
              component_match_count1=$(echo $components|grep -icw $check_component)
              if [[ -n "$component_match_count1" && $component_match_count1 -ge 1 ]]; then component_match_count=$(expr $component_match_count + 1 );fi
            done  
    
            # FMW components
            if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] ; then
              if [[ $NEEDS_RUNNING != "RDBMS" ]]; then 
	        echo "Checking $audit_check_name (CHECK ID $CHECK_ID) because NEEDS_RUNNING=$NEEDS_RUNNING, Selected Components=$fmw_run_comps" and Excluded Components=$fmw_exclude_comps>>$LOGFIL

                #if [ -n "$NEEDS_RUNNING" ] ; then c_needs_running=$NEEDS_RUNNING; else c_needs_running="UNSPECIFIED"; fi
                if [[ -n "$fmw_run_comps" && `echo $fmw_run_comps |grep -iwc "$NEEDS_RUNNING"` -eq "0" ]] ; then
                  component_match_count=0; 
	          echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because NEEDS_RUNNING=$NEEDS_RUNNING and Selected Components=$fmw_run_comps">>$LOGFIL
                fi

                if [[ -n "$fmw_exclude_comps" && `echo $fmw_exclude_comps |grep -iwc "$NEEDS_RUNNING"` -eq "1" ]] ; then
                  component_match_count=0; 
	          echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because NEEDS_RUNNING=$NEEDS_RUNNING and Excluded Components=$fmw_exclude_comps">>$LOGFIL
                fi

                if [[ -n "$NEEDS_RUNNING" && $NEEDS_RUNNING != "UNSPECIFIED" ]] ; then
                  old_ifs=$IFS
                  IFS=$':'
                  fmwnrcomp_cntr=0
                  for fmwcomp in `echo "$NEEDS_RUNNING"`
                  do
                    if [[ -n "$fmwcomp" ]]; then
                      fmwnrcomparr[$fmwnrcomp_cntr]=$fmwcomp
                      fmwnrcomp_cntr=$(expr $fmwnrcomp_cntr + 1)
                    fi
                  done
                  IFS=$old_ifs
                  fmwnrcomp_cntr=0

                  old_ifs=$IFS
                  IFS=$':'
                  fmwruncomp_cntr=0
                  for fmwruncomp in `echo "$fmw_comps_running"`
                  do
                    if [[ -n "$fmwruncomp" ]]; then
                      fmwruncomparr[$fmwruncomp_cntr]=$fmwruncomp
                      fmwruncomp_cntr=$(expr $fmwruncomp_cntr + 1)
                    fi
                  done
                  IFS=$old_ifs
                  fmwruncomp_cntr=0

                  fmw_component_match_count=0
                  for fmwruncomp in "${fmwruncomparr[@]}"
                  do
                    for fmwnrcomp in "${fmwnrcomparr[@]}"
                    do
                      if [[ "$fmwruncomp" = "$fmwnrcomp" ]]; then
                        fmw_component_match_count=1
                        break;
                      fi
                    done
                  done

                  #if [ `echo "$fmw_comps_running" |grep -iwc "$NEEDS_RUNNING"` -eq "0" ] ; then
                  if [[ -n "$fmw_component_match_count" && $fmw_component_match_count -eq "0" ]]; then
                    component_match_count=0; 
                    echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because NEEDS_RUNNING=$NEEDS_RUNNING and Selected Components=$fmw_run_comps and running components in $i = $fmw_comps_running">>$LOGFIL
                  fi
                fi
              fi
            fi
            
            #Profiles
            if [[ -n "$run_profile" && $run_profile -eq "1" ]] ; then
              in_profile=0
              ex_profile=1
	      if [[ $aprofile_id = "RANDOMID" || `echo "$profileids2run" | grep -iwc "RANDOMID"` -eq "1" ]]
	      then
	        in_profile=1
	      else
	        check_in_profiles
	      fi
              if [[ $in_profile -eq "0" || $ex_profile -eq "0" ]] ; then 
                component_match_count=0; 
                echo "Skipping check (id $CHECK_ID) because its not in profile $profiles2run"  >> $LOGFIL
              fi;
            fi
            #components=$saved_components

	    if [[ $run_in_multiple_versions -eq 1 && "$versions_to_run" = "no-release" ]]; then component_match_count=0; fi
	  fi

          # For multiple_version_support we add new checks at the end.
          # The new check may be a collection which can't run in offline
          if [[ $run_in_multiple_versions -eq 1 && $OFFLINE -eq "1" ]]
          then
            if [[ $COMTYPE = "OS_COLLECT" || $COMTYPE = "SQL_COLLECT" ]]
            then #bypass collections in offiline mode
              COMTYPE="NOCOLLECT"
              call_get_log_result=0;
            fi
          fi

          #if [[ $run_in_multiple_versions -eq 1 && "$versions_to_run" = "no-release" ]]; then component_match_count=0; fi
          #if check_exadat_version is null than set very high values so it will execute for any exadata version. this is temporary fix until we have version for all checks
          check_exadata_version=$(echo $check_exadata_version|sed 's/ //g')       
          check_exadata_version=$(echo $check_exadata_version|sed 's/\.//g')
          if [ -z "$check_exadata_version" ]; then check_exadata_version=912240;fi
          
          #To delete white space from check_databaes_Role and to handle old checks where database_role is not assigned so default is primary
          check_database_role=$(echo $check_database_role|sed 's/ //g')       
          if [ -z "$check_database_role" ]; then check_database_role=PRIMARY;fi

          #To delete white space from check_databaes_type and to handle old checks where database_type is not assigned so default is normal
          check_database_type=$(echo $check_database_type|sed 's/ //g')       
          if [ -z "$check_database_type" ]; then check_database_type="NORMAL:CDB";fi

          #To delete white space from check_databaes_mode and to handle old checks where database_mode is not assigned so default is open
          check_database_mode=$(echo $check_database_mode|sed 's/ //g')       
          if [ -z "$check_database_mode" ]; then check_database_mode=3;fi

          #echo  "check_components=$check_components and components=$components component_match_count=$component_match_count for $CHECK_ID"
          if [[ $COMTYPE = "OS" && $REQUIRES_ROOT_OS = 1 ]]
          then
            echo "$COMTYPE" >/dev/null 2>&1
          fi     

          if [ $SILENT -eq "0" ]
          then
	    if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
              if [ $op_mode -eq 0 ]
              then
                ALVL=`grep _$ROW\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
                PMSG=`grep "_"$ROW"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
                FMSG=`grep "_"$ROW"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
                CAT=`grep "_"$ROW"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
                SUBCAT=`grep "_"$ROW"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
              else
                ALVL=`grep _$CHECK_ID\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
                PMSG=`grep "_"$CHECK_ID"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
                FMSG=`grep "_"$CHECK_ID"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
                CAT=`grep "_"$CHECK_ID"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
                SUBCAT=`grep "_"$CHECK_ID"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
              fi 
	    else
     	      ALVL_bak=$ALVL; unset ALVL; ALVL=$ALVL_bak
	    fi
            ALVL_CHECK=$ALVL
          fi

          is_java_check=0;
          is_xml_check=0;

          if [ `echo "$PMSG" | grep -c "HelloWorld"` -gt 0 ] ; then is_java_check=1; fi

          if [[ -n "$is_fmw_machine" && $is_fmw_machine -eq "1" && $OFFLINE -eq 0 && $OSCOLLECTSUM -eq "0" && $IDMHCEXECNT -eq "0" ]] ; then
	    execute_idmhealthcheck
            IDMHCEXECNT=1
          fi 
	  rskip_os_sql=0
          #CHECK TYPES 
          case $COMTYPE in
            OS|IDMHC_CHECK)
              if [ $is_java_check -eq "1" ] ; then
                export JAVA='/usr/bin/java'
                echo "export JAVA='/usr/bin/java'">>$ORCLENVFIL
                #cp -f $SCRIPTPATH/.cgrep/hw.jar $TMPDIR
                #cp -f $SCRIPTPATH/.cgrep/RunJavaChecks.jar $TMPDIR
                cp -f $SCRIPTPATH/.cgrep/hw.jar $RTEMPDIR
                cp -f $SCRIPTPATH/.cgrep/RunJavaChecks.jar $RTEMPDIR
              fi
	      if [[  -n "$run_acchk" && $run_acchk -eq "1" ]] ; then
	 	if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
		  if [ $op_mode -eq 0 ]
                  then
                    COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                    COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                    audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                  else
                    com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                    com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                    COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                    com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                    com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                    COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                    audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                  fi
		fi
                audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`

                if [ $OFFLINE -eq "0"  ]
                then
                  echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $RAT_AC_ASMJAR\n">>$CHECKS_TIMING
                  #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                  copy_env_files_to_tmp
                  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_acchk.sh/g");
      		  rm -f $localcmd>/dev/null 2>&1;
    	  	  security_fix "check_and_fix_script_existence" "$localcmd"

                  echo "#!$bash_scr" >$localcmd
                  echo "$RAT_DEBUG_FLG" >>$localcmd
                  echo "$bash_source" >>$localcmd
		  JDK=$RAT_JAVA_HOME;
		  RTJAR=$JDK/jre/lib/rt.jar
		  ACJAR=$SCRIPTPATH/.cgrep/acchk.jar
		  echo "export JAVA=$JDK/bin/java">>$localcmd
		  echo "export CLASSPATH=\"$RAT_AC_ASMJAR:$RTJAR:$ACJAR\"">>$localcmd
		  echo "export ARGS=\"$RAT_AC_JARDIR\"" >>$localcmd 

                  if [ -n "$COM_REPORT" ]
                  then
		    TAG3=1
                    echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - acchk - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                  fi

                  get_current_epoch
                  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: acchk][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                  if [ $i = $localnode ]
                  then
                    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                      cp -f ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $TMP_OUTPUT
                      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
                    else
                      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                    fi
                    echo "$COM">>$localcmd

                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
                    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
                    echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

      		    security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

                    FILVAL=`$localcmd 2>>$ERRFIL`
                    FILVAL=`echo "$FILVAL"|tr -d '\n'`
                    returncode=`echo $?`
                    set_alvl $returncode;

                    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                      cp -f $localcmd $TMP_OUTPUT >/dev/null 2>&1
                      #cmdname=`basename $localcmd`;
                      #localcmd="$TMP_OUTPUT/$cmdname";
                      #FILVAL=`$localcmd 2>>$ERRFIL`
                      #FILVAL=`echo "$FILVAL"|tr -d '\n'`
                      #returncode=`echo $?`
                      #set_alvl $returncode;
                      #cp -f $TMP_OUTPUT/${CHECK_ID}_${i}_report.out ${OUTPUTDIR}
                      cp -f $OUTFIL_REPORT ${OUTPUTDIR}
                    #else
                    #  FILVAL=`$localcmd 2>>$ERRFIL`
                    #  FILVAL=`echo "$FILVAL"|tr -d '\n'`
                    #  returncode=`echo $?`
                    #  set_alvl $returncode;
                    fi

                    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
                  else #remote
                    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
                    else
                      OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
                    fi

                    echo "$COM">>$localcmd

                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
                    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
                    echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

                    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                    #$SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                    $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1

                    #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                    #  $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$TMP_OUTPUT >/dev/null 2>&1
                    #  $SSHELL $i "chmod 644 $TMP_OUTPUT/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
                    #else
                    #  $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
                    #  $SSHELL $i "chmod 644 ${RTEMPDIR}/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
                    #fi
                    $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT >/dev/null 2>&1
                    $SSHELL $i "chmod 644 $OUTFIL_REPORT >/dev/null 2>&1"

		    #ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \$?"`
		    #security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"
		    ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		    security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"

		    FILVAL=`$SSHELL $i "$localcmd" 2>>$ERRFIL`
                    FILVAL=`echo "$FILVAL"|tr -d '\n'`
                    returncode=`echo $?`
                    set_alvl $returncode;

                    #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                    #  $SSHELL $i "cp -f $RTEMPDIR/localcmd.sh $TMP_OUTPUT"
                    #  cmdname="localcmd.sh";
                    #  localcmd="$TMP_OUTPUT/$cmdname";
		    #  FILVAL=`$SSHELL $i "$localcmd" 2>>$ERRFIL`
                    #  FILVAL=`echo "$FILVAL"|tr -d '\n'`
                    #  returncode=`echo $?`
                    #  set_alvl $returncode;
                    #else
                    #  FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
                    #  FILVAL=`echo "$FILVAL"|tr -d '\n'`
                    #  returncode=`echo $?`
                    #  set_alvl $returncode;
		    #fi
		    #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                    #  $SCOPY $i:$TMP_OUTPUT/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                    #  $SSHELL $i "rm -f $TMP_OUTPUT/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
                    #else
                    #  $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                    #  $SSHELL $i "rm -f $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
                    #fi
                    $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                    $SSHELL $i "rm -f $OUTFIL_REPORT>/dev/null 2>&1"
                    #REM_RC=`$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1;echo \$?;"`
          	    #security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                    REM_RC=`$SSHELL $i "rm -f $localcmd>/dev/null 2>&1;echo \\$?;"`
          	    security_fix "verify_remcode" "$i:$localcmd" "$REM_RC"
                    REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	    security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"
                  fi
		  get_current_epoch
                  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: acchk][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

                  move_failed_to_skipped "$returncode" "" "$i:acchk" "" "$FILVAL"
                  echo "" >>$OSSPOOLFIL
                  printf "%s %s %s %s %s %s\n" "acchk $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL

		  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
                fi
                call_get_log_result=0
                VAL=`grep "acchk $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                if [ -n "$COM_REPORT" ]
                then
                  SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                  if [ $OFFLINE -eq 0 ]
                  then
                    SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                  else
                    SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                  fi
                fi
                get_log_result "inloop" "acchk"
                if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for acchk\n">>$CHECKS_TIMING;fi
	      fi #acchk tool execution
	      	
	      if [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
	      then
		call_get_log_result=0
		echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because execute_once is true">>$LOGFIL
	      elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
	      then
		call_get_log_result=0
		echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because execute_once is true on compute">>$LOGFIL
	      elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OAM" && $NEEDS_RUNNING != "OUD" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
	      then
		call_get_log_result=0
		echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because execute_once is true">>$LOGFIL
	      elif [[ $NEEDS_RUNNING = "RDBMS" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 && ${#ttx_dbpath[@]} -ne 0 ]]
	      then
		if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	          if [ $op_mode -eq 0 ]
	          then 
	            COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
	            COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
	            audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
	          else
                    com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
	            com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
	            COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	            com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
	            com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
	            COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	            audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
	          fi
		fi
	        audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
	      	ORIG_PMSG=$PMSG
	        ORIG_FMSG=$FMSG
	        if [ $OFFLINE -eq 0 ];then cp -f $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;

	        mb_db_counter=0
	        for db_name_to_check in "${mb_db_names[@]}"
	        do
	          skip_this_version=0;
                  index=1;
                  d=1;

                  for ((j=1;j<=${#ttx_dbpath[@]};j+=1));
                  do
                    if [[ "${ttx_dbpath[$j]}" = "$db_name_to_check" ]];
                    then
                      d=$index;
                    fi
                    index=$(expr $index + 1);
                  done

	          if [ $skip_this_version -eq 0 ]
	          then
	            if [ $OFFLINE -eq "0" ]
	            then
	              echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING
	
	              sed  "/TTX_DBPATH/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm -f $INPUTDIR/tmp_env_file.out
	              sed  "/TTX_VERSION/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm -f $INPUTDIR/tmp_env_file.out
	              sed  "/TTX_INSTANCE_NAME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm -f $INPUTDIR/tmp_env_file.out
	              sed  "/TTX_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm -f $INPUTDIR/tmp_env_file.out
	              sed  "/TTX_DAEMON_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm -f $INPUTDIR/tmp_env_file.out
	
	              echo "export TTX_DBPATH='${ttx_dbpath[$d]}'">>$ORCLENVFIL
	              echo "export TTX_VERSION='${ttx_version[$d]}'">>$ORCLENVFIL
	              echo "export TTX_INSTANCE_NAME='${ttx_instance_name[$d]}'">>$ORCLENVFIL
	              echo "export TTX_HOME='${ttx_home[$d]}'">>$ORCLENVFIL
	              echo "export TTX_DAEMON_HOME='${ttx_daemon_home[$d]}'">>$ORCLENVFIL
	
	              #get_cygpath "ORCLENVFIL"
	              #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	              #restore_cygpath "ORCLENVFIL"
	              copy_env_files_to_tmp
	              db_name_to_check_noslash=$(echo ${db_name_to_check}|sed 's/\//_/g')
	              nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${db_name_to_check_noslash}.sh/g");
      		      
    	  	      security_fix "check_and_fix_script_existence" "$localcmd"

	              echo "#!$bash_scr" >$localcmd
	              echo "$RAT_DEBUG_FLG" >>$localcmd
	              echo "$bash_source" >>$localcmd
	              echo ". $TRGTORCLENV">>$localcmd

	              if [ -n "$COM_REPORT" ]
	              then
		      	TAG3=1
	                echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              fi
	        
	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	              if [ $i = $localnode ]
	              then
  		 	OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out	
	                echo "$COM">>$localcmd
	                if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

      		        security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

	                if [ $RAT_DEBUG -eq 1 ]
	                then
	                  FILVAL=`$localcmd`
	               	  returncode=`echo $?`
			  set_alvl $returncode;
	                else
	                  FILVAL=`$localcmd 2>>$ERRFIL`
	               	  returncode=`echo $?`
			  set_alvl $returncode;
	                fi

			#if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
	              else
   			OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
	                echo "$COM">>$localcmd
	                if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			#if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

	                get_cygpath "localcmd"
	                get_cygpath "OUTPUTDIR"
	                get_cygpath "RTEMPDIR"
	                $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	                $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1

		        ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \\$?"`
		        security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"

	                if [ $RAT_DEBUG -eq 1 ]
	                then
	                  FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh"`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                else
	                  FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                fi

	                $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1

                        $SSHELL $i "rm -f $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
                        REM_RC=`$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1;echo \\$?;"`
          	        security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                        REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	        security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"

	                restore_cygpath "localcmd"
	                restore_cygpath "OUTPUTDIR"
	                restore_cygpath "RTEMPDIR"
	              fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	              move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "" "$FILVAL"
	              echo "" >>$OSSPOOLFIL
	              printf "%s %s %s %s %s %s\n" "$db_name_to_check $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL

		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
	            fi

	            if [ -n "$COM_REPORT" ]
	            then
	              SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              if [ $OFFLINE -eq 0 ]
	              then
	                SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
	              else
	                SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              fi
	            fi
	            call_get_log_result=0
	            PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
	            FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
	            VAL=`grep "$db_name_to_check $PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
	            if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
	            get_log_result "inloop" "-"
	            if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING;fi
	          fi
	          mb_db_counter=$(expr $mb_db_counter + 1)
	        done

		unset db_name_to_check
	        mb_db_counter=0
	        write_report_on_fail=1
	        if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
	        then
	          cp -f $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
	          rm -f $INPUTDIR/trgt_orcl_env.orig
	          get_cygpath "ORCLENVFIL"
	          #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	          if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMP_OUTPUT; else  $SCOPY $ORCLENVFIL $i:$TMP_OUTPUT/ >/dev/null;fi;
	          restore_cygpath "ORCLENVFIL"
	        fi
		if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
	      elif [ "$PARAM" = "OMS_HOME" ]
              then
		if [ $OFFLINE -eq 0 ]
                then
                  emfile1=$MASTERFIL
                else
                  emfile1=$DUMPDIR/$CHKFIL
                fi
                if [[ $component_match_count  -lt 1 ]]
                then
                  echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                  call_get_log_result=0
                else
	          if [ $is_oms_installed -eq 1 ]
	          then
		    if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
  	              if [ $op_mode -eq 0 ]
                      then
                        COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                        COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                        audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                      else
                        com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                        com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                        COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                        com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                        COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                      fi
		    fi
                    audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`

		    if [[ `echo "$COM"|grep -ic 'OMS_SYSMAN_PASSWORD'` -gt 0 && -z $OMS_SYSMAN_PASSWORD ]]; then
		      call_get_log_result=0
		      echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because OMS_SYSMAN_PASSWORD is incorrect">>$LOGFIL
		    else
		      ORIG_PMSG=$PMSG
                      ORIG_FMSG=$FMSG
		      
   	              mb_oms_counter=0
		      for mb_oms_home in ${oms_homes[@]}
		      do
			oms_home_version=`grep -i "$i:$mb_oms_home:OMS_VERSION" $emfile1| $AWK -F"=" '{print $2}'|sed 's/ //g'|sed 's/\.//g'`
	                oms_version_found=$(echo $check_exadata_version|grep -iwc $oms_home_version)
			if [[ $oms_version_found -gt "0" ]]
			then
                        mb_oms_home_without_slash=$(echo $mb_oms_home|sed 's/\///g')
                        mb_oms_home_without_slash=$(echo $mb_oms_home_without_slash|sed 's/\.//g')
                        if [ $OFFLINE -eq "0"  ]
                        then
                          echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_oms_home\n">>$CHECKS_TIMING
		          
		          #get_cygpath "ORCLENVFIL"
		          #get_cygpath "TMPDIR"
                          #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
		          #restore_cygpath "ORCLENVFIL"
		          #restore_cygpath "TMPDIR"

		          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                            get_omsOwner
	           	    #chg_files_for_usr "localcmd,OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$localcmd,$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$omsOwner" "$omsGroup"
	           	    chg_files_for_usr "localcmd,ERRFIL,localcmdval" "$localcmd,$ERRFIL,$localcmdval" "$omsOwner" "$omsGroup"
			  fi

		          create_rtmpoutput "$i" "$TMP_OUTPUT" "$omsOwner" "$omsGroup"

                          copy_env_files_to_tmp "$usern"
                          nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_oms_home_without_slash}.sh/g");
      		 	  
    	  	  	  security_fix "check_and_fix_script_existence" "$localcmd"

                          echo "#!$bash_scr" >$localcmd
                          echo "$RAT_DEBUG_FLG" >>$localcmd
                          echo "$bash_source" >>$localcmd
		          echo "export ORACLE_HOME=$mb_oms_home">>$localcmd
                          if [ -n "$COM_REPORT" ]
                          then
		      	    TAG3=1
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_oms_home|tr "[a-z]" "[A-Z]") OMS HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                          fi

                          get_current_epoch
                          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_oms_home][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                          if [ $i = $localnode ]
                          then
		            get_cygpath "OUTPUTDIR"
		            get_cygpath "RTEMPDIR"
		            get_cygpath "TMP_OUTPUT"	  
		            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		              cp -f ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $TMP_OUTPUT
	                      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out

	                      chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT" "$omsOwner" "$omsGroup"
		            else
		              OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		            fi
		            get_cygpath "OUTFIL_REPORT"	  

                            echo "$COM">>$localcmd
                            
                            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
                            echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
                            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

		            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                              #get_omsOwner

		   	      #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$omsOwner"
	           	      #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$omsOwner" "$omsGroup"
			      move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

      		              security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
			      if [[ -e $OUTFIL_REPORT ]]; then
			        security_fix "fix_file_attributes" "$OUTFIL_REPORT" "$omsOwner:$omsGroup"
			      fi

                              chown $omsOwner:$omsGroup $localcmd
                              chown $omsOwner:$omsGroup $TRGTORCLENV
			      chown $omsOwner:$omsGroup $OUTFIL_REPORT
                              FILVAL=`su $omsOwner -c "export OMS_SYSMAN_PASSWORD=$OMS_SYSMAN_PASSWORD;$localcmd" 2>>$ERRFIL`
		              FILVAL=`echo "$FILVAL"|tr -d '\n'`	
                              returncode=`echo $?`
                              set_alvl $returncode;
		              #cp -f $TMP_OUTPUT/${CHECK_ID}_${i}_report.out ${OUTPUTDIR}
		              cp -f $OUTFIL_REPORT ${OUTPUTDIR}

		   	      write_del_rolbk_errlog
                            else
      		              security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

                              FILVAL=`export OMS_SYSMAN_PASSWORD=$OMS_SYSMAN_PASSWORD;$localcmd 2>>$ERRFIL`
		              FILVAL=`echo "$FILVAL"|tr -d '\n'`
                              returncode=`echo $?`
                              set_alvl $returncode;
                            fi
		            #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
		            restore_cygpath "OUTPUTDIR"
		            restore_cygpath "RTEMPDIR"
		            restore_cygpath "TMP_OUTPUT"
		            restore_cygpath "OUTFIL_REPORT"
                          else #remote
		            get_cygpath "OUTPUTDIR"
		            get_cygpath "RTEMPDIR"
		            get_cygpath "TMP_OUTPUT"	  
	    	            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	                      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out

	                      chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT" "$omsOwner" "$omsGroup"
		            else
		              OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
		            fi
		            get_cygpath "OUTFIL_REPORT"	  

                            echo "$COM">>$localcmd
                           
                            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
                            echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
                            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

                            #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			    move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

                            #$SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                            $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1

		            #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
  		            #  $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$TMP_OUTPUT >/dev/null 2>&1
		            #  $SSHELL $i "chmod 644 $TMP_OUTPUT/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
		            #else
		            #  $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
		            #  $SSHELL $i "chmod 644 ${RTEMPDIR}/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
		            #fi
  		            $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT/$omsOwner >/dev/null 2>&1
		            $SSHELL $i "chmod 644 $OUTFIL_REPORT>/dev/null 2>&1"

		            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                              #get_omsOwner

		   	      #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$omsOwner"
	           	      #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$omsOwner" "$omsGroup"

		              ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		    	      security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"

                              $SSHELL $i "chown $omsOwner:$omsGroup $localcmd"
		              $SSHELL $i "chown $omsOwner:$omsGroup $TMP_OUTPUT/${CHECK_ID}_${i}_report.out"	
                              $SSHELL $i "chown $omsOwner:$omsGroup $TRGTORCLENV"
                              FILVAL=`$SSHELL $i "su $omsOwner -c \"export OMS_SYSMAN_PASSWORD=$OMS_SYSMAN_PASSWORD;$localcmd\"" 2>>$ERRFIL`
		              FILVAL=`echo "$FILVAL"|tr -d '\n'`
                              returncode=`echo $?`
                              set_alvl $returncode;

			      write_del_rolbk_errlog
                            else
		              #ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \$?"`
		    	      #security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"
		              ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		    	      security_fix "verify_attrmodcode" "$localcmd" "$ATTRMOD_RC"

                              FILVAL=`$SSHELL $i "export OMS_SYSMAN_PASSWORD=$OMS_SYSMAN_PASSWORD;$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
		              FILVAL=`echo "$FILVAL"|tr -d '\n'`
                              returncode=`echo $?`
                              set_alvl $returncode;
                            fi
		            #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	                    #  $SCOPY $i:$TMP_OUTPUT/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                            #  $SSHELL $i "rm -f $TMP_OUTPUT/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
		            #else
		            #  $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                            #  $SSHELL $i "rm -f $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
		            #fi
                            #REM_RC=`$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1;echo \$?;"`
          	            #security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
		            $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                            $SSHELL $i "rm -f $OUTFIL_REPORT>/dev/null 2>&1"
                            REM_RC=`$SSHELL $i "rm -f $localcmd>/dev/null 2>&1;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$localcmd" "$REM_RC"
                            REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"

		            restore_cygpath "OUTPUTDIR"
		            restore_cygpath "RTEMPDIR"
		            restore_cygpath "TMP_OUTPUT"
		            restore_cygpath "OUTFIL_REPORT"
                          fi

                          get_current_epoch
                          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_oms_home][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

                          move_failed_to_skipped "$returncode" "" "$i:$mb_oms_home" "" "$FILVAL"
                          echo "" >>$OSSPOOLFIL
                          printf "%s %s %s %s %s %s\n" "$mb_oms_home_without_slash $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL

		          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
                        fi
                        call_get_log_result=0
                        VAL=`grep "$mb_oms_home_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                        if [ -n "$COM_REPORT" ]
                        then
                          SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                          if [ $OFFLINE -eq 0 ]
                          then
                            SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                          else
                            SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                          fi
                        fi
                        get_log_result "inloop" "$mb_oms_home"
                        if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for ${mb_oms_home}\n">>$CHECKS_TIMING;fi
			else
			  call_get_log_result=0;
			  echo "Check version($check_exadata_version) and system version($oms_home_version) dont match for check_id =$CHECK_ID">>$LOGFIL
			fi
		      done
		      unset mb_oms_home
		      mb_oms_counter=0
		    fi
	          else
		    call_get_log_result=0;
	          fi
                fi
	      elif [ "$PARAM" = "EMAGENT_HOME" ]
              then
		if [[ -z "$mb_em_home_version" ]]
		then
 		  if [ $OFFLINE -eq 0 ]
  		  then
		    emfile1=$MASTERFIL
		  else
		    emfile1=$DUMPDIR/$CHKFIL
		  fi
		  mb_em_home_version=`grep "$i.EMAGENT_VERSION" $emfile1|$AWK -F"=" '{print $2}'|sed 's/ //g'`
		fi
		if [[ -n $mb_em_home_version ]]; then em_version_found=$(echo $check_exadata_version|grep -iwc $mb_em_home_version); fi
                if [[ $component_match_count  -lt 1 ]]
                then
                  echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                  call_get_log_result=0
		elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1  ]]
                then
                  call_get_log_result=0
                elif [[ $em_version_found -eq "0" ]]
                then
		  call_get_log_result=0
		  echo "Check version($check_exadata_version) and system version($mb_em_home_version) dont match for check_id =$CHECK_ID">>$LOGFIL
                else
	          if [ $is_emagent_installed -eq 1 ]
	          then
		    if [ $is_windows -eq "1" ] ; then
		      get_cygpath "mb_emagent_home"
		      get_cygpath "agent_inst"
                    fi
		    if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
  	              if [ $op_mode -eq 0 ]
                      then
                        COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                        COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                        audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                      else
                        com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                        com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                        COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                        com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                        COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                      fi
		    fi
                    audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
	
		    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
		    OLD_OH=$ORACLE_HOME;
		    #mb_ogg_home=$mb_emagent_home
                    mb_emagent_home_without_slash=$(echo $mb_emagent_home|sed 's/\///g')
                    mb_emagent_home_without_slash=$(echo $mb_emagent_home_without_slash|sed 's/\.//g')
                    mb_emagent_home_with_underscore=$(echo $mb_emagent_home_without_slash|sed 's/\./_/g')
                    if [ $OFFLINE -eq "0"  ]
                    then
                      echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_emagent_home\n">>$CHECKS_TIMING
                      #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;

		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                        get_agentOwner
	                #chg_files_for_usr "localcmd,OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$localcmd,$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$agentOwner" "$agentGroup"
	                chg_files_for_usr "localcmd,ERRFIL,localcmdval" "$localcmd,$ERRFIL,$localcmdval" "$agentOwner" "$agentGroup"
		      fi
		      create_rtmpoutput "$i" "$TMP_OUTPUT" "$omsOwner" "$agentOwner" "$agentGroup"

                      copy_env_files_to_tmp "$usern"
                      #copy_env_files_to_tmp

                      nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_emagent_home_without_slash}.sh/g");
      		      
    	  	      security_fix "check_and_fix_script_existence" "$localcmd"

                      echo "#!$bash_scr" >$localcmd
                      echo "$RAT_DEBUG_FLG" >>$localcmd
                      echo "$bash_source" >>$localcmd
		      echo "export EMAGENT_HOME=${mb_emagent_home}">>$localcmd
		      echo "export EMAGENT_INST=${agent_inst}">>$localcmd
                      if [ -n "$COM_REPORT" ]
                      then
		      	TAG3=1
                        echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_emagent_home|tr "[a-z]" "[A-Z]") ORACLE AGENT HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      fi

                      get_current_epoch
                      echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_emagent_home][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                      if [ $i = $localnode ]
                      then
		        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		          cp -f ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $TMP_OUTPUT
	                  OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out

	                  chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT" "$agentOwner" "$agentGroup"
		        else
		          OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		        fi
                        echo "$COM">>$localcmd
                        
                        if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
                        echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		        echo "export ORACLE_HOME=$OLD_OH">>$localcmd
                        echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

		        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                          #get_agentOwner
		          #cp -f $localcmd $TMP_OUTPUT >/dev/null 2>&1
		          #cmdname=`basename $localcmd`;
		          #localcmd="$TMP_OUTPUT/$cmdname";	

		   	  #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$agentOwner"
	           	  #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$agentOwner" "$agentGroup"
			  move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

      		          security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
			  if [[ -e $OUTFIL_REPORT ]]; then
			    security_fix "fix_file_attributes" "$OUTFIL_REPORT" "$agentOwner:$agentGroup"
			  fi

                          chown $agentOwner:$agentGroup $localcmd
                          chown $agentOwner:$agentGroup $TRGTORCLENV
			  chown $agentOwner:$agentGroup $OUTFIL_REPORT
                          FILVAL=`su $agentOwner -c "$localcmd" 2>>$ERRFIL`
		          FILVAL=`echo "$FILVAL"|tr -d '\n'`	
                          returncode=`echo $?`
                          set_alvl $returncode;
		          cp -f $TMP_OUTPUT/${CHECK_ID}_${i}_report.out ${OUTPUTDIR}
			  write_del_rolbk_errlog
                        else
      		          security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

                          FILVAL=`$localcmd 2>>$ERRFIL`
		          FILVAL=`echo "$FILVAL"|tr -d '\n'`
                          returncode=`echo $?`
                          set_alvl $returncode;
                        fi
		            	
		        #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
                      else #remote
	    	        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	                  OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out

	                  chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT" "$agentOwner" "$agentGroup"
		        else
		          OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
		        fi

                        echo "$COM">>$localcmd
                       
                        if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
                        echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		        echo "export ORACLE_HOME=$OLD_OH">>$localcmd
                        echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

                        #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                        #$SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                        $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1

		        #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
  		        #  $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$TMP_OUTPUT >/dev/null 2>&1
		        #  $SSHELL $i "chmod 644 $TMP_OUTPUT/${CHECK_ID}_${i}_report.out"
		        #else
		        #  $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
		        #  $SSHELL $i "chmod 644 ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out"
		        #fi
  		        $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT/$agentOwner >/dev/null 2>&1
		        $SSHELL $i "chmod 644 $OUTFIL_REPORT >/dev/null 2>&1"

		        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                          #get_agentOwner

		   	  #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$agentOwner"
	           	  #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$agentOwner" "$agentGroup"
			  move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

			  $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1
			  $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT/$agentOwner >/dev/null 2>&1

		          ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		    	  security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"

		          #$SSHELL $i "cp -f $RTEMPDIR/localcmd.sh $TMP_OUTPUT"
                          #cmdname="localcmd.sh";
                          #localcmd="$TMP_OUTPUT/$cmdname";
                          $SSHELL $i "chown $agentOwner:$agentGroup $localcmd >/dev/null 2>&1"
		          #$SSHELL $i "chown $agentOwner:$agentGroup $TMP_OUTPUT/${CHECK_ID}_${i}_report.out"	
		          $SSHELL $i "chown $agentOwner:$agentGroup $OUTFIL_REPORT >/dev/null 2>&1"	
                          $SSHELL $i "chown $agentOwner:$agentGroup $TRGTORCLENV >/dev/null 2>&1"
                          FILVAL=`$SSHELL $i "su $agentOwner -c \"$localcmd\"" 2>>$ERRFIL`
		          FILVAL=`echo "$FILVAL"|tr -d '\n'`
                          returncode=`echo $?`
                          set_alvl $returncode;
			  write_del_rolbk_errlog
                        else
		          #ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \$?"`
		    	  #security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"
		          ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1;echo \\$?"`
		    	  security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"

                          #FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
                          FILVAL=`$SSHELL $i "$localcmd" 2>>$ERRFIL`
		          FILVAL=`echo "$FILVAL"|tr -d '\n'`
                          returncode=`echo $?`
                          set_alvl $returncode;
                        fi
		        #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	                #  $SCOPY $i:$TMP_OUTPUT/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                        #  $SSHELL $i "rm -f $TMP_OUTPUT/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
		        #else
		        #  $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                        #  $SSHELL $i "rm -f $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
		        #fi
                        #REM_RC=`$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1;echo \$?;"`
          	        #security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
	                $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                        $SSHELL $i "rm -f $OUTFIL_REPORT>/dev/null 2>&1"
                        REM_RC=`$SSHELL $i "rm -f $localcmd>/dev/null 2>&1;echo \\$?;"`
          	        security_fix "verify_remcode" "$i:$localcmd" "$REM_RC"
                        REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	        security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"
                      fi

                      get_current_epoch
                      echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_emagent_home][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

                      move_failed_to_skipped "$returncode" "" "$i:$mb_emagent_home" "" "$FILVAL"
                      echo "" >>$OSSPOOLFIL
                      printf "%s %s %s %s %s %s\n" "$mb_emagent_home_with_underscore $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL

		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
                    fi
                    call_get_log_result=0
                    VAL=`grep "$mb_emagent_home_with_underscore $PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                    if [ -n "$COM_REPORT" ]
                    then
                      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      if [ $OFFLINE -eq 0 ]
                      then
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                      else
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      fi
                    fi
                    get_log_result "inloop" "$mb_emagent_home"
                    if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_emagent_home\n">>$CHECKS_TIMING;fi
		    if [ $is_windows -eq "1" ] ; then
		      restore_cygpath "mb_emagent_home"
		      restore_cygpath "agent_inst"
		    fi
	          else
		    call_get_log_result='';
	          fi
                fi
              elif [[ $PARAM = "TIMESTEN" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 && ${#ttx_home[@]} -ne 0 ]]
       	      then
		if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                  if [ $op_mode -eq 0 ]
                  then 
                    COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                    COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                    audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                  else
                    com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
	            com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
	            COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	            com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
	            com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
	            COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                    #COM=`grep "_"$CHECK_ID"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                    #COM_REPORT=`grep "_"$CHECK_ID"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                    audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                  fi
		fi
                audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
                ORIG_PMSG=$PMSG
                ORIG_FMSG=$FMSG

                if [ $OFFLINE -eq 0 ];then cp -f $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;

		mb_db_counter=0
                for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                do
                  skip_this_version=1
                  index=1;
                  d=1;
                  for dump in ${ttx_home[@]}
                  do
                    if [ $dump = $mb_db_homes ];
                    then
                      d=$index;
                      skip_this_version=0;
                    fi
                    index=$(expr $index + 1);
                  done
                  mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                  mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
                  mb_db_homes_with_underscore=$(echo $mb_db_homes_without_slash|sed 's/\./_/g')
                  if [ $skip_this_version -eq 0 ]
                  then
                    if [ $OFFLINE -eq "0"  ]
                    then
                      echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING

                      sed  "/TTX_DBPATH/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm -f $INPUTDIR/tmp_env_file.out
                      sed  "/TTX_VERSION/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm -f $INPUTDIR/tmp_env_file.out
                      sed  "/TTX_INSTANCE_NAME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm -f $INPUTDIR/tmp_env_file.out
                      sed  "/TTX_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm -f $INPUTDIR/tmp_env_file.out
                      sed  "/TTX_DAEMON_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm -f $INPUTDIR/tmp_env_file.out

                      echo "export TTX_DBPATH='${ttx_dbpath[$d]}'">>$ORCLENVFIL
                      echo "export TTX_VERSION='${ttx_version[$d]}'">>$ORCLENVFIL
                      echo "export TTX_INSTANCE_NAME='${ttx_instance_name[$d]}'">>$ORCLENVFIL
                      echo "export TTX_HOME='${ttx_home[$d]}'">>$ORCLENVFIL
                      echo "export TTX_DAEMON_HOME='${ttx_daemon_home[$d]}'">>$ORCLENVFIL

                      #get_cygpath "ORCLENVFIL"
                      #get_cygpath "TMPDIR"
                      #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                      #restore_cygpath "ORCLENVFIL"
                      #restore_cygpath "TMPDIR"
                      copy_env_files_to_tmp
	              nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");
    	  	      security_fix "check_and_fix_script_existence" "$localcmd"

                      echo "#!$bash_scr" >$localcmd
	              echo "$RAT_DEBUG_FLG" >>$localcmd
                      echo "$bash_source" >>$localcmd
                      echo ". $TRGTORCLENV">>$localcmd
                      if [ -n "$COM_REPORT" ]
                      then
		      	TAG3=1
                        echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                      if [ $i = $localnode ]
                      then
			OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                        echo "$COM">>$localcmd

                        if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

	                if [ $RAT_DEBUG -eq 1 ]
                        then
                          FILVAL=`$localcmd`
	              	  returncode=`echo $?`
			  set_alvl $returncode;
	                else
                          FILVAL=`$localcmd 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                fi

			#if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
                      else
			OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
                        echo "$COM">>$localcmd
                        if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			#if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                        get_cygpath "localcmd"
                        get_cygpath "OUTPUTDIR"
                        get_cygpath "RTEMPDIR"
                        $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                        $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
		        ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \\$?"`
		    	security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"
	                if [ $RAT_DEBUG -eq 1 ]
	                then
                          FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh"`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                else
                          FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                fi

                        $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                        $SSHELL $i "rm -f $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
                        REM_RC=`$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1;echo \\$?;"`
          	        security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                        REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	        security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"

                        restore_cygpath "localcmd"
                        restore_cygpath "OUTPUTDIR"
                        restore_cygpath "RTEMPDIR"
                      fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	              move_failed_to_skipped "$returncode" "" "$i:$mb_db_homes" "" "$FILVAL"
                      echo "" >>$OSSPOOLFIL
                      printf "%s %s %s %s %s %s\n" "$mb_db_homes_with_underscore $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL
                    fi
	            call_get_log_result=0
                    PMSG=$(echo $ORIG_PMSG for ${mb_db_homes})
                    FMSG=$(echo $ORIG_FMSG for ${mb_db_homes})
                    call_get_log_result=0;
                    VAL=`grep "$mb_db_homes_with_underscore $PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                    if [ -n "$COM_REPORT" ]
                    then
                      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      if [ $OFFLINE -eq 0 ]
                      then
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                      else
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      fi
                    fi
                    if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
                    get_log_result "inloop" "$mb_db_homes"
                    if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
                  fi
                  mb_db_counter=$(expr $mb_db_counter + 1)
                done
                mb_db_counter=0
                write_report_on_fail=1
                if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
                then
                  cp -f $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                  rm -f $INPUTDIR/trgt_orcl_env.orig
                  get_cygpath "ORCLENVFIL"
                  #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                  if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMP_OUTPUT; else  $SCOPY $ORCLENVFIL $i:$TMP_OUTPUT/ >/dev/null;fi;
                  restore_cygpath "ORCLENVFIL"
                fi
              else 
                match=0				
                for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                do
                  for dump in ${ttx_home[@]}
                  do
                    if [[ "$dump" = "$mb_db_homes" ]];
                    then
                      match=$(expr $match + 1);
                    fi
                  done
                done
                if [[ $PARAM = "BI_INSTANCE" ]] && [[ $match -eq ${#mb_oracle_homes_distinct[@]} ]]
                then
                  call_get_log_result=0 
                elif [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "TIMESTEN" &&  ${ttx_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "GOLDENGATE_HOME" && $is_goldengate_installed -eq 0 ]]
                then
                  call_get_log_result=0
                elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
                then
                  call_get_log_result=0
                elif  [[ $component_match_count  -lt 1 ]]
                then
                  echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                  call_get_log_result=0

		elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1  ]]
                then
                  call_get_log_result=0
                  generate_exceptions_xml "Skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because its excluded"
		  generate_exceptions_json "Skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because its excluded"
                elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]] 
                then
                  call_get_log_result=0 
                  echo "Skipping $audit_check_name (CHECK ID $CHECK_ID)  on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                  generate_exceptions_xml "Skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because its in exclude file $EXCLUDEFIL"
		  generate_exceptions_json "Skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because its in exclude file $EXCLUDEFIL"
                  #added this condtion because Andrego asked not to run these three checks if not profiles in use
		elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
                then 
                  call_get_log_result=0
                  echo "Not running $audit_check_name($CHECK_ID) because no profile is in use">>$LOGFIL
                else 
                  #echo "$SF and count=`echo $SF|grep -ic "GENERIC ORACLE PRE-UPGRADE COLLECTIONS AND AUDIT CHECKS"` and TYP=$TYP"
                  call_get_log_result=1
		  if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                    if [ $op_mode -eq 0 ]
                    then 
                      COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                      COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                      audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                    else
	              com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
	              com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
	              COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	              com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
	              com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
	              COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                      #if action report is "intentionally left blank" then unset it beacuse we dont want to print that in report
                      if [ `echo $COM_REPORT|grep -icw "blank"` -ge 1 ]; then unset COM_REPORT;fi
                      audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                    fi
		  fi
                  audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`

		  if [[ $COMTYPE = "IDMHC_CHECK" ]]; then 
		    call_get_log_result=1
	            plugin_id=$(echo "$COM"|awk -F'.' '{print $NF}'|sed 's/ //g')
 	            plugin_desc="$audit_check_name"
	            plugin_invoke=""
	            plugin_class="$COM"
	            plugin_cpath=""

                    if [ $RAT_DEBUG -eq 1 ] ; then echo "pluginid=$plugin_class"; fi
                    if [[ -n "$idmhc_xml_outfile" && -r "$idmhc_xml_outfile" ]] ; then
                      com_ofile="$OUTPUTDIR/xmlcheck_com.out"
                      rm -f $com_ofile
                      COM="$perl_exe $SCRIPTPATH/.cgrep/idmhc_get_check_status.pl \"$plugin_id\" \"$idmhc_xml_outfile\" >$com_ofile 2>&1; echo \$?"
                      COM_REPORT="cat $com_ofile"
                      OP="-eq"
                      COMP=0
		
		      if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
	 	        echo "$perl_exe $SCRIPTPATH/.cgrep/idmhc_get_check_status.pl \"$plugin_id\" \"$idmhc_xml_outfile\" >$com_ofile 2>/dev/null;"
		      fi
	 	      $perl_exe $SCRIPTPATH/.cgrep/idmhc_get_check_status.pl "$plugin_id" "$idmhc_xml_outfile" >$com_ofile 2>/dev/null; 
		      base_idmhc_xml_outfile=$(basename "$idmhc_xml_outfile")
                      if [[ `cat $com_ofile 2>/dev/null|wc -w|sed 's/ //g'` -eq "0" ]]; then
                        echo "skipping $audit_check_name (checkid:-$CHECK_ID) on $i because it is not applicable to this Identity Management topology" >>$EXCLUDELOG 
                        generate_exceptions_xml "skipping $audit_check_name on $i because it is not applicable to this Identity Management topology"  
		        generate_exceptions_json "skipping $audit_check_name on $i because it is not applicable to this Identity Management topology"
                        call_get_log_result=0
                      fi
		      rm -f $com_ofile  >/dev/null 2>&1;
                    fi
		  else
                    if [ `echo "$COM" | grep -c "<plugin id="` -gt 0 ] ; then is_xml_check=1; fi
                    if [[ $is_xml_check -eq "1" ]] ; then
                      if [ "$RAT_DEBUG" -eq "1" ] ; then echo "COM=$COM"; fi
                      pluginid=$(echo $COM| grep "plugin id="| sed 's/.* id=.//' |sed 's/".*//')
                      if [ $RAT_DEBUG -eq 1 ] ; then echo "pluginid=$pluginid"; fi
                      if [[ -n "$idm_xml_outfile" && -r "$idm_xml_outfile" ]] ; then
                        com_ofile="$OUTPUTDIR/xmlcheck_com.out"
                        rm -f $com_ofile
                        COM="$perl_exe $SCRIPTPATH/.cgrep/idmhc_get_check_status.pl $pluginid $idm_xml_outfile >$com_ofile 2>&1; echo \$?"
                        COM_REPORT="cat $com_ofile"
                        OP="-eq"
                        COMP=0

		        if [[ -n "$RAT_PDEBUG" && $RAT_PDEBUG -eq "1" ]]; then
	 	          echo "$perl_exe $SCRIPTPATH/.cgrep/idmhc_get_check_status.pl \"$plugin_id\" \"$idmhc_xml_outfile\" >$com_ofile 2>/dev/null;"
		        fi
	 	        $perl_exe $SCRIPTPATH/.cgrep/idmhc_get_check_status.pl "$plugin_id" "$idmhc_xml_outfile" >$com_ofile 2>/dev/null; 
		        base_idmhc_xml_outfile=$(basename "$idmhc_xml_outfile")
                        if [[ `cat $com_ofile 2>/dev/null|wc -w|sed 's/ //g'` -eq "0" ]]; then
                          echo "skipping $audit_check_name (checkid:-$CHECK_ID) on $i because it is not applicable to this Identity Management topology" >>$EXCLUDELOG 
                          generate_exceptions_xml "skipping $audit_check_name on $i because it is not applicable to this Identity Management topology" 
 			  generate_exceptions_json "skipping $audit_check_name on $i because it is not applicable to this Identity Management topology"                                                                   
                          call_get_log_result=0
                        fi
		        rm -f $com_ofile  >/dev/null 2>&1;
                      fi
                    fi
		  fi

                  if [[ "$NEEDS_RUNNING" = "ASM" || "$NEEDS_RUNNING" = "ACFS" ]] && [[ $OFFLINE -eq "0" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
                  then
                    OLD_ORACLE_SID=$(grep ORACLE_SID $ORCLENVFIL|cut -d= -f2)
                    OLD_ORACLE_HOME=$(grep ORACLE_HOME $ORCLENVFIL|cut -d= -f2)
		    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then 
		      OLD_ORACLE_HOME="$RAT_ORACLE_HOME";
		    fi
	            sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	            cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	            rm -f $INPUTDIR/tmp_env_file.out
	            sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	            cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	            rm -f $INPUTDIR/tmp_env_file.out
	            echo "export ORACLE_SID=${stack_asm_sid[$stack_counter]}">>$ORCLENVFIL
	            
	            inst_name=${stack_asm_sid[$stack_counter]} 
                    if [[ -n "$crs112" && $crs112 -ge 1 ]]
                    then
                      echo "export ORACLE_HOME=$CRS">>$ORCLENVFIL
                    else
	              echo "export ORACLE_HOME=${stack_asm_home[$stack_counter]}">>$ORCLENVFIL
                    fi
		    update_ld_lib_path "CRS"
                    get_cygpath "ORCLENVFIL"
                    #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                    if [ $i = $localnode ]; then cp -f $ORCLENVFIL $RTEMPDIR; else  $SCOPY $ORCLENVFIL $i:$RTEMPDIR/ >/dev/null;fi;
                    restore_cygpath "ORCLENVFIL"
                    #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`    
                    TRGTORCLENV=$RTEMPDIR/`basename $ORCLENVFIL`    
                    #cat $TRGTORCLENV
                    #$READ -p "OLD_ORACLE_SID=$OLD_ORACLE_SID OLD_ORACLE_HOME=$OLD_ORACLE_HOME ORACLE_HOME=$ORACLE_HOME ORACLE_SID=$ORACLE_SID"
                  fi

	          if [[ -n "$os_check_needs_collect_file" && $os_check_needs_collect_file -eq 1 ]]
	          then 
	            if [ -f $OUTPUTDIR/$VAL_FIL ]
	            then
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			cp -f $OUTPUTDIR/$VAL_FIL $TMP_OUTPUT			
		      else
			cp -f $OUTPUTDIR/$VAL_FIL $RTEMPDIR
		      fi
	              collect_files[$collect_file_counter]=${VAL_FIL}
	              collect_file_counter=$(expr $collect_file_counter + 1 )
	            fi
	          #$READ -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
	          fi
                  #echo  "needs_running=$NEEDS_RUNNING action=$COM"
                  #echo "multiple_db=$multiple_db NEEDS_RUNNING=$NEEDS_RUNNING PARAM=$PARAM limits=`echo $COM|grep -ic "limits.conf"` usrlimit=`echo $COM|grep -ic "usrlimit"`"
                  if [[ `echo $COM|grep -ic "limits.conf"` -ge 1 || `echo $COM|grep -ic "usrlimit"` -ge 1 ]]; then ulimit_cmd=1;else ulimit_cmd=0;fi
                  #Not to call get_log_result for storage server cells in exalogic if its running on remote node
                  if [[ ( $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" ) && -e $CELLIP && -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" && $i != $localnode ]]; then call_get_log_result=0;fi
                  if [[ ( $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" ) && -e $CELLIP && -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && $i != $localnode ]]; then call_get_log_result=0;fi
                  if [[ ( $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" ) && -e $ZFSIP && -n "$is_ssc_zfsnodes_passed" && $is_ssc_zfsnodes_passed -eq "1" && $i != $localnode ]]; then call_get_log_result=0;fi
                  if [[ ( $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" ) && -e $ZFSIP && -n "$is_zfssa_machine" && $is_zfssa_machine -eq "1" && $i != $localnode ]]; then call_get_log_result=0;fi
                  if [[ ( $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" ) && $is_ssc_machine -eq 1 && $is_ssc_zfsnodes_passed -eq 0 ]];then call_get_log_result=0;fi
                  if [[ $NEEDS_RUNNING = "STORAGE_CELL" && $RAT_RUNMODE_INTERNAL = "slave" ]]; then call_get_log_result=0;fi
                  if [[ ( $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" ) && $RAT_RUNMODE_INTERNAL = "slave" ]]; then call_get_log_result=0;fi
                  # Dont call get_log_result if user selected skip cells
                  if [[ $NEEDS_RUNNING = "STORAGE_CELL" && -n "$cell_password_status" && $cell_password_status -eq 3 ]]; then call_get_log_result=0;fi
                  if [[ ($NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS") && -n "$zfs_password_status" && $zfs_password_status -eq 3 && -e $ZFSIP ]] ; then call_get_log_result=0;fi
                  if [[ $NEEDS_RUNNING = "ZFS" && ! -e $ZFSIP ]]; then call_get_log_result=0; fi
                  if [[ $NEEDS_RUNNING = "EXTERNAL_ZFS" && ! -e $EXTZFSIP ]]; then call_get_log_result=0; fi
                  if [[ $NEEDS_RUNNING = "TOR_SWITCH" && ! -n "$RAT_TORSWITCHES" ]]; then call_get_log_result=0; fi
                  #$READ -p "ulimit_cmd=$ulimit_cmd in $COM"
	
                  if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
                  then
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    if [ $OFFLINE -eq 0 ];then cp -f $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;
                    #cat $ORCLENVFIL
                    #$READ -p "before mbd os"
                    mb_db_counter=0
                    mb_db_counter_log=0

                    #Meta File for DB parallelization
 	            if [[ $OFFLINE -eq "0" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	            then 
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		        COM=$(echo "$COM"|sed 's/\$TMPDIR/\$TMP_OUTPUT/g'|sed 's/\$RTEMPDIR/\$TMP_OUTPUT/g')
			COM_REPORT=$(echo "$COM_REPORT"|sed 's/\$TMPDIR/\$TMP_OUTPUT/g'|sed 's/\$RTEMPDIR/\$TMP_OUTPUT/g')
		      fi 
		      t_PSQL_STAT="${PSQL_STAT}_${CHECK_ID}"
                      t_PSQL_METAFIL="${PSQL_METAFIL}_${CHECK_ID}"
	              t_PSQL_INFIL="${PSQL_INFIL}_${CHECK_ID}"

                      echo "CHECKID=$CHECK_ID"                             	 	>  $t_PSQL_METAFIL 
                      echo "COMTYPE=$COMTYPE"                              	 	>> $t_PSQL_METAFIL  
                      echo "COM_START=$COM" 					        >> $t_PSQL_METAFIL 
		      echo "COM_END"						        >> $t_PSQL_METAFIL
                      echo "COM_REPORT_START=$COM_REPORT"                    	        >> $t_PSQL_METAFIL 
                      echo "COM_REPORT_END"    	                   	                >> $t_PSQL_METAFIL 
                      echo "AUDIT_CHECK_NAME=$audit_check_name"            	    	>> $t_PSQL_METAFIL 
                      echo "RAT_RUNMODE_INTERNAL=$RAT_RUNMODE_INTERNAL"    	 	>> $t_PSQL_METAFIL 
	              echo "PARAM_PATH=$PARAM_PATH"                             	>> $t_PSQL_METAFIL
	              echo "ROW=$ROW"                                                   >> $t_PSQL_METAFIL
	
	              #DB information for DB parallelization
	              t_mb_db_counter=0
	              for db_name_to_check in "${mb_db_names[@]}"
	              do
	                match_database_role "${mb_database_role[$t_mb_db_counter]}"
	                match_database_type "${mb_database_type[$t_mb_db_counter]}"

			if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 ]]; then
    			  if [[ ! -n ${mb_oracle_sids[$mb_db_counter]} || ${mb_oracle_sids[$mb_db_counter]} = "" ]]; then
    			     mb_oracle_sids[$mb_db_counter]=$(grep "${mb_running_host[$t_mb_db_counter]}.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}')
    			  fi
			fi
	                echo "${db_name_to_check},${mb_oracle_sids[$t_mb_db_counter]},${mb_oracle_homes[$t_mb_db_counter]},${mb_database_role[$t_mb_db_counter]},$dbrole_match_count,${mb_database_type[$t_mb_db_counter]},$dbtype_match_count,${mb_sysdba_user[$t_mb_db_counter]},${mb_sysdba_pswd[$t_mb_db_counter]},${RAT_PDB_USER},${mb_db_sys_password[$t_mb_db_counter]},${mb_db_connect_string[$t_mb_db_counter]},${mb_checksysdba[$t_mb_db_counter]},${mb_running_host[$t_mb_db_counter]},${mb_database_app_user[$t_mb_db_counter]}" >> $t_PSQL_INFIL
	                t_mb_db_counter=$(expr $t_mb_db_counter + 1)
	              done
		      unset db_name_to_check
	              t_mb_db_counter=0
	            fi

                    psql_counter=0
                    for db_name_to_check in "${mb_db_names[@]}"
                    do
		      unset FILVAL VAL
                      #$READ -p "current_oh_owner=$current_oh_owner"
 	              if [[ $OFFLINE -eq "0" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	              then
	                if [[ $psql_counter -eq 0 ]]
	                then
	                  parallel_sql
	                fi
			#if [[ -n $PRET_STATUS && $PRET_STATUS -ne "0" ]]; then
  			#  move_failed_to_skipped "$PRET_STATUS" "" "$i:$db_name_to_check" "1"
			#fi
			if [[ -n $PRET_STATUS && $PRET_STATUS -eq "0" ]]; then
	                  if [[ -e $OSSPOOLFIL ]]; then FILVAL=`grep "$db_name_to_check $PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`; fi
			fi
  			move_failed_to_skipped "$PRET_STATUS" "" "$i:$db_name_to_check" "1" "$FILVAL"
	
                        psql_counter=$(expr $psql_counter + 1)
	              fi

                      if [ $OFFLINE -eq 0  ]
                      then
                        current_oh_owner=$(ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle 2>/dev/null|awk '{print $3}')
			if [[ -z $current_oh_owner ]]; then
                          current_oh_host=$(grep -w "RDBMS_ORACLE_HOME = ${mb_oracle_homes[$mb_db_counter]}" $MASTERFIL|awk '{print $3}'|cut -d '|' -f4|cut -d ',' -f1)
			  t_flag="-T"
			  current_oh_owner=`$SSHELL $t_flag ${current_oh_host} "ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle 2>/dev/null >&1|awk '{print \\$3}'"`
			fi
                      else
                        usern=$(grep "CURRENT_USER" $DUMPDIR/$CHKFIL|awk '{print $3}')
                        current_oracle_home=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                        current_oh_owner=$(grep -w "RDBMS_ORACLE_HOME = $current_oracle_home" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                      fi
		      if [[ -n $current_oh_owner ]]; then 
			dbGroup=$(groups "$current_oh_owner" 2>/dev/null >&1|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
			if [[ -z $dbGroup && $OFFLINE -eq 0 ]]; then
 		          dbGroup=`$SSHELL $t_flag ${current_oh_host} "groups "$current_oh_owner"|cut -d: -f2|awk '{print \\$1}'|sed 's/ //g'"`
		          dbhome_dir=`$SSHELL $t_flag ${current_oh_host} "grep "^${current_oh_owner}:" /etc/passwd|cut -d":" -f6"`
			else
      			  dbhome_dir=$(grep "^${current_oh_owner}:" /etc/passwd|cut -d":" -f6);
			fi
			if [[ -z $dbhome_dir && $OFFLINE -eq 0 ]]; then
			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			    dbhome_dir=`$SSHELL $t_flag $1 "$bash_scr -c \"su - $dbOwner -c \\\"echo \\\\\\\$HOME\\\"\" 2>/dev/null" 2>/dev/null`
			    if [[ -z $dbhome_dir ]]; then dbhome_dir=`$bash_scr -c "su - $dbOwner -c \"echo \\\\\\\$HOME\" 2>/dev/null" 2>/dev/null`; fi
		          else
			    dbhome_dir=$(echo $HOME);
			  fi
			fi
		      fi 

		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_dirs_existence "$current_oh_owner" "$dbGroup"; fi

                      skip_this_version=0
                      set_skip_this_version "-"
                      if [ $skip_this_version -eq 1 ] ; then
                        echo "Skipping check($CHECK_ID) on version 1 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                      fi

                      #if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]]
                      if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]] || [[ $skip_this_version -eq 0 && -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]
                      then
                        skip_this_version=0
                      else
                        skip_this_version=1
                      fi
                      #$READ -p "current_oh_owner=$current_oh_owner"
                      #following if is to skip any audit checks which query files in ORALCE_HOME not owned by current user
	              call_get_log_result=0
                      if [ $skip_this_version -eq 0 ]
                      then
	                if [ $OFFLINE -eq 0  ]
	                then
	                  inst_mode=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
			  inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}');
	                else
	                  inst_mode=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
			  inst_name=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_NAME|awk '{print $3}');
	                fi
                        #$READ -p "inst_mode=$inst_mode for $db_name_to_check dbrole = ${mb_database_role[$mb_db_counter]} and check_database_role = $check_database_role"
                        match_database_role "${mb_database_role[$mb_db_counter]}"
                        match_database_type "${mb_database_type[$mb_db_counter]}"  
                        if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]
                        then
	                  if [[ $OFFLINE -eq "0"  && -n "$inst_mode" && $inst_mode -eq 3  && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
	                  then
	                    echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING 
	              	    #$READ -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
	                    sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	                    cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	                    rm -f $INPUTDIR/tmp_env_file.out
	                    sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	                    cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	                    rm -f $INPUTDIR/tmp_env_file.out
	                    inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
	                    echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
	                    echo "export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}">>$ORCLENVFIL
			    update_ld_lib_path
	                    #get_cygpath "ORCLENVFIL"
	                    #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	                    #restore_cygpath "ORCLENVFIL"

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	           	      #chg_files_for_usr "localcmd,OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$localcmd,$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
	           	      chg_files_for_usr "localcmd,ERRFIL,localcmdval" "$localcmd,$ERRFIL,$localcmdval" "$current_oh_owner"
			    fi

		            create_rtmpoutput "$i" "$TMP_OUTPUT" "$current_oh_owner" "$dbGroup"

                            copy_env_files_to_tmp "$usern"
	                    nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${db_name_to_check}.sh/g");
      		 	    
    	  	  	    security_fix "check_and_fix_script_existence" "$localcmd"

                            echo "#!$bash_scr" >$localcmd
	                    echo "$RAT_DEBUG_FLG" >>$localcmd
                            echo "$bash_source" >>$localcmd
                            echo ". $TRGTORCLENV">>$localcmd

	                    if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
	                    then	
			      if [ -n "$COM_REPORT" ]; then TAG3=1; fi
	                      get_current_epoch 
	                      echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
	                    fi

	                    if [ $i = $localnode ]
	                    then
			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			        OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
			        OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out

	                  	chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT" "$current_oh_owner"
			      else
			        OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			      fi
                              if [ -n "$COM_REPORT" ]; then
                                echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                              fi
	              	      echo "$COM">>$localcmd
                              if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			      echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	      echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				OLD_DIR=`pwd`
				cd "$dbhome_dir";

		   	  	#subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
	           	 	#chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
			  	move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

      		          	security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
			  	if [[ -e $OUTFIL_REPORT ]]; then
			  	  security_fix "fix_file_attributes" "$OUTFIL_REPORT" "$current_oh_owner:$dbGroup"
			  	fi

				chown $current_oh_owner:$dbGroup $TRGTORCLENV
				chown $current_oh_owner:$dbGroup $localcmd
				if [[ -e $OUTFIL_REPORT ]]; then chown $current_oh_owner:$dbGroup $OUTFIL_REPORT; fi
	              	        FILVAL=`su $current_oh_owner -c "$localcmd 2>>$ERRFIL"`
	              	        returncode=`echo $?`
				set_alvl $returncode;

				move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
				write_del_rolbk_errlog

				cd $OLD_DIR;
	    			unset OLD_DIR
			      else
      		          	security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

	              	        FILVAL=`$localcmd 2>>$ERRFIL`
	              	        returncode=`echo $?`
				set_alvl $returncode;
			      fi

			      #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			      if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
	                    else
			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
  			        OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
  			        OLD_OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out

	                  	chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT" "$current_oh_owner"
			      else
  			        OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			      fi
                              if [ -n "$COM_REPORT" ]; then
                                echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                              fi
                              echo "$COM">>$localcmd
                              if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			      echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	      echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			      #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			      if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
      		   	      security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV" "" "740"
      		   	      security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				OLD_DIR=`pwd`
				cd "$dbhome_dir";

		   	  	#subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
	           	 	#chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
			  	move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

                                get_cygpath "OUTFIL_REPORT"
                                get_cygpath "TMP_OUTPUT"
                                get_cygpath "localcmd"
                                $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1
                                $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT/$current_oh_owner >/dev/null 2>&1

				$SSHELL $i "if [ -e $OUTFIL_REPORT ]; then chown $current_oh_owner:$dbGroup $OUTFIL_REPORT; fi"
		 		ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $current_oh_owner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
				security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		 		ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV >/dev/null 2>&1; chown $current_oh_owner:$dbGroup $TRGTORCLENV >/dev/null 2>&1;echo \\$?"`
				security_fix "verify_attrmodcode" "$i:$TRGTORCLENV" "$ATTRMOD_RC"

                                FILVAL=`$SSHELL $i "su ${current_oh_owner} -c \"$TMP_OUTPUT/localcmd.sh\"" 2>>$ERRFIL`
	              	        returncode=`echo $?`
                                set_alvl $returncode;
				cd $OLD_DIR
	    			unset OLD_DIR
                                restore_cygpath "OUTFIL_REPORT"
                                restore_cygpath "TMP_OUTPUT"
                                restore_cygpath "localcmd"

				write_del_rolbk_errlog
			      else
                                get_cygpath "RTEMPDIR"
                                get_cygpath "localcmd"
                                $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                                $SCOPY $OUTFIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1

		        	ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \\$?"`
		    		security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"

                                FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	              	        returncode=`echo $?`
                                set_alvl $returncode;
                                restore_cygpath "RTEMPDIR"
                                restore_cygpath "localcmd"
			      fi

                              get_cygpath "OUTFIL_REPORT"
                              get_cygpath "OUTPUTDIR"
                              $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                              $SSHELL $i "rm -f $OUTFIL_REPORT>/dev/null 2>&1"
                              REM_RC=`$SSHELL $i "if [ -e $RTEMPDIR/localcmd.sh ]; then rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1; fi;echo \\$?;"`
          	              security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                              REM_RC=`$SSHELL $i "if [ -e $TMP_OUTPUT/localcmd.sh ]; then rm -f $TMP_OUTPUT/localcmd.sh>/dev/null 2>&1; fi;echo \\$?;"`
          	              security_fix "verify_remcode" "$i:$TMP_OUTPUT/localcmd.sh" "$REM_RC"
                              REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	              security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"

                              restore_cygpath "OUTPUTDIR"
                              restore_cygpath "OUTFIL_REPORT"
	                    fi

	              	    if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
	              	    then	
	              	      get_current_epoch 
	                      echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	                    fi

	                    move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "1" "$FILVAL"
	                    echo "" >>$OSSPOOLFIL
	                    printf "%s %s %s %s %s %s\n" "$db_name_to_check $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL
	                    #echo " $db_name_to_check $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL

		      	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
	                  fi 

                          if [[ -n "$inst_mode" && $inst_mode -eq 3 ]]
	                  then
	                    if [ -n "$COM_REPORT" ]
	                    then 
	                      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	                      if [ $OFFLINE -eq 0 ]
	                      then
	                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
	                      else
	                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	                      fi
	                    fi   
	                    PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
	                    FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
	                    VAL=`grep "$db_name_to_check $PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
	                    if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
			
  			    if [[ -n "$rskip_os_sql" && $rskip_os_sql == 1 ]]; then
			      rskip_os_sql=0
	                      mb_db_counter_log=$(expr $mb_db_counter_log + 1)
			    else
	                      get_log_result "inloop" "-"
	                      mb_db_counter_log=$(expr $mb_db_counter_log + 1)
	                      if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING;fi
			    fi
	                  fi
                        else
                          call_get_log_result=0    
                          echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL 
                        fi
                      fi
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
                      mb_db_counter=$(expr $mb_db_counter + 1)
                    done

	            if [[ $OFFLINE -eq "0" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	            then
    		      if [[ -z $RAT_PDEBUG ]]; then 
	                rm -f "$t_PSQL_METAFIL" >/dev/null 2>&1
	                rm -f "$t_PSQL_INFIL" >/dev/null 2>&1
		        rm -f "$t_PSQL_STAT" >/dev/null 2>&1
		      fi
	            fi

		    unset db_name_to_check
                    mb_db_counter=0
                    write_report_on_fail=1
                    if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
                    then 
                      cp -f $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                      rm -f $INPUTDIR/trgt_orcl_env.orig
                      get_cygpath "ORCLENVFIL"
                      #get_cygpath "TMPDIR"
                      get_cygpath "TMP_OUTPUT"
	              #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	              if [ $i = $localnode ]; then cp -f $ORCLENVFIL $RTEMPDIR; else  $SCOPY $ORCLENVFIL $i:$RTEMPDIR/ >/dev/null;fi;
                      restore_cygpath "ORCLENVFIL"
                      #restore_cygpath "TMPDIR"
                      restore_cygpath "TMP_OUTPUT"
                    fi
                    #cat $ORCLENVFIL
                    #$READ -p "after mbd os"
                  elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -ge 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" ]] && [[ $PARAM = "RDBMS" || $PARAM = "BI_INSTANCE" ]] && [[ -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]] 
                  then
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    if [ $OFFLINE -eq 0 ];then cp -f $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;
                    #cat $ORCLENVFIL
                    #$READ -p "before mbd os"
                    mb_db_counter=0
                    mb_db_counter_log=0
                    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                    do
                      skip_this_version=0
                      set_skip_this_version "$mb_db_homes"
                      if [ $skip_this_version -eq 1 ]
                      then #dont run
                        mb_db_counter=$(expr $mb_db_counter + 1)
	                mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                        echo "Skipping check($CHECK_ID) on version 2 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                        continue
                      fi
                      
                      index=1;
                      match=0
                      for dump in ${ttx_home[@]}
                      do
                        if [ $dump = $mb_db_homes ];
                        then
                          match=1;
                        fi
                        index=$(expr $index + 1);
                      done
                      if [ $match -eq 1 ]; then continue; fi		

                      mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                      mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
                      mb_db_homes_with_underscore=$(echo $mb_db_homes_without_slash|sed 's/\./_/g')

                      if [ $OFFLINE -eq "0" ]; then
		        db_name_to_check=`grep "DB_NAME =" $MASTERFIL | grep $mb_db_homes | awk -F"=" '{print $2}' | awk -F"|" '{print $1}' | sed 's/ //g' | head -1`
		      else
		        db_name_to_check=`grep "DB_NAME =" $DUMPDIR/$CHKFIL | grep $mb_db_homes | awk -F"=" '{print $2}' | awk -F"|" '{print $1}' | sed 's/ //g' | head -1`
		      fi

	              if [[ $PARAM = "BI_INSTANCE" ]]
	              then
                      	if [ $OFFLINE -eq "0"  ]
	                then
                          echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING
                      	  sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	                  cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                          rm -f $INPUTDIR/tmp_env_file.out
                      	  sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	                  cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      	  rm -f $INPUTDIR/tmp_env_file.out
                          inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
	                  echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
                          echo "export ORACLE_HOME=${mb_db_homes}">>$ORCLENVFIL
			  update_ld_lib_path
	              	  ORACLE_HOME=${mb_db_homes}
	              	  bi_instances=$(grep -iw "OBIEE_INSTANCE_MAP:" $MASTERFIL |grep -i "$ORACLE_HOME "|awk -F'=' '{print $2}')
	              	  bi_instances=$(echo $bi_instances|sed 's/,/ /g');

	              	  for bi_instance in `echo $bi_instances`		
	              	  do
                      	    bi_instance_without_slash=$(echo $bi_instance|sed 's/\///g')
	              	    bi_instance_without_slash=$(echo $bi_instance_without_slash|sed 's/\.//g')

	              	    sed "/BI_INSTANCE/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              	    cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              	    rm -f $INPUTDIR/tmp_env_file.out
	              	    echo "export BI_INSTANCE=$bi_instance">>$ORCLENVFIL

                            #get_cygpath "ORCLENVFIL"
                            #get_cygpath "TMPDIR"
	              	    #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                            #restore_cygpath "ORCLENVFIL"
                            #restore_cygpath "TMPDIR"

	              	    copy_env_files_to_tmp
                            nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}_${bi_instance_without_slash}.sh/g");
    	  	  	    security_fix "check_and_fix_script_existence" "$localcmd"

	              	    echo "#!$bash_scr" >$localcmd
	              	    echo "$RAT_DEBUG_FLG" >>$localcmd
	              	    echo "$bash_source" >>$localcmd
	              	    echo ". $TRGTORCLENV">>$localcmd
	              	    if [ -n "$COM_REPORT" ]
	              	    then
		      	      TAG3=1
	              	      echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $bi_instance|tr "[a-z]" "[A-Z]") BI_INSTANCE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	    fi

	              	    get_current_epoch 
	              	    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes][TAG2: $bi_instance][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	              	    if [ $i = $localnode ]
	              	    then
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	      echo "$COM">>$localcmd

	              	      if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			      echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	      echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			      security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

	              	      FILVAL=`$localcmd 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;

			      #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			      if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
	              	    else
			      OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
	              	      echo "$COM">>$localcmd
	              	      if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT} ">>$localcmd;fi
			      echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	      echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			      #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			      if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

	              	      get_cygpath "localcmd"
	              	      get_cygpath "RTEMPDIR"
	              	      get_cygpath "OUTPUTDIR"
	              	      $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	              	      $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1 
		              ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \\$?"`
		    	      security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"
	              	      FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;

	              	      $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                              $SSHELL $i "rm -f $OUTFIL_REPORT>/dev/null 2>&1"
                              REM_RC=`$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1;echo \\$?;"`
          	              security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                              REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	              security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"

                              restore_cygpath "localcmd"
                              restore_cygpath "RTEMPDIR"
                              restore_cygpath "OUTPUTDIR"
	              	    fi

	              	    get_current_epoch 
	              	    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes][TAG2: $bi_instance][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	              	    move_failed_to_skipped "$returncode" "" "$i:$mb_db_homes:$bi_instance" "$FILVAL"
	              	    echo "" >>$OSSPOOLFIL
	              	    printf "%s %s %s %s %s %s\n" "$mb_db_homes_with_underscore:$bi_instance_without_slash $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL

		      	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi

	              	    call_get_log_result=0
	              	    PMSG=$(echo $ORIG_PMSG for ${mb_db_homes}:${bi_instance})
	              	    FMSG=$(echo $ORIG_FMSG for ${mb_db_homes}:${bi_instance})
	              	    VAL=`grep "$mb_db_homes_with_underscore:$bi_instance_with_underscore $PARAM_PATH $CHECK_ID " $OSSPOOLFIL|grep -i "$bi_instance"|sed  -n 's/.*== //p'`
	              	    if [ -n "$COM_REPORT" ]
	              	    then 
	              	      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	      if [ $OFFLINE -eq 0 ]
	              	      then
	              	        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
	              	      else
	              	        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	      fi
	              	    fi   
	              	    if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
	              	    get_log_result "inloop" "$mb_db_homes"
	              	  done
	              	fi
	              	ORACLE_HOME=""
	              else
                      	if [ $OFFLINE -eq "0"  ]
                      	then
			  if [[ ! -e $mb_db_homes ]]; then
		            call_get_log_result=0
                            mb_db_counter=$(expr $mb_db_counter + 1)
	                    mb_db_counter_log=$(expr $mb_db_counter_log + 1)
			    echo -e "skipping $audit_check_name at $CHECK_ID on ${i} because $mb_db_homes is not available.\n">>$LOGFIL
			    continue;
			  fi
	              	  echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING
	              	  sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              	  cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              	  rm -f $INPUTDIR/tmp_env_file.out
	              	  sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              	  cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              	  rm -f $INPUTDIR/tmp_env_file.out
	              	  inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
	              	  echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
	              	  echo "export ORACLE_HOME=${mb_db_homes}">>$ORCLENVFIL
			  update_ld_lib_path
	              	  #get_cygpath "ORCLENVFIL"
                          #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	              	  #restore_cygpath "ORCLENVFIL"

			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			    if [ $OFFLINE -eq 0  ]; then
			      OLD_OH=$ORACLE_HOME
			      ORACLE_HOME=${mb_db_homes}
	              	      if [ $i = $localnode ]; then
			        get_dbOwner
			      else
			        get_dbOwner $i
			      fi
			      ORACLE_HOME=$OLD_OH
			    else
			      dbOwner=$(grep "RDBMS_ORACLE_HOME = $mb_db_homes" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
  			      if [ -n $dbOwner ]; then 
			        dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
			        dbhome_dir=$(grep "^${dbOwner}:" /etc/passwd|cut -d":" -f6);
			      fi
			      OLD_DIR=`pwd`
			      cd "$dbhome_dir";  
			    fi 
		    	    if [[ -z $dbOwner ]]; then 
			      call_get_log_result=0
			      mb_db_counter_log=$(expr $mb_db_counter_log + 1);
			      mb_db_counter=$(expr $mb_db_counter + 1); 
			      continue; 
			    fi

	           	    #chg_files_for_usr "localcmd,OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$localcmd,$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
	           	    chg_files_for_usr "localcmd,ERRFIL,localcmdval" "$localcmd,$ERRFIL,$localcmdval"
			  fi

		          create_rtmpoutput "$i" "$TMP_OUTPUT" "$dbOwner" "$dbGroup"

	              	  copy_env_files_to_tmp "$usern"
	              	  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");
      		 	 
    	  	  	  security_fix "check_and_fix_script_existence" "$localcmd"

	              	  echo "#!$bash_scr" >$localcmd
	              	  echo "$RAT_DEBUG_FLG" >>$localcmd
	              	  echo "$bash_source" >>$localcmd
	              	  echo ". $TRGTORCLENV">>$localcmd

			  if [ -n "$COM_REPORT" ]; then TAG3=1; fi
	              	  get_current_epoch 
	              	  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	              	  if [ $i = $localnode ]
	              	  then
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
			      OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out

	                      chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT"
			    else
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			    fi
	              	    if [ -n "$COM_REPORT" ]; then
	              	      echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
	              	    fi
	              	    echo "$COM">>$localcmd

	              	    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	    echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      #if [ $OFFLINE -eq 0  ]; then
			      #  OLD_OH=$ORACLE_HOME
			      #  ORACLE_HOME=${mb_db_homes}
			      #  get_dbOwner
			      #  ORACLE_HOME=$OLD_OH
			      #else
			      #  dbOwner=$(grep "RDBMS_ORACLE_HOME = $mb_db_homes" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
  			      #  if [ -n $dbOwner ]; then 
			      #    dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
			      #    dbhome_dir=$(grep "^${dbOwner}:" /etc/passwd|cut -d":" -f6);
			      #  fi
			      #  OLD_DIR=`pwd`
			      #  cd "$dbhome_dir";  
			      #fi 

		   	      #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
	           	      #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
			      move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

			      if [[ -e $OUTFIL_REPORT ]]; then chown $dbOwner:$dbGroup $OUTFIL_REPORT; fi
      		   	      security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV" "$dbOwner:$dbGroup" "540"
      		   	      security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$dbOwner:$dbGroup" "540"

	              	      FILVAL=`su $dbOwner -c "$localcmd" 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;

			      move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
			      write_del_rolbk_errlog

	  		      cd $OLD_DIR
	    		      unset OLD_DIR
			    else
      		   	      security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV" "" "740"
      		   	      security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

	              	      FILVAL=`$localcmd 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;
			    fi

			    #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
	              	  else
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
			      OLD_OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out

	                      chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT"
			    else
			      OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			    fi
	              	    if [ -n "$COM_REPORT" ]; then
	              	      echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
	              	    fi
	              	    echo "$COM">>$localcmd
	              	    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	    echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			    #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      #if [ $OFFLINE -eq 0  ]; then
			      #  OLD_OH=$ORACLE_HOME
			      #  ORACLE_HOME=${mb_db_homes}
			      #  get_dbOwner
			      #  ORACLE_HOME=$OLD_OH
			      #else
			      #  dbOwner=$(grep "RDBMS_ORACLE_HOME = $mb_db_homes" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
  			      #  if [ -n $dbOwner ]; then 
			      #    dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
			      #    dbhome_dir=$(grep "^${dbOwner}:" /etc/passwd|cut -d":" -f6);
			      #  fi
			      #  OLD_DIR=`pwd`
			      #  cd "$dbhome_dir";  
			      #fi 
			      if [ -n $dbOwner ]; then dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g'); fi

		   	      #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
	           	      #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
			      move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

	              	      $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1
	              	      $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT/$dbOwner >/dev/null 2>&1 

		              $SSHELL $i "if [ -e $OUTFIL_REPORT ]; then chown $dbOwner:$dbGroup $OUTFIL_REPORT; fi"
		 	      ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $dbOwner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
			      security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		 	      ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV >/dev/null 2>&1; chown $dbOwner:$dbGroup $TRGTORCLENV >/dev/null 2>&1;echo \\$?"`
			      security_fix "verify_attrmodcode" "$i:$TRGTORCLENV" "$ATTRMOD_RC"

	              	      FILVAL=`$SSHELL $i "su $dbOwner -c \"$TMP_OUTPUT/localcmd.sh\"" 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;

			      write_del_rolbk_errlog

	  		      cd $OLD_DIR
	    		      unset OLD_DIR
			    else
	              	      $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	              	      $SCOPY $OUTFIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1 

		              ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \\$?"`
		    	      security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"

	              	      FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;
			    fi

	              	    $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                            $SSHELL $i "rm -f $OUTFIL_REPORT>/dev/null 2>&1"
                            REM_RC=`$SSHELL $i "if [ -e $RTEMPDIR/localcmd.sh ]; then rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1; fi;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                            REM_RC=`$SSHELL $i "if [ -e $TMP_OUTPUT/localcmd.sh ]; then rm -f $TMP_OUTPUT/localcmd.sh>/dev/null 2>&1; fi;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$TMP_OUTPUT/localcmd.sh" "$REM_RC"
                            REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"
	              	  fi

	              	  get_current_epoch 
	              	  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	              	  move_failed_to_skipped "$returncode" "" "$i:$mb_db_homes" "" "$FILVAL"
	              	  echo "" >>$OSSPOOLFIL
	              	  #echo " $mb_db_homes_without_slash $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
	              	  printf "%s %s %s %s %s %s\n" "$mb_db_homes_with_underscore $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL

		      	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
	              	fi
	              	call_get_log_result=0
	              	PMSG=$(echo $ORIG_PMSG for ${mb_db_homes})
	              	FMSG=$(echo $ORIG_FMSG for ${mb_db_homes})
	              	VAL=`grep "$mb_db_homes_with_underscore $PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
	              	if [ -n "$COM_REPORT" ]
	              	then 
	              	  SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	  if [ $OFFLINE -eq 0 ]
	              	  then
	              	    SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
	              	  else
	              	    SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	  fi
	              	fi   
	              	if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
	              	get_log_result "inloop" "$mb_db_homes"
                      fi

	              if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
	              mb_db_counter_log=$(expr $mb_db_counter_log + 1)
	              mb_db_counter=$(expr $mb_db_counter + 1)
	
		      unset db_name_to_check
                    done
                    mb_db_counter=0 
		    mb_db_counter_log=0
                    write_report_on_fail=1

                    if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
                    then
                      cp -f $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                      rm -f $INPUTDIR/trgt_orcl_env.orig
                      #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                      if [ $i = $localnode ]; then cp -f $ORCLENVFIL $RTEMPDIR; else  $SCOPY $ORCLENVFIL $i:$RTEMPDIR/ >/dev/null;fi;
                    fi
                  elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
                  then 
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    for mb_ogg_home in `grep -wi $i $OGGHOMESVERSIONFIL|cut -d'|' -f2`
                    do
                      mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                      mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g')
                      mb_ogg_home_with_underscore=$(echo $mb_ogg_home_without_slash|sed 's/\./_/g')
                      mb_ogg_home_version=$(grep -wi $mb_ogg_home $OGGHOMESVERSIONFIL|cut -d'|' -f3|sed 's/\.//g')
                      #Fix for bug 21443278
                      if [ -z "$mb_ogg_home_version" ]; then mb_ogg_home_version=121210;fi
                      ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                      if [ $ogg_version_found -gt 0 ]
                      then
                        if [ $OFFLINE -eq "0"  ]
                        then
		          echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_ogg_home\n">>$CHECKS_TIMING
		          echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$ORCLENVFIL
			  update_ld_lib_path
                     	  #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
		          copy_env_files_to_tmp
		          nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");
      		 	  
    	  	  	  security_fix "check_and_fix_script_existence" "$localcmd"

		          echo "#!$bash_scr" >$localcmd
		          echo "$RAT_DEBUG_FLG" >>$localcmd
		          echo "$bash_source" >>$localcmd
		          echo ". $TRGTORCLENV">>$localcmd
		          if [ -n "$COM_REPORT" ]
		          then
		      	    TAG3=1
		            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_ogg_home|tr "[a-z]" "[A-Z]") GOLDENGATE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		          fi

		          get_current_epoch 
		          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		          if [ $i = $localnode ]
		          then
			    OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		            echo "$COM">>$localcmd

		            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			    security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

		            FILVAL=`$localcmd 2>>$ERRFIL`
		            returncode=`echo $?`
			    set_alvl $returncode;

			    #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
		          else
			    OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
		            echo "$COM">>$localcmd
		            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			    #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

		            $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
		            $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1 
		            $SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh"
		            FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
		            returncode=`echo $?`
			    set_alvl $returncode;

		            $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                            $SSHELL $i "rm -f $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
                            REM_RC=`$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                            REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"
		          fi

		          get_current_epoch 
		          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

		          move_failed_to_skipped "$returncode" "" "$i:$mb_ogg_home" "" "$FILVAL"
		          echo "" >>$OSSPOOLFIL
		          printf "%s %s %s %s %s %s\n" "$mb_ogg_home_with_underscore $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL

		  	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
		        fi
		        call_get_log_result=0
		        PMSG=$(echo $ORIG_PMSG for ${mb_ogg_home})
		        FMSG=$(echo $ORIG_FMSG for ${mb_ogg_home})
		        VAL=`grep "$mb_ogg_home_with_underscore $PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
		        if [ -n "$COM_REPORT" ]
		        then 
		          SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		          if [ $OFFLINE -eq 0 ]
		          then
		            SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
		          else
		            SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		          fi
		        fi   
		        get_log_result "inloop" "$mb_ogg_home"
		        if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_ogg_home\n">>$CHECKS_TIMING;fi
	                #if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${mb_db_homes_without_slash}.${CHECK_ID}|${VAL}" >>$OSACTUAL; fi    
                      else
		        call_get_log_result=0
                        echo "skipping $audit_check_name at $CHECK_ID for $mb_ogg_home because check version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                      fi
                    done
                    if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
                    then
                      cp -f $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                      rm -f $INPUTDIR/trgt_orcl_env.orig
                      #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                      if [ $i = $localnode ]; then cp -f $ORCLENVFIL $RTEMPDIR; else  $SCOPY $ORCLENVFIL $i:$RTEMPDIR/ >/dev/null;fi;
                    fi
                  elif [[ $multiple_db -eq 0 && "$NEEDS_RUNNING" = "RDBMS" ]]
                  #elif [[ -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]] && [[ "$NEEDS_RUNNING" = "RDBMS" || $PARAM = "RDBMS" ]]
                  then
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    mb_db_counter=0 
                    mb_db_counter_log=0 

		    if [ $OFFLINE -eq "0" ]; then
		      db_name_to_check=`grep "DB_NAME =" $MASTERFIL|grep ${mb_oracle_homes[$mb_db_counter]} | awk -F"=" '{print $2}' | awk -F"|" '{print $1}'|sed 's/ //g'|head -1`
		    else
		      db_name_to_check=`grep "DB_NAME =" $DUMPDIR/$CHKFIL|grep ${mb_oracle_homes[$mb_db_counter]} | awk -F"=" '{print $2}' | awk -F"|" '{print $1}'|sed 's/ //g'|head -1`
		    fi
 
                    if [ $OFFLINE -eq 0  ]
                    then
		      if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
			mb_oracle_homes[$mb_db_counter]="$RAT_ORACLE_HOME";
		      fi
                      current_oh_owner=$(ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle|awk '{print $3}')
                      if [[ -z $current_oh_owner ]]; then
                        current_oh_host=$(grep -w "RDBMS_ORACLE_HOME = ${mb_oracle_homes[$mb_db_counter]}" $MASTERFIL|awk '{print $3}'|cut -d '|' -f4|cut -d ',' -f1)
                        t_flag="-T"
                        current_oh_owner=`$SSHELL $t_flag ${current_oh_host} "ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle 2>/dev/null >&1|awk '{print \\$3}'"`
                      fi
	              inst_mode=$(grep "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
                    else
	              inst_mode=$(grep "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
                      usern=$(grep "CURRENT_USER" $DUMPDIR/$CHKFIL|awk '{print $3}')
                      current_oracle_home=$(grep "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                      current_oh_owner=$(grep "RDBMS_ORACLE_HOME = $current_oracle_home" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                    fi
		    if [[ -n $current_oh_owner ]]; then 
		      dbGroup=$(groups "$current_oh_owner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
                      if [[ -z $dbGroup && $OFFLINE -eq 0 ]]; then
                        dbGroup=`$SSHELL $t_flag ${current_oh_host} "groups "$current_oh_owner"|cut -d: -f2|awk '{print \\$1}'|sed 's/ //g'"`
                        dbhome_dir=`$SSHELL $t_flag ${current_oh_host} "grep "^${current_oh_owner}:" /etc/passwd 2>/dev/null|cut -d":" -f6"`
                      else
			dbhome_dir=$(grep "^${current_oh_owner}:" /etc/passwd 2>/dev/null|cut -d":" -f6);
                      fi
		      if [[ -z $dbhome_dir && $OFFLINE -eq 0 ]]; then
		        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      		  dbhome_dir=`$SSHELL $t_flag $1 "$bash_scr -c \"su - $dbOwner -c \\\"echo \\\\\\\$HOME\\\"\" 2>/dev/null" 2>/dev/null`
			  if [[ -z $dbhome_dir ]]; then dbhome_dir=`$bash_scr -c "su - $dbOwner -c \"echo \\\\\\\$HOME\" 2>/dev/null" 2>/dev/null`; fi
		        else
		          dbhome_dir=$(echo $HOME);
		        fi
		      fi
		    fi 
                    #echo "current_oh_owner=$current_oh_owner all_homes=${mb_oracle_homes[@]} current_home=${mb_oracle_homes[$mb_db_counter]} usern=$usern"
		    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then check_usr_dirs_existence "$current_oh_owner" "$dbGroup"; fi

	            call_get_log_result=0
                    skip_this_version=0
                    set_skip_this_version "-"
                    if [ $skip_this_version -eq 1 ] ; then
                      echo "Skipping check($CHECK_ID) on version 3 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                    fi

                    #if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]]
                    if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]] || [[ $skip_this_version -eq 0 && -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]
                    then
                      skip_this_version=0
                    else
                      skip_this_version=1
                    fi

                    if [ $skip_this_version -eq 0 ]
                    then
                      match_database_role "${mb_database_role[$mb_db_counter]}"
                      match_database_type "${mb_database_type[$mb_db_counter]}"
                      if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]      
                      #if [[ "${mb_database_role[$mb_db_counter]}" = "$check_database_role" ]]
                      then
		        if [[ $OFFLINE -eq "0" && -n "$inst_mode" && $inst_mode -eq 3 ]]
		        then
	  	          echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING
	    	          #$READ -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   

                          sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                          cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                          rm -f $INPUTDIR/tmp_env_file.out
                          sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                          cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                          rm -f $INPUTDIR/tmp_env_file.out
                          inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
                          echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
                          echo "export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}">>$ORCLENVFIL
			  update_ld_lib_path
                          #get_cygpath "ORCLENVFIL"
                          #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                          #restore_cygpath "ORCLENVFIL"

			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	           	    #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
	           	    chg_files_for_usr "ERRFIL,localcmdval" "$ERRFIL,$localcmdval" "$current_oh_owner"
			  fi
		          create_rtmpoutput "$i" "$TMP_OUTPUT" "$current_oh_owner" "$dbGroup"

		          copy_env_files_to_tmp "$usern"
	                  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");
    	  	  	  security_fix "check_and_fix_script_existence" "$localcmd"

		          echo "#!$bash_scr" >$localcmd
		          echo "$RAT_DEBUG_FLG" >>$localcmd
		          echo "$bash_source" >>$localcmd
		          echo ". $TRGTORCLENV">>$localcmd

			  if [ -n "$COM_REPORT" ]; then TAG3=1; fi
		          get_current_epoch 
		          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		          if [ $i = $localnode ]
		          then
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
			      OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out

	                      chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT" "$current_oh_owner"
			    else
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			    fi
		            if [ -n "$COM_REPORT" ]; then 
		              echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
		            fi
		            echo "$COM 2>>$ERRFIL">>$localcmd
		            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
		            
			    security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"
			    security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV" "" "740"

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OLD_DIR=`pwd`
			      cd "$dbhome_dir";

		   	      #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
	           	      #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
			      move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

      		   	      security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV" "$current_oh_owner:$dbGroup" "540"
              		      security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$current_oh_owner:$dbGroup" "540"

			      if [[ -e $OUTFIL_REPORT ]]; then
			        security_fix "fix_file_attributes" "$OUTFIL_REPORT" "$current_oh_owner:$dbGroup"
			      fi
			      FILVAL=`su ${current_oh_owner} -c "$localcmd 2>>$ERRFIL"`
		              returncode=`echo $?`
			      set_alvl $returncode;	

			      move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
			      write_del_rolbk_errlog

			      cd $OLD_DIR
	    		      unset OLD_DIR
			    else
		              FILVAL=`$localcmd 2>>$ERRFIL`
		              returncode=`echo $?`
			      set_alvl $returncode;
			    fi

			    #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
		          else
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
			      OLD_OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out

	                      chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT" "$current_oh_owner"
			    else
			      OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			    fi
		            if [ -n "$COM_REPORT" ]; then 
		              echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
		            fi
		            echo "$COM">>$localcmd
		            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
		               	   
			    #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OLD_DIR=`pwd`
			      cd "$dbhome_dir";

		   	      #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
	           	      #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval" "$current_oh_owner"
			      move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"
 
		              $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1
		              $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT/$current_oh_owner >/dev/null 2>&1

			      $SSHELL $i "if [ -e $OUTFIL_REPORT ]; then chown $current_oh_owner:$dbGroup $OUTFIL_REPORT; fi"

		 	      ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $current_oh_owner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
			      security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		 	      ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV >/dev/null 2>&1; chown $current_oh_owner:$dbGroup $TRGTORCLENV >/dev/null 2>&1;echo \\$?"`
			      security_fix "verify_attrmodcode" "$i:$TRGTORCLENV" "$ATTRMOD_RC"
		              FILVAL=`$SSHELL $i "su ${current_oh_owner} -c \"$TMP_OUTPUT/localcmd.sh\"" 2>>$ERRFIL`
		              returncode=`echo $?`
                              set_alvl $returncode;
			      write_del_rolbk_errlog

			      cd $OLD_DIR
	    		      unset OLD_DIR
			    else
		              $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
			      $SCOPY $OUTFIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1

		 	      ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; echo \\$?"`
			      security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"

		              FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
		              returncode=`echo $?`
                              set_alvl $returncode;
			    fi

		            $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                            $SSHELL $i "rm -f $OUTFIL_REPORT>/dev/null 2>&1"
                            REM_RC=`$SSHELL $i "if [ -e $RTEMPDIR/localcmd.sh ]; then rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1; fi;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                            REM_RC=`$SSHELL $i "if [ -e $TMP_OUTPUT/localcmd.sh ]; then rm -f $TMP_OUTPUT/localcmd.sh>/dev/null 2>&1; fi;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$TMP_OUTPUT/localcmd.sh" "$REM_RC"
                            REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	            security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"
		          fi

		          get_current_epoch 
		          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

		          move_failed_to_skipped "$returncode" "" "$i" "" "$FILVAL"
		          echo "" >>$OSSPOOLFIL
		          #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
		          printf "%s %s %s %s %s\n" " $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL
                        else
                          #this part for bug 19134391 when instance is not running(inst_mode=0)
                          call_get_log_result=0
                          echo "skipping $COM at $CHECK_ID for $db_name_to_check because instance for $db_name_to_check is down on $i">>$LOGFIL
		        fi
		        PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
		        FMSG=$(echo $ORIG_FMSG for ${db_name_to_check}) 
		        if [ -n "$COM_REPORT" ]
		        then
		          SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 
		          if [ $OFFLINE -eq 0 ]
		          then
		            SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
		          else
		            SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		          fi                 
		        fi
		        if [[ -n "$inst_mode" && $inst_mode -eq 3 ]]
		        then
		          call_get_log_result=0
		          VAL=`grep "$PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
		          #VAL=`grep "$mb_db_homes_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
		          if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
		          get_log_result "inloop" "-"
		          mb_db_counter_log=$(expr $mb_db_counter_log + 1)
		          if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
		        fi
                      else
                        call_get_log_result=0
                        echo "skipping $COM at $CHECK_ID for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
                      fi
                    fi
		    unset db_name_to_check
		    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
        elif [[ (( $NEEDS_RUNNING = "ZFS" && -e $ZFSIP ) || ( $NEEDS_RUNNING = "EXTERNAL_ZFS" && -e $EXTZFSIP )) && -n "$zfs_password_status" && $zfs_password_status -ne 3 ]] && [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" || $is_ssc_zfsnodes_passed -eq 1 || $is_zfssa_machine -eq 1 || $is_exalogic_foxtrot -eq "1" ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] || [[ $NEEDS_RUNNING = "TOR_SWITCH" && -n "$RAT_TORSWITCHES" ]]
                  then 
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    cell_count=0    
                    COM_KEYWORK=$COM

                    if [[ $NEEDS_RUNNING = "ZFS" ]]; then
                      IP=`cat $ZFSIP`
                      COM_KEYWORK="${COM_KEYWORK}.aksh"
                    elif [[ $NEEDS_RUNNING = "EXTERNAL_ZFS" ]]; then
                      IP=`cat $EXTZFSIP`
                      COM_KEYWORK="${COM_KEYWORK}.aksh"
                    elif [[ $NEEDS_RUNNING = "TOR_SWITCH" ]]; then
                      IP=`echo -e "$RAT_TORSWITCHES" | tr ' ' '\n' | tr ',' '\n'`
                    fi

                    if [ `echo -e "$IP" | wc -l` -eq "0" ] ; then call_get_log_result=0; fi
                    for cellname in `echo -e "$IP"|cut -d= -f2|sed 's/"//g'`
                    do     
                      if [[ $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" ]]; then
                        cell_outfile="${cellname}.exalogic_zfs_checks.out"
                      elif [[ $NEEDS_RUNNING = "TOR_SWITCH" ]]; then
                        cell_outfile="${cellname}.ocm_switch_checks.out"
                      fi
		      if [ $OFFLINE -eq "0" ]
		      then
		        echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${cellname}\n">>$CHECKS_TIMING
                        unset COM
                        unset col_result_count  
                        check_begin_pattern_check=START_OF_AUDIT_CHECK_${COM_KEYWORK}
                        check_end_pattern_check=END_OF_AUDIT_CHECK_${COM_KEYWORK}
                        check_begin_pattern_report=START_OF_REPORT_${COM_KEYWORK}
                        check_end_pattern_report=END_OF_REPORT_${COM_KEYWORK}
       			COM="sed -n /$check_begin_pattern_check/,/$check_end_pattern_check/p $OUTPUTDIR/${cell_outfile}|sed '1d'|sed '\$d'|awk '{print \$NF}'"
                 	COM_REPORT="sed -n /$check_begin_pattern_report/,/$check_end_pattern_report/p $OUTPUTDIR/${cell_outfile}|sed '1d'|sed '\$d'"
                        col_result_count=$(grep -wic "$check_end_pattern_report" $OUTPUTDIR/${cell_outfile})
		        
		        if [[ -n "$execute_once" && $execute_once -eq "4" && "$first_zfs" != "$cellname" ]]; then 
		          echo "skipping $audit_check_name (checkid:- $CHECK_ID) on $cellname because execute_once is true for zfs">>$LOGFIL;
		        else
                          if [[ -n "$col_result_count" && $col_result_count -gt 0 ]]
                          then
			    copy_env_files_to_tmp
			    nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${cellname}.sh/g");
      		 
    	  	  	    security_fix "check_and_fix_script_existence" "$localcmd"

                            call_get_log_result=1
			    echo "#!$bash_scr" >$localcmd
			    echo "$RAT_DEBUG_FLG" >>$localcmd
			    echo "$bash_source" >>$localcmd
			    echo ". $TRGTORCLENV">>$localcmd
			    echo "$COM 2>>$ERRFIL">>$localcmd
			    if [ -n "$COM_REPORT" ]
			    then 
		      	      TAG3=1
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			      echo -e "TO REVIEW COLLECTED DATA FROM $(echo ${cellname}|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			      echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd
			    fi

			    get_current_epoch 
			    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $cellname][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
			    echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
			    chmod 540 $localcmd

			    FILVAL=`$localcmd 2>>$ERRFIL`
			    returncode=`echo $?`
			    set_alvl $returncode;

			    #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			    get_current_epoch 
			    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $cellname][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS		      
			    move_failed_to_skipped "$returncode" "" "$i:$cellname" "" "$FILVAL"
			    echo "" >>$OSSPOOLFIL
			    printf "%s %s %s %s %s\n" " $PARAM_PATH $CHECK_ID ${cellname} == $FILVAL" >>$OSSPOOLFIL
                          else
                            call_get_log_result=0
                            echo "skipping $audit_check_name($CHECK_ID) for $cellname because $check_begin_pattern_check does not exists in $OUTPUTDIR/${cell_outfile}">>$SKIPFIL
                            generate_exceptions_xml  "skipping $audit_check_name($CHECK_ID) for $cellname because $check_begin_pattern_check does not exists in $OUTPUTDIR/${cell_outfile}"
			    generate_exceptions_json "skipping $audit_check_name($CHECK_ID) for $cellname because $check_begin_pattern_check does not exists in $OUTPUTDIR/${cell_outfile}"
                            let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                            let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1;
                          fi #end if when output for a check is not found in storage server collection file
		  	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
			fi
		      fi # end of OFFLINE if
		      if [ -n "$COM_REPORT" ]
		      then
			SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			if [ $OFFLINE -eq 0 ]
			then
			    SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
			else
			    SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		        fi
		      fi
		      #$READ -p "stop for cell check"
		      PMSG=$(echo $ORIG_PMSG for ${cellname})
		      FMSG=$(echo $ORIG_FMSG for ${cellname})
		      VAL=`grep "$PARAM_PATH $CHECK_ID " $OSSPOOLFIL|grep ${cellname} |sed  -n 's/.*== //p' | tr -d '\r'`
                      if [ $cell_count -gt 0 ];then write_report_on_fail=0;fi
                      if [[ -n "$call_get_log_result" && $call_get_log_result -eq 1 ]]; then get_log_result;call_get_log_result=0; fi
                      if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
                      cell_count=$( expr $cell_count + 1 )
                    done  
             	    cell_count=0 
         	  elif [[ -z "$NEEDS_RUNNING" || ( $NEEDS_RUNNING != "ZFS" && $NEEDS_RUNNING != "EXTERNAL_ZFS" && $NEEDS_RUNNING != "TOR_SWITCH" ) ]] && [[  -z "$run_acchk" || $run_acchk -eq "0" ]]
                  then
	            if [ $OFFLINE -eq "0" ]
	            then
		      OLD_RAT_ROOT_RUN=$RAT_ROOT_RUN
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		        RUN_AS_CURRENT_USER=0
		        if [[ $NEEDS_RUNNING = "CRS" || $NEEDS_RUNNING = "RDBMS" || $NEEDS_RUNNING = "ASM" || $HOME_PATH = "CRS" || $HOME_PATH = "RDBMS" || $HOME_PATH = "ASM" ]]; then 
			  RUN_AS_CURRENT_USER=0; 
			else 
			  RUN_AS_CURRENT_USER=1; 
			fi	
		        if [[ $RUN_AS_CURRENT_USER -eq "1" ]]; then 
			  RAT_ROOT_RUN=0; 
			fi
		      fi
	
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		        OLD_OH=$ORACLE_HOME
		        ORACLE_HOME=$CRS 
		        get_dbOwner
		        ORACLE_HOME=$OLD_OH

	                #chg_files_for_usr "localcmd,OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$localcmd,$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
	                chg_files_for_usr "localcmd,ERRFIL,localcmdval" "$localcmd,$ERRFIL,$localcmdval"
		      fi

		      create_rtmpoutput "$i" "$TMP_OUTPUT" "$dbOwner" "$dbGroup"

                      echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                        copy_env_files_to_tmp "$usern"
		      else
                        copy_env_files_to_tmp
		      fi
	              nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");
      		      
    	  	      security_fix "check_and_fix_script_existence" "$localcmd"

                      echo "#!$bash_scr" >$localcmd
	              echo "$RAT_DEBUG_FLG" >>$localcmd
                      echo "$bash_source" >>$localcmd
                      echo ". $TRGTORCLENV">>$localcmd
	              #$READ -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
	              
		      if [ -n "$COM_REPORT" ]; then TAG3=1; fi
	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
	              
      		      security_fix "fix_plugin_or_rtscript_attributes" "$TRGTORCLENV_PATCEHS" "" "740"

	              if [ $i = $localnode ]
	              then
			if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		          OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
		          OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out

	                  chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT"
			else
		          OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			fi
                        if [ -n "$COM_REPORT" ]; then
                          echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                        fi 
	                echo "$COM 2>>$ERRFIL">>$localcmd
                        if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi 
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
	
			if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			  #OLD_OH=$ORACLE_HOME
			  #ORACLE_HOME=$CRS 
			  #get_dbOwner
			  #ORACLE_HOME=$OLD_OH

		   	  #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
	           	  #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
			  move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

              		  security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "$dbOwner:$dbGroup" "540"

			  if [[ -e $OUTFIL_REPORT ]]; then chown $dbOwner:$dbGroup $OUTFIL_REPORT; fi
			  FILVAL=`su $dbOwner -c "$localcmd" 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;

			  move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
			  write_del_rolbk_errlog

	  		  cd $OLD_DIR
	    		  unset OLD_DIR
			else
      		      	  security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

                          FILVAL=`$localcmd 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;
			fi
			#if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
			if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
	              else
                        if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]];
                        then
			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		            OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
		            OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out

	                    chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT"
			  else
		            OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			  fi
                          if [ -n "$COM_REPORT" ]; then
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                          fi 
			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			    #OLD_OH=$ORACLE_HOME
			    #ORACLE_HOME=$CRS 
			    #get_dbOwner
			    #ORACLE_HOME=$OLD_OH
			
	           	    #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL"
			    #move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

			    chown $dbOwner:$dbGroup $TRGTORCLENV	
	                    FILVAL=`$SSHELL_EL $i "su $dbOwner -c \". $TRGTORCLENV; $COM\"" 2>>$ERRFIL`
  			    FILVAL=$(echo $FILVAL|tr -d '\r')
                            if [ -n "$COM_REPORT" ]; then 
			      $SSHELL_EL $i "su $dbOwner -c \". $TRGTORCLENV; $COM_REPORT\"" 2>>$ERRFIL >>$OUTFIL_REPORT;

			      move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append" 
			    fi
			    write_del_rolbk_errlog

	  		    cd $OLD_DIR
	    		    unset OLD_DIR
			  else
	                    FILVAL=`$SSHELL_EL $i " . $TRGTORCLENV; $COM" 2>>$ERRFIL`
  			    FILVAL=$(echo $FILVAL|tr -d '\r')
                            if [ -n "$COM_REPORT" ]; then 
			      $SSHELL_EL $i " . $TRGTORCLENV; $COM_REPORT" 2>>$ERRFIL >>$OUTFIL_REPORT;
			    fi
			  fi
                        else
			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		            OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
		            OLD_OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out

	                    chg_files_for_usr "OUTFIL,OUTFIL_REPORT" "$OUTFIL,$OUTFIL_REPORT"
			  else
		            OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			  fi
                          if [ -n "$COM_REPORT" ]; then
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                          fi 
                          echo "$COM">>$localcmd
                          if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			  echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                  echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			  #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
			  if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			    #OLD_OH=$ORACLE_HOME
			    #ORACLE_HOME=$CRS 
			    #get_dbOwner
			    #ORACLE_HOME=$OLD_OH

		   	    #subs_files_to_usr_files "$localcmd" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
	           	    #chg_files_for_usr "OUTFIL,OUTFIL_REPORT,ERRFIL,localcmdval" "$OUTFIL,$OUTFIL_REPORT,$ERRFIL,$localcmdval"
			    move_files "$ORIG_OUTFIL_REPORT" "$OUTFIL_REPORT"

                            $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1
                            $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT/$dbOwner >/dev/null 2>&1

                            $SSHELL $i "if [ -e $OUTFIL_REPORT ]; then chown $dbOwner:$dbGroup $OUTFIL_REPORT; fi"
		 	    ATTRMOD_RC=`$SSHELL $i "chmod 540 $localcmd >/dev/null 2>&1; chown $dbOwner:$dbGroup $localcmd >/dev/null 2>&1;echo \\$?"`
			    security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
		 	    ATTRMOD_RC=`$SSHELL $i "chmod 540 $TRGTORCLENV >/dev/null 2>&1; chown $dbOwner:$dbGroup $TRGTORCLENV >/dev/null 2>&1;echo \\$?"`
			    security_fix "verify_attrmodcode" "$i:$TRGTORCLENV" "$ATTRMOD_RC"

                            FILVAL=`$SSHELL $i "su $dbOwner -c \"$TMP_OUTPUT/localcmd.sh\"" 2>>$ERRFIL` 
	                    returncode=`echo $?`
			    set_alvl $returncode;
			    write_del_rolbk_errlog

	  		    cd $OLD_DIR
	    		    unset OLD_DIR
			  else
                            $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                            $SCOPY $OUTFIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1

		 	    ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \\$?"`
			    security_fix "verify_attrmodcode" "$i:$localcmd" "$ATTRMOD_RC"
                            FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	                    returncode=`echo $?`
			    set_alvl $returncode;
                          fi
                          get_cygpath "OUTPUTDIR"
                          $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                          restore_cygpath "OUTPUTDIR"
                          REM_RC=`$SSHELL $i "rm -f $localcmd $OUTFIL_REPORT $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
	  	          security_fix "verify_remcode" "$i:$localcmd" "$REM_RC"
                        fi
                      fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	              
	              move_failed_to_skipped "$returncode" "" "$i" "" "$FILVAL"
	              echo "" >>$OSSPOOLFIL
	              #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
	              printf "%s %s %s %s %s\n" " $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL

		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] || [[ -n "$OLD_RAT_ROOT_RUN" && $OLD_RAT_ROOT_RUN -eq "1" ]]; then write_del_rolbk_tmpoutput; fi
	            fi
	            VAL=`grep "$PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                    if [ -n "$COM_REPORT" ]
                    then
                      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      if [ $OFFLINE -eq 0 ]
                      then
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                      else
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      fi
                    fi
	            #if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL ; fi
         	  fi

                  #if [[ $NEEDS_RUNNING = "ASM" && $OFFLINE -eq "0" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
                  if [[ "$NEEDS_RUNNING" = "ASM" || "$NEEDS_RUNNING" = "ACFS" ]] && [[ $OFFLINE -eq "0"  && ${stack_asm_up[$stack_counter]} -eq 1 ]]
                  then
	            sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	            cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	            rm -f $INPUTDIR/tmp_env_file.out
	            sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	            cp -f $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	            rm -f $INPUTDIR/tmp_env_file.out
	            echo "export ORACLE_SID=$OLD_ORACLE_SID">>$ORCLENVFIL
	            echo "export ORACLE_HOME=$OLD_ORACLE_HOME">>$ORCLENVFIL
	  	    update_ld_lib_path "CRS"
                    get_cygpath "ORCLENVFIL"
                    #if [ $i = $localnode ]; then cp -f $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                    if [ $i = $localnode ]; then cp -f $ORCLENVFIL $RTEMPDIR; else  $SCOPY $ORCLENVFIL $i:$RTEMPDIR/ >/dev/null;fi;
                    restore_cygpath "ORCLENVFIL"
                    #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`    
                    TRGTORCLENV=$RTEMPDIR/`basename $ORCLENVFIL`    
                    #cat $TRGTORCLENV
                  fi
                fi
              fi

              if [[ -n "$LEVEL" && $call_get_log_result -eq 1 ]]
              then
                #we don't want to call this function unless there's a valid
                #set of data for it to evaluate.  If there's no level then that
                #just means we've reached the end of the hierarchy and no more
                #rows to process.
                #
                #calling get_log_result() when in SILENT mode will only do logging
                #there won't be any comparison done and the "PASS" flag will be set
                get_log_result
                if [ $OFFLINE -eq 0 ]; then echo -e "end time -  `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi
              fi
	      if [ $OFFLINE -eq 0 ]; then
	        if [[ -n $RUN_AS_CURRENT_USER && $RUN_AS_CURRENT_USER -eq "1" ]]; then
	          RAT_ROOT_RUN=1
	          unset RUN_AS_CURRENT_USER
	        fi
	      fi
              ;;
            OS_COLLECT)
              #if [ $OFFLINE -eq "0" ]
              #then
              #$READ -p "PARAM=$PARAM CRS_I=${crs_installed[$stack_counter]} RDBMS_I=${rdbms_installed[$stack_counter]} SC=$stack_counter "
  	      local_component_match_count=1
              #if  [[ -z $RAT_NO_COMPONENTS_FILTER ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" || $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "SWITCH" || $NEEDS_RUNNING = "SPINE_SWITCH" ]]
              #then
              #  local_component_match_count=0
              #  loop_check_components=$(echo $check_components|sed 's/:/ /g')
              #  for check_component in $loop_check_components
              #  do
              #    component_match_count1=$(echo $components|grep -icw $check_component)
              #    if [[ -n "$component_match_count1" && $component_match_count1 -ge 1 ]]; then local_component_match_count=$(expr $local_component_match_count + 1 );fi
              #  done
              #fi

              if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "GOLDENGATE_HOME" && $is_goldengate_installed -eq 0 ]] || [[ $PARAM = "OMS_HOME" && $is_oms_installed -eq 0 ]]
              then
                call_get_log_result=0
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
              elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]] || [[ $NEEDS_RUNNING = "OMS" && $is_oms_installed -eq 0 ]]
              then
                call_get_log_result=0
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1` 
              elif [[ $NEEDS_RUNNING = "ACFS" && $db_machine_compute -eq 1 ]] 
              then
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
              elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
              then
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
	      elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
              then
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
              elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && "$RAT_RUNMODE_INTERNAL" = "slave" ]]
              then
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
              elif  [[ $component_match_count  -lt 1 ]] || [[ -n $local_component_match_count && $local_component_match_count -lt 1 ]]
              then
                echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
	      elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
              then
                if [[ $NEEDS_RUNNING = "STORAGE_CELL" || $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" || $NEEDS_RUNNING = "SWITCH" || $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "TOR_SWITCH" ]] && [[ "$RAT_RUNMODE_INTERNAL" = "slave" ]]
                then
                  OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                  call_get_log_result=0
                else
                  OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                  call_get_log_result=0
                  echo "Not running $COLLECTION_NAME (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
                fi
              elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
              then
		if [[ $NEEDS_RUNNING = "STORAGE_CELL" || $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" || $NEEDS_RUNNING = "SWITCH" || $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "TOR_SWITCH" ]] && [[ "$RAT_RUNMODE_INTERNAL" = "slave" ]]
                then
                  OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                  call_get_log_result=0
                else
		  OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                  call_get_log_result=0
                  generate_exceptions_xml "Skipping $COLLECTION_NAME because its excluded"
		  generate_exceptions_json "Skipping $COLLECTION_NAME because its excluded"

		fi
              elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$COLLECTION_NAME" $EXCLUDEFIL` -ge 1 ]]
              then
                if [[ $NEEDS_RUNNING = "STORAGE_CELL" || $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "EXTERNAL_ZFS" || $NEEDS_RUNNING = "SWITCH" || $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "TOR_SWITCH" ]] && [[ "$RAT_RUNMODE_INTERNAL" = "slave" ]]
	        then
                  OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                  call_get_log_result=0
  	        else
                  OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                  call_get_log_result=0
                  echo "Skipping $COLLECTION_NAME (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                  generate_exceptions_xml "Skipping $COLLECTION_NAME because its in exclude file $EXCLUDEFIL"
		  generate_exceptions_json "Skipping $COLLECTION_NAME because its in exclude file $EXCLUDEFIL"
                fi
              else
                call_get_log_result=1
		if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                  if [ $op_mode -eq 0 ]
                  then
                    COM=`grep "_"$ROW"-OS_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND //p'` 
                    COM_REPORT=`grep "_"$ROW"-OS_COLLECT_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND_REPORT //p'` 
                    REQUIEE_ROOT=`grep "_"$ROW"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                    COLLECTION_NAME=`grep "_"$ROW"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                  else
                    com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                    com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                    COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                    com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                    com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                    COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                    REQUIEE_ROOT=`grep "_"$CHECK_ID"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                    COLLECTION_NAME=`grep "_"$CHECK_ID"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                  fi
		fi
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                #echo "REQUIEE_ROOT =$REQUIEE_ROOT"
                #$READ -p "STOP"
                #OUTFILNAME is the name we set up in the app as the file name we want
                #the data redirected to when doing OS and SQL COLLECTs
                #we'll search this file for OS and SQL param valuesa
                #so SQL and OS COLLECT creates OUTFIL in the OUTPUTDIR
                #SQL and OS PARAM reads the values of the parameters from OUTFIL
                #OUTFIL will also be archived at the end
                #FIELDPOS is the position we define in the app to tell the script
                #which field to look in for the value as the position might vary from
                #command to command or OS to OS
		if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                  if [ $op_mode -eq 0 ]
                  then
                    OUTFILNAM=`grep _$ROW\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
                  else
                    OUTFILNAM=`grep _$CHECK_ID\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
                  fi
		fi
                #note we do not append an extension here since the OS commands are 
                #executed on each node and for formatting purposes we append the host 
	        #and the .out in the OS_COLLECT case of log_result()
                
                copy_env_files_to_tmp 
                #Changes made by jrmullan 03/22/10
                #I am changing the file names on the remote nodes to be the same regardless of node.  I need to do this to keep pthe
                #root_raccheck.sh script generic so that the sudo command works from every node.  Once the files are copied back to
                #the local node I will append node information at that point.
                #ORIGINAL STATEMENT:
                #OUTFIL=/tmp/"o_"$OUTFILNAM"_"$i".out"
                #OUTFIL=/tmp/"o_"$OUTFILNAM".out"
                OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_"$i".out"
                if [ $i = $localnode ]
                then
                  OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_"$i"_report.out"
                else
                  OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_"$i"_report.out"
                fi

                if [[ $REQUIEE_ROOT -eq 0 && $is_exalogic_machine -ne "1" ]] && [[ $REQUIEE_ROOT -eq 0 && -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -ne "1" ]]
                then
                  if [ $OFFLINE -eq 0 ]
                  then
                    #copy_env_files_to_tmp
	            nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");
      		
    	  	    security_fix "check_and_fix_script_existence" "$localcmd"

	    	    if [[ -n $run_acchk && $run_acchk -eq "1" ]] ; then
                      JDK=$RAT_JAVA_HOME;
                      RTJAR=$JDK/jre/lib/rt.jar
                      ACJAR=$SCRIPTPATH/.cgrep/acchk.jar
                      echo "export JAVA=$JDK/bin/java">>$TRGTORCLENV
                      echo "export CLASSPATH=\"$RAT_AC_ASMJAR:$RTJAR:$ACJAR\"">>$TRGTORCLENV
		      if [[ $COLLECTION_NAME =~ "coverage" ]]
                      then	
                        echo "export ARGS=\"$RAT_AC_TRCDIR\"" >>$TRGTORCLENV
		      else
		        echo "export ARGS=\"$RAT_AC_JARDIR\"" >>$TRGTORCLENV
		      fi
                    fi
                    echo "#!$bash_scr" >$localcmd
	            echo "$RAT_DEBUG_FLG" >>$localcmd
                    echo "$bash_source" >>$localcmd
                    echo ". $TRGTORCLENV">>$localcmd
                    echo "$COM">>$localcmd
                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi
                    
      		    security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

		    #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
		    if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
                  fi
                else
                  if [ $OFFLINE -eq 0 ]
                  then
                    #Changes made by jrmullan 03/22/10
                    #I am changing the file names on the remote nodes to be the same regardless of node.  I need to do this to keep pthe
                    #root_raccheck.sh script generic so that the sudo command works from every node.  Once the files are copied back to
                    #the local node I will append node information at that point.
                    #ORIGINAL STATEMENT:
                    #OUTFIL=/tmp/"o_"$OUTFILNAM"_"$i".out"
                    if [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
                    then
	              if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 && $i = $localnode  && $RAT_RUNMODE_INTERNAL = "master" ]]
	              then
	                OUTFIL=${IBRTEMPDIR}/"s_${OUTFILNAM}.out"
	                OUTFIL_REPORT=${IBRTEMPDIR}/"s_"$OUTFILNAM"_report.out"
                        ROOT_COLLECT_TIMING=${IBRTEMPDIR}/s_root_collect_timing.out
	                COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}' 2>/dev/null|sed 's/\`//g' |sed 's/ //g'`

			if [[ -n "$execute_once" && $execute_once -eq "5" ]]; then
			  echo "if [[ \"$first_ibswitch\" = \$SWITCHNAME ]]; then" >>$IBSWITCHSCRPT
		        fi
	                if [ -z "$COLLECTION_NAME" ] 
	                then
	                  echo "echo \"Collecting - $COMSBSTR \"" >>$IBSWITCHSCRPT
	                else
	                  echo "echo \"Collecting - $COLLECTION_NAME \"" >>$IBSWITCHSCRPT
	                fi
                        echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$IBSWITCHSCRPT
                        write_root_collections_log "$IBSWITCHSCRPT"

			if [ -n "$COM_REPORT" ]; then TAG3=1; fi
	                get_current_epoch 
	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	                echo "$COM >>$OUTFIL" >> $IBSWITCHSCRPT 
                        if [ -n "$COM_REPORT" ]
                        then 
                          echo "echo -e \"TO REVIEW COLLECTED DATA FROM \$(hostname|cut -d. -f1|tr \"[a-z]\" \"[A-Z]\") FOR $(echo $COLLECTION_NAME|tr "[a-z]" "[A-Z]") \\n\\n\\n\" >>$OUTFIL_REPORT" >>$IBSWITCHSCRPT
                          echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$IBSWITCHSCRPT
                        fi
			if [[ -n "$execute_once" && $execute_once -eq "5" ]]; then
			  echo "fi" >>$IBSWITCHSCRPT
		        fi

	                get_current_epoch 
	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	              fi
                    elif [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
                    then
                      if [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 && $current_exadata_version -lt $check_exadata_version ]]
                      then
	                if [ -z "$RAT_CELL_SSH_USER" ] || [[ -n "$DOROOT" && $DOROOT -eq 1 ]] || [ $RAT_CELL_SSH_USER = "cellmonitor" ]
	                then  
	                  if [[ $root_need_cell_ssh -eq 0 && $i = $localnode  && $RAT_RUNMODE_INTERNAL = "master" ]]
	                  then
	                    OUTFIL=${CELLRTEMPDIR}/"c_${OUTFILNAM}.out"
	                    ROOT_COLLECT_TIMING=${CELLRTEMPDIR}/c_root_collect_timing.out
	                    OUTFIL_REPORT=${CELLRTEMPDIR}/"c_"$OUTFILNAM"_report.out"
	                    COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}' 2>/dev/null|sed 's/\`//g' |sed 's/ //g'`

			    if [[ -n "$execute_once" && $execute_once -eq "3" ]]; then
			      echo "if [[ \"$first_storage_cell\" = \$CELLNAME ]]; then" >>$CELLSSCRPT
		            fi
	                    if [ -z "$COLLECTION_NAME" ] 
	                    then
	              	      echo "echo \"Collecting - $COMSBSTR \"" >>$CELLSSCRPT
	                    else
	              	      echo "echo \"Collecting - $COLLECTION_NAME \"" >>$CELLSSCRPT
	                    fi
	                    echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$CELLSSCRPT
	                    write_root_collections_log "$CELLSSCRPT"

			    if [ -n "$COM_REPORT" ]; then TAG3=1; fi
	                    get_current_epoch 
	                    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	                    echo "$COM >>$OUTFIL" >> $CELLSSCRPT
	                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$CELLSSCRPT;fi
			    if [[ -n "$execute_once" && $execute_once -eq "3" ]]; then
			      echo "fi" >>$CELLSSCRPT
		            fi

	                    get_current_epoch 
	                    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	                  fi 
	                elif [[ -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin"  && $REQUIEE_ROOT -eq 2 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
	                then  
	                  if [[ $root_need_cell_ssh -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master"  ]]
	                  then
	                    OUTFIL=${CELLRTEMPDIR}/"c_${OUTFILNAM}.out"
	                    ROOT_COLLECT_TIMING=${CELLRTEMPDIR}/c_root_collect_timing.out
	                    OUTFIL_REPORT=${CELLRTEMPDIR}/"c_"$OUTFILNAM"_report.out"
	                    COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}' 2>/dev/null|sed 's/\`//g' |sed 's/ //g'`

			    if [[ -n "$execute_once" && $execute_once -eq "3" ]]; then
			      echo "if [[ \"$first_storage_cell\" = \$CELLNAME ]]; then" >>$CELLSSCRPT
		            fi
	                    if [ -z "$COLLECTION_NAME" ] 
	                    then
	              	      echo "echo \"Collecting - $COMSBSTR \"" >>$CELLSSCRPT
	                    else
	              	      echo "echo \"Collecting - $COLLECTION_NAME \"" >>$CELLSSCRPT
	                    fi
	                    echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$CELLSSCRPT
	                    write_root_collections_log "$CELLSSCRPT"

			    if [ -n "$COM_REPORT" ]; then TAG3=1; fi
	                    get_current_epoch 
	                    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	                    echo "$COM >>$OUTFIL" >> $CELLSSCRPT
	                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$CELLSSCRPT;fi
			    if [[ -n "$execute_once" && $execute_once -eq "3" ]]; then
			      echo "fi" >>$CELLSSCRPT
		            fi

	                    get_current_epoch 
	                    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	                  fi
	                fi
                      fi  
                    else
		      if [[ "$PARAM" = "EMAGENT_HOME" ]]
		      then
			if [[ -z "$mb_em_home_version" ]]
                          then
                            if [ $OFFLINE -eq 0 ]
                            then
                              emfile1=$MASTERFIL
                            else
                              emfile1=$DUMPDIR/$CHKFIL
                            fi

                            mb_em_home_version=`grep "$i.EMAGENT_VERSION" $emfile1|awk -F"=" '{print $2}'|sed 's/ //g'`
                          fi

                          em_version_found=$(echo $check_exadata_version|grep -iwc "$mb_em_home_version")
		      fi

		      if [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -ne 1 ]]
                      then
		        echo ""
		      elif [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -eq 1 && $em_version_found -eq "0" ]]
                      then
                        echo ""
 		      elif [[ "$PARAM" = "OMS_HOME" && $is_oms_installed -ne 1 ]]
		      then
			 call_get_log_result=0
			 OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
		      else 	
	                OUTFIL=${RTEMPDIR}/"o_"$OUTFILNAM".out"
                        ROOT_COLLECT_TIMING=${RTEMPDIR}/o_root_collect_timing.out
	                OUTFIL_REPORT=${RTEMPDIR}/"o_"$OUTFILNAM"_report.out"
	                if [[ $i = $localnode ]]
	                then
	                  touch $OUTFIL >/dev/null 2>&1
	                  touch $ROOT_COLLECT_TIMING >/dev/null 2>&1
                          if [ -n "$COM_REPORT" ]; then  touch $OUTFIL_REPORT >/dev/null 2>&1;fi
	                else
	                  $SSHELL $i touch $OUTFIL >/dev/null 2>&1
	                  $SSHELL $i touch $ROOT_COLLECT_TIMING >/dev/null 2>&1
                          if [ -n "$COM_REPORT" ]; then   $SSHELL $i touch $OUTFIL_REPORT >/dev/null 2>&1;fi
	                fi
                        echo "echo -e \"TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") FOR $(echo $COLLECTION_NAME|tr "[a-z]" "[A-Z]") \\n\\n\\n\" >>$OUTFIL_REPORT" >>$ROOTSCRPT
	                COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}' 2>/dev/null|sed 's/\`//g' |sed 's/ //g'`
	                if [ -z "$COLLECTION_NAME" ] 
	                then
	                  echo "echo \"Collecting - $COMSBSTR \"" >>$ROOTSCRPT
	                else
	                  echo "echo \"Collecting - $COLLECTION_NAME \"" >>$ROOTSCRPT
	                fi
                        echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$ROOTSCRPT
                        write_root_collections_log "$ROOTSCRPT"

			if [ -n "$COM_REPORT" ]; then TAG3=1; fi
	                get_current_epoch 
	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
			if [[ "$PARAM" = "OMS_HOME" && $is_oms_installed -eq 1 ]]
			then
			  if [ $OFFLINE -eq 0 ]
                          then
                            emfile1=$MASTERFIL
                          else
                            emfile1=$DUMPDIR/$CHKFIL
                          fi
   	                  mb_oms_counter=0
		          for mb_oms_home in ${oms_homes[@]}
		          do
			    oms_home_version=`grep -i "$i:$mb_oms_home:OMS_VERSION" $emfile1| awk -F"=" '{print $2}'|sed 's/ //g'|sed 's/\.//g'`
                            oms_version_found=$(echo $check_exadata_version|grep -iwc $oms_home_version)
			    if [[ $oms_version_found -gt "0" ]]
        	            then
			      echo "export ORACLE_HOME=${mb_oms_home}">>$ROOTSCRPT
	                      echo "$COM  >>$OUTFIL" >> $ROOTSCRPT
		              if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >> $ROOTSCRPT;fi
			    fi
			    mb_oms_counter=$(expr $mb_oms_counter + 1)
			  done
			  mb_oms_counter=0
			  unset mb_oms_home
		        elif [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -eq 1 ]]
		        then

			  if [[ $em_version_found -gt "0" ]]
			  then
			    echo "export EMAGENT_HOME=${mb_emagent_home}" >>$ROOTSCRPT
		            echo "export EMAGENT_INST=${agent_inst}">>$ROOTSCRPT
	                    echo "$COM  >>$OUTFIL" >> $ROOTSCRPT
	                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >> $ROOTSCRPT;fi
			  fi
			else
	                  echo "$COM  >>$OUTFIL" >> $ROOTSCRPT
	                  if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >> $ROOTSCRPT;fi
			fi	

	                get_current_epoch 
	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS
		      fi	
                    fi         
                  fi
                fi
		if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
                if [[ -n "$LEVEL" &&  $REQUIEE_ROOT -eq 0 && $call_get_log_result -eq 1 ]]
                then
                  #we don't want to call this function unless there's a valid
                  #set of data for it to evaluate.  If there's no level then that
                  #just means we've reached the end of the hierarchy and no more
                  #rows to process.
                  #
                  #in SILENT mode we'll execute the command derived here and do 
                  #some logging but there is nothing to compare
                  #echo " in get_log_result REQUIEE_ROOT=$REQUIEE_ROOT"
                  get_log_result
                fi
              fi # OS collect without root ends here
         
              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && -n "$is_fmw_machine" && $is_fmw_machine -eq "1" ]] ; then
                execute_idmhealthcheck
              fi
              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" ]] ; then
                  if [[ $RAT_RUNMODE_INTERNAL = "master" ]] ; then # master.. scp the *v_parameter* to all nodes
                    odir=$(basename $OUTPUTDIR)
                    #for rnode in `cat $HOSTLIST.org |grep -v $localnode`
                    for rnode in `if [ -e $HOSTLIST.org ]; then grep -v $localnode $HOSTLIST.org; fi`
                    do
                      node_ssh_user="$usern"
                      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
                        if [[ `echo "$ea_dom0_nodes" | grep -ic "$rnode"` -le 0 ]]; then
                          node_ssh_user="${root_user}"
                        else
                          node_ssh_user="${foxtrot_dom0_user}"
                        fi
                        if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$rnode "echo \"\$HOME\""); fi
                        l_RTEMPDIR=${l_TMPDIR}/.${program_name}
                      else
                        l_TMPDIR=$TMPDIR
                        l_RTEMPDIR=$RTEMPDIR
                      fi                   

                      get_cygpath "OUTPUTDIR"
                      get_cygpath "RTEMPDIR"
                      $SCOPY $OUTPUTDIR/*v_parameter* $node_ssh_user@$rnode:$l_RTEMPDIR/$odir > /dev/null 2>&1
                      $SSHELL $node_ssh_user@$rnode "touch $l_RTEMPDIR/master.collections.done "
                      restore_cygpath "OUTPUTDIR"
                      restore_cygpath "RTEMPDIR"
                    done
                  fi
              fi 
              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $rootYesNoint -ne 3 && $root_need_cell_ssh -eq 0 ]] && [[ $REQUIRE_ROOT -gt 0 || -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
              then
   	        if [ -f "$ROOTSCRPT" ]; then 
		  if [ ! -e "$OUTPUTDIR/root_${program_name}.sh" ]; then
		    cp -f $ROOTSCRPT $OUTPUTDIR;
		  fi
                fi

                #change permission of temporary raccheck files created by root to current user
                echo "chown $usern:$running_group ${RTEMPDIR}/o_*.out >/dev/null 2>&1">>$ROOTSCRPT
                if [ -n "$RAT_KEEP_SUDO_TMP" ]; 
                then 
                  if [[ -n $RAT_ROOT_SH_DIR ]];then
                    if [[ -d $RAT_ROOT_SH_DIR && -w $RAT_ROOT_SH_DIR && -r $RAT_ROOT_SH_DIR ]];then
                      cp -f $ROOTSCRPT $RAT_ROOT_SH_DIR
                      ROOTSCRPT=$RAT_ROOT_SH_DIR/root_${program_name}.sh
                      write_in_env "RAT_ROOT_SH_DIR" "$RAT_ROOT_SH_DIR"
                    else
                      echo
                      echo -e "${RED}${RAT_ROOT_SH_DIR} either does not exist or user does not have read-write permission. Please set the RAT_ROOT_SH_DIR to directory which have read-write permission and try again.";
                      echo -e "${NORM}"
                      echo "ex: export RAT_ROOT_SH_DIR=/tmp"
                      echo;
                      echo;
                      exit 1;
                    fi
                  else
                    cp -f $ROOTSCRPT /tmp/ 
                    ROOTSCRPT=/tmp/root_${program_name}.sh
                    RAT_ROOT_SH_DIR="/tmp/";
                  fi
                else
                  if [[ -n $RAT_ROOT_SH_DIR ]];then
                    if [[ -d $RAT_ROOT_SH_DIR && -w $RAT_ROOT_SH_DIR && -r $RAT_ROOT_SH_DIR ]];then
                      if [ $i = $localnode ]; then cp -f $ROOTSCRPT $RAT_ROOT_SH_DIR;fi
                      ROOTSCRPT=$RAT_ROOT_SH_DIR/root_${program_name}.sh
                      write_in_env "RAT_ROOT_SH_DIR" "$RAT_ROOT_SH_DIR"
                    else
                      echo
                      echo -e "${RED}${RAT_ROOT_SH_DIR} either does not exist or user does not have read-write permission. Please set the RAT_ROOT_SH_DIR to directory which have read-write permission and try again.";
                      echo -e "${NORM}"
                      echo "ex: export RAT_ROOT_SH_DIR=/tmp"
                      echo;
                      echo;
                      exit 1;
                    fi
                  else 
                    #if [ $i = $localnode ]; then cp -f $ROOTSCRPT $HOME;fi
                    #ROOTSCRPT=$HOME/root_${program_name}.sh
                    if [ $i = $localnode ]; then cp -f $ROOTSCRPT ${RTEMPDIR};fi
                    ROOTSCRPT=${RTEMPDIR}/root_${program_name}.sh
                    RAT_ROOT_SH_DIR=$RTEMDPIR;
                  fi
                fi
                security_fix "fix_plugin_or_rtscript_attributes" "$ROOTSCRPT" "" "540"

                # Create lock file for watchdog for root collections.
                touch $ROOT_LCKFIL

                #$READ -p "STOP  $ROOTSCRPT /tmp/.racrx/"
                #ROOTSCRPT=/tmp/root_${program_name}.sh
                if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
                noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)
                if [[ $i = $localnode && $noPasswordAvailable -eq 0 ]]
                then
                  # Changes made by jrmullan 03/22/10
                  unset FNAMEANDPATH
                  unset FNAME
                  if [ $rootYesNoint -eq 2 ]
                  then
                    echo -e "\nPreparing to run root privileged commands ${print_compute_node} ${i}.\n"
                    # Changes made by jrmullan 03/22/10
                    #$SSHELL -t $i $SUDOCMD "$ROOTSCRPT"
                    $SUDOCMD "$ROOTSCRPT" 2>>$ERRFIL
                  elif [ $rootYesNoint -eq 1 ]
                  then
                    if [[ -n "$samerootpassword" && $samerootpassword -eq 1 ]]
                    then
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands ${print_compute_node} $i."
                        echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                      fi
                      if [ $userid -eq 0 ] ; then
                        $ROOTSCRPT
	                returncode=`echo $?`		
	                move_failed_to_skipped "$returncode" "$ROOTSCRPT execution"
                      else
			if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then
			  compute_ssh_status=1
			else
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $i ls >/dev/null 2>&1;echo $?);
			fi
                        if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                        then
			echo -e "\n$GREEN $i is configured for ssh user equivalency for ${root_user} user $NORM \n";
                          echo "${root_user} password not checked on $i because ssh user equivalence found for ${root_user}">>$LOGFIL
                          $SSHELL ${root_user}@$i "$ROOTSCRPT"
                        else   
			  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then
                            efCheckrootPassword "$i" "$usern" "${root_user}" "$compute_rootpassword"
			    ROOT_CMD="su - ${root_user} -c $ROOTSCRPT"
			  else	
			    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			    checkUserPassword "$i" "${root_user}" "$compute_rootpassword" "1"
			    ROOT_CMD="$SSHELL ${root_user}@$i \"$ROOTSCRPT\""
			  fi
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			  if [ $passwordCheckStatus -eq 0 ]
			  then
			    fixRootPassword "$compute_rootpassword"
			    $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }
                                  log_user 0
				  #spawn -noecho $SSHELL ${root_user}@$i "$ROOTSCRPT"			
				  spawn -noecho $ROOT_CMD
				  match_max 100000
				  expect {
				  -nocase "permission denied *" {
				    exit 4;
			          }
				  -nocase "no)?" {
				    send -- "yes\n"
				  }
                                  -nocase "*?assword:*" {
                                    send -- "\$le_compute_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 
                                  }
				  }
				  # Look for passwd prompt
                                  log_user 1
		       		  set timeout $watchdog_wakeup_root
				  expect {
				    -nocase "*?assword:*" {
				      send -- "\$le_compute_rootpassword\n"
				    }
				    -nocase eof {
				      exit
				    }
				    -nocase timeout {
				      send_error "Timed out while running $ROOTSCRPT on $i\n";
				      exit
				    }
				  }
                                  log_user 1
				  # Stop the on logon tests and if asked to connect to master switch choose no
				  expect {
				    -nocase eof {
				      exit
				    }
				    -nocase timeout {
				      send_error "Timed out while running $ROOTSCRPT on $i\n";
				      exit
				    }
				  }
IBEOF
                          else
			    echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n" |tee -a $LOGFIL 
			  fi
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                        fi 
                      fi
                    elif [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]]
                    then
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands on ${print_compute_node} ${i}."
                        echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                      fi
                      if [ $userid -eq 0 ] ; then
                        $ROOTSCRPT
                      else
                        compute_rootpassword=${a_compute_rootpassword[$stack_counter]}
			if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then
			  compute_ssh_status=1
			else
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $i ls >/dev/null 2>&1;echo $?);
			fi
                        if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                        then
			echo -e "\n$GREEN $i is configured for ssh user equivalency for ${root_user} user $NORM \n";
                          echo "${root_user} password not checked on $i because ssh user equivalence found for ${root_user}">>$LOGFIL
                          $SSHELL ${root_user}@$i "$ROOTSCRPT" 
                        else
			  if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then
                            efCheckrootPassword "$i" "$usern" "${root_user}" "$compute_rootpassword"
			    ROOT_CMD="su - ${root_user} -c $ROOTSCRPT"
			  else	
			    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			    checkUserPassword "$i" "${root_user}" "$compute_rootpassword" "1"
			    ROOT_CMD="$SSHELL ${root_user}@$i \"$ROOTSCRPT\""
			  fi
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			  if [ $passwordCheckStatus -eq 0 ]
			  then
			    fixRootPassword "$compute_rootpassword"
			    $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout 
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }   
                                  log_user 0
				  #spawn -noecho $SSHELL ${root_user}@$i "$ROOTSCRPT"			
				  #spawn -noecho $SSHELL_EL $i "su - ${root_user} -c $ROOTSCRPT"			
                                  spawn -noecho $ROOT_CMD
				  match_max 100000
				  expect {
				  -nocase "permission denied *" {
				    exit 4;
			          }
				  -nocase "no)?" {
					send -- "yes\n"
					}
    			   	  -nocase "*?assword:*" {
                                 	send -- "\$le_compute_rootpassword\n"
                                  	}
			   	  -nocase eof {
					 exit
				  	}
				  }
				  # Look for passwd prompt
                                  log_user 1
		       		  set timeout $watchdog_wakeup_root
                       		  expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_compute_rootpassword\n"
                       		  }
                       		  -nocase eof {
                       		         exit
                       		  }
                       		  -nocase timeout {
		       		 	send_error "Timed out while running $ROOTSCRPT on $i\n";
                       		        exit
                       		  }
                       		  }
                       		  log_user 1
		       		  # Stop the on logon tests and if asked to connect to master switch choose no
                       		  expect {
                       		    -nocase eof {
                       		         exit
                       		  }
                       		    -nocase timeout {
		       		 	send_error "Timed out while running $ROOTSCRPT on $i\n";
                       		         exit
                       		  }
                       		 }
IBEOF
			  else
			    echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL
			  fi
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                        fi   
                      fi
                    else 
                      if [ $userid -ne 0 ] && [[ -z $privilegechk || "$privilegechk" != "addr" ]]
                      then
                        echo -e "Preparing to run root privileged commands ${print_compute_node} $i.  Please enter ${root_user} password when prompted."
                        echo "Preparing to run root privileged commands on $i.  Please enter ${root_user} password when prompted.">>$LOGFIL
                      fi
                      if [ $userid -ne 0 ] && [[ -z $privilegechk || "$privilegechk" != "addr" ]]  
		      then 	
			if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
			  su - ${root_user} -c $ROOTSCRPT
			else
                          $SSHELL ${root_user}@$i "$ROOTSCRPT"			
			fi
                      else
                        $ROOTSCRPT
                      fi
                      #Fix for bug 14336860 
                      #$SSHELL_EL $i "su - root -c $ROOTSCRPT"
                    fi
                  fi
 
                  # Changes made by jrmullan 03/22/10
                  for FNAMEANDPATH in `ls ${RTEMPDIR}/o_* 2>/dev/null`
                  do
                    # Strip off /tmp/ and .out and insert nodename and .out back in to filename
                    FNAME=`echo $FNAMEANDPATH |$AWK 'BEGIN { FS = "/" } {printf $NF}'|cut -d. -f1`
                    if [[ -e $OUTPUTDIR/$FNAME"_"$i".out" && -e $FNAMEANDPATH ]]
                    then 
                      cat $FNAMEANDPATH  >>$OUTPUTDIR/$FNAME"_"$i".out"
                    elif [ -e $FNAMEANDPATH ]
                    then                   
                      cp -rf $FNAMEANDPATH $OUTPUTDIR/$FNAME"_"$i".out" > /dev/null
                    fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -lt 1 && "$FNAME" != "o_exadata_disk.out" && `echo $FNAME|grep -ic "ibswitches"` -lt 1 && `ls -l $FNAMEANDPATH|awk '{print $3}'` != "${root_user}" ]]; then rm -f $FNAMEANDPATH >/dev/null 2>&1;fi
		    #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                    #  if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -ge 1 ]]; then mv -f $FNAMEANDPATH $TMPDIR  >/dev/null 2>&1; fi;
		    #else
                    #  if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -ge 1 && `ls -l $FNAMEANDPATH|awk '{print $3}'` != "${root_user}" ]]; then mv -f $FNAMEANDPATH $TMPDIR  >/dev/null 2>&1; fi;
		    #fi
                  done
                  if [[ -n "$ORACLEENVVARS" && $ORACLEENVVARS != "" ]];then  rm -f $RTEMPDIR/$ORACLEENVVARS >/dev/null 2>&1; fi;
    	  	  security_fix "check_and_fix_script_existence" "$ROOTSCRPT"
                  if [ -f $ROOTSCRPT ]; then rm -f $ROOTSCRPT >/dev/null 2>&1;fi;
                  if [[ -e ${OUTPUTDIR}/o_root_collect_timing_${i}.out && -e $COLLECT_TIMING ]]
                  then
                    cat ${OUTPUTDIR}/o_root_collect_timing_${i}.out >> $COLLECT_TIMING
  		    collect_duration "${OUTPUTDIR}/o_root_collect_timing_${i}.out" "$COLLECT_TIMING"
                    rm -f ${OUTPUTDIR}/o_root_collect_timing_${i}.out  >/dev/null 2>&1
                  fi
                elif [ $noPasswordAvailable -eq 0 ]
                then
                  unset FNAMEANDPATH
                  unset FNAME
                  #$SCOPY $TMPDIR/$ORACLEENVVARS $i:$TMPDIR/ >/dev/null 2>&1
                  $SCOPY $RTEMPDIR/$ORACLEENVVARS $i:$RTEMPDIR/ >/dev/null 2>&1
                  if [ -n "$RAT_KEEP_SUDO_TMP" ];
                  then 
                    $SCOPY $ROOTSCRPT $i:$TMPDIR/ >/dev/null 2>&1
                  else
                    #$SCOPY $ROOTSCRPT $i:$HOME >/dev/null 2>&1
                    $SCOPY $ROOTSCRPT $i:$RTEMPDIR >/dev/null 2>&1
                  fi
                  $SSHELL $i "chmod 540 $ROOTSCRPT"
                  if [ $rootYesNoint -eq 2 ]
                  then
                    echo -e "\nPreparing to run root privileged commands ${print_compute_node} ${i}.\n"
                    $SSHELL -t $i $SUDOCMD "$ROOTSCRPT" 2>>$ERRFIL
                  elif [ $rootYesNoint -eq 1 ]
                  then
                    if [[ -n "$samerootpassword" && $samerootpassword -eq 1 ]]
                    then
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands ${print_compute_node} $i."
                        echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                      fi
		      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then
		        compute_ssh_status=1
		      else
                        compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $i ls >/dev/null 2>&1;echo $?);
		      fi
                      if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                      then
			echo -e "\n$GREEN $i is configured for ssh user equivalency for ${root_user} user $NORM \n";
                        echo "${root_user} password not checked on $i because ssh user equivalence found for ${root_user}">>$LOGFIL
                        $SSHELL ${root_user}@$i "$ROOTSCRPT"
                      else   
			if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                          efCheckrootPassword "$i" "$usern" "${root_user}" "$compute_rootpassword"
			  ROOT_CMD="su - ${root_user} -c $ROOTSCRPT"
			else
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			  checkUserPassword "$i" "${root_user}" "$compute_rootpassword" "1"
			  ROOT_CMD="$SSHELL ${root_user}@$i \"$ROOTSCRPT\""
			fi
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			if [ $passwordCheckStatus -eq 0 ]
			then
			  fixRootPassword "$compute_rootpassword"
			  $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }
                                  log_user 0
				  #spawn -noecho $SSHELL ${root_user}@$i "$ROOTSCRPT"			
				  #spawn -noecho $SSHELL_EL $i "su - ${root_user} -c $ROOTSCRPT"			
				  spawn -noecho $ROOT_CMD
				  match_max 100000
				  expect {
				  -nocase "permission denied *" {
				    exit 4;
			          }
				  -nocase "no)?" {
					send -- "yes\n"
					}
    			   	  -nocase "*?assword:*" {
                                 	send -- "\$le_compute_rootpassword\n"
                                  	}
			   	  -nocase eof {
					 exit
				  	}
				  }
				  # Look for passwd prompt
                                  log_user 1
		       		  set timeout $watchdog_wakeup_root
                       		  expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_compute_rootpassword\n"
                       		  }
                       		    -nocase eof {
                       		         exit
                       		  }
                       		    -nocase timeout {
		       		 	send_error "Timed out while running $ROOTSCRPT on $i\n";
                       		         exit
                       		  }
                       		  }
                       		  log_user 1
		       		  # Stop the on logon tests and if asked to connect to master switch choose no
                       		  expect {
                       		     -nocase eof {
                       		          exit
                       		     }
                       		     -nocase timeout {
		       		  	send_error "Timed out while running $ROOTSCRPT on $i\n";
                       		          exit
                       		     }
                       		  }
IBEOF
			else
			  echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL
			  #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck priviledged check will not be executed on $nodeNameToCheck ${NORM}\n"
			fi
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                      fi
                    elif [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]]
                    then
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands on ${print_compute_node} $i."
                        echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                      fi
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                      compute_rootpassword=${a_compute_rootpassword[$stack_counter]}
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
		      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then
		        compute_ssh_status=1
		      else
                        compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $i ls >/dev/null 2>&1;echo $?);
		      fi
                      if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                      then
			echo -e "\n$GREEN $i is configured for ssh user equivalency for ${root_user} user $NORM \n";
                        echo "${root_user} password not checked on $i because ssh user equivalence found for ${root_user}">>$LOGFIL
                        $SSHELL root@$i "$ROOTSCRPT" 
                      else
			if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" && `echo "$ea_dom0_nodes" | grep -ic "$i"` -gt "0" ]]; then
		  	  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                          efCheckrootPassword "$i" "$usern" "${root_user}" "$compute_rootpassword"
			  ROOT_CMD="su - ${root_user} -c $ROOTSCRPT"
			else
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			  checkUserPassword "$i" "${root_user}" "$compute_rootpassword" "1"
			  ROOT_CMD="$SSHELL ${root_user}@$i \"$ROOTSCRPT\""
			fi
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
		        if [ $passwordCheckStatus -eq 0 ]
		        then
		          fixRootPassword "$compute_rootpassword"
		          $EXPECT -f - 2>>$WATCHLOG << IBEOF
		            set timeout $passwordcheck_timeout
		            set le_compute_rootpassword "$fixedRootPassword"
                            if { "$RAT_EXPECT_DEBUG" == "-d" } {
                              exp_internal 1
                            }
                            log_user 0
		            #spawn -noecho $SSHELL ${root_user}@$i "$ROOTSCRPT"			
		            #spawn -noecho $SSHELL_EL $i "su - ${root_user} -c $ROOTSCRPT"			
			    spawn -noecho $ROOT_CMD
		            match_max 100000
		              expect {
		            -nocase "permission denied *" {
		              exit 4;
		            }
		            -nocase "no)?" {
		          	send -- "yes\n"
		          	}
    		               -nocase "*?assword:*" {
                           	send -- "\$le_compute_rootpassword\n"
                            	}
		               -nocase eof {
		          	 exit
		            	}
		            }
		            # Look for passwd prompt
                            log_user 1
		            set timeout $watchdog_wakeup_root
                            expect {
                              -nocase "*?assword:*" {
                                   send -- "\$le_compute_rootpassword\n"
                              }
                              -nocase eof {
                                   exit
                              }
                              -nocase timeout {
		           	send_error "Timed out while running $ROOTSCRPT on $i\n";
                                   exit
                              }
                            }
                            log_user 1
		            # Stop the on logon tests and if asked to connect to master switch choose no
                            expect {
                               -nocase eof {
                                    exit
                               }
                               -nocase timeout {
		            	send_error "Timed out while running $ROOTSCRPT on $i\n";
                                    exit
                               }
                            }
IBEOF
		        else
		          #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck priviledged check will not be executed on $nodeNameToCheck ${NORM}\n"
		          echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
		        fi
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                      fi
                    else  
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands ${print_compute_node} $i.  Please enter ${root_user} password when prompted."
                        echo "Preparing to run root privileged commands on $i.  Please enter ${root_user} password when prompted.">>$LOGFIL
                      fi
		      if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
		        su - ${root_user} -c $ROOTSCRPT
		      else
        	        $SSHELL ${root_user}@$i "$ROOTSCRPT"			
		      fi
                      #Fix for bug 14336860 
                      #$SSHELL_EL $i "su - root -c $ROOTSCRPT 2>/dev/null"
                    fi
                  fi

                  for FNAMEANDPATH in `$SSHELL -n $i "ls ${RTEMPDIR}/o_* 2>/dev/null"`
                  do
                    FNAME=`echo $FNAMEANDPATH |$AWK 'BEGIN { FS = "/" } {printf $NF}'|cut -d. -f1`
                    if [ -e $OUTPUTDIR/$FNAME"_"$i".out" ]
                    then
                      $SSHELL $i cat $FNAMEANDPATH  >>$OUTPUTDIR/$FNAME"_"$i".out"
                    else
                      $SCOPY -r $i:$FNAMEANDPATH $OUTPUTDIR/$FNAME"_"$i".out" > /dev/null 2>&1
                    fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -lt 1 && "$FNAME" != "o_exadata_disk.out" ]]; then $SSHELL $i rm -f $FNAMEANDPATH >/dev/null 2>&1;fi
                    #if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -ge 1 ]]; then $SSHELL $i mv -f $FNAMEANDPATH $TMPDIR  >/dev/null 2>&1; fi;
                  done
                  #Changes made by jrmullan 03/22/10
                  #$SSHELL $i rm -f /tmp/o_*.out >/dev/null 2>&1
                  #if [[ -n "$ORACLEENVVARS" && $ORACLEENVVARS != "" ]];then $SSHELL $i rm -rf $TMPDIR/$ORACLEENVVARS >/dev/null 2>&1;fi;
                  if [[ -n "$ORACLEENVVARS" && $ORACLEENVVARS != "" ]];then $SSHELL $i rm -rf $RTEMPDIR/$ORACLEENVVARS >/dev/null 2>&1;fi;
                  REM_RC=`$SSHELL $i rm -f $ROOTSCRPT >/dev/null 2>&1;echo \$?;`
	  	  security_fix "verify_remcode" "$i:$ROOTSCRPT" "$REM_RC"

                  if [ -f $ROOTSCRPT ]; 
  		  then 
		    #rm -f $ROOTSCRPT >/dev/null 2>&1;
		    mv -f $ROOTSCRPT $OUTPUTDIR >/dev/null 2>&1;
 		  fi;

                  if [[ -e ${OUTPUTDIR}/o_root_collect_timing_${i}.out && -e $COLLECT_TIMING ]]
                  then
                    cat ${OUTPUTDIR}/o_root_collect_timing_${i}.out >> $COLLECT_TIMING
  		    collect_duration "${OUTPUTDIR}/o_root_collect_timing_${i}.out" "$COLLECT_TIMING"
                    rm -f ${OUTPUTDIR}/o_root_collect_timing_${i}.out  >/dev/null 2>&1
                  fi
                else
		  echo -e "\n${RED}Skipping root privileged commands ${print_compute_node} ${NORM} ${i}\n"|tee -a $LOGFIL
                fi
              fi #Finished here with executing command with root for each host

              echo -e "OSCOLLECTCNT=$OSCOLLECTCNT OSCOLLECTSUM= $OSCOLLECTSUM rootYesNoint=$rootYesNoint root_need_cell_ssh=$root_need_cell_ssh REQUIRE_ROOT=$REQUIRE_ROOT" >>$LOGFIL
              #$READ -p "rootYesNoint=$rootYesNoint"

	      # unlock exacli again to perfrom checks on storage cells
	      if [[ -n $unlocked_storage_cell && $unlocked_storage_cell -eq 1 ]];then
                if [[ $cell_unlocked_flag -eq 0 ]];then
                  for (( exacli_passwd_list_index = 0; exacli_passwd_list_index < $cell_ip_max_index; exacli_passwd_list_index++ ))
                  do
                    cell_ip=${exacli_passwd_list[exacli_passwd_list_index]}
                    is_cell_locked "$cell_ip" "$cell_ssh_user"
                    if [[ -n $cell_locked && $cell_locked -eq 1 ]];then
                      exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
                      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                      unlock_storage_cell_exacli "$exacli_user" "$cell_ip" "${exacli_passwd_list[exacli_passwd_list_index]}"
                      if [[ $? -eq "0" ]];then
                        add_to_skipped_nodes "$cell_ip" "Storage server is not reachable"
                      fi
                    fi                  
                  done
		  cell_unlocked_flag=1   #This flag varibale is used to avoid this section falling in the loop
                  echo -e "\n\nUnlocking Storage Server.."
                  cell_ip_max_index=$exacli_passwd_list_index
                  for (( exacli_passwd_list_index = 0; exacli_passwd_list_index < $cell_ip_max_index; exacli_passwd_list_index++ ))
                  do
                    exacli_locked_period_timeout=0
                    is_cell_locked "${exacli_passwd_list[exacli_passwd_list_index]}" "$cell_ssh_user"
                    if [[ -n $cell_locked && $cell_locked -eq 1 ]]; then
                      while [ $cell_locked -eq 1 ]
                      do
                        is_cell_locked "${exacli_passwd_list[exacli_passwd_list_index]}" "$cell_ssh_user"
                        sleep 3
                        exacli_locked_period_timeout=`expr $exacli_locked_period_timeout + 3`
                        if [[ $exacli_locked_period_timeout -eq "600" ]]; then
                          echo -e "\n\nTimeout:Unable to unlock the storage Server $cell_ip"
                          if [[ $EM_PROBE_MODE -eq 1 ]]
                          then
                            EMSG="$EMSG Timeout: Unable to unlock the storage Server $cell_ip"
                            unable_to_unlock_cell=1
                          fi
                          add_to_skipped_nodes "$cell_ip" "Storage server is not reachable"
                          break
                        fi
                        printf  ". "
                     done
                   fi
                   exacli_passwd_list_index=`expr $exacli_passwd_list_index + 1`
                 done
	       fi
             fi
            if [[ $EM_PROBE_MODE -eq 1 && $unable_to_unlock_cell -eq 1 ]] 
            then   
              update_probe_xml "ERROR" "GENERIC" "$EMSG"
              unable_to_unlock_cell=0
              exit
            fi

    	    if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]] && [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 ]]; then
	      echo ""
              cellname_short=$(echo $cellname|sed 's/\./_/g') 
              CELLDIR_SHORT=$CELLDIR/$cellname_short
              if [ -e $CELLDIR_SHORT ]; then rm -rf $CELLDIR_SHORT >/dev/null 2>&1; fi
              mkdir -p $CELLDIR_SHORT       

   	      if [ -f "$CELLSSCRPT" ]; then chmod 540 $CELLSSCRPT 2>/dev/null; cp -f $CELLSSCRPT $OUTPUTDIR; fi;

	      $CELLSSCRPT 2>/dev/null 
	      returncode=`echo $?`
	      cp -f ${RTEMPDIR}/c_*.out $CELLDIR_SHORT >/dev/null 2>&1
              if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
	      cellnameFullActual=$(hostname|cut -d. -f1)
	      echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
	      move_failed_to_skipped "$returncode" "$CELLSSCRPT execution"
            elif  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $cell_root_command -gt 0  && $cell_password_status -ne 3 && "$profiles2run" != "switch" ]]
            then
              #Create lock file for watchdog for root collections.
              touch $ROOT_LCKFIL

   	      if [ -f "$CELLSSCRPT" ]; then cp -f $CELLSSCRPT $OUTPUTDIR; fi;
              if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
              if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP ]]  
              then
	        cell_files_for_copy="griddisk_attributes iorm_dbplan CellFlashCacheMode"
                #cat $IBSWITCHSCRPT
                #$READ -p "good to run"
                if [ ! -e $CELLDIR ];then mkdir $CELLDIR >/dev/null 2>&1;fi
                cp -f $CELLIP $CELLDIR 2>/dev/null 2>&1
                root_cell_counter=0
                no_of_cells=$(wc -l $CELLIP |awk '{print $1}'|tr -d ' ')
                no_of_cells=$(expr $no_of_cells - 1);
                in_last_cell=0
                if [[ ! -n "$RAT_CELL_RUNMODE" ]] ; then RAT_CELL_RUNMODE="parallel"; fi;

                for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'` 
                do
	          test_node_reachability $cellname $cell_ssh_user;
	          if [ $el_node_ping -eq "1" ] ; then
                    cellPingStatus=0;
	          else
	            cellPingStatus=1;
                  fi

                  if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
                  then
	            noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $cellname)
	            if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]
                    then
                      cellname_full=$cellname
                    else
	              cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)
                    fi
                    
                    if [[ $no_of_cells -eq $root_cell_counter ]] ; then last_cell_name=$cellname; in_last_cell=1; fi
	            cell_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
	            if [[ -n "$cell_password_status" && $cell_password_status -ne 3 ]] && [[ -n "$cell_ssh_status1" && $cell_ssh_status1 -eq 0 && $is_exalogic_machine -eq 0 || -n "$cell_ssh_status1" && $cell_ssh_status1 -eq 0 && $is_exalogic_foxtrot -eq 0 ]]
	            then # ssh is setup on cells
	              if [ -f "$CELLSSCRPT" ] ; then cp -f $CELLSSCRPT $OUTPUTDIR >/dev/null 2>&1; fi;
                      cellname_short=$(echo $cellname|sed 's/\./_/g') 
                      CELLDIR_SHORT=$CELLDIR/$cellname_short
                      #delete directory in exachk output directory for this cell if it exits 
                      if [ -e $CELLDIR_SHORT ]; then rm -rf $CELLDIR_SHORT >/dev/null 2>&1; fi
                      mkdir -p $CELLDIR_SHORT       
                      if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
	                #echo -e "\nStarting to run $cell_ssh_user privileged commands in background on ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname)\n"
			echo -e "\n${GREEN}Starting to run $cell_ssh_user privileged commands in background on ${BLINK}STORAGE SERVER $cellname_full ($cellname) $NORM\n"
                        start_run_on_cell_in_background
	                cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
	                echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                      else
	                echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname)\n"
	      	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      	        is_SSH_blocked "$cellname" "$cell_ssh_user" "$cell_rootpassword" "CELL"
	      	        if [[ $SSH_blocked -eq 1 ]]; then
	      	          echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL
	      	          add_to_skipped_nodes "${cellname}" "SSH Issue: STORAGE SERVER is reachable but SSH is blocked"
                          root_cell_counter=$(expr $root_cell_counter + 1)
	      	          continue;
	      	        fi

                        if [[ -n "$DOROOT" && $DOROOT -eq 1 && -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin" ]] || [[ -n "$RAT_CELL_SSH_USER" && "$RAT_CELL_SSH_USER" = "cellmonitor" ]]
                        then
	      	    	  $SCOPY  $CELLSSCRPT $SCRIPTPATH/.cgrep/$ASREXACHK $SCRIPTPATH/.cgrep/$checkFlashCache $SCRIPTPATH/.cgrep/$validatePassword $cell_ssh_user@$cellname:$CELLTMPDIR >/dev/null 2>&1
       	      	    	  $SSHELL $cell_ssh_user@$cellname chmod 540 $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache $CELLTMPDIR/$validatePassword >/dev/null 2>&1
                          $SSHELL $cell_ssh_user@$cellname mkdir ${CELLRTEMPDIR} >/dev/null 2>&1
                          $SSHELL -t $cell_ssh_user@$cellname sudo "$CELLTMPDIR/${program_name}_cells.sh" 2>/dev/null
	                  returncode=`echo $?`
	                  $SCOPY  $cell_ssh_user@$cellname:${CELLRTEMPDIR}/c_*.out $CELLDIR_SHORT >/dev/null 2>&1
	                  $SSHELL $cell_ssh_user@$cellname rm -f $CELLTMPDIR/${program_name}_cells.sh  >/dev/null 2>&1
    	      	    	  $SSHELL $cell_ssh_user@$cellname rm -f $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache $CELLTMPDIR/$validatePassword >/dev/null 2>&1
	                  $SSHELL $cell_ssh_user@$cellname rm -f ${CELLRTEMPDIR}/c_*.out >/dev/null 2>&1
	                  $SSHELL $cell_ssh_user@$cellname rmdir  ${CELLRTEMPDIR} >/dev/null 2>&1
                          if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
	                  cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
	                  echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                        else
	      	    	  $SCOPY  $CELLSSCRPT $SCRIPTPATH/.cgrep/$ASREXACHK $SCRIPTPATH/.cgrep/$checkFlashCache $SCRIPTPATH/.cgrep/$validatePassword $cell_ssh_user@$cellname:$CELLTMPDIR >/dev/null 2>&1
       	      	    	  $SSHELL $cell_ssh_user@$cellname chmod 540 $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache $CELLTMPDIR/$validatePassword >/dev/null 2>&1
                          $SSHELL $cell_ssh_user@$cellname mkdir ${CELLRTEMPDIR} >/dev/null 2>&1
	                  $SSHELL $cell_ssh_user@$cellname $CELLTMPDIR/${program_name}_cells.sh 2>/dev/null 
	                  returncode=`echo $?`
	                  $SCOPY  $cell_ssh_user@$cellname:${CELLRTEMPDIR}/c_*.out $CELLDIR_SHORT >/dev/null 2>&1
	                  $SSHELL $cell_ssh_user@$cellname rm -f $CELLTMPDIR/${program_name}_cells.sh  >/dev/null 2>&1
    	      	    	  $SSHELL $cell_ssh_user@$cellname rm -f $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache $CELLTMPDIR/$validatePassword >/dev/null 2>&1
	                  $SSHELL $cell_ssh_user@$cellname rm -f ${CELLRTEMPDIR}/c_*.out ${CELLRTEMPDIR}/o_*.out >/dev/null 2>&1
	                  $SSHELL $cell_ssh_user@$cellname rmdir  ${CELLRTEMPDIR} >/dev/null 2>&1
                          if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
	                  cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
	                  echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                        fi
	                move_failed_to_skipped "$returncode" "$CELLTMPDIR/${program_name}_cells.sh execution"
                      fi #end of parallel or seiral if
	            elif [ $noPasswordAvailable -eq 0 ]
	            then
                      cellname_short=$(echo $cellname|sed 's/\./_/g') 
                      CELLDIR_SHORT=$CELLDIR/$cellname_short
                      #delete directory in exachk output directory for this cell if it exits 
                      if [ -e $CELLDIR_SHORT ]; then rm -rf $CELLDIR_SHORT >/dev/null 2>&1; fi
                      mkdir -p $CELLDIR_SHORT       
                      if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
			echo -e "\n${GREEN}Starting to run $cell_ssh_user privileged commands in background on ${BLINK}STORAGE SERVER $cellname_full ($cellname) $NORM\n"
	      	  	#echo -e "\nStarting to run $cell_ssh_user privileged commands in background on ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname)\n"
                      else
	      	  	echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname)\n"
                      fi
	      	      if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 0 ]]
	      	      then
	      	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      	        cell_rootpassword=${a_cell_rootpassword[$root_cell_counter]}
	      	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	      	        #echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full\n"
	      	      fi
	      	      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      	      is_SSH_blocked "$cellname" "$cell_ssh_user" "$cell_rootpassword" "CELL"
	      	      if [[ $SSH_blocked -eq 1 ]]; then
	      	        echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL
	      	        add_to_skipped_nodes "${cellname}" "SSH Issue: STORAGE SERVER is reachable but SSH is blocked"
                        root_cell_counter=$(expr $root_cell_counter + 1)
	      	        continue;
	      	      fi

	      	      cell_type="normal"
	      	      if [[ $passwordCheckStatus -eq 0 ]]
	      	      then # Normal exadata cell
	      	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      	        fixRootPassword "$cell_rootpassword"
                        cellhostname=$($EXPECT -f - << IBEOF
                                            set timeout $passwordcheck_timeout
	      			      	    set le_cell_rootpassword "$fixedRootPassword"
                                            #log_user 0
                                            if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                              exp_internal 1
                                            } 
                                            spawn -noecho $SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1"
                                            match_max 100000
                                            expect {
	      			  	      -nocase "permission denied *" {
	      			  	        exit 4;
	      			              }
                                       	      -nocase "no)?" {
                                                send -- "yes\n"
                                              }
	      			  	      -nocase "*?assword:*" {
	      			  	        send -- "\$le_cell_rootpassword\n"
	      			  	      }
	      			  	      -nocase eof {
	      			  	        exit
	      			  	      }
                                            }
	      			      	    # Look for passwd prompt
	      				    expect {
	      				      -nocase "*?assword:*" {
	      				        send -- "\$le_cell_rootpassword\n"
	      				      }
	      				      -nocase eof {
	      				        exit
	      				      }
	      				      -nocase timeout {
	      				        send_error "Timed out\n";
	      				    	exit
	      				      }
	      				    }
	      			            # Stop the on logon tests and if asked to connect to master switch choose no
	      				    expect {
	      				      -nocase eof {
	      				        exit
	      				      }
	      				      -nocase timeout {
	      					send_error "Timed out\n";
	      					exit
	      				      } 
	      				    }
IBEOF
)
	      	  	if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	      	  	cellnameFullActual=$(echo "$cellhostname"|tail -1|sed 's/ //g'|tr -d '\r')
                        #cellnameFullActual=$(echo $cellhostname|awk 'BEGIN { FS = "password:" };{print $2}'|sed 's/ //g'|sed 's///g')
                        echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out

                        if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
                          start_run_on_cell_in_background
                        else
	      	        if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      	        fixRootPassword "$cell_rootpassword"
	      	        $EXPECT -f - << IBEOF
	      	          set timeout $passwordcheck_timeout
	      	          set le_cell_rootpassword "$fixedRootPassword"
	      	          log_user 0
                          if { "$RAT_EXPECT_DEBUG" == "-d" } {
                            exp_internal 1
                          }
	      	          spawn $SCOPY $CELLSSCRPT $SCRIPTPATH/.cgrep/$ASREXACHK  $SCRIPTPATH/.cgrep/$checkFlashCache $SCRIPTPATH/.cgrep/$validatePassword $cell_ssh_user@$cellname:$CELLTMPDIR
	      	          match_max 100000
	      	          expect {
	      	            -nocase "permission denied *" {
	      	              exit 4;
	      	            }
	      	            -nocase "no)?" {
	      	              send -- "yes\n"
                            } 
	      	            -nocase "*?assword:*" {
	      	              send -- "\$le_cell_rootpassword\n"
	      	            }
	      	            -nocase eof {
	      	              exit
	      	            }
	      	          }
	      	          # Look for passwd prompt
                     	  expect {
                     	    -nocase "*?assword:*" {
                     	      send -- "\$le_cell_rootpassword\n"
                     	    }
                     	    -nocase eof {
                     	      exit
                     	    }
                     	    -nocase timeout {
	             	      send_error "Timed out while copying $CELLSSCRPT on $cellname\n";
                     	      exit
                     	    }
                     	  }
	             	  #Stop the on logon tests and if asked to connect to master switch choose no
                     	  expect {
                     	    -nocase eof {
                     	      exit
                     	    }
                     	    -nocase timeout {
	             	      send_error "Timed out while copying $CELLSSCRPT on $cellname\n";
                     	      exit
                     	    }
                     	  }
IBEOF
                        #-- gadiga create ${RTEMPDIR}
                        $EXPECT -f - << IBEOF
                            set timeout $passwordcheck_timeout			
	      	            set le_cell_rootpassword "$fixedRootPassword"
                            log_user 0
                            if { "$RAT_EXPECT_DEBUG" == "-d" } {
                              exp_internal 1
                            }
                            spawn $SSHELL $cell_ssh_user@$cellname mkdir ${CELLRTEMPDIR} >/dev/null 2>&1
                            match_max 100000
                            expect {
	      	       	      -nocase "permission denied *" {
	      	 	        exit 4;
	      	              }
                              -nocase "no)?" {
                                send -- "yes\n"
	      	              }
	      	              -nocase "*?assword:*" {
	      	                send -- "\$le_cell_rootpassword\n"
	      	              }
	      	              -nocase eof {
	      	                exit
	      	              }
                            }
	      	            # Look for passwd prompt
                     	    expect {
                     	      -nocase "*?assword:*" {
                     	        send -- "\$le_cell_rootpassword\n"
                     	      }
                     	      -nocase eof {
                     	        exit
                     	      }
                     	      -nocase timeout {
	             	      	 send_error "Timed out while creating ${CELLRTEMPDIR} directory on $cellname\n";
                     	        exit
                     	      }
                     	    }
	             	    # Stop the on logon tests and if asked to connect to master switch choose no
                     	    expect {
                     	      -nocase eof {
                     	        exit
                     	      }
                     	      -nocase timeout {
	             	     	 send_error "Timed out while creating ${CELLRTEMPDIR} directory on $cellname\n";
                     	        exit
                     	      }
                     	    }
IBEOF

	      	        $EXPECT -f - << IBEOF
	      	          set timeout $passwordcheck_timeout
	      	          set le_cell_rootpassword "$fixedRootPassword"
	      	          log_user 0
                          if { "$RAT_EXPECT_DEBUG" == "-d" } {
                            exp_internal 1
                          }  
	      	          spawn $SSHELL $cell_ssh_user@$cellname chmod 540 $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache $CELLTMPDIR/$validatePassword
	      	          match_max 100000
	      	          expect {
	      	            -nocase "permission denied *" {
	      	              exit 4;
	      	            }
	      	            -nocase "no)?" {
	      	              send -- "yes\n"
	      	            }
	      	            -nocase "*?assword:*" {
	      	              send -- "\$le_cell_rootpassword\n"
	      	            }
	      	            -nocase eof {
	      	              exit
	      	            }
	      	          }
	      	          # Look for passwd prompt
                     	  expect {
                     	    -nocase "*?assword:*" {
                     	      send -- "\$le_cell_rootpassword\n"
                     	    }
                     	    -nocase eof {
                     	      exit
                     	    }
                     	    -nocase timeout {
	             	      send_error "Timed out while modifying permissions on $cellname\n";
                     	      exit
                     	    }
                     	  }
	             	  # Stop the on logon tests and if asked to connect to master switch choose no
                     	  expect {
                     	    -nocase eof {
                     	      exit
                     	    }
                     	    -nocase timeout {
	             	      send_error "Timed out while modifying permissions on $cellname\n";
                     	      exit
                     	    }
                     	  }
IBEOF
	      	    $EXPECT -f - 2>>$WATCHLOG << IBEOF
	      	       set timeout $passwordcheck_timeout
	      	       set le_cell_rootpassword "$fixedRootPassword"
                       if { "$RAT_EXPECT_DEBUG" == "-d" } {
                         exp_internal 1
                       }
	      	       spawn -noecho $SSHELL $cell_ssh_user@$cellname $CELLTMPDIR/${program_name}_cells.sh
	      	       match_max 100000
	      		 expect {
	      	       -nocase "permission denied *" {
	      	 	     exit 4;
	      	        }
	      	       -nocase "no)?" {
	      		     send -- "yes\n"
	      	        }
	      	       -nocase "*?assword:*" {
	      	    	     send -- "\$le_cell_rootpassword\n"
	      		}
	      		-nocase eof {
	      		     exit
	      		}
	      	      }	
	      	      # Look for passwd prompt
	      	      set timeout $watchdog_wakeup_root
                      expect {
                        -nocase "*?assword:*" {
                          send -- "\$le_cell_rootpassword\n"
                        }
                        -nocase eof {
                          exit
                        }
                        -nocase timeout {
	      	          send_error "Timed out while running $CELLTMPDIR/${program_name}_cells.sh on $cellname\n";
                          exit
                        }
                      } 
	      	      # Stop the on logon tests and if asked to connect to master switch choose no
                      expect {
                        -nocase eof {
                          exit
                        }
                        -nocase timeout {
                          send_error "Timed out while running $CELLTMPDIR/${program_name}_cells.sh on $cellname\n";
                          exit
                        }
                      }
IBEOF
#only for execution
	      	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	      	    returncode=`echo $?`
	      	    move_failed_to_skipped "$returncode" "$CELLTMPDIR/${program_name}_cells.sh execution"
	      	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	      	    $EXPECT -f - << IBEOF
	      	       #set timeout 5
                       set timeout $passwordcheck_timeout
	      	       set le_cell_rootpassword "$fixedRootPassword"
	      	       log_user 0
                       if { "$RAT_EXPECT_DEBUG" == "-d" } {
                          exp_internal 1
                       }    
	      	       spawn $SCOPY $cell_ssh_user@$cellname:${CELLRTEMPDIR}/c_*.out $CELLDIR_SHORT
	      	       match_max 100000
	      	       expect {
	      	         -nocase "permission denied *" {
	      	 	   exit 4;
	      	         }
	      	         -nocase "no)?" {
	      		   send -- "yes\n"
	      	         }
	      	         -nocase "*?assword:*" {
	      	    	   send -- "\$le_cell_rootpassword\n"
	      		 }
	      		 -nocase eof {
	      		   exit
	      		 }
	      	       }
	      	       # Look for passwd prompt
                       expect {
                         -nocase "*?assword:*" {
                           send -- "\$le_cell_rootpassword\n"
                         }
                         -nocase eof {
                           exit
                         }
                         -nocase timeout {
	                   send_error "Timed out while copying outfiles from $cellname\n";
                           exit
                         }
                       }
	               # Stop the on logon tests and if asked to connect to master switch choose no
                       expect {
                         -nocase eof {
                           exit
                         }
                          -nocase timeout {
	               	    send_error "Timed out while copying outfiles from $cellname\n";
                            exit
                          }
                       }
IBEOF
	      	    $EXPECT -f - << IBEOF
	      	       set timeout $passwordcheck_timeout
	      	       set le_cell_rootpassword "$fixedRootPassword"
	      	       log_user 0
                       if { "$RAT_EXPECT_DEBUG" == "-d" } {
                         exp_internal 1
                       }
	      	       spawn $SSHELL $cell_ssh_user@$cellname rm -f $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK  $CELLTMPDIR/$checkFlashCache  $CELLTMPDIR/$validatePassword 2>/dev/null
	      	       match_max 100000
	      	       expect {
	      	         -nocase "permission denied *" {
	      	           exit 4;
	      	         }
	      	         -nocase "no)?" {
	      	           send -- "yes\n"
	      	         }
	      	         -nocase "*?assword:*" {
	      	           send -- "\$le_cell_rootpassword\n"
	      	         }
	      	         -nocase eof {
	      	           exit
	      	         }
	      	       }
	      	       # Look for passwd prompt
                       expect {
                         -nocase "*?assword:*" {
                           send -- "\$le_cell_rootpassword\n"
                         }
                         -nocase eof {
                           exit
                         }
                         -nocase timeout {
	                   send_error "Timed out while removing files on $cellname\n";
                           exit
                         }
                       }
	               # Stop the on logon tests and if asked to connect to master switch choose no
                       expect {
                         -nocase eof {
                           exit
                         }
                         -nocase timeout {
	                   send_error "Timed out while removing files on $cellname\n";
                           exit
                         }
                       }
IBEOF
	      	    $EXPECT -f - << IBEOF
	      	       set timeout $passwordcheck_timeout
	      	       set le_cell_rootpassword "$fixedRootPassword"
	      	       log_user 0
                       if { "$RAT_EXPECT_DEBUG" == "-d" } {
                         exp_internal 1
                       }   
	      	       spawn $SSHELL $cell_ssh_user@$cellname rm -f ${CELLRTEMPDIR}/c_*.out ${CELLRTEMPDIR}/o_*.out
	      	       match_max 100000
	      	       expect {
	      	         -nocase "permission denied *" {
	      	 	   exit 4;
	      	         }
	      	         -nocase "no)?" {
	      		   send -- "yes\n"
	      	         }
	      	         -nocase "*?assword:*" {
	      	    	   send -- "\$le_cell_rootpassword\n"
	      		 }
	      		 -nocase eof {
	      		   exit
	      		 }
	      	       }
	      	       # Look for passwd prompt
                       expect {
                         -nocase "*?assword:*" {
                           send -- "\$le_cell_rootpassword\n"
                         }
                         -nocase eof {
                           exit
                         }
                         -nocase timeout {
	                   send_error "Timed out while removing files on $cellname\n";
                           exit
                         }
                       }
	               # Stop the on logon tests and if asked to connect to master switch choose no
                       expect {
                         -nocase eof {
                           exit
                         }
                         -nocase timeout {
	                   send_error "Timed out while removing files on $cellname\n";
                           exit
                         }
                       }
IBEOF
                    $EXPECT -f - << IBEOF
	      	       set timeout $passwordcheck_timeout
	      	       set le_cell_rootpassword "$fixedRootPassword"
	      	       log_user 0
                       if { "$RAT_EXPECT_DEBUG" == "-d" } {
                         exp_internal 1
                       }
	      	       spawn $SSHELL $cell_ssh_user@$cellname rmdir  ${CELLRTEMPDIR}
	      	       match_max 100000
	      	       expect {
	      	         -nocase "permission denied *" {
	      	 	   exit 4;
	      	         }
	      	         -nocase "no)?" {
	      		   send -- "yes\n"
	      	         }
	      	         -nocase "*?assword:*" {
	      	    	   send -- "\$le_cell_rootpassword\n"
	      		 }
	      		 -nocase eof {
	      		   exit
	      		 }
	      	       }
	      	       # Look for passwd prompt
                       expect {
                         -nocase "*?assword:*" {
                           send -- "\$le_cell_rootpassword\n"
                         }
                         -nocase eof {
                           exit
                         }
                         -nocase timeout {
	              	   send_error "Timed out while removing $CELLRTEMPDIR directory on $cellname\n";
                           exit
                         }
                      }
	              # Stop the on logon tests and if asked to connect to master switch choose no
                      expect {
                         -nocase eof {
                           exit
                         }
                         -nocase timeout {
	                   send_error "Timed out while removing $CELLRTEMPDIR directory on $cellname\n";
                           exit
                         }
                      }
IBEOF
	      	    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                    if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
                  fi #end of parallel and serial check exeuction
	      	else
	      	  echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
	      	fi 
	            else
	              echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${cellname}\n"|tee -a $LOGFIL
	            fi
  	            if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
  	            then
  	              cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
  	              collect_duration "$CELLDIR/c_root_collect_timing.out" "$COLLECT_TIMING"
  	              rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
  	            elif [[ -e $CELLDIR_SHORT/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
  	            then
  	              cat $CELLDIR_SHORT/c_root_collect_timing.out >> $COLLECT_TIMING
  	              collect_duration "$CELLDIR_SHORT/c_root_collect_timing.out" "$COLLECT_TIMING"
  	              rm -f $CELLDIR_SHORT/c_root_collect_timing.out  >/dev/null 2>&1
  	            fi
                  else
	            if [[ $ssh_go_ahead = 0 ]]
	            then
	              echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but ssh took too long.${NORM}\n"|tee -a $LOGFIL
	              add_to_skipped_nodes "${cellname}" "Network latency issue: Storage Server is pingable but ssh took too long"
	            else
	              echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} because its not available.${NORM}\n"|tee -a $LOGFIL
	              add_to_skipped_nodes "${cellname}" "Storage Server is not available"
	            fi
                  fi  

	          if [[ $RAT_CELL_RUNMODE != "parallel" ]] ; then
  	            TMP_CELLDIR_SHORT=$RTEMPDIR/.CELLDIR/$cellname_short
  	            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then TMP_CELLDIR_SHORT=$TMP_OUTPUT/.CELLDIR/$cellname_short; fi
	            BASE_TMP_CELLDIR_SHORT=$(dirname $TMP_CELLDIR_SHORT);
  	            mkdir -p ${TMP_CELLDIR_SHORT} >/dev/null 2>&1
  	            for cfiles in `echo "$cell_files_for_copy"`
  	            do 
  	              cp -f $CELLDIR_SHORT/c_cbc_${cfiles}*.out ${TMP_CELLDIR_SHORT} >/dev/null 2>&1 
	      	      cp -f $CELLDIR/c_cbc_${cfiles}*.out $BASE_TMP_CELLDIR_SHORT >/dev/null 2>&1 
  	            done
	          fi

                  root_cell_counter=$(expr $root_cell_counter + 1)
                done

                if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]]; then
                  wait_for_cell_completion
	          copy_cellfiles_to_remotenodes
                fi
              fi
              if [ -e $CELLDIR/cells.out ]; then 
	        cp -f $CELLDIR/cells.out $RTEMPDIR >/dev/null 2>&1; 
	        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then cp $CELLDIR/cells.out $TMP_OUTPUT >/dev/null 2>&1;
	        else
  	          dirlist=$(echo "$USR_DIRS"|sed "s/^\s*//g"|sed "s/\s*$//g")
  	          for utildir in `echo "$dirlist"`
  	          do
	            cp $CELLDIR/cells.out $utildir >/dev/null 2>&1;
 	          done
	        fi
	      fi
              root_cell_counter=0 
              #function to discover mixed hardware cells
              #mixed_hardware_cells_discovery 
            fi #Finished here with executing command with root for each cell

              no_ib_switch=1
              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $ibswitch_root_command -gt 0  && -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 ]]
              then
                #Create lock file for watchdog for root collections.
                touch $ROOT_LCKFIL

                if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e ${RTEMPDIR}/o_ibswitches.out ]]  
                then
                  if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi  
                  #cat $IBSWITCHSCRPT
                  #$READ -p "good to run"
                  #function to map ip address to switch name and find switch type for each(leaf or spine)
                  switch_ip_type_name_mapping 
                  ib_root_counter=0
                  no_of_ibs=$(wc -l ${RTEMPDIR}/o_ibswitches.out | awk '{print $1}')
                  no_of_ibs=$(expr $no_of_ibs - 1);
                  in_last_ib=0
	          last_ib_name=""
                  if [[ ! -n "$RAT_IBSWITCH_RUNMODE" ]] ; then RAT_IBSWITCH_RUNMODE="parallel"; fi;
                  for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
                  do
                    if [ $no_of_ibs -eq $ib_root_counter ] ; then
	              last_ib_name=$switchname
                      in_last_ib=1
                      no_ib_switch=0
                    fi
                    #Following code is to change switch ip address to fully qualified domain name so OS_OUT_CHECK dont get skipped
                    is_ibswitch_ip=$(echo $switchname|grep -c '[A-Za-z]')
                    if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
                    then
                      switchname_short=$(echo $switchname|sed 's/\./_/g')
                    else
                      switchname_short=$(echo $switchname|cut -d. -f1)            
                      #switchname=$(nslookup $switchname|grep -iw name|awk '{print $NF}'|sed 's/\.$//')
                    fi
                    switchDirShort=$OUTPUTDIR/$switchname_short
                    if [ -e $switchDirShort ]; then rm -rf $switchDirShort >/dev/null 2>&1; fi
                    mkdir -p $switchDirShort  
                    echo $switchname>>$INPUTDIR/o_ibswitches.out      
                    #$READ -p "after converting ip to name"
                    noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $switchname)  
                    switch_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
                     
                    if [[ -n "$switch_ssh_status" && $switch_ssh_status -eq 0 ]]
                    then
                      if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
	                echo -e "\n${GREEN}Starting to run $ibswitch_user privileged commands in background on ${BLINK}INFINIBAND SWITCH ${switchname} $NORM\n"
			echo -e "\nStarting to run $ibswitch_user privileged commands in background on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n" >>$LOGFIL
                        start_run_on_ib_in_background
                      else
	                echo -e "\nPreparing to run $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n"
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			is_SSH_blocked "$switchname" "$ibswitch_user" "$switch_rootpassword" "SWITCH"
			if [[ $SSH_blocked -eq 1 ]]; then
			  echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${RED} ${switchname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL 
			  add_to_skipped_nodes "${switchname}" "SSH Issue: INFINIBAND SWITCH is reachable but SSH is blocked"
                          ib_root_counter=$(expr $ib_root_counter + 1)
			  continue;
			fi   

                        $SSHELL $ibswitch_user@$switchname mkdir ${IBRTEMPDIR} >/dev/null 2>&1
                        $SCOPY  $IBSWITCHSCRPT $ibswitch_user@$switchname:$IBTMPDIR >/dev/null 2>&1
                        $SCOPY  $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${IBRTEMPDIR} >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname chmod 540 $IBTMPDIR/${program_name}_ibswitch.sh >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname $IBTMPDIR/${program_name}_ibswitch.sh 2>/dev/null 
	                returncode=`echo $?`
                        $SCOPY  $ibswitch_user@$switchname:${IBRTEMPDIR}/s_*.out $switchDirShort >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname rm -f $IBTMPDIR/${program_name}_ibswitch.sh  >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname rm -f ${IBRTEMPDIR}/s_*.out ${IBRTEMPDIR}/o_*.out ${IBRTEMPDIR}/${SWITCH_TYPE_FIL_SHORT} >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname rmdir ${IBRTEMPDIR} >/dev/null 2>&1
                        if [ -e $switchDirShort ]; then format_cell_switch_files "$switchname_short" "$switchDirShort" "switch";fi
	                move_failed_to_skipped "$returncode" "$IBTMPDIR/${program_name}_ibswitch.sh execution"
                      fi
                    elif [ $noPasswordAvailable -eq 0 ]
                    then
                      if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
	                echo -e "\n${GREEN}Starting to run $ibswitch_user privileged commands in background on ${BLINK}INFINIBAND SWITCH ${switchname}. $NORM\n"
			echo -e "\nStarting to run $ibswitch_user privileged commands in background on ${BLINK}INFINIBAND SWITCH${NORM} ${switchname}.\n" >>$LOGFIL
                      else
	                echo -e "\nPreparing to run $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH${NORM} ${switchname}.\n"
                      fi
	              if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq 0 ]]
	              then
	                switch_rootpassword=${a_ib_switch_root_password[$ib_root_counter]}
	              fi
                      #$READ -p "$switchname $ibswitch_user $switch_rootpassword"  
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
                      checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "1"  
		      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
		      is_SSH_blocked "$switchname" "$ibswitch_user" "$switch_rootpassword" "SWITCH"
		      if [[ $SSH_blocked -eq 1 ]]; then
		        echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${RED} ${switchname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL 
		        add_to_skipped_nodes "${switchname}" "SSH Issue: INFINIBAND SWITCH is reachable but SSH is blocked"
                        ib_root_counter=$(expr $ib_root_counter + 1)
		        continue;
		      fi   

                      if [ $passwordCheckStatus -eq 0 ]
                      then
                        if [ -f "$IBSWITCHSCRPT" ] ; then cp -f $IBSWITCHSCRPT $OUTPUTDIR >/dev/null 2>&1; fi;

                        if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
                          start_run_on_ib_in_background
                        else
                          # gadiga - create the /tmp/.program first
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
			  fixRootPassword "$switch_rootpassword"
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }  
			   spawn $SSHELL $ibswitch_user@$switchname mkdir ${IBRTEMPDIR} >/dev/null 2>&1
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			   }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			  }
			  # Look for passwd prompt
                       	  	expect {
                       	        -nocase "*?assword:*" {
                       	             send -- "\$le_switch_rootpassword\n"
                       	        }
                       	        -nocase eof {
                       	             exit
                       	        }
                       	        -nocase timeout {
		       	     	send_error "Timed out while creating on $switchname\n";
                       	            exit
                       	        }
                       	     }
		       	  # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while creating on $switchname\n";
                       		        exit
                       		    }
                           }
IBEOF
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }   
			   spawn $SCOPY $IBSWITCHSCRPT $ibswitch_user@$switchname:$IBTMPDIR
			    match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			      # Look for passwd prompt
                       	      	expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying $IBSWITCHSCRPT on $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	      # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying $IBSWITCHSCRPT on $switchname\n";
                       		        exit
                       		    }
                       	      }
IBEOF
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }   
			   spawn $SCOPY $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${IBRTEMPDIR}
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
			      exit 4;
			   }
			   -nocase "no)?" {
				 send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
  		            }
			    # Look for passwd prompt
                       	    	expect {
                       	          -nocase "*?assword:*" {
                       	               send -- "\$le_switch_rootpassword\n"
                       	          }
                       	          -nocase eof {
                       	               exit
                       	          }
                       	          -nocase timeout {
		       	       	send_error "Timed out while copying $SWITCH_TYPE_FIL on $switchname\n";
                       	              exit
                       	          }
                       	       }
		       	    # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying $SWITCH_TYPE_FIL on $switchname\n";
                       		        exit
                       		    }
                       	    }
IBEOF

			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }  
			   spawn $SSHELL $ibswitch_user@$switchname chmod 540 $IBTMPDIR/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    # Look for passwd prompt
                       	    expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while changing permissions on $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	    # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while changing permissions on $switchname\n";
                       		        exit
                       		    }
                       		 }
IBEOF
			  $EXPECT -f - 2>>$WATCHLOG << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   #log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           } 
			   spawn -noecho $SSHELL_EL $ibswitch_user@$switchname $IBTMPDIR/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    set timeout $watchdog_wakeup
			    # Look for passwd prompt
                       	      	expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while running $IBTMPDIR/${program_name}_ibswitch.sh on $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	         # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while running $IBTMPDIR/${program_name}_ibswitch.sh on $switchname\n";
                       		        exit
                       		    }
                       	    }
IBEOF
			  #only for execution
			  returncode=`echo $?`
			  move_failed_to_skipped "$returncode" "$IBTMPDIR/${program_name}_ibswitch.sh execution"
			  
			  $EXPECT -f - << IBEOF
			   #set timeout 5
                           set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
			   spawn $SCOPY $ibswitch_user@$switchname:${IBRTEMPDIR}/s_*.out $switchDirShort
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			     exit 4;
			   }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    # look for passwd prompt
                       	    expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while copying ${IBRTEMPDIR}/s_*.out files from $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	     # stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while copying ${IBRTEMPDIR}/s_*.out files from $switchname\n";
                       		        exit
                       		    }
                       	      }
IBEOF
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
			   spawn $SSHELL $ibswitch_user@$switchname rm -f $IBTMPDIR/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    # look for passwd prompt
                       	    expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while removing $IBTMPDIR/${program_name}_ibswitch.sh from $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	    # stop the on logon tests and if asked to connect to master switch choose no
                       	    expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while removing $IBTMPDIR/${program_name}_ibswitch.sh from $switchname\n";
                       		        exit
                       		    }
                       		 }
IBEOF
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           } 
			   spawn $SSHELL $ibswitch_user@$switchname rm -f ${IBRTEMPDIR}/s_*.out ${IBRTEMPDIR}/o_*.out ${IBRTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
  		            # look for passwd prompt
                            expect {
                              -nocase "*?assword:*" {
                                   send -- "\$le_switch_rootpassword\n"
                              }
                              -nocase eof {
                                   exit
                              }
                              -nocase timeout {
		          	send_error "Timed out while removing files from $switchname\n";
                                  exit
                              }
                           }
		           # stop the on logon tests and if asked to connect to master switch choose no
                           expect {
                              -nocase eof {
                                   exit
                              }
                              -nocase timeout {
		          	send_error "Timed out while removing files from $switchname\n";
                                  exit
                              }
                           }
IBEOF
                  	  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   spawn $SSHELL $ibswitch_user@$switchname rmdir ${IBRTEMPDIR}
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    # look for passwd prompt
                       	    expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while removing ${IBRTEMPDIR} from $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	     # stop the on logon tests and if asked to connect to master switch choose no
                       	      expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while removing ${IBRTEMPDIR} from $switchname\n";
                       		        exit
                       		    }
                       	      }
IBEOF
			  if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
                          if [ -e $switchDirShort ]; then format_cell_switch_files "$switchname_short" "$switchDirShort" "switch";fi
                        fi # endif RAT_RUNMODE
                      else
                        echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
                        add_to_skipped_nodes "$switchname" "The $ibswitch_user password validation failed on InfiniBand Switch"
                      fi  
                    else
		      echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n"|tee -a $LOGFIL
		      add_to_skipped_nodes "${switchname}" "The $ibswitch_user password validation failed InfiniBand Switch."
                    fi
  		    if [[ -e $OUTPUTDIR/s_root_collect_timing.out && -e $COLLECT_TIMING ]]
  		    then
  		      cat $OUTPUTDIR/s_root_collect_timing.out >> $COLLECT_TIMING
  		      collect_duration "$OUTPUTDIR/s_root_collect_timing.out" "$COLLECT_TIMING"
  		      rm -f $OUTPUTDIR/s_root_collect_timing.out  >/dev/null 2>&1
  		    elif [[ -e $switchDirShort/s_root_collect_timing.out && -e $COLLECT_TIMING ]]
  		    then
  		      cat $switchDirShort/s_root_collect_timing.out >> $COLLECT_TIMING
  		      collect_duration "$switchDirShort/s_root_collect_timing.out" "$COLLECT_TIMING"
  		      rm -f $switchDirShort/s_root_collect_timing.out  >/dev/null 2>&1
  		    fi
                    ib_root_counter=$(expr $ib_root_counter + 1)
                  done

                  if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ; then
                    wait_for_ib_completion
                  fi
                  #This is to copy new switch names file after converting ip addresses to fully qualified domain name
                  if [ -e $INPUTDIR/o_ibswitches.out ]; then mv -f $INPUTDIR/o_ibswitches.out  ${RTEMPDIR}/o_ibswitches.out;fi  
                  #$READ -p "stop after mvoing file"
                fi
                #function to map ip address to switch name and find switch type for each(leaf or spine)
                #switch_ip_type_name_mapping 
              fi #Finished here with executing command with root for each infiniband switch 

	      if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]; then
	        if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "parallel" ]] ; then
	          wait_for_system_completion;
  		  copy_cellfiles_to_remotenodes;
	        fi
	      fi

	      if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "parallel" ]] ; 
	      then
	        if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "serial" ]];
	        then
	        	print_ib=0;
	        fi 
	        if [[ "$last_ib_name" != "" ]];
	        then
	          if [[ "$print_ib" = "1" ]];
	          then	
	            if [[ -n "$cell_type" && $cell_type  != "zfscell" ]] || [[ -z $cell_type ]] ; then
	              if [ -f ${RTEMPDIR}/${switchname}.out ]; then
	                echo -e "\n"
	                echo "Collections from INFINIBAND SWITCH:";
	                echo "------------------------------------";
	                cat ${RTEMPDIR}/${switchname}.out			
	                print_ib=0;
	              fi
	            fi
	          fi
	        fi
	      fi

    	      if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
	        printf "."
                if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 ]] && [ $components != "OVM" ]; then
                  if [ $SILENT -eq 0 ]
                  then
                    echo -e "\n\nData collections completed. Checking best practices on ${i}."
                    echo -e "--------------------------------------------------------------------------------------\n\n" 
                  fi
                  if [ -e "$ROOT_LCKFIL" ] ; then rm -f "$ROOT_LCKFIL" >/dev/null 2>&1; fi
		fi
	      else
                if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 ]] && [ $components != "OVM" ] 
                then 
                  if [ $SILENT -eq 0 ]
                  then
                    #commented following if because exalogic also has collections and want to print this on exalogic too 
                    #if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 0 || $i = $localnode ]]
                    #then 
                    echo -e "\n\nData collections completed. Checking best practices on ${i}."
                    echo -e "--------------------------------------------------------------------------------------\n\n" 
                    #fi  
                  else
                    echo -e "\n\nNow collecting Oracle Patch inventory.Please standby."
                  fi
                  if [ -e "$ROOT_LCKFIL" ] ; then rm -f "$ROOT_LCKFIL" >/dev/null 2>&1; fi

  	          dirlist=$(echo "$USR_DIRS"|sed "s/^\s*//g"|sed "s/\s*$//g")
  	          for utildir in `echo "$dirlist"`
  	          do
  	            oldTMP_OUTPUT=$TMP_OUTPUT
  	            TMP_OUTPUT=$utildir
	            cp -rf $RTEMPDIR/.CELLDIR $TMP_OUTPUT >/dev/null 2>&1 
	            cp -f $RTEMPDIR/cells.out $TMP_OUTPUT >/dev/null 2>&1
	            cp -f $RTEMPDIR/switch_ip_type_name_mapping_detail.out $TMP_OUTPUT >/dev/null 2>&1
	            #cp -f $TMPDIR/CellFlashCacheMode.out $TMP_OUTPUT >/dev/null 2>&1
	            cp -f $RTEMPDIR/CellFlashCacheMode.out $TMP_OUTPUT >/dev/null 2>&1
  	            TMP_OUTPUT=$oldTMP_OUTPUT
  	            unset oldTMP_OUTPUT
  	          done
                fi
                if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" ]] ; then
                  if [[ $RAT_RUNMODE_INTERNAL = "slave" &&  $is_exalogic_machine -eq "0" && $is_exalogic_foxtrot -eq 0 && $is_bda_domu -eq 0 ]] ; then # wait for $RTEMPDIR/master.collections.done
                    #echo "waiting for master collections. ";
                    mc_done=0
                    while [[ $mc_done -eq "0" ]] ; do
                      if [[ -e "$RTEMPDIR/master.collections.done" ]] ; then mc_done=1; fi;
                      if [[ $mc_done -eq "0" ]] ; then
                        #printf ". "
                        sleep 2
                      fi
                    done
                    echo
                  fi
                fi
                #To copy cell flash cache mode file to each node to execute BP9 or greater in Grid Infrastructure home for Write Back Flash Cache on remote node 
                if [[ -e $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out && $i = $localnode ]]
                then
                  for rnode in `if [ -e $HOSTLIST.org ]; then cat $HOSTLIST.org;else cat $HOSTLIST;fi`;
	          do 
      	            node_ssh_user="$usern"
      	            if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      	              if [[ `echo "$ea_dom0_nodes" | grep -ic "$rnode"` -le 0 ]]; then
      	                node_ssh_user="${root_user}"
      	              else
      	                node_ssh_user="${foxtrot_dom0_user}"
      	              fi
      	              if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$rnode "echo \"\$HOME\""); fi
      	              l_RTEMPDIR=${l_TMPDIR}/.${program_name}
      	            else
      	              l_TMPDIR=$TMPDIR
      	              l_RTEMPDIR=$RTEMPDIR
      	            fi		   

	            #if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 && `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
	              if [[ "$rnode" = $localnode ]]; then
	                cp -f $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out $TMP_OUTPUT/CellFlashCacheMode.out > /dev/null 2>&1;
	              else
	                $SCOPY $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out $node_ssh_user@$rnode:$TMP_OUTPUT/CellFlashCacheMode.out > /dev/null 2>&1;
	              fi
	            fi	  
	            if [[ "$rnode" = $localnode ]]; then
	              #cp -f $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out $l_TMPDIR/CellFlashCacheMode.out > /dev/null 2>&1;
	              cp -f $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out $l_RTEMPDIR/CellFlashCacheMode.out > /dev/null 2>&1;
	            else
	              #$SCOPY $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out $node_ssh_user@$rnode:$l_TMPDIR/CellFlashCacheMode.out > /dev/null 2>&1;
	              $SCOPY $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out $node_ssh_user@$rnode:$l_RTEMPDIR/CellFlashCacheMode.out > /dev/null 2>&1;
	            fi
	            echo "rnode=$rnode" >>$LOGFIL;
	          done
                fi  
	      fi
              #mixed_hardware=0 
              #if [[ $(ls -l $CELLDIR 2>/dev/null|wc -l) -gt 10 && "$i" = "$localnode" ]];then  mixed_hardware_cells_discovery;fi
              #if [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 ]]; then cp -rf $OUTPUTDIR/*vm_cfg_guid* $RTEMPDIR >/dev/null 2>&1; cp -rf $OUTPUTDIR/*showvnics_guid* $RTEMPDIR >/dev/null 2>&1;fi
  	      ;;
            SQL|SQL_PARAM|SQL_COLLECT|SQL_OUT_CHECK|OS_PARAM|OS_PACKAGE|OS_PATCH|CLUSTERWIDE_CHECK|SYSTEMWIDE_CHECK|ORACLE_PATCH|CROSS_NODE_CHECK)
              case $COMTYPE in
                SQL)
           	  #if [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
                  #if  [[ -n "$it_is_rac" && $it_is_rac -eq 0 &&  $component_match_count  -lt 1 ]]
                  if  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
		  elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1  ]]
                  then
                  call_get_log_result=0
                  #echo "Skipping $audit_check_name (CHECK ID $CHECK_ID)  on $i because its excluded">>$EXCLUDELOG
                  generate_exceptions_xml "Skipping $audit_check_name because its excluded"
		  generate_exceptions_json "Skipping $audit_check_name because its excluded"
                
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"
		    generate_exceptions_json "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"

	          elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
                  then
                    call_get_log_result=0
                    echo "Not running $audit_check_name($CHECK_ID) because no profile is in use">>$LOGFIL
                  else   
                    call_get_log_result=1
		    schema_null=0
                    mb_db_counter=0
                    mb_db_counter_log=0
	            if [[ -n "${stack_dbinst_up[$stack_counter]}" &&  ${stack_dbinst_up[$stack_counter]} -ne 0 ]]
	            then
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	                if [ $op_mode -eq 0 ]
	                then
	                  COM=`grep "_"$ROW"-SQL_COMMAND" $REFFIL |sed  -n 's/.*SQL_COMMAND //p'`
	                  COM_REPORT=`grep "_"$ROW"-SQL_COMMAND_REPORT" $REFFIL |sed  -n 's/.*SQL_COMMAND_REPORT //p'`
	                  audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
	                else
                          com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
	                  com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
	                  COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	                  com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
	                  com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
	                  COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	                  #COM=`grep "_"$CHECK_ID"-SQL_COMMAND" $REFFIL |sed  -n 's/.*SQL_COMMAND //p'`
	                  #COM_REPORT=`grep "_"$CHECK_ID"-SQL_COMMAND_REPORT" $REFFIL |sed  -n 's/.*SQL_COMMAND_REPORT //p'`
	                  audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
	                fi
		      fi
	              audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
	              #in this case $SPOOLFILE already exists so we can lookup the value
	              #we're looking for now
	              #VAL=`grep $PARAM_PATH $SPOOLFIL |awk {'print $3'}`
                      ORIG_PMSG=$PMSG
                      ORIG_FMSG=$FMSG

                      #Meta File for DB parallelization
 	              if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	              then 
			t_PSQL_STAT="${PSQL_STAT}_${CHECK_ID}"
                        t_PSQL_METAFIL="${PSQL_METAFIL}_${CHECK_ID}"
	                t_PSQL_INFIL="${PSQL_INFIL}_${CHECK_ID}"

                        echo "CHECKID=$CHECK_ID"                             	 >  $t_PSQL_METAFIL 
                        echo "COMTYPE=$COMTYPE"                              	 >> $t_PSQL_METAFIL  
                        echo "COM_START=$COM"                                  	 >> $t_PSQL_METAFIL 
		        echo "COM_END"						 >> $t_PSQL_METAFIL
                        echo "COM_REPORT_START=$COM_REPORT"                    	 >> $t_PSQL_METAFIL 
                        echo "COM_REPORT_END"    	                   	 >> $t_PSQL_METAFIL 
                        echo "AUDIT_CHECK_NAME=$audit_check_name"            	 >> $t_PSQL_METAFIL 
                        echo "RAT_RUNMODE_INTERNAL=$RAT_RUNMODE_INTERNAL"    	 >> $t_PSQL_METAFIL 
	
	                #DB information for DB parallelization
	                t_mb_db_counter=0
	                for db_name_to_check in "${mb_db_names[@]}"
	                do
	                  match_database_role "${mb_database_role[$t_mb_db_counter]}"
	                  match_database_type "${mb_database_type[$t_mb_db_counter]}"
			  if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 ]]; then
    			    if [[ ! -n ${mb_oracle_sids[$mb_db_counter]} || ${mb_oracle_sids[$mb_db_counter]} = "" ]]; then
    			      mb_oracle_sids[$mb_db_counter]=$(grep "${mb_running_host[$t_mb_db_counter]}.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}')
    			    fi
			  fi
#			  RAT_DB_APP_USER=$(grep -w "${db_name_to_check}.DATABASE_APP_USER" $MASTERFIL|awk '{print $3}')
	                  echo "${db_name_to_check},${mb_oracle_sids[$t_mb_db_counter]},${mb_oracle_homes[$t_mb_db_counter]},${mb_database_role[$t_mb_db_counter]},$dbrole_match_count,${mb_database_type[$t_mb_db_counter]},$dbtype_match_count,${mb_sysdba_user[$t_mb_db_counter]},${mb_sysdba_pswd[$t_mb_db_counter]},${RAT_PDB_USER},${mb_db_sys_password[$t_mb_db_counter]},${mb_db_connect_string[$t_mb_db_counter]},${mb_checksysdba[$t_mb_db_counter]},${mb_running_host[$t_mb_db_counter]},${mb_database_app_user[$t_mb_db_counter]}" >> $t_PSQL_INFIL
	                  t_mb_db_counter=$(expr $t_mb_db_counter + 1)
	                done
			unset db_name_to_check
	                t_mb_db_counter=0
	              fi

	              psql_counter=0
                      for db_name_to_check in "${mb_db_names[@]}"
                      do
			unset FILVAL VAL
			SKIP_CHECK=0
	                #DB parallelization
 	                if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	                then
	                  if [[ $psql_counter -eq 0 ]]
	                  then
	                    parallel_sql
	                  fi
			  #if [[ -n $PRET_STATUS && $PRET_STATUS -ne "0" ]]; then
  			  #  move_failed_to_skipped "$PRET_STATUS" "" "$i:$db_name_to_check" "1" "$FILVAL"
			  #fi
			  if [[ -n $PRET_STATUS && $PRET_STATUS -eq "0" ]]; then
			    if [[ -e "$OUTPUTDIR/d_check_${db_name_to_check}.out" ]] ; then
                              if [[ `uname -s` = "HP-UX" ]] ; then
                                PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
		                FILVAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		                FILVAL=`echo $FILVAL|sed 's/^ *\(.*\) *$/\1/'`
		              else
		                FILVAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		                FILVAL=`echo $FILVAL|sed 's/^ *\(.*\) *$/\1/'`
		              fi
                            fi
			  fi
  			  move_failed_to_skipped "$PRET_STATUS" "" "$i:$db_name_to_check" "1" "$FILVAL"
	
                          psql_counter=$(expr $psql_counter + 1)
	                fi
	               
                        skip_this_version=0
                        set_skip_this_version "-"
                        if [ $skip_this_version -eq 1 ]
                        then #dont run
                          mb_db_counter=$(expr $mb_db_counter + 1)
                          echo "Skipping check($CHECK_ID) on version 4 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                          continue
                        fi
                        match_database_role "${mb_database_role[$mb_db_counter]}"
                        match_database_type "${mb_database_type[$mb_db_counter]}"

			if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
			then
			  RAT_DB_APP_USER=${mb_database_app_user[$mb_db_counter]};
        	          if [[ -z "$RAT_DB_APP_USER" && `echo $COM |grep -ic "#APP_USER#"` -gt 0 ]]
                	  then
                            #echo "Skipping check($CHECK_ID) as schema name variable RAT_DB_APP_USER is null" >> $LOGFIL
                            schema_null=1
	                  fi
	
        	          COM=`echo "$COM" | sed "s/#APP_USER#/$RAT_DB_APP_USER/g"`;
                	  COM_REPORT=`echo "$COM_REPORT" | sed "s/#APP_USER#/$RAT_DB_APP_USER/g"`;
			fi

                        if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 && -n "$schema_null" && $schema_null -ne 1 ]]
                        #if [[ "${mb_database_role[$mb_db_counter]}" = "$check_database_role" ]]
                        then 
	                  DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
			  #remote_database_code && $i = $localnode ]]
	                  if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
	                  then
	                    export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
	                    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}

			    FULL_OUTFIL=$OUTPUTDIR/${CHECK_ID}_${db_name_to_check}_full.out
  	                    OUTFIL=$OUTPUTDIR/d_check_${db_name_to_check}.out
	                    INFIL=$INPUTDIR/${CHECK_ID}_${db_name_to_check}.sql
			    SQL_CON_SCRPT=$OUTPUTDIR/${CHECK_ID}_${db_name_to_check}_con.sql
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      NEW_FULL_OUTFIL=$TMP_OUTPUT/${CHECK_ID}_${db_name_to_check}_full.out
  	                      NEW_OUTFIL=$TMP_OUTPUT/d_check_${db_name_to_check}.out
	                      NEW_INFIL=$TMP_OUTPUT/${CHECK_ID}_${db_name_to_check}.sql
			      SQL_CON_SCRPT=$TMP_OUTPUT/${CHECK_ID}_${db_name_to_check}_con.sql
			    fi

			    security_fix "check_and_fix_script_existence" "$INFIL"

                            if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]; then echo "alter session set container=$db_name_to_check;">$INFIL;fi

	                    echo "$COM">>$INFIL

			    # if anonymous pl/sql block
			    anonymous_plsql=0
			    if [[ -n "$COM" && `echo "$COM"|grep -iwc "BEGIN"` -gt "0" ]] || [[ -n "$COM_REPORT" && `echo "$COM_REPORT"|grep -iwc "END"` -gt "0" ]]; then
			      anonymous_plsql=1
			      sql_output_splitter="DBMS_OUTPUT.PUT_LINE('_SQL_SPLITTER_');"
			    else
			      sql_output_splitter="select '_SQL_SPLITTER_' from dual;"
			    fi
	
			    if [[ -n "$COM_REPORT" ]]; then 
			      INFIL_REPORT=${INPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.sql
			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			        NEW_INFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${db_name_to_check}_report.sql
			      fi
			      security_fix "check_and_fix_script_existence" "$INFIL_REPORT"
			      echo "$COM_REPORT">>$INFIL_REPORT

			      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			        NEW_ROOT_SOURCEFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${db_name_to_check}_report.out
			      fi
		              if [ $OFFLINE -eq 0 ]
		              then
		                SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${db_name_to_check}_report.out
		              else
		                SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
		              fi
		              echo -e "TO REVIEW COLLECTED DATA FOR $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$SOURCEFIL_REPORT
			    fi

                            #if its PDB then will connect to database using user name and password
                            if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]
                            then 
                              #it will set this string but should never use because ${mb_checksysdba[$mb_db_counter]} will always be 1
                              dbConnectString="${RAT_PDB_USER}/${mb_db_sys_password[$mb_db_counter]}@"${mb_db_connect_string[$mb_db_counter]}" as sysdba"  
                            else
                              DBUSR=${mb_sysdba_user[$mb_db_counter]}
                              DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
                              dbConnectString="$DBUSR/$DBPWD as sysdba"  
                            fi
                            #$READ -p "running for $db_name_to_check" 
		            if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
		            then	
			      if [ -n "$COM_REPORT" ]; then TAG3=1; fi
		              get_current_epoch 
		              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
		            fi

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		              if [ ${mb_running_host[$mb_db_counter]} = $localnode ]; then
			        get_dbOwner
			      else
			        get_dbOwner ${mb_running_host[$mb_db_counter]}
			      fi
		    	      if [[ -z $dbOwner ]]; then mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
			      if [[ -n "$COM_REPORT" ]]; then 
			        chg_files_for_usr "NEW_INFIL,NEW_FULL_OUTFIL,NEW_OUTFIL,NEW_INFIL_REPORT,NEW_ROOT_SOURCEFIL_REPORT,SQL_CON_SCRPT" "$NEW_INFIL,$NEW_FULL_OUTFIL,$NEW_OUTFIL,$NEW_INFIL_REPORT,$NEW_ROOT_SOURCEFIL_REPORT,$SQL_CON_SCRPT"
			      else
			        chg_files_for_usr "NEW_INFIL,NEW_FULL_OUTFIL,NEW_OUTFIL,SQL_CON_SCRPT" "$NEW_INFIL,$NEW_FULL_OUTFIL,$NEW_OUTFIL,$SQL_CON_SCRPT"
			      fi 
			      security_fix "check_and_fix_script_existence" "$SQL_CON_SCRPT"
    	  	  	      security_fix "check_and_fix_script_existence" "$NEW_INFIL_REPORT"
			    fi

			    security_fix "check_and_fix_script_existence" "$NEW_INFIL"
		            if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
		            then
		              if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
		              then
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  cp -f $INFIL $NEW_INFIL
				  chown $dbOwner:$dbGroup $NEW_INFIL

			    	  if [[ -n "$COM_REPORT" ]]; then 
				    cp -f $INFIL_REPORT $NEW_INFIL_REPORT
				    chown $dbOwner:$dbGroup $NEW_INFIL_REPORT
		                  
				    echo "spool $NEW_FULL_OUTFIL append"		>  $SQL_CON_SCRPT
				    cat $NEW_INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"				>> $SQL_CON_SCRPT
				    cat $NEW_INFIL_REPORT				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"					>> $SQL_CON_SCRPT

				    chown $dbOwner:$dbGroup $SQL_CON_SCRPT
				  else
				    echo "spool $NEW_FULL_OUTFIL append"		>  $SQL_CON_SCRPT
				    cat $NEW_INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"					>> $SQL_CON_SCRPT
			          fi

		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
				  @@$SQL_CON_SCRPT
		                  exit
EOF
"
		                  returncode=`echo $?`

				  split_files "$NEW_FULL_OUTFIL" "$sql_output_splitter" "$NEW_OUTFIL $NEW_ROOT_SOURCEFIL_REPORT"

				  move_files "$NEW_OUTFIL" "$OUTFIL" append
				  if [[ -n "$COM_REPORT" ]]; then
				    move_files "$NEW_ROOT_SOURCEFIL_REPORT" "$SOURCEFIL_REPORT" "append"
				  fi

    	    		  	  write_del_rolbk_tmpoutput
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else
			    	  if [[ -n "$COM_REPORT" ]]; then 
				    echo "spool $FULL_OUTFIL append"		>  $SQL_CON_SCRPT
				    cat $INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    cat $INFIL_REPORT				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT

				    chown $dbOwner:$dbGroup $SQL_CON_SCRPT
				  else
				    echo "spool $FULLOUTFIL append"		>  $SQL_CON_SCRPT
				    cat $INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT
			          fi

		                  $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off  
		                  set serveroutput on
				  @@$SQL_CON_SCRPT
		                  exit
EOF
		                  returncode=`echo $?`
				  split_files "$FULL_OUTFIL" "$sql_output_splitter" "$OUTFIL $SOURCEFIL_REPORT"
				fi
		              else #remote_database_code
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			    	  if [[ -n "$COM_REPORT" ]]; then 
				    TMP_FULL_SPOOLFIL=$TMP_OUTPUT/sqltorun_full.out
				    TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
				    TMP_RSPOOLFIL=$TMP_OUTPUT/sqltorun_report.out
			            chg_files_for_usr "TMP_SPOOLFIL" "$TMP_SPOOLFIL"
			            chg_files_for_usr "TMP_RSPOOLFIL" "$TMP_RSPOOLFIL"
			            chg_files_for_usr "TMP_FULL_SPOOLFIL" "$TMP_FULL_SPOOLFIL"

				    cp -f $INFIL $NEW_INFIL
				    cp -f $INFIL_REPORT $NEW_INFIL_REPORT

				    echo "spool $TMP_FULLSPOOLFIL"		>  $SQL_CON_SCRPT
				    cat $NEW_INFIL				>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    cat $NEW_INFIL_REPORT			>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT

				    $SSHELL ${mb_running_host[$mb_db_counter]} "mkdir -p $TMP_OUTPUT >/dev/null 2>&1; chown $dbOwner:$dbGroup $TMP_OUTPUT >/dev/null 2>&1"
				    get_cygpath "SQL_CON_SCRPT"
				    get_cygpath "TMP_OUTPUT"
				    $SCOPY $SQL_CON_SCRPT ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun_con.sql
				    restore_cygpath "SQL_CON_SCRPT"
				    restore_cygpath "TMP_OUTPUT"

				    $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun_con.sql"
                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                    export ORACLE_HOME=$ORACLE_HOME;
                                    export ORACLE_SID=$ORACLE_SID;
				    cd "$dbhome_dir";
		                    su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                    set head off
		                    set lines 80
		                    set feedback off
                                    set timing off
		                    set serveroutput on
				    @@$TMP_OUTPUT/sqltorun_con.sql
		                    exit
EOF
"
EOF2
		                    returncode=`echo $?`
				  else
				    TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
				    TMP_FULL_SPOOLFIL=$TMP_OUTPUT/sqltorun_full.out
			            chg_files_for_usr "TMP_SPOOLFIL" "$TMP_SPOOLFIL"
			            chg_files_for_usr "TMP_FULL_SPOOLFIL" "$TMP_FULL_SPOOLFIL"

				    cp -f $INFIL $NEW_INFIL

				    echo "spool $TMP_FULL_SPOOLFIL"		>  $SQL_CON_SCRPT
				    cat $NEW_INFIL				>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT

				    $SSHELL ${mb_running_host[$mb_db_counter]} "mkdir -p $TMP_OUTPUT >/dev/null 2>&1; chown $dbOwner:$dbGroup $TMP_OUTPUT >/dev/null 2>&1"
				    get_cygpath "SQL_CON_SCRPT"
		                    get_cygpath "NEW_INFIL"
		                    $SCOPY $SQL_CON_SCRPT ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun_con.sql
				    restore_cygpath "SQL_CON_SCRPT"
		                    restore_cygpath "NEW_INFIL"

				    $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun_con.sql"
                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                    export ORACLE_HOME=$ORACLE_HOME;
                                    export ORACLE_SID=$ORACLE_SID;
				    cd "$dbhome_dir";
		                    su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                    set head off
		                    set lines 80
		                    set feedback off
                                    set timing off
		                    set serveroutput on
		                    @@$TMP_OUTPUT/sqltorun_con.sql"
		                    exit
EOF
"
EOF2
		                    returncode=`echo $?`
				  fi
          			  REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_OUTPUT/sqltorun_con.sql>/dev/null 2>&1;echo \\$?;"`
	  	  		  security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun_con.sql" "$REM_RC"

    	    		  	  write_del_rolbk_tmpoutput
				  cd $OLD_DIR
				  unset OLD_DIR
				else
			    	  if [[ -n "$COM_REPORT" ]]; then 
				    TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
				    TMP_RSPOOLFIL=$RTEMPDIR/sqltorun_report.out
				    TMP_FULL_SPOOLFIL=$RTEMPDIR/sqltorun_full.out
 
				    echo "spool $TMP_FULL_SPOOLFIL"		>  $SQL_CON_SCRPT
				    cat $INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    cat $INFIL_REPORT				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT

				    get_cygpath "SQL_CON_SCRPT"
				    get_cygpath "RTEMPDIR"
				    $SCOPY $SQL_CON_SCRPT ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun_con.sql
				    restore_cygpath "SQL_CON_SCRPT"
				    restore_cygpath "RTEMPDIR"

                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                    export ORACLE_HOME=$ORACLE_HOME;
                                    export ORACLE_SID=$ORACLE_SID;
		                    $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                    set head off
		                    set lines 80
		                    set feedback off
                                    set timing off
		                    set serveroutput on
		                    @@$RTEMPDIR/sqltorun_con.sql
		                    exit
EOF
EOF2
		                    returncode=`echo $?`
				  else
				    TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
				    TMP_FULL_SPOOLFIL=$RTEMPDIR/sqltorun_full.out

				    echo "spool $TMP_FULLSPOOLFIL"		>  $SQL_CON_SCRPT
				    cat $INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT

				    get_cygpath "SQL_CON_SCRPT"
		                    get_cygpath "INFIL"
		                    $SCOPY $SQL_CON_SCRPT ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun_con.sql
				    restore_cygpath "SQL_CON_SCRPT"
		                    restore_cygpath "INFIL"

                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                    export ORACLE_HOME=$ORACLE_HOME;
                                    export ORACLE_SID=$ORACLE_SID;
		                    $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                    set head off
		                    set lines 80
		                    set feedback off
                                    set timing off
		                    set serveroutput on
		                    @@$RTEMPDIR/sqltorun_con.sql
		                    exit
EOF
EOF2
		                    returncode=`echo $?`
				  fi
          			  REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $RTEMPDIR/sqltorun_con.sql>/dev/null 2>&1;echo \\$?;"`
	  	  		  security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun_con.sql" "$REM_RC"
				fi
			
				get_cygpath "TMP_FULL_SPOOLFIL"
		                get_cygpath "RTEMPDIR"
		                $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_FULL_SPOOLFIL $RTEMPDIR
				restore_cygpath "TMP_FULL_SPOOLFIL"
		                restore_cygpath "RTEMPDIR"

			 	split_files "$RTEMPDIR/sqltorun_full.out" "$sql_output_splitter" "$RTEMPDIR/sqltorun.out $RTEMPDIR/sqltorun_report.out"	

			    	if [[ -n "$COM_REPORT" ]]; then 
				  cat $RTEMPDIR/sqltorun_report.out >> $SOURCEFIL_REPORT	 
				fi
                                cat $RTEMPDIR/sqltorun.out >> $OUTFIL
		              fi
			      rm -f $RTEMPDIR/sqltorun_report.out >/dev/null 2>&1;
			      rm -f $RTEMPDIR/sqltorun.out >/dev/null 2>&1;

			      if [[ -e "$OUTPUTDIR/d_check_${db_name_to_check}.out" ]] ; then
                                if [[ `uname -s` = "HP-UX" ]] ; then
                                  PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
		                  FILVAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		                  FILVAL=`echo $FILVAL|sed 's/^ *\(.*\) *$/\1/'`
		                else
		                  FILVAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		                  FILVAL=`echo $FILVAL|sed 's/^ *\(.*\) *$/\1/'`
		                fi
                              fi
		              move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "1" "$FILVAL"
		            else
		              if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
		              then
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  if [[ -n "$COM_REPORT" ]]; then
				    cp -f $INFIL_REPORT $NEW_INFIL_REPORT
				    chown $dbOwner:$dbGroup $NEW_INFIL_REPORT
				  fi
				  cp -f $INFIL $NEW_INFIL
				  chown $dbOwner:$dbGroup $NEW_INFIL

				  if [[ -n "$COM_REPORT" ]]; then
				    echo "spool $NEW_FULL_OUTFIL append"		>  $SQL_CON_SCRPT
				    cat $NEW_INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"				>> $SQL_CON_SCRPT
				    cat $NEW_INFIL_REPORT				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"					>> $SQL_CON_SCRPT

				    chown $dbOwner:$dbGroup $SQL_CON_SCRPT
				  else
				    echo "spool $NEW_FULL_OUTFIL append"		>  $SQL_CON_SCRPT
				    cat $NEW_INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"					>> $SQL_CON_SCRPT
				  fi

		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
				  @@$SQL_CON_SCRPT
		                  exit
EOF
"
		                  returncode=`echo $?`

				  split_files "$NEW_FULL_OUTFIL" "$sql_output_splitter" "$NEW_OUTFIL $NEW_ROOT_SOURCEFIL_REPORT"

				  move_files "$NEW_OUTFIL" "$OUTFIL" append
				  if [[ -n "$COM_REPORT" ]]; then
				    move_files "$NEW_ROOT_SOURCEFIL_REPORT" "$SOURCEFIL_REPORT" "append"
				  fi

    	    		  	  write_del_rolbk_tmpoutput
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else
		                  #$READ -p "before asm collection"
				  if [[ -n "$COM_REPORT" ]]; then 
				    echo "spool $FULL_OUTFIL append"		>  $SQL_CON_SCRPT
				    cat $INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    cat $INFIL_REPORT				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT

				    chown $dbOwner:$dbGroup $SQL_CON_SCRPT
			 	  else
				    echo "spool $FULL_OUTFIL append"		>  $SQL_CON_SCRPT
				    cat $INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT
				  fi

		                  $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
				  @@$SQL_CON_SCRPT
		                  exit
EOF
		                  returncode=`echo $?`
				  split_files "$FULL_OUTFIL" "$sql_output_splitter" "$OUTFIL $SOURCEFIL_REPORT"
				fi
		              else #remote_database_code
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			    	  if [[ -n "$COM_REPORT" ]]; then 
				    TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
				    TMP_RSPOOLFIL=$RTEMPDIR/sqltorun_report.out
				    TMP_CSQLTORUN=$TMP_OUTPUT/sqltorun_con.sql
				    TMP_FULL_SPOOLFIL=$TMP_OUTPUT/sqltorun_full.out

				    cp -f $INFIL $NEW_INFIL
				    cp -f $INFIL_REPORT $NEW_INFIL_REPORT

			            chg_files_for_usr "TMP_SPOOLFIL,TMP_RSPOOLFIL,TMP_FULL_SPOOLFIL,TMP_CSQLTORUN" "$TMP_SPOOLFIL,$TMP_RSPOOLFIL,$TMP_FULL_SPOOLFIL,$TMP_CSQLTORUN"

				    echo "spool $TMP_FULL_SPOOLFIL"			>  $SQL_CON_SCRPT
				    cat $NEW_INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"				>> $SQL_CON_SCRPT
				    cat $NEW_INFIL_REPORT				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"					>> $SQL_CON_SCRPT

				    $SSHELL ${mb_running_host[$mb_db_counter]} "mkdir -p $TMP_OUTPUT/$dbOwner >/dev/null 2>&1; chown $dbOwner:$dbGroup $TMP_OUTPUT/$dbOwner >/dev/null 2>&1"
				    get_cygpath "SQL_CON_SCRPT"
				    get_cygpath "TMP_OUTPUT"
		                    $SCOPY $SQL_CON_SCRPT ${mb_running_host[$mb_db_counter]}:$TMP_CSQLTORUN
				    restore_cygpath "SQL_CON_SCRPT"
				    restore_cygpath "TMP_OUTPUT"

                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                    export ORACLE_HOME=$ORACLE_HOME;
                                    export ORACLE_SID=$ORACLE_SID;
				    cd "$dbhome_dir";
		                    su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                    set head off
		                    set lines 80
		                    set feedback off
                                    set timing off
		                    set serveroutput on
				    @@$TMP_CSQLTORUN
		                    exit
EOF
"
EOF2
		                    returncode=`echo $?`

				  else
				    TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
				    TMP_CSQLTORUN=$TMP_OUTPUT/sqltorun_con.sql
				    TMP_FULL_SPOOLFIL=$TMP_OUTPUT/sqltorun_full.out

				    cp -f $INFIL $NEW_INFIL

			            chg_files_for_usr "TMP_CSQLTORUN,TMP_SPOOLFIL,TMP_FULL_SPOOLFIL" "$TMP_CSQLTORUN,$TMP_SPOOLFIL,$TMP_FULL_SPOOLFIL"

				    echo "spool $TMP_FULL_SPOOLFIL"			>  $SQL_CON_SCRPT
				    cat $NEW_INFIL					>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"				>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"					>> $SQL_CON_SCRPT

				    $SSHELL ${mb_running_host[$mb_db_counter]} "mkdir -p $TMP_OUTPUT/$dbOwner >/dev/null 2>&1; chown $dbOwner:$dbGroup $TMP_OUTPUT/$dbOwner >/dev/null 2>&1"
				    get_cygpath "NEW_INFIL"
		                    $SCOPY $SQL_CON_SCRPT ${mb_running_host[$mb_db_counter]}:$TMP_CSQLTORUN
				    restore_cygpath "NEW_INFIL"

				    $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_CSQLTORUN"
                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                    export ORACLE_HOME=$ORACLE_HOME;
                                    export ORACLE_SID=$ORACLE_SID;
				    cd "$dbhome_dir";
		                    su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                    set head off
		                    set lines 80
		                    set feedback off
                                    set timing off
		                    set serveroutput on
		                    @@$TMP_CSQLTORUN
		                    exit
EOF
"
EOF2
		                    returncode=`echo $?`
				  fi
          			  REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $TMP_CSQLTORUN>/dev/null 2>&1;echo \\$?;"`
	  	  		  security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$TMP_CSQLTORUN" "$REM_RC"

    	    		  	  write_del_rolbk_tmpoutput
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else 
			    	  if [[ -n "$COM_REPORT" ]]; then 
				    TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
				    TMP_RSPOOLFIL=$RTEMPDIR/sqltorun_report.out
				    TMP_FULL_SPOOLFIL=$RTEMPDIR/sqltorun_full.out

				    echo "spool $TMP_FULL_SPOOLFIL"		>  $SQL_CON_SCRPT
				    cat $RTEMPDIR/sqltorun.sql			>> $SQL_CON_SCRPT
				    echo "$sql_output_splitter"			>> $SQL_CON_SCRPT
				    cat $RTEMPDIR/sqltorun_report.sql 		>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT

				    get_cygpath "SQL_CON_SCRPT"
				    get_cygpath "RTEMPDIR"
		                    $SCOPY $SQL_CON_SCRPT ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun_con.sql
				    restore_cygpath "SQL_CON_SCRPT"
				    restore_cygpath "RTEMPDIR"

                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                    export ORACLE_HOME=$ORACLE_HOME;
                                    export ORACLE_SID=$ORACLE_SID;
		                    $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                    set head off
		                    set lines 80
		                    set feedback off
                                    set timing off
		                    set serveroutput on
		                    @@$RTEMPDIR/sqltorun_con.sql
		                    exit
EOF
EOF2
		                    returncode=`echo $?`

				  else
				    TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
				    TMP_FULL_SPOOLFIL=$RTEMPDIR/sqltorun_full.out

				    echo "spool $TMP_FULL_SPOOLFIL"		>  $SQL_CON_SCRPT
				    cat $RTEMPDIR/sqltorun.sql			>> $SQL_CON_SCRPT
				    if [[ -n "$anonymous_plsql" && $anonymous_plsql -eq "1" ]]; then echo "/" >> $SQL_CON_SCRPT; fi
				    echo "spool off"				>> $SQL_CON_SCRPT

				    get_cygpath "INFIL"
		                    $SCOPY $SQL_CON_SCRPT ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun_con.sql
                                    restore_cygpath "INFIL"

                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                    export ORACLE_HOME=$ORACLE_HOME;
                                    export ORACLE_SID=$ORACLE_SID;
		                    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                    set head off
		                    set lines 80
		                    set feedback off
                                    set timing off
		                    set serveroutput on
		                    @@$RTEMPDIR/sqltorun_con.sql
		                    exit
EOF
EOF2
		                    returncode=`echo $?`
				  fi
          			  REM_RC=`$SSHELL ${mb_running_host[$mb_db_counter]} "rm -f $RTEMPDIR/sqltorun_con.sql>/dev/null 2>&1;echo \\$?;"`
	  	  		  security_fix "verify_remcode" "${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun_con.sql" "$REM_RC"
				fi

				get_cygpath "TMP_FULL_SPOOLFIL"
				get_cygpath "RTEMPDIR"
		                $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_FULL_SPOOLFIL $RTEMPDIR
				restore_cygpath "TMP_FULL_SPOOLFIL"
				restore_cygpath "RTEMPDIR"

			 	split_files "$RTEMPDIR/sqltorun_full.out" "$sql_output_splitter" "$RTEMPDIR/sqltorun.out $RTEMPDIR/sqltorun_report.out"	

			    	if [[ -n "$COM_REPORT" ]]; then 
				  cat $RTEMPDIR/sqltorun_report.out >> $SOURCEFIL_REPORT	 
				fi
                                cat $RTEMPDIR/sqltorun.out >> $OUTFIL
		              fi
			      rm -f $RTEMPDIR/sqltorun_report.out >/dev/null 2>&1;
			      rm -f $RTEMPDIR/sqltorun.out >/dev/null 2>&1;

			      if [[ -e "$OUTPUTDIR/d_check_${db_name_to_check}.out" ]] ; then
                                if [[ `uname -s` = "HP-UX" ]] ; then
                                  PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
		                  FILVAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		                  FILVAL=`echo $FILVAL|sed 's/^ *\(.*\) *$/\1/'`
		                else
		                  FILVAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		                  FILVAL=`echo $FILVAL|sed 's/^ *\(.*\) *$/\1/'`
		                fi
                              fi
		              move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "1" "$FILVAL"
		            fi
    	  	 	    security_fix "check_and_fix_script_existence" "$NEW_INFIL"

		     	    if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
		            then	
		              get_current_epoch 
	           	      echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS
			    fi
		          else
			   if [[ -e "$OUTPUTDIR/d_check_${db_name_to_check}.out" ]] ; then
                            if [[ `uname -s` = "HP-UX" ]] ; then
                              PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
		              VAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		              VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
		            else
		              VAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		              VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
		            fi
                           fi
		          fi 

		          SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
		          if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]; then
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    			      if [[ `echo "$TMP_OUTPUT"|grep -cw "USR_HOMEDIR"` -eq "0" ]]; then
    			        mv -f $TMP_OUTPUT/*_con.sql $OUTPUTDIR >/dev/null 2>&1
    			      else
    			        dirlist=$(echo "$USR_DIRS"|sed "s/^\s*//g"|sed "s/\s*$//g")
    			        for utildir in `echo "$dirlist"`
    			        do
			          find $utildir -name '*_con.sql' -type f -exec mv -f {} $OUTPUTDIR  \; >/dev/null 2>&1
    			        done
    			      fi
			    else
			       mv -f $INPUTDIR/*_con.sql $OUTPUTDIR >/dev/null 2>&1
			    fi
			  else
			    mv -f $SQL_CON_SCRPT $OUTPUTDIR >/dev/null 2>&1
			  fi

			  #SKIP_CHECK=0
		          if [[ -e "$OUTPUTDIR/d_check_${db_name_to_check}.out" ]] ; then
                            if [[ `uname -s` = "HP-UX" ]] ; then
                              PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
		              VAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|grep -v "^select"|cut -d= -f2`
		              VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
			      if [[ `grep -wic $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|grep -v "^select"|cut -d= -f2` -gt 1 ]]; then SKIP_CHECK=1; fi
		            else
		              VAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|grep -v "^select"|cut -d= -f2`
		              VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
			      if [[ `grep -wic $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|grep -v "^select"|cut -d= -f2` -gt 1 ]]; then SKIP_CHECK=1; fi
		            fi
			  fi
			  if [[ -n "$rskip_os_sql" && $rskip_os_sql == 1 ]]; then
			    rskip_os_sql=0
			    mb_db_counter=$(expr $mb_db_counter + 1)
			    continue
			  else
			    if [[ -n $SKIP_CHECK && $SKIP_CHECK -eq 0 ]]; then
		              call_get_log_result=0
		              PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
		              FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
		              get_log_result "inloop" "-"
		              mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                              #$READ -p "stop for pass/fail $db_name_to_check"
			    fi
			  fi
                        else
                          call_get_log_result=0    
			  if [[ -n "$schema_null" && $schema_null -eq 1 ]]; then 
	                    echo "Skipping check($CHECK_ID) for $db_name_to_check because schema name variable RAT_DB_APP_USER is null" >> $LOGFIL
			  else
			    echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
			  fi	
                        fi
                        mb_db_counter=$(expr $mb_db_counter + 1)
                      done

 		      if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	              then
    		        if [[ -z $RAT_PDEBUG ]]; then 
		          rm -f "$t_PSQL_METAFIL" >/dev/null 2>&1
		          rm -f "$t_PSQL_INFIL" >/dev/null 2>&1
		          rm -f "$t_PSQL_STAT" >/dev/null 2>&1
			fi
	              fi

		      unset db_name_to_check
		      mb_db_counter=0
                      write_report_on_fail=1
                    else
                      call_get_log_result=0
                      echo -e "\n\nskipping $COM at $ROW ($audit_check_name) because either no database was running or user selected None from database select list\n\n">>$LOGFIL
	            fi
                  fi
           	  #$READ -p "COM=$COM param path=$PARAM_PATH at $ROW recommended value=$COMP operator=$OP alert level=$ALVL actual value=$VAL" 
           	  ;;
                SQL_COLLECT)
                  #echo "${stack_asm_up[$stack_counter]}  ${stack_dbinst_up[$stack_counter]} ${stack_db_status[$stack_counter]}"
                  mb_db_counter=0
                  if [ $OFFLINE -eq "0" ] &&  [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ] 
                  then
                    call_get_log_result=1
		    schema_null=0
		    if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                      if [ $op_mode -eq 0 ]
                      then
                        COM=`grep "_"$ROW"-SQL_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*SQL_COLLECT_COMMAND //p'`
                        COLLECTION_NAME=`grep "_"$ROW"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                      else
                        com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                        com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                        COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                        com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                        COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        COLLECTION_NAME=`grep "_"$CHECK_ID"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                      fi
		    fi
                    #OUTFILNAME is the name we set up in the app as the file name we want
                    #the data redirected to when doing OS and SQL COLLECTs
                    #we'll search this file for OS and SQL param values
                    #so SQL and OS COLLECT creates OUTFIL in the OUTPUTDIR
                    #SQL and OS PARAM reads the values of the parameters from OUTFIL
                    #OUTFIL will also be archived at the end
                    #FIELDPOS is the position we define in the app to tell the script
                    #which field to look in for the value as the position might vary from
                    #command to command or OS to OS

		    if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                      if [ $op_mode -eq 0 ]
	              then
	                OUTFILNAM=`grep _$ROW\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
	              else
	                OUTFILNAM=`grep _$CHECK_ID\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
	              fi
		    fi

                    #Meta File for DB parallelization
	            if [[ $OFFLINE -eq "0" ]] && [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
	            then 
		      t_PSQL_STAT="${PSQL_STAT}_${CHECK_ID}"
                      t_PSQL_METAFIL="${PSQL_METAFIL}_${CHECK_ID}"
	              t_PSQL_INFIL="${PSQL_INFIL}_${CHECK_ID}"

                      echo "CHECKID=$CHECK_ID"                             	    >  $t_PSQL_METAFIL 
                      echo "COMTYPE=$COMTYPE"                              	    >> $t_PSQL_METAFIL  
                      echo "COM_START=$COM"                                         >> $t_PSQL_METAFIL
                      echo "COM_END"                                                >> $t_PSQL_METAFIL
                      echo "COM_REPORT_START=$COM_REPORT"                           >> $t_PSQL_METAFIL
                      echo "COM_REPORT_END"                                         >> $t_PSQL_METAFIL
                      echo "AUDIT_CHECK_NAME=$audit_check_name"            	    >> $t_PSQL_METAFIL 
	              echo "COLLECTION_NAME=$COLLECTION_NAME"                       >> $t_PSQL_METAFIL
	              echo "STACK_ASM_SID=${stack_asm_sid[$stack_counter]}"         >> $t_PSQL_METAFIL
	              echo "STACK_ASM_HOME=${stack_asm_home[$stack_counter]}"       >> $t_PSQL_METAFIL
                      echo "RAT_RUNMODE_INTERNAL=$RAT_RUNMODE_INTERNAL"    	    >> $t_PSQL_METAFIL 
	              echo "OUTFILNAM=$OUTFILNAM"                                   >> $t_PSQL_METAFIL
	
	              #DB information for DB parallelization
	              t_mb_db_counter=0
	              for db_name_to_check in "${mb_db_names[@]}"
	              do
	                match_database_role "${mb_database_role[$t_mb_db_counter]}"
	                match_database_type "${mb_database_type[$t_mb_db_counter]}"
			if [[ -n $RAT_CACHE_RUN && $RAT_CACHE_RUN -eq 1 ]]; then
    			  if [[ ! -n ${mb_oracle_sids[$mb_db_counter]} || ${mb_oracle_sids[$mb_db_counter]} = "" ]]; then
    			    mb_oracle_sids[$mb_db_counter]=$(grep "${mb_running_host[$t_mb_db_counter]}.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}')
    			  fi
			fi
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
	                echo "${db_name_to_check},${mb_oracle_sids[$t_mb_db_counter]},${mb_oracle_homes[$t_mb_db_counter]},${mb_database_role[$t_mb_db_counter]},$dbrole_match_count,${mb_database_type[$t_mb_db_counter]},$dbtype_match_count,${mb_sysdba_user[$t_mb_db_counter]},${mb_sysdba_pswd[$t_mb_db_counter]},${RAT_PDB_USER},${mb_db_sys_password[$t_mb_db_counter]},${mb_db_connect_string[$t_mb_db_counter]},${mb_checksysdba[$t_mb_db_counter]},${mb_running_host[$t_mb_db_counter]},${mb_database_app_user[$t_mb_db_counter]}" >> $t_PSQL_INFIL
			if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
	                t_mb_db_counter=$(expr $t_mb_db_counter + 1)
	              done
		      unset db_name_to_check
	              t_mb_db_counter=0
	            fi

                    if [ "$NEEDS_RUNNING" = "ASM" ]
                    then
                      OUTFIL=$OUTPUTDIR/"a_"$OUTFILNAM".out"
	              INFIL=$INPUTDIR/"d_"$OUTFILNAM"_"$DB".sql"
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			NEW_OUTFIL=$TMP_OUTPUT/"a_"$OUTFILNAM".out"
	                NEW_INFIL=$TMP_OUTPUT/"d_"$OUTFILNAM"_"$DB".sql"
		      fi
                    else
                      mb_db_counter=0
                      mb_db_counter_log=0
	              psql_counter=0
	              for db_name_to_check in "${mb_db_names[@]}"
	              do
			if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
                        then
			  RAT_DB_APP_USER=${mb_database_app_user[$mb_db_counter]};
        	          if [[ -z "$RAT_DB_APP_USER" && `echo $COM |grep -ic "#APP_USER#"` -gt 0 ]]
                	  then
                            #echo "Skipping check($CHECK_ID) as schema name variable RAT_DB_APP_USER is null" >> $LOGFIL
                            schema_null=1
	                  fi
	
        	          COM=`echo $COM | sed "s/#APP_USER#/$RAT_DB_APP_USER/g"`;
                	  COM_REPORT=`echo $COM_REPORT | sed "s/#APP_USER#/$RAT_DB_APP_USER/g"`;
			fi

	                #DB parallelization
	                if [[ $OFFLINE -eq "0" ]] && [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] && [[ $component_match_count -ge 1 ]]
	                then
	                  if [[ $psql_counter -eq 0 ]]
	                  then
	                    parallel_sql
	                  fi
                          psql_counter=$(expr $psql_counter + 1)
	                fi

	                skip_this_version=0
                        set_skip_this_version "-"
                        if [ $skip_this_version -eq 1 ]
                        then
                          mb_db_counter=$(expr $mb_db_counter + 1)
                          echo "Skipping check($CHECK_ID) on version 5 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                          continue
                        fi

	                OUTFIL=$OUTPUTDIR/"d_"$OUTFILNAM"_"$db_name_to_check".out"
	                INFIL=$INPUTDIR/"d_"$OUTFILNAM"_"$db_name_to_check".sql"
		        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			  NEW_OUTFIL=$TMP_OUTPUT/"a_"$OUTFILNAM".out"
	                  NEW_INFIL=$TMP_OUTPUT/"d_"$OUTFILNAM"_"$db_name_to_check".sql"
		        fi
                        export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
                        export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
                        match_database_role "${mb_database_role[$mb_db_counter]}"
                        match_database_type "${mb_database_type[$mb_db_counter]}"
                        if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 && -n "$schema_null" && $schema_null -ne 1 ]]
                        then
                          call_get_log_result=0
                          get_log_result "inloop" "-"
	                  mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                        else
			 if [[ -n "$schema_null" && $schema_null -eq 1 ]]
			 then	
	                   echo "Skipping check($CHECK_ID) for $db_name_to_check because schema name variable RAT_DB_APP_USER is null" >> $LOGFIL
			 else
			   echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
			 fi
                        fi
                        mb_db_counter=$(expr $mb_db_counter + 1)
	                #note that since each sql command is run only once, unlike OS commands
	                #and there's no host name to account for, we'll go ahead and append the
	                #.out extension here rather than in log_result()
	                #if [ "$NEEDS_RUNNING" = "ASM" ]
	                #then
	                #    OUTFIL=$OUTPUTDIR/"a_"$OUTFILNAM"_"$DB".out"
	                #else
	                #fi
	                #OUTFIL=$OUTPUTDIR/"d_"$OUTFILNAM".out"

	                #in the case of SQL_COLLECT we need both an OUTFIL (spool file)
	                #and an INFIL (a script file) which will be executed by SQL*Plus
	                #it is named the same but with a .sql extension
	                #and will be stored in INPUTDIR instead of OUTPUTDIR
	              done
		      unset db_name_to_check
	              mb_db_counter=0
	              if [[ $OFFLINE -eq "0" ]] && [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
                      then
    		        if [[ -z $RAT_PDEBUG ]]; then 
                          rm -f "$t_PSQL_METAFIL" >/dev/null 2>&1
                          rm -f "$t_PSQL_INFIL" >/dev/null 2>&1
		          rm -f "$t_PSQL_STAT" >/dev/null 2>&1
			fi
                      fi
	            fi
                  fi
                  ;;
                SQL_PARAM)
                  mb_db_counter=0
                  mb_db_counter_log=0
                  if  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
		  elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
		  then
                    call_get_log_result=0
                    echo "Not running $PARAM_PATH (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
		  elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                  then
                    call_get_log_result=0
                    generate_exceptions_xml "Skipping $PARAM_PATH because its excluded"
		    generate_exceptions_json "Skipping $PARAM_PATH because its excluded"

                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
		    generate_exceptions_json "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"

                  else   
                    call_get_log_result=1
	            if [[ -n "${stack_dbinst_up[$stack_counter]}" && ${stack_dbinst_up[$stack_counter]} -ne 0 ]] || [ ${stack_asm_up[$stack_counter]} -eq 1 ]
	            then
	              COM=`echo "SQL PARAMETER $PARAM_PATH  $OP  $COMP"`
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	                if [ $op_mode -eq 0 ]
	                then
	                  SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                else
	                  SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                fi
		      fi
	              SOURCEFILENAME=$SOURCEFIL
                      if [[ "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
	              then
                        SOURCEFIL_REPORT=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                        if [ $OFFLINE -eq 0 ]
                        then
                          SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"a_"$SOURCEFIL".out"
                        else
                          SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                        fi
	                SOURCEFIL=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                        if [ -e $SOURCEFIL ]
                        then
		          if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	                    if [ $op_mode -eq 0 ]
	                    then
	                      FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	                    else
	                      FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	                    fi       
			  fi
	                  inst_name=${stack_asm_sid[$stack_counter]}
	                  case $FIELDPOS in
	                    1) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $1'}`
	                      ;;
	                    2) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $2'}`
	                      ;;
	                    3) 
                              # removed + from ASM instnace in hp-ux to avoid rep: ?, *, or + not preceded by valid regular expression
                              if [ `uname -s` = "HP-UX" ]
                              then 
                                inst_name_trimmed=$(echo $inst_name|sed 's/\+//g')
                                VAL=`grep -wi "${inst_name_trimmed}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`
                              else
                                VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`  
                              fi
	                      ;;
	                    4) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $4'}`
	                      ;;
	                    5) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $5'}`
	                      ;;
	                    99) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	                      ;;
	                  esac          
                        fi
	                #if [ $ISBRANCH -eq 0 ]; then echo "$inst_name|$CHECK_ID|$VAL">>$AACTUAL; fi 
                      else  
                        ORIG_PMSG=$PMSG
                        ORIG_FMSG=$FMSG
	                for db_name_to_check in "${mb_db_names[@]}"
	                do
	                  skip_this_version=0
	                  set_skip_this_version "-"
                          if [ $skip_this_version -eq 1 ]
                          then
                            mb_db_counter=$(expr $mb_db_counter + 1)
                            echo "Skipping check($CHECK_ID) on version 6 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                            continue
                          fi
                          source_file_exists=0
	                  if [ $OFFLINE -eq 0 ]
                          then
                            inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
                            inst_mode=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
                          else
                            inst_name=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_NAME|awk '{print $3}')
                            inst_mode=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
                          fi
                          match_database_role "${mb_database_role[$mb_db_counter]}"
                          match_database_type "${mb_database_type[$mb_db_counter]}"  
                          if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]] 
	                  then
	                    DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
	                    #if [[ "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
	                    if [[ "$SOURCEFILENAME" = "v_parameter" && $inst_mode -ne 0 ]]
	                    then
	              	      SOURCEFIL_REPORT=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      if [ $OFFLINE -eq 0 ]
	              	      then
	              	        SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      else
	              	        SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      fi
	              	      SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
                              instance_exists=0
                              if [ -e $SOURCEFIL ] ;then instance_exists=$(grep -wc $inst_name $SOURCEFIL);fi  
	              	      if [[ -e $SOURCEFIL && $instance_exists -gt 0 ]]
	              	      then
	              	        source_file_exists=1
				if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	              	          if [ $op_mode -eq 0 ]
	              	          then
	              	            FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              	          else
	              	            FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              	          fi
				fi
	              	        case $FIELDPOS in
	              	          1) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $1'}`
	              	          ;;
	              	          2) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $2'}`
	              	          ;;
	              	          3) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`
	              	          ;;
	              	          4) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $4'}`
	              	          ;;
	              	          5) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $5'}`
	              	          ;;
	              	          99) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	              	          ;;
	              	        esac
	              	      fi
	                      #elif [[ "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
	                    elif [[ "$SOURCEFILENAME" = "v_parameter_u" && ${inst_mode} -ne 0 ]]
	                    then
	              	      SOURCEFIL_REPORT=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      if [ $OFFLINE -eq 0 ]
	              	      then
	              	        SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      else
	              	        SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      fi
	              	      SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      if [ -e $SOURCEFIL ]
	              	      then
	              	        source_file_exists=1
				if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	              	          if [ $op_mode -eq 0 ]
	              	          then
	              	            FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              	          else
	              	            FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              	          fi
				fi
	              	        case $FIELDPOS in
	              	          1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
	              	          ;;
	              	          2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
	              	          ;;
	              	          3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
	              	          ;;
	              	          4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
	              	          ;;
	              	          5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
	              	          ;;
	              	          99) VAL=`grep -w $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	              	          ;;
	              	        esac
	              	      fi  
	                    fi
                            #if [[ $inst_mode -eq 0 || $source_file_exists -eq 0 || $instance_exists -eq 0 ]]; then call_get_log_result=0;fi
	                    #if [[ $inst_mode -ne 0 && $source_file_exists -eq 1 && $instance_exists -gt 0 ]]
                            if [[ $inst_mode -eq 0 || $source_file_exists -eq 0 ]]; then call_get_log_result=0;fi
	                    if [[ $inst_mode -ne 0 && $source_file_exists -eq 1 ]]
	                    then
	              	      #if [ $ISBRANCH -eq 0 ]; then echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL; fi 
	              	      call_get_log_result=0
	              	      PMSG=$(echo $ORIG_PMSG on ${inst_name} instance) 
	              	      FMSG=$(echo $ORIG_FMSG on ${inst_name} instance)
	              	      #$READ -p "inst_name=$inst_name"
	              	      if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
	              	      get_log_result "inloop" "-"
	                      mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                            else
                              echo "skipping $PARAM_PATH at $ROW for $db_name_to_check because inst_mode=$inst_mode and source_file_exists=$source_file_exists \
                                    and instance_exists=$instance_exists">>$LOGFIL
                              if [[ $inst_mode -ne 0 && $source_file_exists -eq 1 && $instance_exists -eq 0 ]]
                              then
                                echo "skipping SQL Parameter $PARAM_PATH checking (checkid:-$CHECK_ID) because $inst_name not found in $SOURCEFIL" >>$SKIPFIL 
                                let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                                let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
				validate_needs_running;
                              fi
	                    fi
                          else
                            call_get_log_result=0    
                            echo "skipping $PARAM_PATH at $ROW for $db_name_to_check because database role (${mb_database_role[$mb_db_counter]}) does not match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
                          fi
	                  mb_db_counter=$(expr $mb_db_counter + 1)
	                done
			unset db_name_to_check
                        mb_db_counter=0
                        write_report_on_fail=1
                      fi
	            fi
                  fi
                  ;;
                OS_PARAM)
                  if  [[  $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
		  elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
                  then
                    call_get_log_result=0
                    echo "Not Running $PARAM_PATH (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
  		  elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                  then
                    call_get_log_result=0
                    generate_exceptions_xml "Skipping $PARAM_PATH because its excluded"
		    generate_exceptions_json "Skipping $PARAM_PATH because its excluded"
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
		    generate_exceptions_json "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
                  else   
                    call_get_log_result=1
	            COM=`echo "OS PARAMETER $PARAM_PATH  $OP  $COMP"`
		    if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	              if [ $op_mode -eq 0 ]
	              then
	                SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              else
	                SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              fi
		    fi
	            SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                    if [ $OFFLINE -eq 0 ]
                    then
	              SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                    else
	              SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                    fi
	            SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
		    if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	              if [ $op_mode -eq 0 ]
	              then
	                FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              else
	                FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              fi 
		    fi
                  fi
                  ;;
                CROSS_NODE_CHECK)
                #Following code is to store CROSS_NODE_CHECK check_ids. later based on this list, checks will be executed.
	          call_get_log_result=0
                  if [ "$i" = "$localnode" ]
                  then
	            #call_get_log_result=1
	            if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
	            noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)       
	            if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	            then
	              call_get_log_result=0
	            elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	            then
	              call_get_log_result=0
	            elif  [[ $component_match_count  -lt 1 ]]
	            then
	              echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
	              call_get_log_result=0
		    elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
  		    then
                      call_get_log_result=0
                      echo "Not running $audit_check_name (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL

		    elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                    then
                      call_get_log_result=0
                      generate_exceptions_xml "Skipping $audit_check_name because its excluded"
		      generate_exceptions_json "Skipping $audit_check_name because its excluded"
                    elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
	            then
	              call_get_log_result=0
	              echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                      generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"
		      generate_exceptions_json "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"

	            else    
	              call_get_log_result=0
                      process_cross_node_checks=1
                      cross_node_checkids[$cross_node_checkids_counter]=$CHECK_ID
	              cross_node_checkids_counter=$(expr $cross_node_checkids_counter + 1 ) 
                      echo $CHECK_ID >> $OUTPUTDIR/cross_node_checkids.out
	            fi
                  fi   
                  #$READ -p "stop for cross node check"  
                  ;;  
                CLUSTERWIDE_CHECK|SYSTEMWIDE_CHECK)
                  call_get_log_result=1
                  #$READ -p "PARAM=$PARAM asm_installed=${asm_installed[$stack_counter]} needs_running=$NEEDS_RUNNING asm_up= ${stack_asm_up[$stack_counter]} "
                  #$READ -p "PARAM=$PARAM asm_installed=${asm_installed[$stack_counter]} needs_running=$NEEDS_RUNNING asm_up= ${stack_asm_up[$stack_counter]} "
                  if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
                  noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)       
                  if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	          then
	            call_get_log_result=0
	          #elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	          elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	          then
	            call_get_log_result=0
	          elif  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
		  elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
		  then
                    call_get_log_result=0
                    echo "Not running $audit_check_name (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
		  elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                  then
                    call_get_log_result=0
                    generate_exceptions_xml "Skipping $audit_check_name because its excluded"
		    generate_exceptions_json "Skipping $audit_check_name because its excluded"
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL" 
		    generate_exceptions_json "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"
                    #elif [[ -n "$noPasswordAvailable" && $noPasswordAvailable -ge 1 ]]
                    #then
                    #    call_get_log_result=0
	          else    
	            call_get_log_result=1 
		    if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                      if [ $op_mode -eq 0 ]
                      then
                        if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
                        then
	                  COM=`grep "_"$ROW"-CLUSTERWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*CLUSTERWIDE_CHECK_COMMAND //p'`
                        else
	                  COM=`grep "_"$ROW"-SYSTEMWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*SYSTEMWIDE_CHECK_COMMAND //p'`
                        fi
	                audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                        REQUIEE_ROOT=`grep "_"$ROW"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                      else
                        if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
                        then
                          com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                          com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                          COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d') 
                          com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                          com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                          COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        else
                          com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                          com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                          COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                          com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                          com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                          COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        fi
	                audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                        REQUIEE_ROOT=`grep "_"$CHECK_ID"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                      fi
		    fi
	            audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
                    #$READ -p "rootYesNoint=$rootYesNoint"
                    if [[ $REQUIEE_ROOT -eq 1 && $rootYesNoint -eq 3 ]]
                    then
                      echo "">/dev/null 
	              call_get_log_result=0
                    else
                      #echo "audit_check_name=$audit_check_name executed"
	              if [ $OFFLINE -eq "0" ]
	              then
			if [ -n "$COM_REPORT" ]; then TAG3=1; fi
	                get_current_epoch 
 	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	                if [ $i = $localnode ]
	                then
	                  copy_env_files_to_tmp
	                  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");
      		 	  
    	  	  	  security_fix "check_and_fix_script_existence" "$localcmd"

                          CLUSTERCHECK_FIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	                  echo "#!$bash_scr" >$localcmd
	                  echo "$RAT_DEBUG_FLG" >>$localcmd
	                  echo "$bash_source" >>$localcmd
	                  echo ". $TRGTORCLENV">>$localcmd
	                  echo "$COM 2>>$ERRFIL">>$localcmd

                          if [ $REQUIEE_ROOT -eq 0 ]
                          then
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$CLUSTERCHECK_FIL_REPORT
                          fi
                          if [ -n "$COM_REPORT" ] 
                          then 
                            echo "$COM_REPORT >> $CLUSTERCHECK_FIL_REPORT 2>>$ERRFIL">>$localcmd
                          else
                            echo "$COM >> $CLUSTERCHECK_FIL_REPORT 2>>$ERRFIL">>$localcmd
                          fi

                          echo "echo -e \"\n\n\" >> $CLUSTERCHECK_FIL_REPORT 2>>$ERRFIL">>$localcmd 
			  echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                  echo "exit 0">>$localcmd

      		   	  security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

                          if [ $RAT_DEBUG -eq 1 ]
                          then
                            FILVAL=`$localcmd`
                            returncode=`echo $?`
                          else
                            FILVAL=`$localcmd 2>>$ERRFIL`
                            returncode=`echo $?`
                          fi
			  set_alvl
			  #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
		    	  if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm -f $localcmd; fi
	                else
	                  copy_env_files_to_tmp
	                  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");
      		 	  
    	  	  	  security_fix "check_and_fix_script_existence" "$localcmd"

                          CLUSTERCHECK_FIL_REPORT=${RTEMPDIR}/${CHECK_ID}_${i}_report.out
	                  echo "#!$bash_scr" >$localcmd
	                  echo "$RAT_DEBUG_FLG" >>$localcmd
	                  echo "$bash_source" >>$localcmd
	                  echo ". $TRGTORCLENV">>$localcmd
	                  echo "$COM">>$localcmd
                          if [ $REQUIEE_ROOT -eq 0 ]
                          then    
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$CLUSTERCHECK_FIL_REPORT
                          fi
                          if [ -n "$COM_REPORT" ]
                          then 
                            echo "$COM_REPORT >> $CLUSTERCHECK_FIL_REPORT">>$localcmd
                          else
                            echo "$COM >> $CLUSTERCHECK_FIL_REPORT">>$localcmd      
                          fi
                          echo "echo -e \"\n\n\" >> $CLUSTERCHECK_FIL_REPORT">>$localcmd 
			  echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                  echo "exit 0">>$localcmd

      		   	  security_fix "fix_plugin_or_rtscript_attributes" "$localcmd" "" "540"

	             	  #if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
		    	  if [ -e "$localcmd" ]; then cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
 
                          get_cygpath "localcmd"
                          get_cygpath "RTEMPDIR"
                          get_cygpath "CLUSTERCHECK_FIL_REPORT"
                          $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	                  $SCOPY $CLUSTERCHECK_FIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1

		          ATTRMOD_RC=`$SSHELL $i "chmod 540 $RTEMPDIR/localcmd.sh >/dev/null 2>&1;echo \\$?"`
		    	  security_fix "verify_attrmodcode" "$i:$RTEMPDIR/localcmd.sh" "$ATTRMOD_RC"

                          restore_cygpath "localcmd"
                          restore_cygpath "RTEMPDIR"
                          restore_cygpath "CLUSTERCHECK_FIL_REPORT"
	                  if [ $RAT_DEBUG -eq 1 ]
	                  then
	              	    FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh"`
	              	    returncode=`echo $?`
	                  else
	                    FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	              	    returncode=`echo $?`
	                  fi
			  set_alvl
                          get_cygpath "CLUSTERCHECK_FIL_REPORT"
                          get_cygpath "OUTPUTDIR"
	                  $SCOPY $i:$CLUSTERCHECK_FIL_REPORT $OUTPUTDIR >/dev/null 2>&1

                          $SSHELL $i "rm -f $CLUSTERCHECK_FIL_REPORT>/dev/null 2>&1"
                          REM_RC=`$SSHELL $i "if [ -e $RTEMPDIR/localcmd.sh ]; then rm -f $RTEMPDIR/localcmd.sh>/dev/null 2>&1; fi;echo \\$?;"`
          	          security_fix "verify_remcode" "$i:$RTEMPDIR/localcmd.sh" "$REM_RC"
                          REM_RC=`$SSHELL $i "rm -f $TRGTORCLENV>/dev/null 2>&1;echo \\$?;"`
          	          security_fix "verify_remcode" "$i:$TRGTORCLENV" "$REM_RC"

                          restore_cygpath "CLUSTERCHECK_FIL_REPORT"
                          restore_cygpath "OUTPUTDIR"
	                fi

	                get_current_epoch 
 	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ][TAG3: $TAG3] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	                move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "" "$FILVAL"
	                echo "" >>$OSSPOOLFIL
	                #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
	                printf "%s %s %s %s %s\n" " $PARAM_PATH $CHECK_ID == $FILVAL" >>$OSSPOOLFIL

		        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
	              fi 
	              VAL=`grep "$PARAM_PATH $CHECK_ID " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                      if [ -n "$VAL" ]
                      then  
                        echo $CHECK_ID >> $OUTPUTDIR/crs_checkids.out
	                if [  ! -f $CLUSTERCHECK_FIL ]
	                then
	                  crs_check_id[$clusterware_check_count]=$CHECK_ID
	                  clusterware_check_count=`expr $clusterware_check_count + 1`
	                  if [ $OFFLINE -eq "0" ]; then echo "$i $ROW $COM == $FILVAL" >$CLUSTERCHECK_FIL; fi;
	                else
	                  crs_check_id[$clusterware_check_count]=$CHECK_ID
	                  clusterware_check_count=`expr $clusterware_check_count + 1`
	                  if [ $OFFLINE -eq "0" ]; then echo "$i $ROW $COM == $FILVAL" >>$CLUSTERCHECK_FIL; fi;
	                fi
                      fi 
		      if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then 
		        old_db_machine_compute=$db_machine_compute
			db_machine_compute=1
		      fi 
                      if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP  && $cell_password_status -ne 3 && "$COMTYPE" = "SYSTEMWIDE_CHECK" && -n "$skip_in_silent" && $skip_in_silent -eq 0 ]]
                      then
                        cellFilePlaceHolder=$( echo "$COM"|sed  -n 's/.*cat //p'|$AWK 'BEGIN { FS = "/" } {printf $2}'|$AWK '{print $1}'|$AWK '{sub(/o_/,"");print}'|$AWK '{sub(/.out/,"");print}')
                        for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'`
                        do
                          if [ -e $CELLDIR/cells.out ]; then cellname_full=$(grep -w "$cellname" $CELLDIR/cells.out|grep -v "^ *#"|awk '{print $NF}'|head -1); fi 
                          cellname=$(echo $cellname|sed 's/\./_/g')  
                          CLUSTERCHECK_FIL_REPORT=$OUTPUTDIR/${CHECK_ID}_report.out
                          if [ -e $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}.out ]; then FILVAL=$(cat $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}.out);fi
	                  if [ $OFFLINE -eq "0" ]; then echo "$cellname $ROW $COM == $FILVAL" >>$CLUSTERCHECK_FIL; fi;
                          if [ -e $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}_report.out ]
                          then 
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $cellname_full|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$CLUSTERCHECK_FIL_REPORT
                            cat $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}_report.out >>$CLUSTERCHECK_FIL_REPORT
                            echo -e "\n\n" >> $CLUSTERCHECK_FIL_REPORT
                          fi
                        done
                      fi
		      if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then db_machine_compute=$old_db_machine_compute; fi 
                      #making to CLUSTERWIDE_CHECK so log_fail and log_pass can work as before
                      if [ "$COMTYPE" = "SYSTEMWIDE_CHECK" ]; then COMTYPE=CLUSTERWIDE_CHECK;fi
	            fi
                  fi
                  ;;
                OS_PATCH)
                  if  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL  
                    call_get_log_result=0
		elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
		then
                  call_get_log_result=0
                  echo "Not running $PARAM_PATH (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
		 elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                  then
                    call_get_log_result=0
                    generate_exceptions_xml "Skipping $PARAM_PATH because its excluded"
		    generate_exceptions_json "Skipping $PARAM_PATH because its excluded"

                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]] 
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
		    generate_exceptions_json "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"

                  else
                    call_get_log_result=1
	            if [ $OFFLINE -eq 0 ]
	            then
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	                if [ $op_mode -eq 0 ]
	                then
	                  SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                else
	                  SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                fi 
		      fi
	              call_get_log_result=1 
                      SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      if [ $OFFLINE -eq 0 ]
                      then
                        SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                      else
                        SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      fi
	              SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
	              case `uname -s` in 
	                SunOS)
	                  os_patch_count=0
	                  os_patch_base=0
	                  os_patch_rls=0
	                  os_patch_rls_actual=0 
	                  os_patch_base=$(echo $PARAM_PATH|cut -d- -f1)
	                  os_patch_rls=$(echo $PARAM_PATH|cut -d- -f2)
	                  #os_patch_count=$(grep -c $os_patch_base $SOURCEFIL)
	                  os_patch_count=$(cat $SOURCEFIL|cut -d: -f2|awk '{print $1}'|grep -c $os_patch_base)
	                  #$READ -p "os_patch_count=$os_patch_count"
	                  if [ $os_patch_count -ge 1 ]
	                  then 
	                    if [ $i = $localnode ]
	                    then
	                      os_patch_rls_actual=$(showrev -p |cut -d: -f2|awk '{print $1}'|grep ${os_patch_base}|cut -d- -f2)
	                    else
	                      os_patch_rls_actual=$($SSHELL $i showrev -p |cut -d: -f2|awk '{print $1}'|grep ${os_patch_base}|cut -d- -f2)
	                    fi
	                    #$READ -p "os_patch_rls_actual=$os_patch_rls_actual"
	                    if [ $os_patch_rls_actual -ge $os_patch_rls ]
	                    then
	                      os_patch_status=1
	                    else
	                      os_patch_status=2
	                    fi
	                  else
	                    os_patch_status=0
	                  fi 
	                  echo "${CHECK_ID}_${PARAM_PATH}_os_patch_status == $os_patch_status">>$OSSPOOLFIL
	                  ;;
	                AIX|HP-UX)
	                  os_patch_count=0
	                  os_patch_count=$(grep $PARAM_PATH $SOURCEFIL|wc -l)
	                  if [ $os_patch_count -gt 0 ]
	                  then
	                     os_patch_status=1
	                  else
	                     os_patch_status=0
	                  fi     
	                  echo "${CHECK_ID}_${PARAM_PATH}_os_patch_status == $os_patch_status">>$OSSPOOLFIL
	                  ;;
	                *)
	                  ;;
	              esac #patch OS case ends here
	              echo "OS PATCH status variable are os_patch_count=$os_patch_count,os_patch_base=$os_patch_base,os_patch_rls=$os_patch_rls and os_patch_rls_actual=$os_patch_rls_actual" os_patch_status=$os_patch_status >>$LOGFIL
	            else # this else is for offline patch 
                      call_get_log_result=1
	              os_patch_status=$(grep "${CHECK_ID}_${PARAM_PATH}_os_patch_status" $OSSPOOLFIL|sed  -n 's/.*== //p')
	            fi
	            #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${os_patch_status}@$os_patch_rls_actual" >>$OSACTUAL; fi
                  fi
                  ;;
                ORACLE_PATCH)
                  if [[ $HOME_PATH = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $HOME_PATH = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $HOME_PATH = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	          then
	            call_get_log_result=0
	          elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	          then
	            call_get_log_result=0
                  elif [[ $NEEDS_RUNNING = "ACFS" && $db_machine_compute -eq 1 ]] 
                  then
                    call_get_log_result=0
                  elif  [[  $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
		elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
                  then
                  call_get_log_result=0
                  echo "Not running $PARAM_PATH (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
		elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                  then
                    call_get_log_result=0
                    generate_exceptions_xml "Skipping $PARAM_PATH because its excluded"
		    generate_exceptions_json "Skipping $PARAM_PATH because its excluded"
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
		    generate_exceptions_json "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
	          else    
	            call_get_log_result=1 
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG  
                    if [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" ]]
                    then
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                        if [ $op_mode -eq 0 ]
	                then
	                  SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                else
	                  SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                fi
		      fi
                      if [ $OFFLINE -eq 0 ]
	              then
	                SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/o_${SOURCEFIL}_${i}_report.out
	              else
	                SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/o_${SOURCEFIL}_${i}_report.out
	              fi
                      SOURCEFIL_REPORT=$OUTPUTDIR/o_${SOURCEFIL}_${i}_report.out
	              SOURCEFIL=$OUTPUTDIR/o_${SOURCEFIL}_${i}.out
                      if [[ -e $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
                      then
                        PARAM_PATH=$(echo $PARAM_PATH|sed 's/,/ /g')
                        VAL=0
                        for each_oracle_patch in $PARAM_PATH
                        do
                          oracle_patch_count=$(grep -icw $each_oracle_patch $SOURCEFIL)
                          if [ $oracle_patch_count -ge 1 ]; then VAL=$oracle_patch_count;break;fi
                        done 
                        if [ $HOME_PATH = "CRS" ] ;then message4Home=$CRS;elif [ $HOME_PATH = "ASM" ]; then  message4Home=$ASM_HOME;fi
                        PMSG=$(echo $ORIG_PMSG $message4Home)
                        FMSG=$(echo $ORIG_FMSG $message4Home) 
                        if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
                        then
                          get_log_result
                          call_get_log_result=0
                        fi 
                      else 
	                echo "skipping Oracle Patch $PARAM_NAME checking (checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
	                generate_exceptions_xml "skipping Oracle Patch $PARAM_NAME checking because `basename $SOURCEFIL` not found"
			generate_exceptions_json "skipping Oracle Patch $PARAM_NAME checking because `basename $SOURCEFIL` not found"
                        call_get_log_result=0
                        let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			validate_needs_running;
                      fi
                    elif [ $HOME_PATH = "RDBMS" ]
                    then
                      mb_db_counter_log=0
                      for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                      do
                        skip_this_version=0
                        set_skip_this_version "$mb_db_homes"
                        if [ $skip_this_version -eq 1 ]
                        then #dont run
                          mb_db_counter=$(expr $mb_db_counter + 1)
                          echo "Skipping check($CHECK_ID) on version 7 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                          continue
                        fi
                        mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                        mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g') 
                        mb_db_homes_with_underscore=$(echo $mb_db_homes_without_slash|sed 's/\./_/g')
			if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	                  if [ $op_mode -eq 0 ]
	                  then
	                    SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                  else
	                    SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                  fi	     
			else
			  SOURCEFIL=$ORIG_SOURCEFIL
			fi
                        if [ $OFFLINE -eq 0 ]
	                then
	                  SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
	                else
	                  SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
	                fi
	                SOURCEFIL_REPORT=$OUTPUTDIR/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
                        SOURCEFIL=$OUTPUTDIR/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}.out
	                if [[ -e $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
	                then
                          PARAM_PATH=$(echo $PARAM_PATH|sed 's/,/ /g')
	                  VAL=0
	                  for each_oracle_patch in $PARAM_PATH
	                  do
	                    oracle_patch_count=$(grep -icw $each_oracle_patch $SOURCEFIL)
	                    if [ $oracle_patch_count -ge 1 ]; then VAL=$oracle_patch_count;break;fi
	                  done
	                  PMSG=$(echo $ORIG_PMSG $mb_db_homes)
	                  FMSG=$(echo $ORIG_FMSG $mb_db_homes) 
                          if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
	                  then
	                    get_log_result "inloop" "$mb_db_homes"
	                    mb_db_counter_log=$(expr $mb_db_counter_log + 1)
	                  fi
	                else 
	                  echo "skipping Oracle Patch $PARAM_NAME checking (checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
	                  generate_exceptions_xml "skipping Oracle Patch $PARAM_NAME checking because `basename $SOURCEFIL` not found"
			  generate_exceptions_json "skipping Oracle Patch $PARAM_NAME checking because `basename $SOURCEFIL` not found"

	                  call_get_log_result=0
                          let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                          let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			  validate_needs_running;
	                fi   
                      done  
                      call_get_log_result=0
                    fi 
                  fi
                  ;;   
                OS_PACKAGE)
                  #be available via an OS_COLLECT, so we'll check each node's output
                  #OS PAckages are kind of a special case, so doing some trickery here
                  #we first want to check to see if the package is installed
                  #then if it is we want to check to see if the package version is
                  #a known bad version
                  #
                  #we manipulate FMSG,PMSG,OP and COMP to get the desired effect
                  #when get_log_result() is called, those don't come from the data file
                  #as they do for other checks, or if they do we're over-riding them
                  #elif  [[ $components != "NONE" &&  $components != $check_components ]]
                  #elif  [[ $components != "NONE" &&  $component_match_count  -lt 1 ]]
                  if  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
		elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
		then
                  call_get_log_result=0
                  echo "Not running $PARAM_PATH (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
		elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                  then
                    call_get_log_result=0
                    generate_exceptions_xml "Skipping $PARAM_PATH because its excluded"
		    generate_exceptions_json "Skipping $PARAM_PATH because its excluded"
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG    
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL" 
		    generate_exceptions_json "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"

                  else
                    call_get_log_result=1
	            if [ $OFFLINE -eq "0" ]
	            then
	              #if running in SILENT mode then we don't want to do any of this
	              #we'll have all we need from the output of the OS command which 
	              #outputs the packages, eg., rpm -qa in linux
	              # HERE we are in NON SILENT mode
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	                if [ $op_mode -eq 0 ]
	                then
	                  SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                else
	                  SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                fi
		      fi
	              #each node could potentially have a different listing of packages
	              #so use the node specific listing to check
	              #RPM STATUS
	              # 0=exact version is installed
	              # 1=higher version of same package is installed
	              # 2=package is installed but version is lower than recommended
	              # 3=package not instaleld
	              #sed 's/|/-/g'
	              SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      if [ $OFFLINE -eq 0 ]
                      then
	                SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                      else
	                SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      fi
	              SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
	              call_get_log_result=1 
	              rpm_arch=99
	              case `uname -s` in 
	                Linux)
	                  rpm_match=$(grep -c $PARAM_PATH $SOURCEFIL)
	                  unset rpm_arr1
	                  unset rpm_arr2
	                  unset rpm_name
	                  unset rpm_status
	                  func_rpm_status=0
	                  ir_counter=0
	                  how_many_name_r=1
	                  how_many_no_r=0
	                  if [ $rpm_match -eq 1 ]
	                  then
	                    rpm_status=0
	                  else
                            #if [ -z "$IFS ]
                            #then
                            old_ifs=$IFS
                            #fi
	                    IFS=$'|'
	                    #$READ -p "package name =$PARAM_PATH"
	                    for ir in $PARAM_PATH
	                    do
	               	      rpm_arr1[$ir_counter]=$ir
	               	      if [ -z "$rpm_name" ]
	               	      then
	               	        rpm_name=${rpm_arr1[0]}
	               	      fi
	               	      ir_counter=$(expr $ir_counter + 1)
	                    done
	                    ir_counter=$(expr $ir_counter - 1)
	                    if [ "$i" = "$localnode" ]
	                    then
	               	      actual=$(rpm -q "$rpm_name" --queryformat "%{name}|%{version}|%{release}|%{arch}\n")
	               	      rpm_q_rstatus=$?
	                    else
	               	      #set -xv
	               	      IFS=$old_ifs
	               	      sshrpm="rpm -q $rpm_name --queryformat \"%{name}|%{version}|%{release}|%{arch}\n\""
                              #OLD_SSHELL=$SSHELL
                              #SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
	               	      rpm_actual=$($SSHELL $i $sshrpm)
	               	      rpm_q_rstatus=$?
	               	      actual=$(echo $rpm_actual|sed 's/ /|/g')
                              #SSHELL=$OLD_SSHELL 
	               	      #$READ -p "ssh $i $sshrpm and actual is $actual"
	               	      IFS=$'|'
	               	      #set +xv
	                    fi
	                    #$READ -p "RPM name is $rpm_name and actual found on system is $actual rpm_q_rstatus=$rpm_q_rstatus"
	                    if [ $rpm_q_rstatus -ne 0 ]
	                    then
	               	      rpm_status=3
	               	      #echo "rpm $PARAM_PATH is not installed on sysetm"
	                    else
	               	      no_of_rpms=$(echo $actual|wc -l)
	               	      #$READ -p "before 2$actual"
	               	      if [ $no_of_rpms -gt 1 ]
	               	      then
	               	        actual1=$actual
	               	        actual=$(echo $actual|grep ${rpm_arr1[$ir_counter]}|sed 's/ /|/g')
	               	        if [ -z "$actual" ] 
	               	        then
	               	          actual=$(echo $actual1|grep -v "x86_64"|sed 's/ /|/g') 
	               	          #$READ -p " after 2 $actual"
	               	        fi
	               	      fi
                              if [ `echo "$actual"|wc -l` -gt 1 ]; then actual=$(echo "$actual"|head -1);fi
	               	      ar_counter=0
	               	      how_many_name_a=0
	               	      how_many_no_a=0
	               	      element_count=0
	               	      no_of_loops=0 
	               	      for arpm in $actual
	               	      do
	               	        rpm_arr2[$ar_counter]=$arpm
	               	        if [ -z "$rpm_name" ]
	               	        then
	               	          rpm_name=${rpm_arr2[0]}
	               	        fi
	               	        ar_counter=$(expr $ar_counter + 1)
	               	      done
	               	      for array_item in ${rpm_arr1[*]}
	               	      do
	               	        if [ $element_count -eq 1 -o $element_count -eq 2 ] && [ -n "$array_item" ]
	               	        then
	               	          no_of_loops=$(expr $no_of_loops + 1)
	               	        fi
	               	        if [ $element_count -eq 3 ] && [ "${rpm_arr1[3]}" != "${rpm_arr2[3]}" ]
	               	        then
	               	          case "${rpm_arr1[3]}" in
	               	            i386)
	               	              if [[ "${rpm_arr2[3]}" = "i486" ||  "${rpm_arr2[3]}" = "i586" ||  "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
	               	              then
	               	                rpm_arch=1
	               	              fi
	               	              ;;
	               	            i486)
	               	              if [ "${rpm_arr2[3]}" = "i386" ]
	               	              then
	               	                rpm_arch=0
	               	              elif [[ "${rpm_arr2[3]}" = "i586" ||  "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
	               	              then
	               	                rpm_arch=1
	               	              fi
	               	              ;;
	               	            i586)
	               	              if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486"  ]]
	               	              then
	               	                rpm_arch=0
	               	              elif [[ "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
	               	              then
	               	                rpm_arch=1
	               	              fi  
	               	              ;;
	               	            i686)
	               	              if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486" || "${rpm_arr2[3]}" = "i586"  ]]
	               	              then
	               	                rpm_arch=0
	               	              elif [  "${rpm_arr2[3]}" = "i886" ] 
	               	              then
	               	                rpm_arch=1
	               	              fi
	               	              ;;
	               	            i886)
	               	              if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486" || "${rpm_arr2[3]}" = "i586"  || "${rpm_arr2[3]}" = "i686" ]]
	               	              then
	               	                rpm_arch=0 
	               	              fi
	               	              ;; 
	               	            *)
	               	              rpm_status=3
	               	            ;; 
	               	          esac    
	               	          #$READ -p "${rpm_arr1[3]} and ${rpm_arr2[3]} $rpm_status $actual $PARAM_PATH"
	               	        fi
	               	        #$READ -p "element is $array_item"
	               	        element_count=$(expr $element_count + 1)
	               	      done
	               	      element_count=0
	                        #no_of_loops=$(expr $how_many_name_r + 2)
	               	      if [ -z "$rpm_status" ]
	               	      then
	               	        while [ "$how_many_name_r" -le "$no_of_loops" ]
	               	        do
	               	          #echo "to compare ${rpm_arr1[$how_many_name_r]} and ${rpm_arr2[$how_many_name_r]} and func_rpm_status =$func_rpm_status"
	               	          if [ "$func_rpm_status" -eq 0 ]
	               	          then
	               	            compare_rpmversion "${rpm_arr1[$how_many_name_r]}" "${rpm_arr2[$how_many_name_r]}"
	               	            rpm_status=$func_rpm_status
	               	          fi
	               	          how_many_name_r=$(expr $how_many_name_r + 1)
	               	        done
	               	      fi
	                    fi
                            IFS=$old_ifs
	                  fi 
	                  echo "${CHECK_ID}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
	                  echo "${CHECK_ID}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
	                  ;;
	                SunOS)
	                  PARAM_PATH=$(echo $PARAM_PATH|cut -d '|' -f1)
	                  rpm_match=$(grep -c "$PARAM_PATH" $SOURCEFIL)
	                  if [ $rpm_match -eq 1 ]
	                  then
	                    rpm_status=0
	                  else
	                    if [ $i = $localnode ]
	                    then
	                      rpm_match=$(pkginfo -q $PARAM_PATH;echo $?)
	                    else
	                      sshrpm="pkginfo -q $PARAM_PATH;echo \$?"
	                      rpm_match=$($SSHELL $i $sshrpm)
                              #$READ -p "rpm_match=$rpm_match and sshrpm=$sshrpm"
	                    fi
	                    actual=$PARAM_PATH
	                    if [ $rpm_match -eq 0 ]
	                    then
	                      rpm_status=1
	                    else
	                      rpm_status=3
	                    fi
	                  fi
	                  echo "${CHECK_ID}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
	                  echo "${CHECK_ID}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
	                  ;;
	                AIX)
	                  rpm_match=$(grep -c $PARAM_PATH $SOURCEFIL)
	                  unset rpm_arr1
	                  unset rpm_arr2
	                  unset rpm_name
	                  unset rpm_status
	                  func_rpm_status=0
	                  ir_counter=0
	                  how_many_name_r=1
	                  how_many_no_r=0
	                  if [ $rpm_match -eq 1 ]
	                  then
	                    rpm_status=0
	                  else
                            if [ -n "$IFS" ]
                            then
                              old_ifs=$IFS
                            fi
                            IFS=$'|'
	                    #$READ -p "package name =$PARAM_PATH"
	                    for ir in $PARAM_PATH
	                    do
	                      rpm_arr1[$ir_counter]=$ir
	                      if [ -z "$rpm_name" ]
	                      then
	                        rpm_name=${rpm_arr1[0]}
	                      fi
	                      ir_counter=$(expr $ir_counter + 1)
	                    done
	                    ir_counter=$(expr $ir_counter - 1)
	                    if [ "$i" = "$localnode" ]
	                    then
	                      actual=$(lslpp -lcq "$rpm_name" 2> /dev/null|head -1|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
	                    else
	                      IFS=$old_ifs
                              sshrpm="lslpp -lcq $rpm_name 2>/dev/null|head -1"  
                              #OLD_SSHELL=$SSHELL
                              #SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
                              actual=$($SSHELL $i $sshrpm|sed 's/ /|/g')
                              actual=$(echo $actual|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
                              #SSHELL=$OLD_SSHELL
	                      IFS=$'|'
	                      #actual=$($SSHELL $i lslpp -lcq "$rpm_name" 2>/dev/null|head -1|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
	                    fi
	                    if [[ -z "$actual" || $actual = "|"  ]]
	                    then
	                      rpm_status=3
	                      #echo "rpm $PARAM_PATH is not installed on sysetm"
	                    else
	                      #$READ -p "actual is $actual"
	                      ar_counter=0
	                      how_many_name_a=0
	                      how_many_no_a=0
	                      element_count=0
	                      no_of_loops=0
	                      for arpm in $actual
	                      do
	                        rpm_arr2[$ar_counter]=$arpm
	                        if [ -z "$rpm_name" ]
	                        then
	                  	  rpm_name=${rpm_arr2[0]}
	                        fi
	                        ar_counter=$(expr $ar_counter + 1)
	                      done
	                      if [ -z "$rpm_status" ]
	                      then
	                        #echo "to compare ${rpm_arr1[1]} and ${rpm_arr2[1]} and func_rpm_status =$func_rpm_status"
	                        if [ "$func_rpm_status" -eq 0 ]
	                        then
	                  	  compare_rpmversion "${rpm_arr1[1]}" "${rpm_arr2[1]}"
	                  	  rpm_status=$func_rpm_status
	                        fi
	                      fi
	                    fi
	                  fi
                          unset IFS
                          IFS=$' \t\n'  
	                  echo "${CHECK_ID}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
	                  echo "${CHECK_ID}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
	                  ;;
	              esac #packages OS case ends here
	              #if [ $ISBRANCH -eq 0 ]; then echo "${CHECK_ID}|${rpm_status}@$actual" >>$OSACTUAL;fi
	            else # package offline else so above is for online and below is for offline 
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
	                if [ $op_mode -eq 0 ]
	                then
	                  SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                else
	                  SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                fi
		      fi
	              #each node could potentially have a different listing of packages
	              #so use the node specific listing to check
	              #RPM STATUS
	              # 0=exact version is installed
	              # 1=higher version of same package is installed
	              # 2=package is installed but version is lower than recommended
	              # 3=package not instaleld
	              #sed 's/|/-/g'
	              SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      if [ $OFFLINE -eq 0 ]
                      then
	                SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                      else
	                SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      fi
	              #write the code here to read back from os spool file
	              #$READ -p "PARAM_PATH=$PARAM_PATH"
	              call_get_log_result=1
	              pkgtype=$(echo $PARAM_PATH|cut -d '|' -f2)
	              pkgarch=$(echo $PARAM_PATH|cut -d '|' -f4)
	               
	              if [[ -z "$pkgtype" && "$pkgarch" != "ppc_64" ]]
	              then 
	                PARAM_PATH=$(echo $PARAM_PATH|cut -d '|' -f1)
	              fi
	              rpm_status=$(grep "${CHECK_ID}_${PARAM_PATH}_rpm_status" $OSSPOOLFIL|sed  -n 's/.*== //p')
	              rpm_arch=$(grep "${CHECK_ID}_${PARAM_PATH}_rpm_arch" $OSSPOOLFIL|sed  -n 's/.*== //p')
	              #$READ -p "RPM status $rpm_status and PARAM_PATH=$PARAM_PATH pkgarch=$pkgarch"
	            fi
                  fi
                  ;;
              esac # this end case is for SQL|SQL_PARAM|SQL_COLLECT|OS_PARAM|OS_PACKAGE|OS_PATCH
              case $COMTYPE in
                OS_PARAM)
                  if  [[ $component_match_count  -lt 1 ]]
                  then 
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL 
                    call_get_log_result=0
		elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
                  then
                  call_get_log_result=0
                  echo "Not running $PARAM_PATH (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
#                  generate_exceptions_xml "Skipping $PARAM_PATH because its profile only"
		elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                  then
                    call_get_log_result=0
                    #echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID)  on $i because its excluded">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its excluded"
		    generate_exceptions_json "Skipping $PARAM_PATH because its excluded"

                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]  
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"   
		    generate_exceptions_json "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
                  else
                    call_get_log_result=1
	            case $FIELDPOS in
	              1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
	               ;;
	              2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
	               ;;
	              3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
	               ;;
	              4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
	               ;;
	              5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
	               ;;
	              99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	               ;;
	            esac
	            #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
                  fi
		  #commented below to execute sql out check
         	  ;;
    	      esac
              #-----------------DEBUGGING---------------
	      #       echo "----------------------------------------------"
              #       echo "COMMAND = $COM"
              #       echo "RESULT = $VAL"
              #--------------END DEBUGGING-------------
              #if [ -n "$LEVEL" ]
              #then
              #  get_log_result
	      if [[ -n "$LEVEL" && -n $call_get_log_result && $call_get_log_result -eq 1 ]]; then  get_log_result; fi;
              #fi
              ;;
            OS_OUT_CHECK)
              if [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -eq 1 ]] || [[ "$PARAM" = "OMS_HOME" && $is_oms_installed -eq 1 ]]
              then
	        if [[ -z "$mb_em_home_version" ]]
                then
                  if [ $OFFLINE -eq 0 ]
                  then
                    emfile1=$MASTERFIL
                  else
                    emfile1=$DUMPDIR/$CHKFIL
                  fi
                  mb_em_home_version=`grep "$i.EMAGENT_VERSION" $emfile1|awk -F"=" '{print $2}'|sed 's/ //g'`
                fi
                em_version_found=$(echo $check_exadata_version|grep -iwc $mb_em_home_version) 
              fi
              if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "TIMESTEN" &&  ${ttx_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "GOLDENGATE_HOME" && $is_goldengate_installed -eq 0 ]] || [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -ne 1 ]] || [[ "$PARAM" = "OMS_HOME" && $is_oms_installed -ne 1 ]]
              then
                call_get_log_result=0
              elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]] || [[ "$NEEDS_RUNNING" = "EMAGENT" && $is_emagent_installed -ne 1 ]] || [[ "$NEEDS_RUNNING" = "OMS" && $is_oms_installed -ne 1 ]]
              then
                call_get_log_result=0 
              elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
              then
                call_get_log_result=0    
                echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because execute_once is true">>$LOGFIL   
              elif [[ $NEEDS_RUNNING != "OIM" && $NEEDS_RUNNING != "OUD" && $NEEDS_RUNNING != "OAM" && $execute_once -eq 1 && $i != $localnode ]] || [[ $NEEDS_RUNNING = "OIM" && $execute_once -eq 1 && $i != $pickedoim ]] || [[ $NEEDS_RUNNING = "OUD" && $execute_once -eq 1 && $i != $pickedoud ]] || [[ $NEEDS_RUNNING = "OAM" && $execute_once -eq 1 && $i != $pickedoam ]]
              then
                call_get_log_result=0    
		echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because execute_once is true">>$LOGFIL
	      elif [[ $execute_once -eq 2 && $i != "$first_compute" ]]
	      then
		call_get_log_result=0
                echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because execute_once is true on compute">>$LOGFIL   
              elif  [[ $component_match_count  -lt 1 ]]
              then
                echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                call_get_log_result=0
	      elif [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -eq 1 && $em_version_found -eq "0" ]] || [[ "$PARAM" = "OMS_HOME" && $is_oms_installed -eq 1 && $em_version_found -eq "0" ]]
              then
                call_get_log_result=0
                echo "Check version($check_exadata_version) and system version($mb_em_home_version) dont match for check_id =$CHECK_ID">>$LOGFIL
	      elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
              then
                call_get_log_result=0
                echo "Not running $audit_check_name($CHECK_ID) because no profile is in use">>$LOGFIL
	      elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
              then
                call_get_log_result=0
                generate_exceptions_xml "Skipping $audit_check_name because its excluded"
		generate_exceptions_json "Skipping $audit_check_name because its excluded"

              elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
              then
                echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"
		generate_exceptions_json "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"

                call_get_log_result=0
              elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ $i != $localnode ]]
              then
                call_get_log_result=0
              else
                if [ $OFFLINE -eq 0 ]; then switch_name_file=${RTEMPDIR}/o_ibswitches.out;else switch_name_file=$OUTPUTDIR/o_ibswitches.out;fi
                #$READ -p "before switch os_out_check"
		if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                  if [ $op_mode -eq 0 ]
                  then
	            audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                  else
	            audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                  fi
		fi
	        audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
                if [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]]
                then
                  #write_switchname_in_report=1
                  if [ $write_switchname_in_report -eq 1 ]
                  then
                    write_switchname_in_report=0
                    echo "============================================================="|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                    echo "                    InfiniBand switch checks                 "|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                    echo "============================================================="|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                  fi
                  ORIG_PMSG=$PMSG
                  ORIG_FMSG=$FMSG
                  mb_db_counter=0
                  mb_db_counter_log=0
                  for switchname in `cat $switch_name_file`
                  do
		    if [[ -n "$execute_once" && $execute_once -eq "5" && "$first_ibswitch" != "$switchname" ]]; then 
		      echo "skipping $audit_check_name (checkid:- $CHECK_ID) on $switchname because execute_once is true for switch">>$LOGFIL;
		    else
                    if [ -e $OUTPUTDIR/s_getnm2type_${switchname}.out ]
                    then 
                      switch_type=$(cat $OUTPUTDIR/s_getnm2type_${switchname}.out)
                      if [[ "$switch_type" = "36P" || "$switch_type" = "36p" ]]; then switch_type_running=SPINE_SWITCH;else switch_type_running=SWITCH;fi
                    else
		      t_switchname_short=""
		      if [[ `echo "$switchname"|grep -c '[A-Za-z]'` -gt "0" ]]; then t_switchname_short=$(echo $switchname|cut -d. -f1); fi
		      if [ -e $OUTPUTDIR/s_getnm2type_${t_switchname_short}.out ]; then
                        switch_type=$(cat $OUTPUTDIR/s_getnm2type_${t_switchname_short}.out)
			if [[ "$switch_type" = "36P" || "$switch_type" = "36p" ]]; then switch_type_running=SPINE_SWITCH;else switch_type_running=SWITCH;fi
		      else
                        switch_type_running=SWITCH 
		      fi
                    fi
                    is_ibswitch_ip=$(echo $switchname|grep -c '[A-Za-z]')
                    if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
                    then
                      switchname_short=$(echo $switchname|sed 's/\./_/g')
                    else
                      switchname_short=$(echo $switchname|cut -d. -f1)            
                      #switchname=$(nslookup $switchname|grep -iw name|awk '{print $NF}'|sed 's/\.$//')
                    fi
                    #Added this branch to execute checks based on the switch type. check is not execute and not put in skipped if switch type does not match needs_running   
                    skip_this_target=0
		    rskip_os_out_check=0
                    set_skip_this_target $switchname
                    if [[ "$NEEDS_RUNNING" = "$switch_type_running" && $skip_this_target -eq "0" ]]
                    then  
		      call_get_log_result=1
		      COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
		        if [ $op_mode -eq 0 ]
		        then
		          SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		        else
		          SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		        fi
		      else
			SOURCEFIL=$ORIG_SOURCEFIL
		      fi
		      if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out" ]
		      then
		        SOURCEFIL_REPORT=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out"
		      else
		        SOURCEFIL_REPORT=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short".out"
		      fi
		      if [ $OFFLINE -eq 0 ]
		      then
		        if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out" ]
		        then
		      	  SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"s_"$SOURCEFIL"_"$switchname_short"_"report".out"
		        else
		      	  SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"s_"$SOURCEFIL"_"$switchname_short".out"
		        fi
		      else
		        if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out" ]
		        then
		      	  SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out"
		        else
		      	  SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short".out"
		        fi
		      fi
		      SOURCEFIL=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short".out"
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
		        if [ $op_mode -eq 0 ]
		        then
		          FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		        else
		          FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		        fi
		      fi
		      if [ -f $SOURCEFIL ]
		      then
		        case $FIELDPOS in
		          1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
		           ;;
		          2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
		           ;;
		          3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
		           ;;
		          4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
		           ;;
		          5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
		          ;;
		          99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
		          ;;
		        esac
	                move_failed_to_skipped "OS_OUT_CHECK" "" "$switchname" "" "$VAL"
		      else
		        echo "skipping $audit_check_name (checkid:- $CHECK_ID) on $switchname because `basename $SOURCEFIL` not found" >>$SKIPFIL;
		        generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') on $switchname because `basename $SOURCEFIL` not found" 
			generate_exceptions_json "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') on $switchname because `basename $SOURCEFIL` not found"
                        let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			validate_needs_running;
		        #$READ -p "stop here to check skip file"
		      fi
		      PMSG=$(echo $ORIG_PMSG on infiniband switch ${switchname})
		      FMSG=$(echo $ORIG_FMSG on infiniband switch ${switchname})
		      #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
		      if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
		      then
		        get_log_result "inloop" "switch"
		        mb_db_counter_log=$(expr $mb_db_counter_log + 1)
		      fi
                    else
                      if [[ $skip_this_target -eq "1" ]] ; then
                        echo "skip_this_target=1 for $audit_check_name on $switchname so skipping">>$LOGFIL
                      else
                        echo "NEEDS_RUNNING($NEEDS_RUNNING) does not match to switch_type_running($switch_type_running) for $audit_check_name on $switchname so skipping">>$LOGFIL
                      fi
                    fi
		    fi
                    mb_db_counter=$(expr $mb_db_counter + 1) # needed for opstat
                  done
                  mb_db_counter=0
                #$READ -p "after switch os_out_check"
                elif [[ $NEEDS_RUNNING = "STORAGE_CELL" && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP &&  -n "$cell_password_status" && $cell_password_status -ne 3 && $current_exadata_version -lt $check_exadata_version  && "$profiles2run" != "switch" ]]
                then
                  #write_cellname_in_report=1
                  if [ $write_cellname_in_report -eq 1 ]
                  then
                    write_cellname_in_report=0
                    echo "============================================================="|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                    echo "                    Storage server checks                    "|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                    echo "============================================================="|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                  fi
                  #$READ -p "stop to see why its writing"
                  #ORIG_PMSG=$PMSG
                  #ORIG_FMSG=$FMSG
		  call_get_log_result=0
                  cell_count=0
                  cell_count_cwc=0
                  amb_temp_total=0 
                  outcheck_cell_counter=0 
                  amb_temp_cell_count=0
                  unset a_cellname
	          unset a_cellCheckStatus
                  for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'`
                  do 
                    check_status=0
		    orig_cellname=$cellname
                    cellname_short=$(echo $cellname|sed 's/\./_/g') 
                    cellipaddr=$cellname
                    #if [ $OFFLINE -eq 0 ]
                    #then
                    #  cellname=$(cat /etc/hosts|grep "$cellname"|awk '{print $NF}'|cut -d'-' -f1)
                    #else
                    #cellname=$(cat $CELLDIR/cells.out|grep -w "$cellname"|awk '{print $NF}')
                    cellname=$(grep -w "$cellname" $CELLDIR/cells.out|awk '{print $NF}')
                    #fi
		    if [[ -n "$execute_once" && $execute_once -eq "3" && "$first_storage_cell" != "$cellname" ]]; then 
		      echo "skipping $audit_check_name (checkid:- $CHECK_ID) on $cellname because execute_once is true for cell">>$LOGFIL;
		    else
                    mixed_hardware_execute_check=1
		    #if [[ -z $RAT_NO_COMPONENTS_FILTER ]]; then
		    #  cell_component=$(grep -iw "COMPONENTS" $MASTERFIL|grep -w $cellname|cut -d= -f2|cut -d: -f1|sed 's/ //g')
		    #  if [[ -n $cell_component && $cell_component != "" ]]; then
		    #    if [[ "$cell_component" = "V2" ]]; then
		    #        if [[ `echo $check_components|grep -icw DBM` -eq 1 ]]; then mixed_hardware_execute_check=1; fi
		    #    else
		    #      if [[ `echo $check_components|grep -icw "$cell_component"` -eq 0 ]]; then mixed_hardware_execute_check=0; fi
		    #    fi
		    #  else
		    #    cell_component=$(grep -iw "COMPONENTS" $MASTERFIL|grep -w $orig_cellname|cut -d= -f2|cut -d: -f1|sed 's/ //g')
		    #    if [[ -n $cell_component && $cell_component != "" ]]; then
		    #      if [[ "$cell_component" = "V2" ]]; then
		    #        if [[ `echo $check_components|grep -icw DBM` -eq 1 ]]; then mixed_hardware_execute_check=1; fi
		    #      else
		    #        if [[ `echo $check_components|grep -icw "$cell_component"` -eq 0 ]]; then mixed_hardware_execute_check=0; fi
		    #      fi
		    #    fi
		    #  fi
                    #elif [[ $mixed_hardware -gt 1 && -e $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out ]]
                    if [[ $mixed_hardware -gt 1 && -e $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out ]]
                    then
                      #mixed_hardware_cell_type_v2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out| grep -wci "SUN FIRE X4275")
                      #mixed_hardware_cell_type_x2_2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out| grep -wci "SUN FIRE X4[1-2]70 M2")
                      #mixed_hardware_cell_type_x3_2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out| grep -wci "SUN FIRE X4[1-2]70 M3")
                      #mixed_hardware_cell_type_x4_2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out| grep -ci "SUN SERVER X4-2")
                      mixed_hardware_cell_type_v2=$(grep -wci "SUN FIRE X4275" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x2_2=$(grep -wci "SUN FIRE X4[1-2]70 M2" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x3_2=$(grep -wci "SUN FIRE X4[1-2]70 M3" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x4_2=$(grep -ci "SUN SERVER X4-2" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x5_2=$(grep -ci "ORACLE SERVER X5-2" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x6_2=$(grep -ci "ORACLE SERVER X6-2" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x7_2=$(grep -ci "ORACLE SERVER X7-2" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)

                      if [[ -n "$RAT_NO_COMPONENTS_FILTER" && $mixed_hardware_cell_type_v2 -eq 1 && `echo $check_components|grep -icw EXADATA` -eq 0 ]]
		      then
                        mixed_hardware_execute_check=0
                      fi 
		      if [[ -z $RAT_NO_COMPONENTS_FILTER && $mixed_hardware_cell_type_v2 -eq 1 && `echo $check_components|grep -icw DBM` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
		      fi

                      if [[ $mixed_hardware_cell_type_x2_2 -eq 1 && `echo $check_components|grep -icw X2-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi 
                      if [[ $mixed_hardware_cell_type_x3_2 -eq 1 && `echo $check_components|grep -icw X3-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi
                      if [[ $mixed_hardware_cell_type_x4_2 -eq 1 && `echo $check_components|grep -icw X4-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi 
                      if [[ $mixed_hardware_cell_type_x5_2 -eq 1 && `echo $check_components|grep -icw X5-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi 
                      if [[ $mixed_hardware_cell_type_x6_2 -eq 1 && `echo $check_components|grep -icw X6-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi  
                      if [[ $mixed_hardware_cell_type_x7_2 -eq 1 && `echo $check_components|grep -icw X7-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi  
                    fi 

		    rskip_os_out_check=0
                    if [ $mixed_hardware_execute_check -eq 1 ]
                    then 
		      COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
		        if [ $op_mode -eq 0 ]
		        then
		          SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		        else
		          SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		        fi
		      else
			SOURCEFIL=$ORIG_SOURCEFIL;
		      fi
		      cell_outcheck_type=$(echo $SOURCEFIL|cut -d_ -f1)
		      SOURCEFIL_REPORT_CELL=$CELLDIR/"c_"$SOURCEFIL"_"$cellname_short"_report.out"
		      if [[ -n "$cell_outcheck_type" && $cell_outcheck_type = "cbc" ]]
		      then 
		        SOURCEFIL_TRIM=$(echo $SOURCEFIL|sed 's/cbc_//g')
		      elif [[ -n "$cell_outcheck_type" && $cell_outcheck_type = "cwc" ]]
		      then
		        SOURCEFIL_TRIM=$(echo $SOURCEFIL|sed 's/cwc_//g')
		      fi
		      SOURCEFIL_REPORT=$OUTPUTDIR/"c_"$SOURCEFIL_TRIM"_report.out"
		      if [ $OFFLINE -eq 0 ]
		      then
		        SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"c_"$SOURCEFIL_TRIM"_report.out"
		      else
		        SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"c_"$SOURCEFIL_TRIM"_report.out"
		      fi
		      SOURCEFIL=$CELLDIR/"c_"$SOURCEFIL"_"$cellname_short".out"
		      if [[ -e $SOURCEFIL_REPORT_CELL && $OFFLINE -eq 0 && -n "$SOURCEFIL_TRIM" && $ISBRANCH -eq 0 ]]
		      then
		        echo -e "TO REVIEW COLLECTED DATA FROM $(echo $cellname|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >> $SOURCEFIL_REPORT
		        cat $SOURCEFIL_REPORT_CELL >>$SOURCEFIL_REPORT
		        rm -f $SOURCEFIL_REPORT_CELL >/dev/null 2>&1
		        echo -e "\n\n\n" >>$SOURCEFIL_REPORT
		      fi
		      if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
		        if [ $op_mode -eq 0 ]
		        then
		          FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		        else
		          FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		        fi
		      fi
		      if [[ -f $SOURCEFIL && 1 -eq 2 ]]
		      then
		        case $FIELDPOS in
		          1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
		           ;;
		          2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
		           ;;
		          3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
		           ;;
		          4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
		           ;;
		          5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
		          ;;
		          99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
		          ;;
		        esac
	                move_failed_to_skipped "OS_OUT_CHECK" "" "$cellname" "" "$VAL"
		      fi
                      #added this to avoid skipped checks for unreachable storage cells
                      if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log ] 
                      then
                        is_it_skipped_cell=$(grep -icw $cellipaddr $OUTPUTDIR/${program_name}_skipped_nodes.log)
                      fi
		      #if [ -e $SOURCEFIL ]
		      if [[ -e $SOURCEFIL ]] && [[ -n "$rskip_os_out_check" && $rskip_os_out_check -eq "0" ]] 
		      then
		        VAL=$(cat $SOURCEFIL|head -1|awk '{print $1}')
		        call_get_log_result=1

	                move_failed_to_skipped "OS_OUT_CHECK" "" "$cellname" "" "$VAL"
                      elif [[ -n "$is_it_skipped_cell" &&  $is_it_skipped_cell -ge 1 ]]
                      then 
                        echo "skipping $audit_check_name (checkid:-$CHECK_ID) on $cellipaddr because cell is not available" >>$LOGFIL  
                        VAL=$VAL1
		      #else
		      elif [[ -n "$rskip_os_out_check" && $rskip_os_out_check -eq "0" ]]
		      then
		        VAL=$VAL1
		        echo "skipping $audit_check_name (checkid:-$CHECK_ID) on $cellname because `basename $SOURCEFIL` not found" >>$SKIPFIL;
		        generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') on $cellname because `basename $SOURCEFIL` not found" 
			generate_exceptions_json "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') on $cellname because `basename $SOURCEFIL` not found"
		        call_get_log_result=0
                        let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			validate_needs_running;
		      fi
		      unset CELL_VAL
		      if [[ -n "$rskip_os_out_check" && $rskip_os_out_check -eq "0" ]]; then
		        if [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
		        then
		          if [ $cell_count_cwc -eq 0 ]
		          then
		            VAL1=$VAL
		            CELL_VAL=1 
		          else
		            VAL2=$VAL
		            if [ $RAT_DEBUG -eq 1 ]
		            then
		              if [[ -n "$VAL1" && -n "$VAL2" ]] && [ "$VAL1" = "$VAL2" ]
		              then 
		                CELL_VAL=1
		              else
		                CELL_VAL=0
		                cell_count=$(expr $cell_count + 1 )
		              fi 
		            else
		              if [[ -n "$VAL1" && -n "$VAL2" ]] && [ "$VAL1" = "$VAL2" ]  2>>$ERRFIL
		              then 
		                CELL_VAL=1
		              else
		                CELL_VAL=0
		                cell_count=$(expr $cell_count + 1 )
		              fi
		            fi  
		          fi  
		        elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc"  && "$CHECK_ID" != "A4C28178C200A9CBE040E50A1EC00952" ]]
		        then
		          VAL1=$VAL 
		          if [ $RAT_DEBUG -eq 1 ]
		          then
		            if [ "$VAL1" "$OP" "$COMP" ]
		            then
		              CELL_VAL=1 
		            else
		              CELL_VAL=0 
		              cell_count=$(expr $cell_count + 1 ) 
		            fi
		          else
		            if [ "$VAL1" "$OP" "$COMP" ]  2>>$ERRFIL
		            then
		              CELL_VAL=1 
		            else
		              CELL_VAL=0 
		              cell_count=$(expr $cell_count + 1 ) 
		            fi
		          fi   
		        #elif [[ -e $SOURCEFIL && "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952" && `echo $cellname|egrep -ic '01$|02$|03$'` -gt 0 && $outcheck_cell_counter -lt 4 ]] 
		        #then
                        #  amb_temp_total=$(expr $amb_temp_total + $VAL )
                        #  amb_temp_cell_count=$(expr $amb_temp_cell_count + 1 )
                        #fi
		        elif [[ -e $SOURCEFIL && "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952" ]]
		        then
		          VAL1=$VAL 
		          if [ $RAT_DEBUG -eq 1 ]
		          then
		            if [[ $VAL1 -lt 5 || $VAL1 -gt 32 ]]; 
		            then 
		              CELL_VAL=0; 
		            else 
		              CELL_VAL=1; 
                            fi
		          else
		            if [[ $VAL1 -lt 5 || $VAL1 -gt 32 ]] 2>>$ERRFIL
		            then 
		              CELL_VAL=0; 
		            else 
		              CELL_VAL=1; 
                            fi
		          fi   
		          if [[ `echo $cellname|egrep -ic '01$|02$|03$'` -gt 0 && $outcheck_cell_counter -lt 4 ]]; then
		            amb_temp_total=$(expr $amb_temp_total + $VAL )
		            amb_temp_cell_count=$(expr $amb_temp_cell_count + 1 )
		          fi
		        fi    
		        #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
		        if [ -e $SOURCEFIL ];then a_cellname[$cell_count_cwc]=$cellname;fi
		        if [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
		        then
		          if [[ $CELL_VAL -eq 1 ]]; then a_cellCheckStatus[$cell_count_cwc]=PASS;else a_cellCheckStatus[$cell_count_cwc]=$ALVL;fi
		        elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc" ]]
		        then
		          if [[ $CELL_VAL -eq 1 ]]; then a_cellCheckStatus[$cell_count_cwc]=PASS;else a_cellCheckStatus[$cell_count_cwc]=$ALVL;fi
		        fi
		        if [ -e $SOURCEFIL ];then cell_count_cwc=$(expr $cell_count_cwc + 1);fi
		      fi
		      outcheck_cell_counter=$(expr $outcheck_cell_counter + 1)
		      #$READ -p "stop here to check"
		    else
		      echo "$audit_check_name did not execute on $cellname because $old_components does not match with $CELLDIR/c_cbc_CellMakeModel_${cellname}_report.out">>$LOGFIL
		    fi
		    fi
		    #$READ -p "stop here to check for cell check"
                  done
                  #if [[ $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
                  if [[  "$cell_outcheck_type" = "cwc" ]]
                  then
                    if [[ $cell_count -eq 0 && $CELL_VAL -eq 1 ]]; then VAL=$COMP;elif [[ $cell_count -gt 0 ]];then VAL="0123456789XYZ";fi
                  #elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc" ]]
                  elif [[ "$cell_outcheck_type" = "cbc"  && "$CHECK_ID" != "A4C28178C200A9CBE040E50A1EC00952" ]]
                  then
                    if [[ $cell_count -eq 0 && $CELL_VAL -eq 1 ]]; then VAL=$VAL1;elif [[ $cell_count -gt 0 ]];then VAL="0123456789XYZ";fi
                  elif [ "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952"  ] 
                  then
                    if [[ -n "$amb_temp_total"  && $amb_temp_total -gt 0 ]]
                    then
                      amb_temp_avg=$(echo "scale=0;$amb_temp_total / $amb_temp_cell_count"|bc)
                      echo "amb_temp_total=$amb_temp_total and amb_temp_avg=$amb_temp_avg amb_temp_cell_count = $amb_temp_cell_count">>$LOGFIL
                      if [[ $amb_temp_avg -lt 5 || $amb_temp_avg -gt 32 ]]; then VAL=1; else VAL=0; fi
                    else
                      echo "skipping $audit_check_name (checkid:-$CHECK_ID) because this cluster does not access the first three storage servers" >>$SKIPFIL
                      generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because this cluster does not access the first three storage servers" 
		      generate_exceptions_json "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because this cluster does not access the first three storage servers"
                      call_get_log_result=0
                      let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
		      validate_needs_running;
                    fi
                  fi
                  #if [ "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952" ]
                  #then
                  #$READ -p "stop here to check again"
                  #fi
		  #if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
		  if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL"  ]]
		  then
		    get_log_result
	          fi
                  #$READ -p "after switch os_out_check"
                elif [[ -z "$NEEDS_RUNNING" || $NEEDS_RUNNING = "UNSPECIFIED" || $NEEDS_RUNNING = "CRS" || $NEEDS_RUNNING = "ASM" || $NEEDS_RUNNING = "EMAGENT" || $NEEDS_RUNNING = "OMS" ]] && [ $rootYesNoint -ne 3 ] 
                then
		  call_get_log_result=1
		  rskip_os_out_check=0
		  COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
		  if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
		    if [ $op_mode -eq 0 ]
		    then
		      SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		    else
		      SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		    fi
		  fi
                  SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_report_"$i".out"
                  if [ ! -e $SOURCEFIL_REPORT ]; then SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i"_report.out";fi
                  if [ $OFFLINE -eq 0 ]
                  then
                    SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_report_"$i".out"
                    if [ ! -e $SOURCEFIL_REPORT_NEW ]; then SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i"_report.out";fi
                  else
                    SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_report_"$i".out"
                    if [ ! -e $SOURCEFIL_REPORT_NEW ]; then SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i"_report.out";fi
                  fi
		  SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out" 
		  if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
		    if [ $op_mode -eq 0 ]
		    then
		      FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		    else
		      FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		    fi
		  fi
		  if [[ -f $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
		  then
		    case $FIELDPOS in
		      1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
		       ;;
		      2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
		       ;;
		      3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
		       ;;
		      4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
		       ;;
		      5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
		      ;;
		      99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
		      ;;
		    esac
	            move_failed_to_skipped "OS_OUT_CHECK" "" "$i" "" "$VAL"
                  else
                    #if [[ "$NEEDS_RUNNING" != "SWITCH" || "$NEEDS_RUNNING" != "STORAGE_CELL" ]]
                    #then
                    echo "skipping $audit_check_name(checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
                    generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because `basename $SOURCEFIL` not found"
		    generate_exceptions_json "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because `basename $SOURCEFIL` not found"

                    call_get_log_result=0 
                    let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                    let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
		    validate_needs_running;
                    # fi
		  fi
		  #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
		  if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
		  then
		    get_log_result
		  fi
                fi
              fi
              if [ -n "$old_components" ]; then components=$old_components;unset old_components;fi
              #if [ $NEEDS_RUNNING = "STORAGE_CELL" ]; then $READ -p "stop";fi   
              ;;
            SQL_OUT_CHECK)
              if  [[ $component_match_count  -lt 1 ]]
              then
                echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                call_get_log_result=0
		elif [ -z "$profiles2run" ] && [[ -n "$PROFILE_ONLY" && "$PROFILE_ONLY" = "Y" ]]
		then
                  call_get_log_result=0
                  echo "Not running $audit_check_name (CHECK ID $CHECK_ID)  on $i because no profile is in use">>$LOGFIL
                  #generate_exceptions_xml "Skipping $audit_check_name because its profile only"
		elif  [ -e $OUTPUTDIR/cmdexfil.txt ] && [[ `grep -ic $CHECK_ID $OUTPUTDIR/cmdexfil.txt` -ge 1 ]]
                then
                  call_get_log_result=0
                  #echo "Skipping $audit_check_name (CHECK ID $CHECK_ID)  on $i because its excluded">>$EXCLUDELOG
                  generate_exceptions_xml "Skipping $audit_check_name because its excluded"
		  generate_exceptions_json "Skipping $audit_check_name because its excluded"

              elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
              then
                call_get_log_result=0
                echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"  
		generate_exceptions_json "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"

              else
                mb_db_counter=0
                call_get_log_result=1
                COM=`echo "SQL OUT CHECK $PARAM_PATH  $OP  $COMP"`
		if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                  if [ $op_mode -eq 0 ]
                  then
                    SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
                  else
                    SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
                  fi
		else
		  SOURCEFIL=$ORIG_SOURCEFIL
		fi
                #echo "PARAM_PATH=$PARAM_PATH and SOURCEFIL=$SOURCEFIL"
                ORIG_PMSG=$PMSG
                ORIG_FMSG=$FMSG
                for db_name_to_check in "${mb_db_names[@]}"
                do
                  skip_this_version=0
                  set_skip_this_version "-"
                  if [$skip_this_version -eq 1 ]
                  then
                    mb_db_counter=$(expr $mb_db_counter + 1)
                    echo "Skipping check($CHECK_ID) on version 8 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                    continue
                  fi
                  DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
                  PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
                  FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
                  if [ $SOURCEFIL = "check" ]
                  then
               	    SOURCEFIL=$OUTPUTDIR/"d_check_${db_name_to_check}.out"
                  else
               	    SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFIL"_"${db_name_to_check}".out"
                  fi 
		  if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
                    if [ $op_mode -eq 0 ] 
                    then
               	      FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
                    else
               	      FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
                    fi
		  fi
                  #NEEDS_RUNNING="RDBMS"
                  if [ -n "$LEVEL" ] && [ ${stack_asm_up[$stack_counter]} -eq 1 -a ${stack_db_status[$mb_db_counter]} -ne 0 ]
                  then
               	    case $FIELDPOS in
               	      1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
               	       ;;
               	      2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
               	       ;;
               	      3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
               	       ;;
               	      4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
               	       ;;
               	      5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
               	       ;;
               	      99) VAL=`grep -w $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
               	       ;;
               	    esac
               	    if [ $ISBRANCH -eq 0 ]
               	    then
               	      echo "$CHECK_ID|$VAL">>$DBACTUAL
               	    fi
               	    #$READ -p "New SOURCEFIL=$SOURCEFIL"
                    if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
               	    if [[ -n $call_get_log_result && $call_get_log_result -eq 1 ]]; then  get_log_result; fi;
                  fi
                  mb_db_counter=$(expr $mb_db_counter + 1)
                done
		unset db_name_to_check
                mb_db_counter=0
                write_report_on_fail=1
              fi
              ;;
   	    IDMHC_COLLECT)
	      ;;
            *)
              if [ -n "$LEVEL" ]
              then
                echo "INVALID COMMAND TYPE - $COMTYPE"
              fi
     	      ;;
     	  esac # this end case is for rest of the commands which is not included in above all
     	  #echo "grep _$ROW\-$COMTYPE\_COMMAND $REFFIL"# |sed -n 's\/.*$COMTYPE_COMMAND \/\/p'"
 
          get_current_epoch 
          echo -e "[CHECK:$CHECK_ID][HOST: $i][TYPE: $COMTYPE][COLLECTION_NAME: $COLLECTION_NAME][AUDIT_CHECK_NAME: $audit_check_name] Check End Time: $epoch_time" >> $CHK_TIMINGS
          echo -e "" >> $CHK_TIMINGS
     
          #---------------DEBUGGING---------------------    
          
          #     if [ -n "$LEVEL" ]
          #     then
          #       echo ""
          #       echo "ROW = $ROW"
          #       echo "TYPE = $COMTYPE"
          #       echo "PARAM_PATH = $PARAM_PATH"
          #       echo "OPERATOR = $OP"
          #       echo "COMPARE_VALUE = $COMP"
          #       echo "PASS_MSG = $PMSG"
          #       echo "FAIL_MSG = $FMSG"
          #       echo "IS_BRANCH = $ISBRANCH"
          #       echo "LEVEL = $LEVEL"
          #       echo "CURRENT LEVEL = $CUR_LEVEL"
          #       echo "SF = $SF"
          #       echo "CAT = $CAT"
          #       echo "SUBCAT = $SUBCAT"
          #       echo "----------------------------------------------"
          #       echo ""
          #     fi
          #
          #-------------END DEBUGGING--------------------

          # Incase of db related checks, check if run in a loop, the OPSTAT is from last entry in loop
          # To fix that m_opstat array is created
          passed_hosts=$(echo "${m_opstat[$CUR_LEVEL]}" | sed 's/,failedontarget//g' | sed 's/failedontarget//g')
          if [[ -n "$passed_hosts" && $ISBRANCH -eq "1" ]]
          then # Succeeded in atleast one loop
            OPSTAT=1
          fi

          #this code manages traversing down the command hierarchy
          if [[ -z "$COMTYPE"  &&  -z "$LEVEL"  &&  "$L2" -eq 0 ]]
          then
            #this means there were no more "root" commands
            #we've reached the end of the hierarchy
            ROW=
          else
            if [[ $LEVEL -eq 1  &&  $ISBRANCH -eq 0 ]]
            then
              #this is a "root" command and no branching required
              #we've landed on a "non-branching root" command, the simplest case
              #increment the level one counter and re-initailze all the others
              #sets us up to look for the NEXT root command, whether branching or not
              CUR_LEVEL=1
              L1=$(($L1+1))
              L2=0;L3=0;L4=0;L5=0;L6=0;L7=0;L8=0;L9=0;L10=0
            elif [ $ISBRANCH -eq 0 ]
            then
              #the level is implicitly > 1 so we're executing a step at some level
              #we had to have gotten here as the result of a successful branch
              #need to determine if there are aby other commands at this level
              #we shoudl be on CUR_LEVEL.  CUR_LEVEL cannot be = 1
              case $CUR_LEVEL in
                2) L2=$(($L2+1)) ;;
                3) L3=$(($L3+1)) ;;
                4) L4=$(($L4+1)) ;;
                5) L5=$(($L5+1)) ;;
                6) L6=$(($L6+1)) ;;
                7) L7=$(($L7+1)) ;;
                8) L8=$(($L8+1)) ;;
                9) L9=$(($L9+1)) ;;
               10) L10=$(($L10+1)) ;;
                *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [1 - $LEVEL,$CUR_LEVEL]" ;;
              esac
              #echo "L2 = $L2,  ROW = $L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10,  CUR_LEVEL = $CUR_LEVEL"
            elif [[ $ISBRANCH -eq 1  &&  $OPSTAT -eq 1 ]]
            then
              #we're executing a branch at some level, need to take into account the
              #result , success or failure of the branch
              
              #-----------------DEBUGGING--------------------
              #       echo "BRANCH SUCCESS - $ROW"
              #----------------END DEBUGGING----------------
               
              #it the branch succeeds then we need to go a level deeper
              # to look for steps and or other branches
              #there should be steps if the data was entered correctly

              case $LEVEL in
                1) L2=$(($L2+1)) CUR_LEVEL=2 ;;
                2) L3=$(($L3+1)) CUR_LEVEL=3 ;;
                3) L4=$(($L4+1)) CUR_LEVEL=4 ;;
                4) L5=$(($L5+1)) CUR_LEVEL=5 ;;
                5) L6=$(($L6+1)) CUR_LEVEL=6 ;;
                6) L7=$(($L7+1)) CUR_LEVEL=7 ;;
                7) L8=$(($L8+1)) CUR_LEVEL=8 ;;
                8) L9=$(($L9+1)) CUR_LEVEL=9 ;;
                9) L10=$(($L10+1)) CUR_LEVEL=10 ;;
                *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [2 - $LEVEL,$CUR_LEVEL]" ;;
              esac
            elif [[ $ISBRANCH -eq 1  &&  $OPSTAT -eq 0 ]]
            then
              #this could be a branch at any level (1-10) that failed
              #in that case we do not want to pursue any steps or branches
              #in its hierarchy.  we need to go back up one level to see
              #if there are any other steps or branches, except if the failing
              #bracn was already at level 1
              #when a branch fails we need to stay at the same level because
              #there could be other branches or steps at the same level as the
              #failed branch so we just need to increment the counter for the
              #current level as with the ISBRANCH=0 case

              #-----------------DEBUGGING--------------------
              #       echo "BRANCH FAILURE - $ROW"
              #----------------END DEBUGGING----------------
          
              case $CUR_LEVEL in
                1) L1=$(($L1+1)) ;;
                2) L2=$(($L2+1)) ;;
                3) L3=$(($L3+1)) ;;
                4) L4=$(($L4+1)) ;;
                5) L5=$(($L5+1)) ;;
                6) L6=$(($L6+1)) ;;
                7) L7=$(($L7+1)) ;;
                8) L8=$(($L8+1)) ;;
                9) L9=$(($L9+1)) ;;
               10) L10=$(($L10+1)) ;;
                *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [3 - $LEVEL,$CUR_LEVEL]" ;;
              esac
            fi
            ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
          fi
          #re-initialize LEVEL, the next row processed at top of loop should dictate
          #what level we are on byt parsing it from the data
          LEVEL=
        done
        #the above section is only going to be processed if $TYP = -a or -b
        ;;
    esac
  fi #OFFLINE checking for OS commands ends here
  
  case $TYP in
    -a|-p|-f|-u)
      if [[ $SILENT -eq 0 ]] 
      then
        #SCRIPTVER=`grep $DBVERSION $REFFIL |awk {'print $3'}`
        #PATCHVER=`grep $SCRIPTVER $REFFIL |awk {'print $3'}`
        #NON_PCW_NUM=`grep -c RP_COMPARE_VALUE $REFFIL1`
        #if [[ -n "$crsdb_mixed_version" && $crsdb_mixed_version -eq 1 ]]
        #then
        #    PCW_NUM=`grep -c PP_COMPARE_VALUE $REFFIL2`
        #    #$READ -p "it came here and found $PCW_NUM patchs from $REFFIL2"
        #else
        PCW_NUM=`grep -c PP_COMPARE_VALUE $REFFIL1`
        #fi
        if [[ $no_patches -eq 0 && $TYP != "-p" && -n "$db_machine_compute" && $db_machine_compute -eq 0 ]] 
        then
          echo -e "\n\nBest Practice checking completed.Checking recommended patches on ${i}."
          echo -e "---------------------------------------------------------------------------------\n\n"
        fi
      fi
      PATCHRESULT=$OUTPUTDIR/o_patch_result_${i}.out
      pp_crs_pcount=0
      pp_crs_tcount=0
      pp_rdbms_pcount=0
      pp_asm_pcount=0
      rp_rdbms_pcount=0
      rp_rdbms_tcount=0
      rp_asm_pcount=0
      unset rs_crs_applied
      unset rs_rdbms_applied
      unset rs_asm_applied
      if [[ -n "${asm_installed[$stack_counter]}" && ${asm_installed[$stack_counter]} -eq 0 ]]
      then
        unset ASM_HOME
      fi
      ##================================================================================================
      # CHANGED DONE BY GIRI TO QUERY OPATCH RATHER THAN COMPS.XML TO FIND OUT  ABOUT PATCH IF NUMBER OF NODES ARE LESS THAN 5
	   
      #if [ `cat $HOSTLIST |wc -l` -lt 5  ]
      if [[ `cat $HOSTLIST |wc -l` -lt 999 && $OFFLINE -eq 0 ]] 
      then
        echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Recommended patches analysis on ${i}\n">>$RACCHECK_TIMING
        if [ $i = $localnode ]
        then 
          if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "CRS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]] || [[ `echo $components|grep -cwi "SIDB"` -ge 1 && $oracle_restart -eq "1" ]]
          then
	    echo "Collecting patch inventory on CRS HOME $CRS"|tee -a $LOGFIL
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$CRS
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH

	      chg_files_for_usr "ERRFIL" "$ERRFIL"

	      su $dbOwner -c "$CRS/OPatch/opatch lsinventory -oh $CRS > $TMP_OUTPUT/$dbOwner/o_crs_inventory_${i}.out 2>>$ERRFIL"
	      crs_opatch_status=$(echo $?)
	      mv -f $TMP_OUTPUT/$dbOwner/o_crs_inventory_${i}.out $OUTPUTDIR >/dev/null 2>&1 

	      write_del_rolbk_errlog

              write_del_rolbk_tmpoutput
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $CRS/OPatch/opatch lsinventory -oh $CRS > $OUTPUTDIR/o_crs_inventory_${i}.out 2>>$ERRFIL
	      crs_opatch_status=$(echo $?)
	    fi
	    #if opatch fails then copy comps.xml as second source of patch info
	    if [ $crs_opatch_status  -ne 0 ]
	    then 
	      echo "Opatch failed with error code $crs_opatch_status on $i for $CRS.\n\n${program_name} will use $CRS/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
	      cat $CRS/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_crs_inventory_${i}.out
	    fi
	    if [ $crs_opatch_status  -eq 0 ]
	    then
	      grep -w ^Patch $OUTPUTDIR/o_crs_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_crs_patchlist_${i}.out
              echo "$i|crs|$CRS|${stack_crs_version[$stack_counter]}">$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
	      grep -w ^Patch $OUTPUTDIR/o_crs_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
	    fi
          fi

          if [ -n "$ASM_HOME" ] && [[ `echo $components|grep -cwi "NONE"` -ge 1 || `echo $components|grep -icw "ASM"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
	  then
            echo "Collecting patch inventory on ASM HOME $ASM_HOME"|tee -a $LOGFIL
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$ASM_HOME
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH

	      chg_files_for_usr "ERRFIL" "$ERRFIL"

	      su $dbOwner -c "$ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME > $TMP_OUTPUT/$dbOwner/o_asm_inventory_${i}.out 2>>$ERRFIL"
              asm_opatch_status=$(echo $?)
	      mv -f $TMP_OUTPUT/$dbOwner/o_asm_inventory_${i}.out $OUTPUTDIR >/dev/null 2>&1 

	      write_del_rolbk_errlog

              write_del_rolbk_tmpoutput
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME > $OUTPUTDIR/o_asm_inventory_${i}.out 2>>$ERRFIL
              asm_opatch_status=$(echo $?)
	    fi
            if [ $asm_opatch_status -ne 0 ]
            then 
              echo "Opatch failed with error code $asm_opatch_status on $i for $ASM_HOME.\n\n${program_name} will use $ASM_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
              cat $ASM_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_asm_inventory_${i}.out
            fi
            if [ $asm_opatch_status -eq 0 ]
            then
              grep ^Patch $OUTPUTDIR/o_asm_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_asm_patchlist_${i}.out
              echo "$i|asm|$ASM_HOME|$asm_version">$OUTPUTDIR/o_asm_installed_patchlist_${i}.out
              grep ^Patch $OUTPUTDIR/o_asm_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_asm_installed_patchlist_${i}.out 
            fi
	  fi

          if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "RDBMS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 || `echo $components|grep -icw "SIDB"` -ge 1 ]] 
          then
	    mb_db_counter=0
            for mb_db_homes in ${mb_oracle_homes_distinct[@]}
            do
              mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
              #$READ -p "mb_db_homes=$mb_db_homes"
              if [ -d $mb_db_homes ] 
              then
                rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
                if [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 && $rdbms_home_version -ne $targetversion ]]
                then
                  echo "Skipping $mb_db_homes because running in post upgrade and version is $rdbms_home_version">>$LOGFIL
                else
              	  echo "Collecting patch inventory on ORACLE_HOME $mb_db_homes "|tee -a $LOGFIL
              	  export ORACLE_HOME=$mb_db_homes
		  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
		    get_dbOwner
		    if [[ -z $dbOwner ]]; then mb_db_counter=$(expr $mb_db_counter + 1); continue; fi

	            chg_files_for_usr "ERRFIL" "$ERRFIL"

		    su $dbOwner -c "$ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME > $TMP_OUTPUT/$dbOwner/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL"
              	    rdbms_opatch_status=$(echo $?)
		    mv -f $TMP_OUTPUT/$dbOwner/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out $OUTPUTDIR >/dev/null 2>&1

  	 	    write_del_rolbk_errlog

              	    write_del_rolbk_tmpoutput
	      	    cd $OLD_DIR
	    	    unset OLD_DIR
		  else
              	    $ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL
              	    rdbms_opatch_status=$(echo $?)
		  fi
              	  if [ $rdbms_opatch_status -ne 0 ]
              	  then 
              	    echo  "Opatch failed with error code $rdbms_opatch_status on $i for $ORACLE_HOME.\n\n${program_name} will use $ORACLE_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
              	    if [ -e $ORACLE_HOME/inventory/ContentsXML/comps.xml ]; then 
		      cat $ORACLE_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out; 
		    fi
              	  fi
              	  if [ $rdbms_opatch_status -eq 0 ]
              	  then
              	    grep ^Patch $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${i}.out
                    echo "$i|rdbms|$ORACLE_HOME|$rdbms_home_version">$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
                    grep ^Patch $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
              	  fi
                fi
              fi
              mb_db_counter=$(expr $mb_db_counter + 1)
            done
            mb_db_counter=0
          fi
        else    
          if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "CRS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1  ]] || [[ `echo $components|grep -cwi "SIDB"` -ge 1 && $oracle_restart -eq "1" ]]  
          then
	    echo "Collecting patch inventory on CRS HOME $CRS "|tee -a $LOGFIL
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$CRS
	      get_dbOwner $i
	      ORACLE_HOME=$OLD_OH

	      chg_files_for_usr "ERRFIL" "$ERRFIL"

	      $SSHELL $i "su $dbOwner -c \"$CRS/OPatch/opatch lsinventory -oh $CRS\"" > $TMP_OUTPUT/$dbOwner/o_crs_inventory_${i}.out 2>>$ERRFIL
	      crs_opatch_status=$(echo $?)
	      mv -f $TMP_OUTPUT/$dbOwner/o_crs_inventory_${i}.out $OUTPUTDIR >/dev/null 2>&1

	      write_del_rolbk_errlog

              write_del_rolbk_tmpoutput
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $SSHELL $i $CRS/OPatch/opatch lsinventory -oh $CRS > $OUTPUTDIR/o_crs_inventory_${i}.out 2>>$ERRFIL
	      crs_opatch_status=$(echo $?)
	    fi
	    if [ $crs_opatch_status  -ne 0 ] 
	    then 
	      echo "Opatch failed with error code $crs_opatch_status on $i for $CRS.\n\n${program_name} will use $CRS/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">>$LOGFIL
	      $SSHELL $i  cat  $CRS/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_crs_inventory_${i}.out
	    fi
	    if [ $crs_opatch_status  -eq 0 ]
	    then
	      grep ^Patch $OUTPUTDIR/o_crs_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_crs_patchlist_${i}.out
              echo "$i|crs|$CRS|${stack_crs_version[$stack_counter]}">$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
              grep -w ^Patch $OUTPUTDIR/o_crs_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
	    fi
          fi

          if [ -n "$ASM_HOME" ] && [[ `echo $components|grep -cwi "NONE"` -ge 1  || `echo $components|grep -icw"ASM"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
	  then
            echo "Collecting patch inventory on ASM HOME $ASM_HOME "|tee -a $LOGFIL
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$ASM_HOME
	      get_dbOwner $i
	      ORACLE_HOME=$OLD_OH

	      chg_files_for_usr "ERRFIL" "$ERRFIL"

	      $SSHELL $i "su $dbOwner -c \"$ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME\"" > $TMP_OUTPUT/$dbOwner/o_asm_inventory_${i}.out 2>>$ERRFIL
              asm_opatch_status=$(echo $?)
	      mv -f $TMP_OUTPUT/$dbOwner/o_asm_inventory_${i}.out $OUTPUTDIR >/dev/null 2>&1

	      write_del_rolbk_errlog

              write_del_rolbk_tmpoutput
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $SSHELL $i $ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME > $OUTPUTDIR/o_asm_inventory_${i}.out 2>>$ERRFIL
              asm_opatch_status=$(echo $?)
	    fi
            if [ $asm_opatch_status -ne 0 ]
            then
              echo "Opatch failed with error code $asm_opatch_status on $i for $ASM_HOME.\n${program_name} will use $ASM_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
              $SSHELL $i cat $ASM_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_asm_inventory_${i}.out
            fi
            if [ $asm_opatch_status -eq 0 ]
            then
              grep ^Patch $OUTPUTDIR/o_asm_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_asm_patchlist_${i}.out
              echo "$i|asm|$ASM_HOME|$asm_version">$OUTPUTDIR/o_asm_installed_patchlist_${i}.out
              grep ^Patch $OUTPUTDIR/o_asm_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_asm_installed_patchlist_${i}.out
            fi
	  fi
          if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "RDBMS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
	  then
	    mb_db_counter=0
	    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
	    do
	      mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
	      validate_remote_oracle_home=$($SSHELL $i ls -l $mb_db_homes >/dev/null 2>&1;echo $?)
	      if [[ -n "$validate_remote_oracle_home" && $validate_remote_oracle_home -eq 0 ]]
	      then
                rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
                if [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 && $rdbms_home_version -ne $targetversion ]]
                then
	          echo "Skipping $mb_db_homes because running in post upgrade and version is $rdbms_home_version">>$LOGFIL
		else
		  echo "Collecting patch inventory on ORACLE_HOME $mb_db_homes "|tee -a $LOGFIL
		  export ORACLE_HOME=$mb_db_homes
		  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
		    get_dbOwner $i
		    if [[ -z $dbOwner ]]; then mb_db_counter=$(expr $mb_db_counter + 1); continue; fi
		    chg_files_for_usr "ERRFIL" "$ERRFIL"

		    $SSHELL $i "su $dbOwner -c \"$ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME\"" > $TMP_OUTPUT/$dbOwner/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL
		    rdbms_opatch_status=$(echo $?)
		    mv -f $TMP_OUTPUT/$dbOwner/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out $OUTPUTDIR >/dev/null 2>&1

		    write_del_rolbk_errlog

              	    write_del_rolbk_tmpoutput
	      	    cd $OLD_DIR
	    	    unset OLD_DIR
		  else
		    $SSHELL $i $ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL
		    rdbms_opatch_status=$(echo $?)
		  fi
		  if [ $rdbms_opatch_status -ne 0 ]
		  then 
		    echo  "Opatch failed with error code $rdbms_opatch_status on $i for $ORACLE_HOME.\n\n${program_name} will use $ORACLE_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
		    $SSHELL $i cat $ORACLE_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out
		  fi
		  if [ $rdbms_opatch_status -eq 0 ]
		  then
		    grep ^Patch $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${i}.out
                    echo "$i|rdbms|$ORACLE_HOME|$rdbms_home_version">$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
                    grep ^Patch $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
		  fi
                fi
	      fi
	      mb_db_counter=$(expr $mb_db_counter + 1)
	    done
	    mb_db_counter=0
          fi
        fi
      else
        if [ $SILENT = 1 ]
        then
          cp -f $CRS_INVENTORY $OUTPUTDIR/o_crs_comps_${i}.xml
          cp -f $RDBMS_INVENTORY $OUTPUTDIR/o_rdbms_comps_${i}xml
          if [[ -n $ASM  && $g112 -gt 0 ]]
          then
            cp -f $ASM_INVENTORY $OUTPUTDIR/o_asm_comps_${i}.xml
          fi
        fi
      fi
      ##================================================================================================
      #To format headings for patches on screen,output file and logfile 
      #IF RUNNING IN SILENT MODE, DONT CHECK PATCHES APPLIED OR NOT. JUST DUMP THE PATCH FILES ON OUTPUTDIR	
      #echo "DEBUG SILENT=$SILENT and RUNSWITCH=$RUNSWITCH"

      if [[ $SILENT -eq "0" && $RUNSWITCH != "-b"  &&  $no_patches -eq 0 && $db_machine_compute -eq 0 && $oda_machine -eq 0 ]]
      then  
        fmt_recomended="Patch#"
        fmt_rdbms="RDBMS"
        fmt_crs="CRS"
        fmt_asm="ASM"
        fmt_rdbms_home="RDBMS_HOME"
        fmt_patch_type_header="type"
        fmt_dscrp="Patch-Description"
        fmt_patch_yes="yes"
        fmt_patch_no="no"
        fmt_patch_type_merge="merge"
        fmt_patch_type_oneoff="single"
        fmt_hname=`echo $i`
        fmt_line_header="---------------------------------------------------------------------------------"
        fmt_ppheader_1="Total patches"
	fmt_ppheader_2="Applied on CRS"
	fmt_ppheader_4="Applied on ASM"
        fmt_ppheader_3="Applied on RDBMS"
        fmt_rpheader_1="Total patches"
        fmt_rpheader_2="Applied on RDBMS"
        fmt_rpheader_3="Applied on ASM"
        crs_patch_printed_html=0 # gadiga  track first time print to print heading
        pp_crs_tcount=$PCW_NUM
        if [[ $CREATE_HTML_REPORT -eq 1 && -e ${OUTPUTDIR}/o_crs_inventory_${i}.out ]]
        then
          print_crs_patch_detail_heading_html;
        fi
        set old_patch_type
        if [ -e ${OUTPUTDIR}/o_crs_inventory_${i}.out ]
        then
      	  echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
      	  pcw_rec_num=$PCW_NUM
      	  RCPATCH=`grep _1-PP_RECOMMEND_VALUE $REFFIL1 |awk {'print $2'}`
      	  if [[ -n $RCPATCH ]] ; then pcw_rec_num=1; fi
      	  echo "$pcw_rec_num Recommended CRS patches for `echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g'` from ${CRS} on $fmt_hname"|tee -a $LOGFIL|tee -a $PREPFIL
      	  echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
      	  echo $fmt_recomended $fmt_crs $fmt_asm $fmt_rdbms $fmt_rdbms_home  $fmt_dscrp|awk '{printf "%-9s%-5s%-7s%-6s%-40s%-45s\n",$1,$2,$3,$4,$5,$6}'|tee -a $LOGFIL|tee -a $PREPFIL
      	  echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
          if [[ $CREATE_HTML_REPORT -eq 1 && $PCW_NUM -eq "0" ]]
          then # For html report.. as we dont enter for loop, tell user that there are no patches
            print_crs_patch_detail_html;
          fi
      	  #for ((j=1; j<=($PCW_NUM); j+=1));
	  j=1
	  while [[ $j -le $PCW_NUM ]]
      	  do
      	    SUBJ=`grep "_"$j"-PP_COMMAND" $REFFIL1 |sed  -n 's/.*-PP_COMMAND //p'` 
      	    PATCH=`grep _$j-PP_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
      	    RCPATCH=`grep _$j-PP_RECOMMEND_VALUE $REFFIL1 |awk {'print $2'}`
      	    PATCHTYPE=`grep _$j-PP_PARAM_PATH $REFFIL1 |awk {'print $2'}`
            PATCH2CHK=$PATCH
      	    if [ -n "$RCPATCH" ] ; then 
               PATCH=$RCPATCH; 
	       PATCH_PRINT=$RCPATCH;
	       SUBJ_PRINT=$SUBJ
            fi
      	    #==========================================================================================
      	    check_patch "crs" "$PATCH2CHK"
      	    ###=========================================================================================
      	    if [ -n "$RCPATCH" ] ; then pp_crs_tcount=1; fi
      	    if [ "$APPLIED" -gt "0" ]
      	    then
      	      fmt_crs_applied=$fmt_patch_yes
      	      rs_crs_applied=1
      	      pp_crs_pcount=$(($pp_crs_pcount+1))
      	      if [ -n "$RCPATCH" ] ; then pp_crs_pcount=1; fi
      	      #Added by kumar
      	      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	      then
      	        echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','crs','$CRS','${stack_crs_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	      fi
      	    else
      	      fmt_crs_applied=$fmt_patch_no
      	      rs_crs_applied=0
      	      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	      then
      	  	echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','crs','$CRS','${stack_crs_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	      fi
      	    fi
      	    mb_db_counter=0
      	    #$READ -p "${mb_db_versions_all[$mb_db_counter]} and  ${stack_crs_version[$stack_counter]}"
      	    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
      	    do
      	      mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
      	      if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
      	      then
      	        rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
      	        #$READ -p "rdbms_home_version=$rdbms_home_version"
      	        if [[ -n "${stack_crs_version[$stack_counter]}" && -n "$rdbms_home_version" && ${rdbms_home_version} -eq `echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g'` ]]
      	        then
      	          mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
      	          #==========================================================================================
      	          if [ -n "$RCPATCH" ] ; then 
                    j_k_applied=0
                    for j_k in `grep "PP_RECOMMEND_VALUE $RCPATCH" $REFFIL1 |cut -d"-" -f1 | tr -d "_"`
                    do
                      j_k_PATCH=`grep _$j_k-PP_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
                      check_patch "rdbms" "$j_k_PATCH"
                      j_k_applied=$(expr $j_k_applied + $APPLIED)
                    done 
                    APPLIED=$j_k_applied
                  else
      	            check_patch "rdbms" "$PATCH2CHK"
                  fi
      	          #==========================================================================================
                  #echo "patch log rdbms_home_version=$rdbms_home_version and mb_db_homes=$mb_db_homes for $i for CRS" 
		  print_rdbms_home_version=${rdbms_home_version};
		  if [[ -n "$print_rdbms_home_version" && `echo "$print_rdbms_home_version"|grep -c "\."` -eq 0 ]]; then
  		    print_rdbms_home_version=$(echo "$print_rdbms_home_version" | sed 's/[0-9]/&./g' | sed 's/\.//' | sed 's/.$//');
		  fi
      	          if [ "$APPLIED" -gt "0" ]
      	          then
      	      	    mb_fmt_rdbms_applied[$mb_db_counter]=$fmt_patch_yes
      	      	    mb_rs_rdbms_applied[$mb_db_counter]=1
      	      	    pp_rdbms_pcount=$(($pp_rdbms_pcount+1))
      	            if [ -n "$RCPATCH" ] ; then pp_rdbms_pcount=1; fi
      	      	    mb_pp_rdbms_pcount[$mb_db_counter]=$pp_rdbms_pcount
      	      	    mb_crs_oh[$mb_db_counter]=$mb_db_homes
      	      	    #Added by kumar
      	      	    if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	      	    then
      	      	      echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','${mb_db_homes}','${print_rdbms_home_version}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	      	    fi
      	          else
      	            mb_fmt_rdbms_applied[$mb_db_counter]=$fmt_patch_no
      	            mb_rs_rdbms_applied[$mb_db_counter]=0
      	            mb_crs_oh[$mb_db_counter]=$mb_db_homes
      	            if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	            then
      	              echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','${mb_db_homes}','${print_rdbms_home_version}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	            fi
      	          fi
      	     	fi
      	      fi
      	      mb_db_counter=$(expr $mb_db_counter + 1)
      	    done
      	    rdbms_home_count_for_crs=$mb_db_counter
      	    mb_db_counter=0
      	    if [[ -n "$ASM_HOME" && -e ${OUTPUTDIR}/o_asm_inventory_${i}.out ]]
      	    then
      	      #==========================================================================================
      	      check_patch "asm" "$PATCH2CHK"
      	      ###=========================================================================================
              asm_version=$(grep $i $MASTERFIL|grep -w VERSION|awk '{print $3}') 
              if [ -z "$asm_version" ]; then asm_version=${stack_crs_version[$stack_counter]};fi
      	      if [ "$APPLIED" -gt "0" ]
      	      then
      	        fmt_asm_applied=$fmt_patch_yes
      	        rs_asm_applied=1
      	        pp_asm_pcount=$(($pp_asm_pcount+1))
      	        if [ -n "$RCPATCH" ] ; then pp_asm_pcount=1; fi
      	        #Added by kumar
      	        if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	        then
      	  	  echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','$asm_version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	        fi
      	      else
      	         fmt_asm_applied=$fmt_patch_no
      	         rs_asm_applied=0
      	         if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	         then
      	  	   echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','$asm_version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	         fi
      	      fi
      	    fi
            ####  #################################################
            if [ "$P_PATCH" != "$PATCH" ] ; then
      	    if [ $PATCHTYPE = "Merge" ] 
      	    then
      	      fmt_patch_type=$fmt_patch_type_merge
      	    else
      	      fmt_patch_type=$fmt_patch_type_oneoff
      	    fi
      	    #if [ $OFFLINE -eq 0 ] 
      	    #then
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
                echo $PATCH_PRINT |awk '{printf "%-9s",$1}'
	    else
		echo $PATCH |awk '{printf "%-9s",$1}'
	    fi
            if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
            then
	     if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
	      fmt_subj=`echo $SUBJ_PRINT |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,79)}'`
	     else
      	      fmt_subj=`echo $SUBJ |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,79)}'`
	     fi
      	      if [ $fmt_crs_applied = $fmt_patch_yes ]
      	      then
      	        echo -e $GREEN$fmt_crs_applied$NORM|$AWK '{printf "%-5s",$2}'
      	      else
      	        echo -e $RED $fmt_crs_applied $NORM|$AWK '{printf "%-5s",$2}'
      	      fi
      	      if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
      	      then
      	        echo -e $GREEN $fmt_asm_applied $NORM|$AWK '{printf "%-6s",$2}'
      	      else
      	        echo -e $RED $fmt_asm_applied $NORM|$AWK '{printf "%-6s",$2}'
      	      fi
      	      mb_db_counter=0
      	      for mb_db_homes in ${mb_oracle_homes_distinct[@]}
      	      do
      	        if [ -n "${mb_fmt_rdbms_applied[$mb_db_counter]}" ]
      	        then
      	          fmt_rdbms_applied=${mb_fmt_rdbms_applied[$mb_db_counter]}
      	          mb_crs_rdbms_home=${mb_crs_oh[$mb_db_counter]}
      	          if [ $fmt_rdbms_applied = $fmt_patch_yes ]
      	          then
      	      	    echo -e $GREEN $fmt_rdbms_applied $NORM|$AWK '{printf "%-7s",$2}'
      	          else
      	      	    echo -e $RED $fmt_rdbms_applied $NORM|$AWK '{printf "%-7s",$2}'
      	          fi
      	          echo -e $mb_crs_rdbms_home|$AWK '{printf "%-19s",$1}'
      	        fi
      	        mb_db_counter=$(expr $mb_db_counter + 1)
      	      done  
      	      mb_db_counter=0
            else
             if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              fmt_subj=`echo $SUBJ_PRINT |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,79)}'`
             else
              fmt_subj=`echo $SUBJ |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,79)}'`
             fi
      	      if [ $fmt_crs_applied = $fmt_patch_yes ]
      	      then
      	        echo -e $GREEN$fmt_crs_applied$NORM|$AWK '{printf "%-20s",$fmt_crs_applied}'
      	      else
      	        echo -e $RED $fmt_crs_applied $NORM|$AWK '{printf "%-20s",$fmt_crs_applied}'
      	      fi
      	      if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
      	      then
      	        echo -e $GREEN $fmt_asm_applied $NORM|$AWK '{printf "%-20s",$fmt_asm_applied}'
      	      else
      	        echo -e $RED $fmt_asm_applied $NORM|$AWK '{printf "%-20s",$fmt_asm_applied}'
      	      fi
      	      mb_db_counter=0
              #echo  "mb_fmt_rdbms_applied=${mb_fmt_rdbms_applied[@]} and mb_crs_oh=${mb_crs_oh[@]}"
      	      for mb_db_homes in ${mb_oracle_homes_distinct[@]}
      	      do
      	        if [ -n "${mb_fmt_rdbms_applied[$mb_db_counter]}" ]
      	        then
      	      	  #$READ -p "fmt_rdbms_applied=$fmt_rdbms_applied and fmt_patch_yes=$fmt_patch_yes array=${mb_fmt_rdbms_applied[$mb_db_counter]}"
      	      	  fmt_rdbms_applied=${mb_fmt_rdbms_applied[$mb_db_counter]}
      	      	  mb_crs_rdbms_home=${mb_crs_oh[$mb_db_counter]}
      	      	  if [ $fmt_rdbms_applied = $fmt_patch_yes ]
      	      	  then
      	      	    echo -e $GREEN $fmt_rdbms_applied $NORM|$AWK '{printf "%-19s",$fmt_rdbms_applied}'
      	      	  else
      	      	    echo -e $RED $fmt_rdbms_applied $NORM|$AWK '{printf "%-19s",$fmt_rdbms_applied}'
      	      	  fi
      	      	  echo -e $mb_crs_rdbms_home|$AWK '{printf "%-19s",$mb_crs_rdbms_home}'
                  #echo -e "\n"|awk '{printf "%-40s",$1}'
      	          #echo -e $mb_db_homes|awk '{printf "%-40s",$mb_db_homes}'
      	        fi
      	        mb_db_counter=$(expr $mb_db_counter + 1)
      	      done
      	      mb_db_counter=0
              #$READ -p "stop"
            fi #end if of uname -s AIX
      	    #echo $fmt_patch_type|awk '{printf "%-8s",$fmt_patch_type}'
      	    #echo $fmt_patch_type|awk '{printf "%-8s",$1}'
      	    echo $PATCH $fmt_crs_applied $fmt_asm_applied $fmt_rdbms_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'>>$PREPFIL
      	    echo $PATCH $fmt_crs_applied $fmt_asm_applied $fmt_rdbms_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'>>$LOGFIL
      	    #$READ -p "PATCHRESULT=$PATCHRESULT"
      	    echo $PATCH@$rs_crs_applied@$rs_rdbms_applied@$rs_asm_applied >>$PATCHRESULT
      	    #echo $fmt_subj |awk '{printf "%-45s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $REPFIL

      	    if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
      	    then
      	      echo $fmt_subj |$AWK 'BEGIN { FS = "\n" };{printf "%-45s\n",$1}'|tee -a $LOGFIL | tee -a $PREPFIL
      	    else
      	      echo $fmt_subj |$AWK '{printf "%-45s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $PREPFIL
      	    fi
            fi #if [ "$P_PATCH" != "$PATCH" ] ; then
            P_PATCH=$PATCH

            if [ $CREATE_HTML_REPORT -eq 1 ]
            then
              print_crs_patch_detail_html;
            fi
      	    #else
      	    #echo $PATCH $fmt_crs_applied $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'|tee -a $FREPFIL
      	    #echo $fmt_subj |awk '{printf "%-45s\n",$fmt_subj}'|tee -a $FREPFIL
            #fi
    	    #########################################################6
	  j=$(( j+1 ))
          done
        fi
        mb_db_counter=0
        OLD_REFFIL1=$REFFIL1
        P_PATCH=""
        #echo "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} all version=${mb_db_version_all[@]}"
        if [[ -n "$single_instance_run" && $single_instance_run -eq "1" ]] ; then 
          if [[ -n "$oracle_restart" && $oracle_restart -eq 1 ]] ; then
            patch_prefix="RP";
          else
	    patch_prefix="SP"; 
          fi
        else 
          patch_prefix="RP"; 
        fi;

        for mb_db_homes in ${mb_oracle_homes_distinct[@]}
        do  
          mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
          rp_rdbms_pcount=0
          rp_asm_pcount=0 
          if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
          then           
	    if [[ -n $crsdb_mixed_version && $crsdb_mixed_version -eq 1 ]]
	    then
              rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
	      if [ $OFFLINE -eq 0 ]
	      then 
	        REFFIL1=$INPUTDIR/rules_${rdbms_home_version}.dat
	        #REFFIL1=$INPUTDIR/rules_${mb_db_versions_all[$mb_db_counter]}.dat
	      else
	        REFFIL1=$DUMPDIR/rules_${rdbms_home_version}.dat
	      fi
	    fi
            #echo "mb_db_homes=$mb_db_homes $DUMPDIR/mb_db_homes_distinct.out crsdb_mixed_version=$crsdb_mixed_version" 
            NON_PCW_NUM=0  
	    if [ -r $REFFIL1 ]; then NON_PCW_NUM=$(grep -c ${patch_prefix}_COMPARE_VALUE $REFFIL1 2>$ERRFIL);fi
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	    echo "" |tee -a $LOGFIL |tee -a $PREPFIL
	    echo "" |tee -a $LOGFIL |tee -a $PREPFIL
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
            non_pcw_rec_num=$NON_PCW_NUM
            RCPATCH=`grep _1-${patch_prefix}_RECOMMEND_VALUE $REFFIL1 |awk {'print $2'}`
            if [[ -n $RCPATCH ]] ; then non_pcw_rec_num=1; fi
	    echo "$non_pcw_rec_num Recommended RDBMS patches for ${rdbms_home_version} from ${mb_oracle_homes_distinct[$mb_db_counter]} on $i"|tee -a $LOGFIL|tee -a $PREPFIL
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	    echo $fmt_recomended $fmt_rdbms $fmt_asm $fmt_patch_type_header $fmt_dscrp|awk '{printf "%-9s%-9s%-8s%-20s%-40s\n",$1,$2,$3,$4,$5}'|tee -a $LOGFIL|tee -a $PREPFIL
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	    unset rs_crs_applied
	    unset rs_rdbms_applied
	    unset rs_asm_applied
	    napply_rdbms_cnt=0
	    napply_asm_cnt=0
	    napply_molecule=0
	    napply_molecule_cnt=1
	    unset rdbms_napply_missing_list
	    unset asm_napply_missing_list
            printed_rdbms_patch_html=0 # gadiga added to track first time
            rp_rdbms_tcount=${NON_PCW_NUM}
            if [[ $CREATE_HTML_REPORT -eq 1 && $NON_PCW_NUM -eq "0" ]]
            then
              print_rdbms_patch_detailed_html
            fi
	    #$READ -p "File being used $REFFIL1"
	    #$READ -p "File being used is $REFIL1 mb_db_counter=$mb_db_counter"
	    for ((j=1;j<=${NON_PCW_NUM:-0};j+=1)); 
	    do
	      y=1
	      unset isnapply
	      SUBJ=`grep "_"$j"-${patch_prefix}_COMMAND" $REFFIL1 |sed  -n 's/.*-'${patch_prefix}'_COMMAND //p'`
	      PATCH=`grep _$j-${patch_prefix}_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
	      RCPATCH=`grep _$j-${patch_prefix}_RECOMMEND_VALUE $REFFIL1 |awk {'print $2'}`
	      PATCHTYPE=`grep _$j-${patch_prefix}_PARAM_PATH $REFFIL1 |awk {'print $2'}`
              PATCH2CHK=$PATCH
              if [ -n "$RCPATCH" ] ; then
                 PATCH=$RCPATCH;
              fi
              #if [[ -n "$oracle_restart" && $oracle_restart -eq 1 ]] ; then PATCH2CHK=$RCPATCH; fi
	      #$READ -p "PATCHTYPE=$PATCHTYPE"
	      #PATCHTYPE=`grep _$j-RP_PARAM_PATH $REFFIL1 |sed  -n 's/.*-RP_PARAM_PATH //p'`
	      
	      if [ $PATCHTYPE = "Merge" ]
	      then
	        fmt_patch_type=$fmt_patch_type_merge
	        isnapply=0
	      elif [ `echo $PATCHTYPE|grep -c "N-APPLY("` -ge 1 ]
	      then
	        isnapply=1
	        SUBJ=`grep "_"$j"-${patch_prefix}_COMMAND_SUBJ" $REFFIL1 |sed  -n 's/.*-'${patch_prefix}'_COMMAND_SUBJ//p'`
	        napply_molecule=$(grep -c $PATCHTYPE $REFFIL1)
	        fmt_patch_type=$(echo $PATCHTYPE|cut -d'(' -f1)
	      else
	        isnapply=0
	        fmt_patch_type=$fmt_patch_type_oneoff
	      fi
	      #if [[ $old_patch_type = $PATCHTYPE && $isnapply -eq 1 ]] 
	      #then
	      #  fmt_patch_type="$napply_molecule "
	      #fi  
	      #old_patch_type=$PATCHTYPE
	      #==========================================================================================
              if [ -n "$RCPATCH" ] ; then
                if [[ -n "$oracle_restart" && $oracle_restart -eq 1 ]] ; then
	          check_patch "rdbms" "$PATCH2CHK"
                else
                  j_k_applied=0
                  for j_k in `grep "${patch_prefix}_RECOMMEND_VALUE $RCPATCH" $REFFIL1 |cut -d"-" -f1 | tr -d "_"`
                  do
                    j_k_PATCH=`grep _$j_k-${patch_prefix}_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
                    check_patch "rdbms" "$j_k_PATCH"
                    j_k_applied=$(expr $j_k_applied + $APPLIED)
                  done
                  APPLIED=$j_k_applied
                fi
              else
	        check_patch "rdbms" "$PATCH2CHK"
              fi
	      ###=========================================================================================
              #echo "patch log rdbms_home_version=$rdbms_home_version and mb_db_homes=$mb_db_homes for $i for RDBMS" 
      	      if [ -n "$RCPATCH" ] ; then rp_rdbms_tcount=1; fi
	      print_rdbms_home_version=${rdbms_home_version};
  	      if [[ -n "$print_rdbms_home_version" && `echo "$print_rdbms_home_version"|grep -c "\."` -eq 0 ]]; then
	        print_rdbms_home_version=$(echo "$print_rdbms_home_version" | sed 's/[0-9]/&./g' | sed 's/\.//' | sed 's/.$//');
	      fi
	      if [ "$APPLIED" -gt "0" ]
	      then
	        fmt_rdbms_applied=$fmt_patch_yes
	        rs_rdbms_applied=1
	        rp_rdbms_pcount=$(($rp_rdbms_pcount+1))
      	        if [ -n "$RCPATCH" ] ; then rp_rdbms_pcount=1; fi
	        if [ $isnapply -eq 1 ]
	        then 
	          napply_rdbms_cnt=$(($napply_rdbms_cnt+1))
	          fmt_rdbms_applied_napply=$(echo ${napply_rdbms_cnt}/${napply_molecule})
	        fi
	        #Added by kumar
	        if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	        then
	          echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','${mb_db_homes}','${print_rdbms_home_version}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
	        fi   
	      else
	        fmt_rdbms_applied=$fmt_patch_no
	        rs_rdbms_applied=0
	        #Added by kumar
	        if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	        then   
	          echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','${mb_db_homes}','${print_rdbms_home_version}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
	        fi 
	        if [ $isnapply -eq 1 ]
	        then 
	          fmt_rdbms_applied_napply=$(echo ${napply_rdbms_cnt}/${napply_molecule})
	          if [ -z "$rdbms_napply_missing_list" ] 
	          then
	            rdbms_napply_missing_list=${PATCH}
	          else
	            rdbms_napply_missing_list=$(echo ${rdbms_napply_missing_list}","${PATCH})
	          fi
	        fi
	      fi
	      #echo "ASM_HOME=$ASM_HOME" 
	      if [[ -n "$ASM_HOME" && -e ${OUTPUTDIR}/o_asm_inventory_${i}.out ]]
	      then
	        #==========================================================================================
	        check_patch "asm" "$PATCH2CHK" 
	        ###=========================================================================================
                asm_version=$(grep $i $MASTERFIL|grep -w VERSION|awk '{print $3}')
                if [ -z "$asm_version" ]; then asm_version=${stack_crs_version[$stack_counter]};fi
	        if [ "$APPLIED" -gt "0" ]
	        then
	          fmt_asm_applied=$fmt_patch_yes
	          rp_asm_pcount=$(($rp_asm_pcount+1))
      	          if [ -n "$RCPATCH" ] ; then rp_asm_pcount=1; fi
	          rs_asm_applied=1
	          if [ $isnapply -eq 1 ]
	          then 
	             napply_asm_cnt=$(($napply_asm_cnt+1))
	             fmt_asm_applied_napply=$(echo ${napply_asm_cnt}/${napply_molecule})
	          fi
	          #Added by kumar
	          if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	          then   
	             echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','$asm_version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
	          fi
	        else
	          fmt_asm_applied=$fmt_patch_no
	          rs_asm_applied=0
	          #Added by kumar
	          if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	          then
	            echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','$asm_version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
	          fi
	          if [ $isnapply -eq 1 ]
	          then 
	            #napply_asm_cnt=$(($napply_rdbms_cnt+1))
	            fmt_asm_applied_napply=$(echo ${napply_asm_cnt}/${napply_molecule})
	            if [ -z "$asm_napply_missing_list" ]
	            then
	              asm_napply_missing_list=${PATCH}
	            else
	              asm_napply_missing_list=$(echo ${asm_napply_missing_list}","${PATCH})
	            fi
	          fi
	        fi
	      fi
	      if [ $isnapply -eq 1 ]
	      then
	        PATCH=$(echo $PATCHTYPE|sed  -n 's/.*(//p'|sed 's/)//g')
	      fi
	      #$READ -p " $napply_molecule and  $napply_molecule_cnt $PATCH nappy=$isnapply rdbms_napply_missing_list=$rdbms_napply_missing_list" 
	      if  [[ $isnapply -eq 1 && $napply_molecule_cnt -lt $napply_molecule ]]
	      then
	        napply_molecule_cnt=$(($napply_molecule_cnt+1))
	      else
                if [ "$P_PATCH" != "$PATCH" ] ; then
	        echo $PATCH |awk '{printf "%-9s",$1}'
	        #$READ -p "napply_rdbms_cnt=$napply_rdbms_cnt and napply_molecule_cnt=$napply_molecule_cnt"
	        if [ $isnapply -eq 1 ] && [[ $napply_rdbms_cnt -gt 0 && $napply_rdbms_cnt -lt $napply_molecule_cnt ]]
	        then
	          fmt_rdbms_applied=$fmt_patch_no
	          fmt_asm_applied=$fmt_patch_no
	          if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
	          then
	            fmt_subj=`echo $SUBJ |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,80)}'`
	            if [ $fmt_rdbms_applied = $fmt_patch_yes ]
	            then
	              echo -e $GREEN $fmt_rdbms_applied_napply $NORM|$AWK '{printf "%-9s",$2}'
	            else
	              echo -e $RED $fmt_rdbms_applied_napply $NORM|$AWK '{printf "%-9s",$2}'  
	            fi
	            echo "Missing fixes from n-apply patch $PATCH from RDBMS HOME  are $rdbms_napply_missing_list" > $napply_missing_list
	            if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
	            then
	              echo -e $GREEN $fmt_asm_applied_napply $NORM|$AWK '{printf "%-8s",$2}'
	            else
	              echo -e $RED $fmt_asm_applied_napply $NORM|$AWK '{printf "%-8s",$2}'
	            fi
	            if [ -n "$ASM_HOME" ]
	            then
	              echo "Missing fixes from n-apply patch $PATCH from ASM HOME are $asm_napply_missing_list" >> $napply_missing_list
	            fi
	          else 
	            fmt_subj=`echo $SUBJ |$AWK '{print substr($SUBJ,0,80)}'`
	            if [ $fmt_rdbms_applied = $fmt_patch_yes ]
	            then
	              echo -e $GREEN $fmt_rdbms_applied_napply $NORM|$AWK '{printf "%-22s",$fmt_rdbms_applied}'
	            else
	              echo -e $RED $fmt_rdbms_applied_napply $NORM|$AWK '{printf "%-22s",$fmt_rdbms_applied}'  
	            fi 
	            echo "Missing fixes from n-apply patch $PATCH from RDBMS HOME  are $rdbms_napply_missing_list" >>  $napply_missing_list
	            if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
	            then
	              echo -e $GREEN $fmt_asm_applied_napply $NORM|$AWK '{printf "%-22s",$fmt_asm_applied}'
	            else
	              echo -e $RED $fmt_asm_applied_napply $NORM|$AWK '{printf "%-22s",$fmt_asm_applied}'
	            fi
	            if [ -n "$ASM_HOME" ]
	            then
	              echo "Missing fixes from n-apply  patch $PATCH from ASM HOME are $asm_napply_missing_list" >> $napply_missing_list
	            fi
	          fi
	          echo $fmt_patch_type|$AWK '{printf "%-20s",$1}'
	          echo $PATCH $fmt_rdbms_applied_napply $fmt_asm_applied_napply $fmt_patch_type|$AWK '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
	          echo $PATCH $fmt_rdbms_applied_napply $fmt_asm_applied_napply $fmt_patch_type|$AWK '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$PREPFIL
                  if [ $CREATE_HTML_REPORT -eq 1 ]
                  then
                    print_rdbms_patch_detailed_html "$PATCH" "$fmt_rdbms_applied_napply" "$fmt_asm_applied_napply" "$fmt_patch_type"
                  fi
	        else
	          if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
	          then
	            fmt_subj=`echo $SUBJ |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,60)}'`
	            if [ $fmt_rdbms_applied = $fmt_patch_yes ]
	            then
	              echo -e $GREEN $fmt_rdbms_applied $NORM|$AWK '{printf "%-9s",$2}'
	            else
	              echo -e $RED $fmt_rdbms_applied $NORM|$AWK '{printf "%-9s",$2}'  
	            fi 
	            if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
	            then
	              echo -e $GREEN $fmt_asm_applied $NORM|$AWK '{printf "%-8s",$2}'
	            else
	              echo -e $RED $fmt_asm_applied $NORM|$AWK '{printf "%-8s",$2}'
	            fi
	          else 
	            fmt_subj=`echo $SUBJ |awk '{print substr($SUBJ,0,80)}'`
	            if [ $fmt_rdbms_applied = $fmt_patch_yes ]
	            then
	              echo -e $GREEN $fmt_rdbms_applied $NORM|$AWK '{printf "%-22s",$fmt_rdbms_applied}'
	            else
	              echo -e $RED $fmt_rdbms_applied $NORM|$AWK '{printf "%-22s",$fmt_rdbms_applied}'  
	            fi 
	            if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
	            then
	              echo -e $GREEN $fmt_asm_applied $NORM|$AWK '{printf "%-22s",$fmt_asm_applied}'
	            else
	              echo -e $RED $fmt_asm_applied $NORM|$AWK '{printf "%-22s",$fmt_asm_applied}'
	            fi
	          fi
	          echo $fmt_patch_type|$AWK '{printf "%-20s",$1}'
	          echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|$AWK '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
	          echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$PREPFIL
                  if [ $CREATE_HTML_REPORT -eq 1 ]
                  then
                    print_rdbms_patch_detailed_html "$PATCH" "$fmt_rdbms_applied" "$fmt_asm_applied" "$fmt_patch_type"
                  fi
	        fi
	        #echo $fmt_patch_type|awk '{printf "%-20s",$1}'
	        #echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
	        #echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$REPFIL
	        if [[ `uname -s` = "AIX"  || `uname -s` = "HP-UX" ]]
	        then
	          echo $fmt_subj |$AWK 'BEGIN { FS = "\n" };{printf "%-40s\n",$1}'|tee -a $LOGFIL | tee -a $PREPFIL
	        else
	          echo $fmt_subj |$AWK '{printf "%-40s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $PREPFIL
	        fi
	        #echo "missing patch list $rdbms_napply_missing_list and $asm_napply_missing_list"
	        napply_molecule_cnt=1
	        napply_rdbms_cnt=0
	        napply_asm_cnt=0
	        unset rdbms_napply_missing_list
	        unset asm_napply_missing_list
	      fi
	      #$READ -p "PATCHRESULT=$PATCHRESULT"
	      echo $PATCH@$rs_crs_applied@$rs_rdbms_applied@$rs_asm_applied>>$PATCHRESULT
              fi #if [ "$P_PATCH" != "$PATCH" ] ; then
              P_PATCH=$PATCH
	    done 
	    mb_non_pcw_num[$mb_db_counter]=$rp_rdbms_tcount
	    mb_rp_rdbms_pcount[$mb_db_counter]=$rp_rdbms_pcount
	    mb_rp_asm_pcount[$mb_db_counter]=$rp_asm_pcount
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
	    if [[ -f $napply_missing_list  ]]
	    then
	      echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
	      cat $napply_missing_list>>$PREPFIL
	      rm -f $napply_missing_list
	    fi
          fi
          mb_db_counter=$(expr $mb_db_counter + 1)
        done
        REFFIL1=$OLD_REFFIL1
        mb_db_counter=0
     
        P_PATCH=""
        #$READ -p "it should work till here"
        #echo "OFFLINE=$OFFLINE TYP=$TYP RUNSWITCH=$RUNSWITCH single_instance_run=$single_instance_run"
        if [[ $OFFLINE -eq 0 && "$TYP" = "-a" || "$TYP" = "-p"  ]] || [[ $OFFLINE -eq 1 && "$RUNSWITCH" = "-a" || "$RUNSWITCH" = "-p" && $single_instance_run -eq 0 ]]
        then
          if [[ $single_instance_run -eq "0" ]] || [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
               head="ASM"
            else
               head="Clusterware"
            fi 
            echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo "              $head patches summary report"|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
            then
              echo $fmt_ppheader_1|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_2|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_3|awk 'BEGIN { FS = "\n" } ;{printf "%-17s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_4|awk 'BEGIN { FS = "\n" } ;{printf "%-15s\n",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL                       
            else
              echo $fmt_ppheader_1|awk '{printf "%-15s",$fmt_ppheader_1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_2|awk '{printf "%-15s",$fmt_ppheader_2}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_3|awk '{printf "%-17s",$fmt_ppheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_4|awk '{printf "%-15s\n",$fmt_ppheader_4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            fi
            echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL  
            echo $pp_crs_tcount $pp_crs_pcount $pp_rdbms_pcount $pp_asm_pcount |awk '{printf "%-15s%-15s%-17s%-15s\n",$1,$2,$3,$4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            if [ $CREATE_HTML_REPORT -eq 1 ]
            then
              print_cluster_patch_summary_html;
            fi
          fi
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo "              RDBMS homes patches summary report"|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
          then
            echo $fmt_rpheader_1|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_rpheader_2|awk 'BEGIN { FS = "\n" } ;{printf "%-17s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_rpheader_3|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo ORACLE_HOME    |awk 'BEGIN { FS = "\n" } ;{printf "%-20s\n",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          else
            echo $fmt_rpheader_1|awk '{printf "%-15s",$fmt_rpheader_1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_rpheader_2|awk '{printf "%-17s",$fmt_rpheader_2}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_rpheader_3|awk '{printf "%-15s",$fmt_rpheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo ORACLE_HOME|awk '{printf "%-15s\n",$fmt_rpheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          fi
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          mb_db_counter=0
          mb_db_counter_printed=0 # gadiga Required for html printing
          for mb_db_homes in ${mb_oracle_homes_distinct[@]}
          do 
            mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
            if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
            then
              echo ${mb_non_pcw_num[$mb_db_counter]} ${mb_rp_rdbms_pcount[$mb_db_counter]} ${mb_rp_asm_pcount[$mb_db_counter]} $mb_db_homes|awk '{printf " %-15s%-15s%-17s%-20s\n",$1,$2,$3,$4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              if [ $CREATE_HTML_REPORT -eq 1 ]
              then
                print_rdbms_patch_summary_html 1;
              fi
            else
              if [ $CREATE_HTML_REPORT -eq 1 ]
              then
                print_rdbms_patch_summary_html 0;
              fi
            fi
            mb_db_counter=$(expr $mb_db_counter + 1)
          done
          mb_db_counter=0
          mb_db_counter_printed=0
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          #else
          #echo $fmt_line_header|tee -a $FREPFIL
          #echo ""|tee -a $FREPFIL
          #echo ""|tee -a $FREPFIL
        fi
      fi # THIS IS THE END OF CHECKING THE SILENT MODE
         #the patch checks are only going to be process if $TYP = -a or -p
      ;;
  esac
  #To delete temporary set ORACLE env file after doing all processing
  #for rmFile in `cat $HOSTLIST`
  #do
  #  
  #  if [ -f /tmp/root_"$rmFile".sh ]
  #  then
  #    rm /tmp/root_"$rmFile".sh
  #  fi
  #  ls -l /tmp/root_"$rmFile".sh
  #  $READ -p " rm -f /tmp/root_"$rmFile".sh" 
  #done

  if [ $i = $localnode ]
  then
    rm -f ${RTEMPDIR}/o_*${i}.out 2>/dev/null
  elif [ $OFFLINE -eq 0 ] 
  then
    $SSHELL $i "rm -f ${RTEMPDIR}/o_*${i}.out" 2>/dev/null
  fi
  #rm -f $TMPDIR/root_"$i".sh >/dev/null 2>&1
  rm -f $RTEMPDIR/root_"$i".sh >/dev/null 2>&1
  
  #loop to delete all os collect files created for os checks
  for collect_file_name in "${collect_files[@]}"
  do
    if [ -f $collect_file_name ]; then rm -f $collect_file_name; fi;
  done
  os_check_needs_collect_file=0 
  
  #this counter is used to track which instance and crs is being worked upon.0 for 1st node and 1 for second node and so forth
  stack_counter=`expr $stack_counter + 1`
  echo
  #echo "Finished run on node $i.. parallel=$RAT_COMPUTE_PARALLEL runmode=$RAT_RUNMODE_INTERNAL";
  #-----------------------------------------------
  #if [[ -n "$RAT_COMPUTE_PARALLEL" && $RAT_COMPUTE_PARALLEL -eq "1" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
  #  wait_for_compute_completion
  #  echo "waited for completeion";
  #fi
  #OFFLINE=1
done
#HOST LOOP Ends
get_current_epoch "1"
end_time=$epoch_time

echo "End Time:$end_time" >> $LOGFIL

let chk_dur=$end_time-$start_time
let dh=$chk_dur/3600
let dm=($chk_dur-3600*$dh)/60
let ds=($chk_dur-3600*$dh)-60*$dm
dsec=$(echo "$ds" | awk '{printf("%d\n",$1 + 0.5)}')

if [ $dh -gt 0 ]; then
  checks_duration="$dh Hours, $dm mins, $dsec seconds";
else
  if [ $dm -gt 0 ]; then
    checks_duration="$dm mins, $dsec seconds";
  else
    checks_duration="$dsec seconds";
  fi
fi

if [ -e $MASTERFIL ]; then echo "CHECKS_DURATION = $checks_duration" >> $MASTERFIL; fi

#printf "Total runtime: %02d:%02d:%02.4f\n" $dh $dm $ds
#echo "Total runtime: $dd $dh $dm $ds"

if [ -n "$MERGEFILES" ]
then
  rm -rf $HOSTLIST
  mv -f $HOSTLIST.new $HOSTLIST
fi

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]]
then
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    mv -f "$ERRFIL" $RTEMPDIR/${program_name}_${FDS}/ >/dev/null 2>&1  
  fi
  diff $MASTERFIL.saved $MASTERFIL > $MASTERFIL.diff
  OFFLINE=1
  killtree $watchdog_pid 9 >/dev/null 2>&1
  exit 0;
fi

if [[ $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
  mv -f $HOSTLIST.org $HOSTLIST
  wait_for_compute_completion
  OFFLINE=0
fi

#following code is to check that same patches are installed on each node for every oracle home

#To delete 0 byte files 
if [ $is_windows -eq "0" ] ; then
  find $OUTPUTDIR -size -1c  -exec rm -rf {} \ >/dev/null 2>&1; #TEMPCHANGE
fi
OIFS="${IFS}";
IFS=$'\n'

insertStatementsForInstalledPatches 'rdbms' $ORACLE_HOME ${stack_dbinst_version[$stack_counter]}
insertStatementsForInstalledPatches 'crs' $CRS ${stack_crs_version[$stack_counter]}
insertStatementsForInstalledPatches 'asm' $ASM_HOME 

if [ -z $MERGEFILES ]; then uploadInstalledPatches; fi

#have to set IFS back to default to get patch loop working. otherwise it was treating both hostname as sinle line
if [ `cat $HOSTLIST|wc -l` -gt 1 ]
then
  patch_counter=0
  for h_patch in `cat $HOSTLIST`
  do
    if [ $patch_counter -eq 0 ]
    then
      if [ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]; then source_crs=$OUTPUTDIR/o_crs_patchlist_${h_patch}.out;fi;
    else
      if [ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]  
      then
        diff $source_crs $OUTPUTDIR/o_crs_patchlist_${h_patch}.out >/dev/null 2>&1
        if [ $? -eq 0 ]; then crs_patch_diff=1;else crs_patch_diff=0;break;fi
      fi
    fi
    patch_counter=$(expr $patch_counter + 1)
  done
  if [[ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out && $crs_patch_diff -eq 1 ]] 
  then
    CRS_PATCH_MSG="${GREEN} PASS =>$NORM    CRS home has same number of patches installed across the cluster."
    crs_patch_check_status=1
  elif [  -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]
  then
    CRS_PATCH_MSG="${RED} FAIL =>$NORM    CRS home does not have same number of patches installed across the cluster."
    crs_patch_check_status=0
  fi

  mb_db_counter=0
  for mb_db_homes in ${mb_oracle_homes_distinct[@]}
  do
    mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
    patch_counter=0
    for h_patch in `cat $HOSTLIST`
    do
      #$READ -p "file to read=$OUTPUTDIR/o_rdbms_patchlist_${h_patch}_${mb_db_homes_fil}.out hostname=$h_patch"
      if [ $patch_counter -eq 0 ]
      then
        if [ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]; then source_rdbms=$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out;fi;
      else
        #$READ -p "$source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${h_patch}.out"
        if [ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]  
        then
  	  #$READ -p "$source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${h_patch}_${mb_db_homes_fil}.out"
          diff $source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out >/dev/null 2>&1
          if [ $? -eq 0 ]; then mb_rdbms_patch_diff[$mb_db_counter]=1;else mb_rdbms_patch_diff[$mb_db_counter]=0;break;fi
        fi
      fi
      #$READ -p "rdbms_patch_diff=${mb_rdbms_patch_diff[$mb_db_counter]} patch_counter=$patch_counter"
      patch_counter=$(expr $patch_counter + 1)
    done 
    mb_db_counter=$(expr $mb_db_counter + 1)
  done

  mb_db_counter=0
  for mb_db_homes in ${mb_oracle_homes_distinct[@]}
  do
    mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
    if [[ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out && ${mb_rdbms_patch_diff[$mb_db_counter]} -eq 1 ]] 
    then
      MB_RDBMS_PATCH_MSG[$mb_db_counter]="${GREEN} PASS =>$NORM    RDBMS home ${mb_db_homes} has same number of patches installed across the cluster."
      mb_rdbms_patch_check_status[$mb_db_counter]=1
    elif [  -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]
    then
      MB_RDBMS_PATCH_MSG[$mb_db_counter]="${RED} FAIL =>$NORM    RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster."
      mb_rdbms_patch_check_status[$mb_db_counter]=0
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  mb_db_counter=0

  patch_counter=0
  for h_patch in `cat $HOSTLIST`
  do
    if [ $patch_counter -eq 0 ]
    then
      if [ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]; then source_asm=$OUTPUTDIR/o_asm_patchlist_${h_patch}.out;fi;
    else
      if [ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]  
      then
        diff $source_asm $OUTPUTDIR/o_asm_patchlist_${h_patch}.out >/dev/null 2>&1
        if [ $? -eq 0 ]; then asm_patch_diff=1;else asm_patch_diff=0;break;fi
      fi
    fi
    patch_counter=$(expr $patch_counter + 1)
  done

  patch_counter=0
  if [[ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out && $asm_patch_diff -eq 1 ]] 
  then
    ASM_PATCH_MSG="${GREEN} PASS =>$NORM    ASM home has same number of patches installed across the cluster."
    asm_patch_check_status=1
  elif [  -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]
  then
    ASM_PATCH_MSG="${RED} FAIL =>$NORM    ASM home does not have same number of patches installed across the cluster."
    asm_patch_check_status=0
  fi
fi
#following code is to check clustewide checks
#echo "stack_counter=$stack_counter clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"

#$READ -p "stack_counter=$stack_counter ${cls_check_host_list[*]} ${cls_check_host_list[0]} and ${cls_check_host_list[1]}"
#To set clusterware_check_count value from a compute node if last node was a control VM.
if [[ $clusterware_check_count -ne $clusterware_check_count_old && $clusterware_check_count_old -gt 0 ]]; then clusterware_check_count=$clusterware_check_count_old;fi
#$READ -p "clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"
if [[ -z "$MERGEFILES" ]]
then
  if [[ $SILENT -eq 0 && $clusterware_check_count -ge 1 ]]
  then
    echo -e "\n"|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo "                      CLUSTERWIDE CHECKS"|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
  fi
fi
crs_stack_counter=$clusterware_check_count
C_ACTUAL=${OUTPUTDIR}/c_actual.out
crs_check_file_counter=0
COMTYPE="CLUSTERWIDE_CHECK"
if [ -f $C_ACTUAL ]; then rm -f $C_ACTUAL; fi;
#$READ -p "crs_stack_counter=$crs_stack_counter and array =${crs_check_id[*]} SILENT=$SILENT"

while [[ $crs_stack_counter -gt 0 && $SILENT -eq 0 ]]
do 
   if [ -n "$MERGEFILES" ]
   then
     CLUSTERCHECK_FIL=$WRKDIR/.MERGED_COLLECTIONS/${crs_check_id[$crs_check_file_counter]}.out
     cls_no_of_nodes=$(cat $WRKDIR/.MERGED_COLLECTIONS/${crs_check_id[$crs_check_file_counter]}.out|wc -l|sed 's/ //g')
   else
     CLUSTERCHECK_FIL=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out
     cls_no_of_nodes=$(cat ${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out|wc -l|sed 's/ //g')
   fi
   #$READ -p " ls -l $CLUSTERCHECK_FIL"
   if [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && -n ${crs_check_id[$crs_check_file_counter]} ]]; then
     . $INPUTDIR/${crs_check_id[$crs_check_file_counter]}_load_checks_attributes.sh 2>>$ERRFIL
   else
     COMTYPE=$(grep "_"${crs_check_id[$crs_check_file_counter]}"-TYPE" $REFFIL |awk {'print $2'})
   fi
   crs_check_counter=0
   unset cls_check_val1
   unset cls_check_val2
   unset no_of_cells
   unset cell_stack_counter
   crs_val_set=0
   #following branch is to handle system wide check where we need to include storage server also to compare some value across nodes
   if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
   then
     if [ -n "$MERGEFILES" ]
     then
       stack_counter=$(cat $WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge|wc -l|sed 's/ //g');  
       tmp_stack_counter=0
       for compute_name in `cat $WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge`
       do
         cls_check_host_list[$tmp_stack_counter]=$compute_name
         tmp_stack_counter=$(expr $tmp_stack_counter + 1 )
       done
     fi
     crs_host_counter=$stack_counter
   else 
     if [[ -n "$skip_in_silent" && $skip_in_silent -eq "0" ]]
     then
        if [ -e $CELLIP ] ;then no_of_cells=$(grep "cell=" $CELLIP|grep -v ^#|wc -l|tr -d ' '); else no_of_cells=0; fi
        if [ -e $CELLDIR/cells.out ] ;then crs_host_counter=$(expr $stack_counter + $no_of_cells );else crs_host_counter=$stack_counter;fi
        cell_stack_counter=$stack_counter
        for cls_cell_host in $(if [ -e $CELLDIR/cells.out ] ;then cat $CELLDIR/cells.out|awk '{print $3}';fi) 
        do
          cls_check_host_list[$cell_stack_counter]=$cls_cell_host
          cell_stack_counter=$(expr $cell_stack_counter + 1 )
        done
     else # No cells in -s or -S
       no_of_cells=0
     fi
   fi
   SOURCEFIL_REPORT=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}_report.out
   if [ $OFFLINE -eq 0 ]
   then
     SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${crs_check_id[$crs_check_file_counter]}_report.out 
   else
     SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}_report.out 
   fi
   while [ $crs_host_counter -gt 0 ] 
   do
     if [ -n "$MERGEFILES" ]
     then   
       CLUSTERCHECK_FIL_REPORT=$WRKDIR/.MERGED_COLLECTIONS/${crs_check_id[$crs_check_file_counter]}_"${cls_check_host_list[$crs_check_counter]}"_report.out   
     else
       CLUSTERCHECK_FIL_REPORT=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}_"${cls_check_host_list[$crs_check_counter]}"_report.out   
     fi
     #$READ -p "hostname=${cls_check_host_list[$crs_check_counter]}"
     ROW=$(cat $CLUSTERCHECK_FIL|head -1|awk '{print $2}')
     #$READ -p "crs_check_counter=$crs_check_counter and crs_host_counter=$crs_host_counter"
     cls_host_exists=$(grep -ic "${cls_check_host_list[$crs_check_counter]}" $CLUSTERCHECK_FIL)

     if [ -n "$MERGEFILES" ]; then
       if [[ -z "$cls_host_exists" || $cls_host_exists -eq 0 ]]; then
         for xdir in $dirarr
	 do
	   xdir=$(echo $xdir|sed 's/\.zip//g');
	   unset t_CLUSTERCHECK_FIL_REPORT
	   unset t_CLUSTERCHECK_FIL
	   t_CLUSTERCHECK_FIL_REPORT=${xdir}/outfiles/${crs_check_id[$crs_check_file_counter]}_"${cls_check_host_list[$crs_check_counter]}"_report.out
	   t_CLUSTERCHECK_FIL=${xdir}/outfiles/${crs_check_id[$crs_check_file_counter]}.out

	   if [[ -e $t_CLUSTERCHECK_FIL ]]; then cls_host_exists=$(grep -ic "${cls_check_host_list[$crs_check_counter]}" $t_CLUSTERCHECK_FIL); fi
	   if [[ -n "$cls_host_exists" && $cls_host_exists -ge 1 ]]; then
	     CLUSTERCHECK_FIL_REPORT=$t_CLUSTERCHECK_FIL 
	     CLUSTERCHECK_FIL=$t_CLUSTERCHECK_FIL
	     break;
	   fi
	 done	  
       fi
     fi

     if [[ -n "$cls_host_exists" && $cls_host_exists -ge 1 && -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]
     then
       if [ -z "$cls_check_val1" ]
       then
         if [[ -z $RAT_NO_COMPONENTS_FILTER ]]; then
           cls_check_val1=$(grep "${cls_check_host_list[$crs_check_counter]} " $CLUSTERCHECK_FIL|sed  -n 's/.*== //p')
	 else
           cls_check_val1=$(grep "${cls_check_host_list[$crs_check_counter]} $ROW" $CLUSTERCHECK_FIL|sed  -n 's/.*== //p')
	 fi
       else
         if [[ -z $RAT_NO_COMPONENTS_FILTER ]]; then
           cls_check_val2=$(grep "${cls_check_host_list[$crs_check_counter]} " $CLUSTERCHECK_FIL|sed  -n 's/.*== //p')
	 else
           cls_check_val2=$(grep "${cls_check_host_list[$crs_check_counter]} $ROW" $CLUSTERCHECK_FIL|sed  -n 's/.*== //p')
	 fi
         # this is the fix to overcome the issue of having empty value for some nodes
         if [ -z "$cls_check_val2" ]; then cls_check_val2=$cls_check_val1;fi
         if [[ -n "$crs_val_set"  && $crs_val_set -eq 0 ]]
         then
	   if [ $RAT_DEBUG -eq 1 ]
	   then
	     if [[ -n "${cls_check_val1}" && -n "${cls_check_val2}" ]] && [ "${cls_check_val1}" = "${cls_check_val2}" ] 2>>$ERRFIL
	     then
	       CRS_VAL=1
	     else
	       CRS_VAL=0
	       crs_val_set=1   
	       #break
	     fi 
	   else
	     if [[ -n "${cls_check_val1}" && -n "${cls_check_val2}" ]] && [ "${cls_check_val1}" = "${cls_check_val2}" ]
	     then
	       CRS_VAL=1
	     else
	       CRS_VAL=0
	       crs_val_set=1   
	       #break
	     fi
	   fi 
         fi
         #$READ -p "${cls_check_host_list[$crs_check_counter]} $ROW"
       fi
     fi
     if [ -e $CLUSTERCHECK_FIL_REPORT ]; then cat $CLUSTERCHECK_FIL_REPORT >>$SOURCEFIL_REPORT;fi     

     if [ -n "$MERGEFILES" ]; then
       if [ ! -e $CLUSTERCHECK_FIL_REPORT ]; then
	 for xdir in $dirarr
	 do
	   xdir=$(echo $xdir|sed 's/\.zip//g');
	   unset t_CLUSTERCHECK_FIL_REPORT
	   t_CLUSTERCHECK_FIL_REPORT=${xdir}/outfiles/${crs_check_id[$crs_check_file_counter]}_"${cls_check_host_list[$crs_check_counter]}"_report.out

	   if [ -e $t_CLUSTERCHECK_FIL_REPORT ]; then 
	     if [[ `grep -icw "${cls_check_host_list[$crs_check_counter]}" $SOURCEFIL_REPORT` -eq 0 ]]; then cat $t_CLUSTERCHECK_FIL_REPORT >>$SOURCEFIL_REPORT; break; fi
	   fi
	 done
       fi 
     fi

     crs_check_counter=$(expr $crs_check_counter + 1 )
     crs_host_counter=$(expr $crs_host_counter - 1 )
     #$READ -p "crs_check_counter=$crs_check_counter and crs_host_counter=$crs_host_counter $cls_host_exists for ${crs_check_id[$crs_check_file_counter]}"
   done
   if [[ -z $RAT_LOAD_CHECK_ATTRIBUTES ]] || [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && $op_mode -eq 0 ]]; then
     if [ $op_mode -eq 0 ]
     then 
       PMSG=`grep "_"$ROW"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
       FMSG=`grep "_"$ROW"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
       SF=`grep "_"$ROW"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
       CAT=`grep "_"$ROW"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
       SUBCAT=`grep "_"$ROW"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
       ALVL=`grep _$ROW\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
       audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
       NEEDS_RUNNING=`grep "_"$ROW"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'` 
       TARGET_TYPE=`grep "_"$ROW"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'` 
       ISBRANCH=`grep _$ROW\-IS_BRANCH $REFFIL |awk {'print $2'} `
       OP=`grep _$ROW\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
       if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$ROW\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi 
     else
       PMSG=`grep "_"${crs_check_id[$crs_check_file_counter]}"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
       FMSG=`grep "_"${crs_check_id[$crs_check_file_counter]}"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
       SF=`grep "_"${crs_check_id[$crs_check_file_counter]}"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
       check_components=`grep "_"${crs_check_id[$crs_check_file_counter]}"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
       CAT=`grep "_"${crs_check_id[$crs_check_file_counter]}"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
       SUBCAT=`grep "_"${crs_check_id[$crs_check_file_counter]}"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
       ALVL=`grep _${crs_check_id[$crs_check_file_counter]}\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
       audit_check_name=`grep "_"${crs_check_id[$crs_check_file_counter]}"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
       NEEDS_RUNNING=`grep "_"${crs_check_id[$crs_check_file_counter]}"-NEEDS_RUNNING" $REFFIL|sed  -n 's/.*NEEDS_RUNNING //p'`  
       TARGET_TYPE=`grep "_"${crs_check_id[$crs_check_file_counter]}"-TARGET_TYPE" $REFFIL|sed  -n 's/.*TARGET_TYPE //p'`  
       ISBRANCH=`grep _"${crs_check_id[$crs_check_file_counter]}-IS_BRANCH" $REFFIL |awk {'print $2'}`
       OP=`grep _"${crs_check_id[$crs_check_file_counter]}-OPERATOR" $REFFIL |sed  -n 's/.*OPERATOR //p'`
       if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _"${crs_check_id[$crs_check_file_counter]}-OPERATOR" $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
     fi
   else
     ALVL_bak=$ALVL; unset ALVL; ALVL=$ALVL_bak
   fi
   ALVL_CHECK=$ALVL
   audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
   if [ "$COMTYPE" = "SYSTEMWIDE_CHECK" ]; then COMTYPE=CLUSTERWIDE_CHECK;fi
   if [[ -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]
   then
     if [[ $ALVL = "INFO" && $CRS_VAL -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [ $write_info_actual_files -eq 1 ]; then echo "${crs_check_id[$crs_check_file_counter]}|$CRS_VAL" >> $C_ACTUAL;fi 
   fi
   #following code is create report file if clusterwide check fails
   if [[ -n "$CRS_VAL" && $OFFLINE -eq 0 ]] || [[ -n "$MERGEFILES" ]]
   then
     if [[ -n "$MERGEFILES" ]]
     then
       if [[ `grep -ic ${crs_check_id[$crs_check_file_counter]} $WRKDIR/.MERGED_COLLECTIONS/slave_results.out.merge` -gt 0 ]]
       then
         if [[ -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]; then  get_log_result;fi
         crs_stack_counter=`expr $crs_stack_counter - 1`
         crs_check_file_counter=`expr $crs_check_file_counter + 1`
         continue;
       fi
     fi
   fi
   #$READ -p "audit_check_name=$audit_check_name $CLUSTERCHECK_FIL_REPORT SOURCEFIL_REPORT=$SOURCEFIL_REPORT"
   #add if condition for get_log_result to not to  execute if no of nodes are not greater than 1 in clusterwide check
   if [[ -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]; then  get_log_result;fi 

   crs_stack_counter=`expr $crs_stack_counter - 1`
   crs_check_file_counter=`expr $crs_check_file_counter + 1`
done
crs_stack_counter=0
#reassiging i back to localnode to process cross node checks other wise it goes to remote node in copy_env_file function
i=$localnode

#Following code is to process CROSS_NODE_CHECKS
#counter has been increased after adding last item in arrary. -1 to bring it back to last item
cross_node_checkids_counter=$(expr $cross_node_checkids_counter - 1 )

unset COL_COMTYPE
while [[ $process_cross_node_checks -eq 1 && $cross_node_checkids_counter -ge 0 ]]
do
  if [[ -n $RAT_LOAD_CHECK_ATTRIBUTES && -n $CHECK_ID ]]; then
    COMTYPE=CLUSTERWIDE_CHECK 
    COL_COMTYPE=CROSS_NODE_CHECK
    CHECK_ID=${cross_node_checkids[$cross_node_checkids_counter]}
    crs_check_id[$crs_check_file_counter]=$CHECK_ID 

    . $INPUTDIR/${CHECK_ID}_load_checks_attributes.sh 2>>$ERRFIL

    ALVL_bak=$ALVL; unset ALVL; ALVL=$ALVL_bak
  else
    COMTYPE=CLUSTERWIDE_CHECK 
    COL_COMTYPE=CROSS_NODE_CHECK
    CHECK_ID=${cross_node_checkids[$cross_node_checkids_counter]}
    crs_check_id[$crs_check_file_counter]=$CHECK_ID 
    PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}`
    HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}`
    ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
    PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
    NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
    TARGET_TYPE=`grep "_"$CHECK_ID"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'| sed 's/^ *\(.*\) *$/\1/'`
    execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
    check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
    check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
    check_database_type=$(grep "_"$CHECK_ID"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
    check_database_mode=$(grep "_"$CHECK_ID"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
    SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
    check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
    OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
    if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
    COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'`
    com_begin_pattern="_${CHECK_ID}-${COL_COMTYPE}_COMMAND_START"
    com_end_pattern="_${CHECK_ID}-${COL_COMTYPE}_COMMAND_END"
    COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
    com_report_begin_pattern="_${CHECK_ID}-${COL_COMTYPE}_COMMAND_REPORT_START"
    com_report_end_pattern="_${CHECK_ID}-${COL_COMTYPE}_COMMAND_REPORT_END"
    COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
    audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
    if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
    if [ $SILENT -eq "0" ]
    then
      ALVL=`grep _$CHECK_ID\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
      PMSG=`grep "_"$CHECK_ID"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
      FMSG=`grep "_"$CHECK_ID"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
      CAT=`grep "_"$CHECK_ID"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
      SUBCAT=`grep "_"$CHECK_ID"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
      ALVL_CHECK=$ALVL
    fi
  fi
  #assign_execute_once
  
  if [ $OFFLINE -eq 0 ]; then echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi
  copy_env_files_to_tmp
  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");
 
  security_fix "check_and_fix_script_existence" "$localcmd"
  echo "#!$bash_scr" >$localcmd
  echo "$RAT_DEBUG_FLG" >>$localcmd
  echo "$bash_source" >>$localcmd
  if [ $OFFLINE -eq 1 ] 
  then 
    echo "export OUTPUTDIR=${OUTPUTDIR}">>$TRGTORCLENV
    echo "export TMPDIR=$TMPDIR">>$TRGTORCLENV
  fi
  echo ". $TRGTORCLENV">>$localcmd;
  if [ -n "$COM_REPORT" ] && [[ $OFFLINE -eq 0 ]]
  then
    echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
  fi
  OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
  echo "$COM 2>>$ERRFIL">>$localcmd
  if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
  echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
  echo "exit 0">>$localcmd
  chmod 540 $localcmd
  FILVAL=`$localcmd 2>>$ERRFIL`
  returncode=`echo $?`
  set_alvl

  if [ -e "$localcmd" ]; then 
    if [ -e "$ORCLENVFIL" ]; then
      #cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; #rm -f $localcmd; 
      cat $TRGTORCLENV > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; #rm -f $localcmd;
      security_fix "check_and_fix_script_existence" "$localcmd";
    fi
  fi

  move_failed_to_skipped "$returncode"
  VAL=$FILVAL
  if [ -n "$COM_REPORT" ]
  then
    SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
    if [ $OFFLINE -eq 0 ]
    then
      SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
    else
      SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
    fi
  fi  
  cross_node_get_log_result_call=1
  get_log_result
  if [ $OFFLINE -eq 0 ]; then echo -e "end time -  `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi

  cross_node_checkids_counter=$(expr $cross_node_checkids_counter - 1 )
  crs_check_file_counter=$(expr $crs_check_file_counter + 1) 

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then write_del_rolbk_tmpoutput; fi
done
unset COL_COMTYPE
crs_check_file_counter=0
#$READ -p "stop after corss node processing"
###CROSS_NODE_CHECK processing ends here

if [ $SILENT -eq 0 ]
then
  if [[ -n "$CRS_PATCH_MSG" && -n "$crs_patch_check_status" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || $crs_patch_check_status -eq 0 ]];then echo -e "$CRS_PATCH_MSG";fi; 
  mb_db_counter=0
  for mb_db_homes in ${mb_oracle_homes_distinct[@]}
  do 
    if [[ -n "${MB_RDBMS_PATCH_MSG[$mb_db_counter]}" && -n "${mb_rdbms_patch_check_status[$mb_db_counter]}" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || ${mb_rdbms_patch_check_status[$mb_db_counter]} -eq 0 ]]; then echo -e "${MB_RDBMS_PATCH_MSG[$mb_db_counter]}";fi;
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  mb_db_counter=0
  if [[ -n "$ASM_PATCH_MSG" && -n "$asm_patch_check_status" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || $asm_patch_check_status -eq 0 ]]; then echo -e "$ASM_PATCH_MSG";fi; 
  if [ -n "$crs_patch_check_status" ] && [[ "$TYP" != "-p" ]]
  then
    if [ $crs_patch_check_status -eq 1 ]
    then
      echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$CWCREPFIL_PASS   
      echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
      echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$MISCCWCHECK
      if [[ $CREATE_HTML_REPORT -eq 1 ]]
      then # gadiga - for html reporting
        write_cwc_status_html "PASS" "CRS home has same number of patches installed across the cluster";
      fi
    else 
      echo "Check:- FAIL => CRS home does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL
      echo "Check:- FAIL => CRS home does not  have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL
      echo "Check:- FAIL => CRS home does not have same number of patches installed across the cluster">>$MISCCWCHECK
      if [[ $CREATE_HTML_REPORT -eq 1 ]]
      then # gadiga - for html reporting
        write_cwc_status_html "FAIL" "CRS home does not have same number of patches installed across the cluster"
      fi
    fi
  fi
  if [[ "$TYP" != "-p" ]]
  then
    mb_db_counter=0
    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
    do
      if [ -n "${mb_rdbms_patch_check_status[$mb_db_counter]}" ]
      then
        if [ ${mb_rdbms_patch_check_status[$mb_db_counter]} -eq 1 ]
        then
    	    echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$CWCREPFIL_PASS
    	    echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
    	    echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$MISCCWCHECK
          if [[ $CREATE_HTML_REPORT -eq 1 ]]
          then # gadiga - for html reporting
            write_cwc_status_html "PASS" "RDBMS home ${mb_db_homes} has same number of patches installed across the cluster"
          fi
        else
    	    echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL 
    	    echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL 
    	    echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$MISCCWCHECK 
          if [[ $CREATE_HTML_REPORT -eq 1 ]]
          then # gadiga - for html reporting
            write_cwc_status_html "FAIL" "RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster"
          fi
        fi
      fi
      mb_db_counter=$(expr $mb_db_counter + 1)
    done
    mb_db_counter=0
  fi
  if [ -n "$asm_patch_check_status" ] && [[ "$TYP" != "-p" ]]
  then
    if [ $asm_patch_check_status -eq 1 ]
    then
      echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$CWCREPFIL_PASS
      echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
      echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$MISCCWCHECK
      if [[ $CREATE_HTML_REPORT -eq 1 ]]
      then # gadiga - for html reporting
        write_cwc_status_html "PASS" "ASM home has same number of patches installed across the cluster"
      fi
    else 
      echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL
      echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL
      echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$MISCCWCHECK
      if [[ $CREATE_HTML_REPORT -eq 1 ]]
      then # gadiga - for html reporting
        write_cwc_status_html "FAIL" "ASM home does not have same number of patches installed across the cluster"
      fi
    fi
  fi
  #MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
  if [ -z "$platform" ]; then platform=$(uname -s);fi;
  CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
  CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
  CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
  CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
  echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
fi
####

if [ -z $ent_naming ]; then ent_naming=$localnode; else ent_naming=$DB; fi;
#----------------------------------------------------------------------
#Added by kumar
if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
then
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    upload_outfil=$TMP_OUTPUT/upload_${program_name}_result.lst
    upload_patch_outfil=$TMP_OUTPUT/upload_${program_name}_patch_result.lst
    old_upload_outfil=$OUTPUTDIR/upload_${program_name}_result.lst
    old_upload_patch_outfil=$OUTPUTDIR/upload_${program_name}_patch_result.lst

    upload_raccheck_result_fil=$TMP_OUTPUT/upload_${program_name}_result.sql
    upload_raccheck_patch_result_fil=$TMP_OUTPUT/upload_${program_name}_patch_result.sql
    old_upload_raccheck_result_fil=$OUTPUTDIR/upload_${program_name}_result.sql
    old_upload_raccheck_patch_result_fil=$OUTPUTDIR/upload_${program_name}_patch_result.sql

    move_files "$old_upload_raccheck_result_fil" "$upload_raccheck_result_fil"
    move_files "$old_upload_raccheck_patch_result_fil" "$upload_raccheck_patch_result_fil" 
  else
    upload_outfil=$OUTPUTDIR/upload_${program_name}_result.lst
    upload_patch_outfil=$OUTPUTDIR/upload_${program_name}_patch_result.lst
  fi

  if [ "$TYP" != "-p" ]
  then  
    if [[ -n $RAT_UPLOAD_TABLE ]];then 
      insert_data_into_table "$RAT_UPLOAD_TABLE" "$upload_raccheck_result_fil" "$upload_outfil"
      if [ $data_upload_status -eq 2 ] 
      then
        echo -e $RED"${program_name} was not able to make successfull connection to database to upload result.\nPlease run ${OUTPUTDIR_NEW}/upload/upload_${program_name}_result.sql script manually to upload result to database\n$NORM"|tee -a $LOGFIL    
      elif [ $data_upload_status -eq 3 ]
      then
        echo -e $RED"$upload_error insert statement have failed from ${OUTPUTDIR_NEW}/upload/upload_${program_name}_result.sql Please see the $OUTPUTDIR_NEW/log/upload_${program_name}_result.lst and fix those errors manually\n$NORM"|tee -a $LOGFIL
      fi
    fi 
  fi
  if [[ -n "$data_upload_status" && $data_upload_status -ne 2 ]]
  then
    if [[ -n $RAT_PATCH_UPLOAD_TABLE ]];then
      if [[ "$TYP" = "-a" || "$TYP" = "-s" || "$TYP" = "-S" || "$TYP" = "-p" || "$TYP" = "-u" ]]
      then  
        insert_data_into_table "$RAT_PATCH_UPLOAD_TABLE" "$upload_raccheck_patch_result_fil" "$upload_patch_outfil"
        if [ $data_upload_status -eq 2 ] 
        then         
          echo -e $RED"${program_name} was not able to make successfull connection to database to upload result.\nPlease run ${OUTPUTDIR_NEW}/upload/upload_${program_name}_patch_result.sql script manually to upload result to database\n$NORM"|tee -a $LOGFIL    
        elif [ $data_upload_status -eq 3 ]
        then
          echo -e $RED"$upload_error insert statement have failed from ${OUTPUTDIR_NEW}/upload/upload_${program_name}_patch_result.sql Please see the $OUTPUTDIR_NEW/log/upload_${program_name}_patch_result.lst and fix those errors manually\n$NORM"|tee -a $LOGFIL
        fi 
      fi
    fi
  fi
  #moving data upload result back to output dir if it was run as root and executed from TMP_OUTPUT
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]
  then
     move_files $upload_outfil $old_upload_outfil
     move_files $upload_patch_outfil $old_upload_patch_outfil
  fi
  echo -e ${GREEN}"${upload_pass_msg} $upload_pass_msg2"${NORM}
fi
#----------------------------------------------------------------------

IFS="${OIFS}";
##to delete ssh configuration
if [[ $OFFLINE -eq 0 && 1 -eq 2 ]]
then 
  arr=`expr $arr - 1`
  while [[ -n $arr && $arr -ge 0 ]]
  do
    if [ $i = $localnode ]
    then
      rm -rf ~/.ssh 2>/dev/null
    else
      ssh ${hnameArr[$arr]} rm -rf ~/.ssh 
    fi
    arr=`expr $arr - 1`
  done
fi

for i in `cat $HOSTLIST`
do
  if [ $i = $localnode ]
  then
    rm -f $TRGTORCLENV 2>/dev/null
    #rm -f $TMPDIR/raccheck_env.out 2>/dev/null
    rm -f $RTEMPDIR/raccheck_env.out 2>/dev/null
  elif [ $OFFLINE -eq 0 ]
  then
    node_ssh_user=$usern
    if [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]]; then
      if [[ `echo "$ea_dom0_nodes" | grep -ic "$i"` -le 0 ]]; then
        node_ssh_user="${root_user}"
      else
        node_ssh_user="${foxtrot_dom0_user}"
      fi
      if [[ -n $RAT_TMPDIR ]]; then l_TMPDIR=$TMPDIR; else l_TMPDIR=$($SSHELL ${node_ssh_user}@$i "echo \"\$HOME\""); fi
      l_RTEMPDIR=${l_TMPDIR}/.${program_name}
    else
      l_TMPDIR=$TMPDIR
      l_RTEMPDIR=$RTEMPDIR
    fi
    $SSHELL $node_ssh_user@$i "rm -f $TRGTORCLENV" 2>/dev/null
    #$SSHELL $node_ssh_user@$i "rm -f $l_TMPDIR/raccheck_env.out" 2>/dev/null
    $SSHELL $node_ssh_user@$i "rm -f $l_RTEMPDIR/raccheck_env.out" 2>/dev/null
  fi
done
OIFS="${IFS}";
IFS=$'\n'

if [ $is_windows -eq "1" ] ; then
  OUTPUTDIR_NEW=$OUTPUTDIR #TEMPCHANGE
fi
#To copy EXCLUDEFIL to OUTPUTDIR
if [ -e $EXCLUDEFIL ]; then cp -f $EXCLUDEFIL $OUTPUTDIR;fi;
if [ -e $WRKDIR/cgrep ]; then rm -f $WRKDIR/cgrep >/dev/null 2>&1;fi;
if [[ $OFFLINE -eq 0 && -n "$OUTPUTDIR_NEW" ]]
then
  if [ $is_windows -eq "0" ] ; then
    mv -f $OUTPUTDIR $OUTPUTDIR_NEW 2>>$ERRFIL #TEMPCHANGE
  fi
  OUTPUTDIR=$OUTPUTDIR_NEW
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    #ERRFIL=$TMP_OUTPUT/${program_name}_error.log
    OLD_ERRFIL=$OUTPUTDIR/${program_name}_error.log
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
    PSEUDOERRFIL=$TMP_OUTPUT/${program_name}_error.log
  else
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
  fi
  LOGFIL=$OUTPUTDIR/${program_name}.log
  SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
  RSKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks_runtime.log
  REPFIL=$OUTPUTDIR/${program_name}.rep
  XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
  XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
  JSONREPFIL=$OUTPUTDIR/${program_name}_results.json
  CLOUDLOG=$OUTPUTDIR/${program_name}_opc.json
  JSONSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.json
  XMLRECFIL=$OUTPUTDIR/${program_name}_recommendations.xml
  CHK_TIMINGS=$OUTPUTDIR/${program_name}_epoch_checks_timings.out
  SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
  REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
  REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
  SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
  SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
  PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
  PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
  CWCREPFIL=$OUTPUTDIR/${program_name}_cwc.rep
  SCWCREPFIL=$OUTPUTDIR/${program_name}_cwc_summary.rep
  CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
  SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
  CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
  SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
  CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
  CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
  CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
  CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
  IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
  IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
  IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
  IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
  COLLECT_TIMING=$OUTPUTDIR/${program_name}_collection_timings.out
  CHECKS_TIMING=$OUTPUTDIR/${program_name}_checks_timings.out
  RACCHECK_TIMING=$OUTPUTDIR/${program_name}_timings.out
  HOSTLIST=$OUTPUTDIR/o_host_list.out
  MISCCWCHECK=$OUTPUTDIR/clusterwide_patch_compare.out 
  MASTERFIL=$OUTPUTDIR/raccheck_env.out
  CELLDIR="$OUTPUTDIR/.CELLDIR"
  EXCLUDELOG=$OUTPUTDIR/excluded_check_ids.log
  OGGHOMESVERSIONFIL=$OUTPUTDIR/ogg_homes_version.out
fi

if [ $SILENT -ne 1 ]
then
  if [[ -e $SKIPFIL && `cat $SKIPFIL|wc -l` -gt 4 ]]
  then
    echo -e "$fmt_line_header\n">>$SREPFIL
    echo -e "Some checks were skipped. Please review $SKIPFIL for more detail\n">>$SREPFIL
    echo -e "$fmt_line_header\n\n">>$SREPFIL
    echo -e "$fmt_line_header\n">>$REPFIL
    echo -e "Some checks were skipped. Please review $SKIPFIL for more detail\n">>$REPFIL
    echo -e "$fmt_line_header\n\n">>$REPFIL
  fi 
  if [ -f $SCWCREPFIL_FAIL  ]
  then 
    if [ `cat $SCWCREPFIL_FAIL|wc -l` -gt 6 ]; then cat $SCWCREPFIL_FAIL >>$SREPFIL; fi;
  fi
  if [ -f $SREPFIL_FAIL ]
  then
    if [ `cat $SREPFIL_FAIL|wc -l` -gt 6 ]; then  cat $SREPFIL_FAIL >>$SREPFIL; fi;
  fi
  if [ -f $CELLSREPFIL_FAIL ]; then  cat $CELLSREPFIL_FAIL >>$SREPFIL;fi   
  if [ -f $IBSREPFIL_FAIL ]; then  cat $IBSREPFIL_FAIL >>$SREPFIL;fi   
  if [ -f $SCWCREPFIL_PASS ] 
  then 
    if [ `cat $SCWCREPFIL_PASS|wc -l` -gt 6 ]; then cat $SCWCREPFIL_PASS >>$SREPFIL ;fi;
  fi
  if [ -f $SREPFIL_PASS ] 
  then 
    if [ `cat $SREPFIL_PASS|wc -l` -gt 6 ]; then cat $SREPFIL_PASS >>$SREPFIL ;fi;
  fi
  if [ -f $CELLSREPFIL_PASS ]; then  cat $CELLSREPFIL_PASS >>$SREPFIL;fi   
  if [ -f $IBSREPFIL_PASS ]; then  cat $IBSREPFIL_PASS >>$SREPFIL;fi   
  if [ -f $PSREPFIL ];     then cat $PSREPFIL >>$SREPFIL;fi;
  if [ -f $CWCREPFIL_FAIL ]
  then 
    if [ `cat $CWCREPFIL_FAIL|wc -l` -gt 6 ]; then cat $CWCREPFIL_FAIL>>$REPFIL; fi;
  fi
  if [ -f $REPFIL_FAIL ] 
  then 
    if [ `cat $REPFIL_FAIL|wc -l` -gt 6 ]; then cat $REPFIL_FAIL >>$REPFIL; fi;
  fi
  if [ -f $CELLREPFIL_FAIL ]; then  cat $CELLREPFIL_FAIL >>$REPFIL;fi   
  if [ -f $IBREPFIL_FAIL ]; then  cat $IBREPFIL_FAIL >>$REPFIL;fi   
  if [ -f $CWCREPFIL_PASS ]
  then 
    if [ `cat $CWCREPFIL_PASS|wc -l` -gt 6 ]; then cat $CWCREPFIL_PASS >>$REPFIL; fi;
  fi
  if [ -f $REPFIL_PASS ]
  then
    if [ `cat $REPFIL_PASS|wc -l` -gt 6 ]; then cat $REPFIL_PASS >>$REPFIL; fi;
  fi
  if [ -f $CELLREPFIL_PASS ]; then  cat $CELLREPFIL_PASS >>$REPFIL;fi   
  if [ -f $IBREPFIL_PASS ]; then  cat $IBREPFIL_PASS >>$REPFIL;fi   
  if [ -f $PREPFIL ];     then cat $PREPFIL >>$REPFIL;fi;
  echo "Detailed report is $REPFIL">>$SREPFIL
  if [ $OFFLINE -eq 0 ]
  then
    echo "Log file is at $LOGFIL">>$REPFIL
  fi
  #SREPFIL=$OUTPUTDIR/raccheck_summary.rep 
  #REPFIL=$OUTPUTDIR/raccheck.rep 
  #echo  "Summary report  - $SREPFIL"
  #echo  "Detailed report  - $REPFIL"
fi

#call function to generate exadata version report
if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]] || [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] || [[ -n "$is_exalogic_foxtrot" && $is_exalogic_foxtrot -eq "1" ]] || [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]];
then
  if [[ $OFFLINE -eq 0 ]]; then
    if [[ -n $is_bda_dom0 && $is_bda_dom0 -eq 1 || -n $is_bda_domu && $is_bda_domu -eq 1 ]];then 
      echo
    else
      generate_exadata_report; 
    fi
  fi
fi

if [[ -z $MERGEFILES ]]; then echo "RUN_ARGUMENTS = $argsaved" >> $MASTERFIL; else copy_localonly; fi

if [[ -n "$RUNNING_ONCELL" && $RUNNING_ONCELL -eq "1" ]]; then
  if [[ -e $CELLDIR && -e $COLLECT_TIMING ]]
  then
    for tfile in `find $CELLDIR -name "c_root*timing.out"`
    do
      cat $tfile > $COLLECT_TIMING
      collect_duration "$tfile" "$COLLECT_TIMING"
      rm -f $tfile >/dev/null 2>&1
    done
  fi
fi

# Create rachcehck.html file
if [[ $CREATE_HTML_REPORT -eq 1 ]]
then
  top_consumers
  create_raccheck_html
fi

if [[ -n "$fmw_dbrunonly" && $fmw_dbrunonly -eq "1" ]]; then
  echo "IS_FMW_MACHINE = $is_fmw_machine" >> $MASTERFIL
fi

########
if [ $SILENT -eq "1" ]
then
  if [ -f $REPFIL ]; then rm -f $REPFIL;fi;
  if [ -f $SREPFIL ]; then rm -f $SREPFIL; fi;
  if [ -f $SCWCREPFIL_FAIL  ]; then rm -f $SCWCREPFIL_FAIL; fi;
  if [ -f $SREPFIL_FAIL ]; then rm -f $SREPFIL_FAIL; fi;
  if [ -f $SCWCREPFIL_PASS ]; then rm -f $SCWCREPFIL_PASS; fi;
  if [ -f $SREPFIL_PASS ]; then rm -f $SREPFIL_PASS; fi;
  if [ -f $CWCREPFIL_FAIL ]; then rm -f $CWCREPFIL_FAIL; fi;
  if [ -f $REPFIL_FAIL ]; then rm -f $REPFIL_FAIL; fi;
  if [ -f $CWCREPFIL_PASS ]; then rm -f $CWCREPFIL_PASS; fi;
  if [ -f $REPFIL_PASS ]; then rm -f $REPFIL_PASS; fi;
  if [ -f $CELLSREPFIL_PASS ]; then rm -f $CELLSREPFIL_PASS;fi
  if [ -f $CELLSREPFIL_FAIL ]; then rm -f $CELLSREPFIL_FAIL;fi
  if [ -f $CELLREPFIL_PASS ]; then rm -f $CELLREPFIL_PASS;fi
  if [ -f $CELLREPFIL_FAIL ]; then rm -f $CELLREPFIL_FAIL;fi
  if [ -f $IBSREPFIL_PASS ]; then rm -f $IBSREPFIL_PASS;fi
  if [ -f $IBSREPFIL_FAIL ]; then rm -f $IBSREPFIL_FAIL;fi
  if [ -f $IBREPFIL_PASS ]; then rm -f $IBREPFIL_PASS;fi
  if [ -f $IBREPFIL_FAIL ]; then rm -f $IBREPFIL_FAIL;fi
else
  #To delete control-M from report file
  if [ $OFFLINE -eq 0 ]
  then
    cat $REPFIL|tr -d '\r' >$INPUTDIR/${program_name}.rep
    cp -f $INPUTDIR/${program_name}.rep $REPFIL
    rm -f $INPUTDIR/${program_name}.rep
    if [ -e "${HTML_REPFILE}" ]
    then 
      echo "Detailed report (html) - ${HTML_REPFILE}"
    fi 
    #if [ -e $OUTPUTDIR/${program_name}_versions.html ]; then echo  "Exadata version report  - $OUTPUTDIR/${program_name}_versions.html";fi  
  else
    #cat $REPFIL |tr -d '\r' >$TMPDIR/${program_name}.rep
    #cp -f $TMPDIR/${program_name}.rep $REPFIL
    #rm -f $TMPDIR/${program_name}.rep
    if [[ -z $MERGEFILES ]]; then 
      cat $REPFIL |tr -d '\r' >$RTEMPDIR/${program_name}.rep
      cp -f $RTEMPDIR/${program_name}.rep $REPFIL
      rm -f $RTEMPDIR/${program_name}.rep
    fi
    if [ -e $DUMPDIR/collections.dat  ]; then rm -f $DUMPDIR/collections.dat; fi;
    if [ -e $DUMPDIR/collections_new.dat  ]; then rm -f $DUMPDIR/collections_new.dat; fi;
    if [ -e $DUMPDIR/rules.dat  ]; then rm -f $DUMPDIR/rules.dat; fi;
    if [ -e $DUMPDIR/rules_new.dat  ]; then rm -f $DUMPDIR/rules_new.dat; fi;
    if [ -e "${HTML_REPFILE}" ]
    then 
      if [ -n "$MERGEFILES" ]
      then
        rm -rf $DUMPDIR/*.html.out.tailed >/dev/null 2>&1
        if [ -e "$WRKDIR/.MERGED_COLLECTIONS/check_env.out.merge" ]; then mv -f $WRKDIR/.MERGED_COLLECTIONS/check_env.out.merge $DUMPDIR/.check_env.out.merge; fi
        if [ -e "$WRKDIR/.MERGED_COLLECTIONS/slave_results.out.merge" ]; then mv -f $WRKDIR/.MERGED_COLLECTIONS/slave_results.out.merge $DUMPDIR/slave_results.out; fi
        if [ -e "$WRKDIR/.MERGED_COLLECTIONS/cell_ib_count.out.merge" ]; then mv -f $WRKDIR/.MERGED_COLLECTIONS/cell_ib_count.out.merge $DUMPDIR/.cell_ib_count.out.merge; fi
	if [ -e "$WRKDIR/.MERGED_COLLECTIONS/mb_db_tmp.out.merge" ]; then mv -f $WRKDIR/.MERGED_COLLECTIONS/mb_db_tmp.out.merge $DUMPDIR/.mb_db_tmp.out.merge; fi

        d_index=0
        for xdir in $dirarr
        do
          xdir=`basename $xdir`;
          xdir=$(echo $xdir|sed 's/\.zip//g');

          if [ $d_index -ne 0 ];
          then
     	    rm -rf $WRKDIR/.MERGED_COLLECTIONS/$xdir	
          else
     	    replace_name=$xdir
          fi
          d_index=$(expr $d_index + 1);
        done
	OLD_HTML_REPFILE=$HTML_REPFILE
        HTML_REPFILE=$(echo "$HTML_REPFILE"|sed "s|\.MERGED_COLLECTIONS/||g");
        HTML_REPFILE=$(echo "$HTML_REPFILE"|sed "s/${replace_name}/${replace_name}_merge/g");
      fi
      echo "Detailed report (html) - ${HTML_REPFILE}"
      if [ -n "$MERGEFILES" ]; then
        NEW_HTML_REPFILE=$HTML_REPFILE
        HTML_REPFILE=$OLD_HTML_REPFILE
      fi
    fi 
    #if [ -e $DUMPDIR/${program_name}_versions.html ]; then echo  "Exadata version report  - $DUMPDIR/${program_name}_versions.html";fi  
  fi
  if [ -e $OUTPUTDIR/${program_name}.html ]
  then
    echo "Note: Use links (text mode browser) or your favorite browser to view the html report."
  fi
fi
if [[ -z $MERGEFILES ]]; then echo "RUNNING_ONCELL = $RUNNING_ONCELL" >> $MASTERFIL; fi
#to change the name of raccheck_env.out to check_env.out
if [ $OFFLINE -eq 0 ]; then mv -f $MASTERFIL $OUTPUTDIR/check_env.out;elif [ $OFFLINE -eq 1 ]; then mv -f $DUMPDIR/raccheck_env.out $DUMPDIR/check_env.out;fi
if [ -e ${RTEMPDIR}/o_ibswitches.out ]; then cp -f ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1; fi;

#This is where em plugin xml ends
  echo "</Checks>" >> $XMLRECFIL
  echo "</${xml_prefix1}Results>" >> $XMLREPFIL
  echo "</${xml_prefix2}Exclusions>" >> $XMLSKIPFIL
if [[ -z $MERGEFILES && $OFFLINE -eq "0" ]]; then
  if [[ -e "$JSONREPFIL" ]] ; then
    sed -e '/^$/d' $JSONREPFIL > $JSONREPFIL.bak && mv -f $JSONREPFIL.bak $JSONREPFIL
    sed -e '$s/,$//' $JSONREPFIL > $JSONREPFIL.bak && mv -f $JSONREPFIL.bak $JSONREPFIL
  fi

  if [[ -e "$JSONSKIPFIL" ]] ; then
    sed -e '/^$/d' $JSONSKIPFIL > $JSONSKIPFIL.bak && mv -f $JSONSKIPFIL.bak $JSONSKIPFIL
    sed -e '$s/,$//' $JSONSKIPFIL > $JSONSKIPFIL.bak && mv -f $JSONSKIPFIL.bak $JSONSKIPFIL
  fi

fi
#

#provide ip addresses instead of switch and cell names in result xml file 
if [[ $OFFLINE -eq 0 ]]; then
  if [ -e $XMLREPFIL ]; then 
    if [ -e $CELLDIR/cells.out ]; then
      for cellname in `cat $CELLDIR/cells.out|cut -d= -f2|cut -d\; -f2|sed 's/"//g'|sed 's/ //g'`
      do
        is_cell_ip=$(echo $cellname|grep -c '[A-Za-z]')
        if [[ -n $is_cell_ip && $is_cell_ip -ne 0 ]]; then
          cellname_ip=`cat $CELLDIR/cells.out|grep "$cellname"|cut -d= -f1|cut -d\; -f2|sed 's/"//g'|sed 's/ //g'`
  
          is_cell_ip=$(echo $cellname_ip|grep -c '[A-Za-z]')
          if [[ -n $is_cell_ip && $is_cell_ip -eq 0 ]]; then
	    celln=`echo $cellname|$AWK -F. '{print $1}'`
            sed "s/ColumnValue Name=\"NodeName\" value=\"$cellname\"\/>/ColumnValue Name=\"NodeName\" value=\"$celln\"\/\>+       \<ColumnValue Name=\"IPAddress\" value=\"$cellname_ip\"\/>/g" $XMLREPFIL | sed 's/+ /\n /g' > $XMLREPFIL.new	
            mv -f $XMLREPFIL.new $XMLREPFIL
	    if [ -e $JSONREPFIL ]; then
		sed "s/{\"Name\":\"NodeName\",\"value\":\"$cellname\"}/{\"Name\":\"NodeName\",\"value\":\"$celln\"},+   {\"Name\":\"IPAddress\",\"value\":\"$cellname_ip\"}/g" $JSONREPFIL | sed 's/+ /\n /g' > $JSONREPFIL.new
		mv -f $JSONREPFIL.new $JSONREPFIL
	    fi
          fi
        fi
      done
    fi

    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
    then
      if [ -e ${OUTPUTDIR}/o_ibswitches.out ]; then
        for switchname in `cat ${OUTPUTDIR}/o_ibswitches.out`
        do
	  is_name=$(echo "$switchname"|grep -c '[A-Za-z]')
	  if [[ -n $is_name && $is_name -gt 0 ]]; then
            switchn=`echo "$switchname"|$AWK -F. '{print $1}'`
	  else
	    switchn=$switchname
	  fi 
	  if [ -e $EAOUT ]; then
	    if [[ -n $is_name && $is_name -gt 0 ]]; then
              stype=$(grep "$switchn" $EAOUT | head -1 | cut -d= -f1 | sed 's/_hostname/=/g')
              stype_test=$(echo "$stype"|grep -c '[A-Za-z]')
	    else
              stype_test=$(echo "$switchn"|grep -c '[A-Za-z]')
            fi
	  else
            stype_test=$(echo "$switchn"|grep -c '[A-Za-z]')
	  fi
          if [[ -n $stype_test && $stype_test -gt 0 ]]; then
	    if [ -e $EAOUT ]; then
              switchname_ip=$(grep "$stype" $EAOUT | cut -d= -f2)
	    else
	      switchname_ip=`nslookup "$switchn" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`;
	    fi
            is_ibswitch_ip=$(echo "$switchname_ip"|grep -c '[A-Za-z]')
            if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]; then
	      iswitchn=`echo "$switchname"|$AWK -F. '{print $1}'`
              sed "s/ColumnValue Name=\"NodeName\" value=\"$switchname\"\/>/ColumnValue Name=\"NodeName\" value=\"$switchname\"\/\>+       \<ColumnValue Name=\"IPAddress\" value=\"$switchname_ip\"\/>/g" $XMLREPFIL | sed 's/+ /\n /g' > $XMLREPFIL.new
              mv -f $XMLREPFIL.new $XMLREPFIL
	      sed "s/{\"Name\":\"NodeName\",\"value\":\"$switchname\"}/{\"Name\":\"NodeName\",\"value\":\"$switchname\"},+   {\"Name\":\"IPAddress\",\"value\":\"$switchname_ip\"}/g" $JSONREPFIL | sed 's/+ /\n /g' > $JSONREPFIL.new
              mv -f $JSONREPFIL.new $JSONREPFIL
            fi
	  else
	    switchname_ip=$switchn
            iswitchname=`nslookup "$switchname_ip"|grep -w name|$AWK '{print $NF}'|sed 's/.$//'`;
	    iswitchname=`echo "$iswitchname"|$AWK -F. '{print $1}'`
	    is_ibswitch_name=$(echo "$iswitchname"|grep -c '[A-Za-z]')
	    if [[ -n $is_ibswitch_name && $is_ibswitch_name -ne 0 ]]; then
	      iswitchn=`echo "$iswitchname"|$AWK -F. '{print $1}'`
              sed "s/ColumnValue Name=\"NodeName\" value=\"$switchname_ip\"\/>/ColumnValue Name=\"NodeName\" value=\"$iswitchn\"\/\>+       \<ColumnValue Name=\"IPAddress\" value=\"$switchname_ip\"\/>/g" $XMLREPFIL | sed 's/+ /\n /g' > $XMLREPFIL.new
	      mv -f $XMLREPFIL.new $XMLREPFIL
	      sed "s/{\"Name\":\"NodeName\",\"value\":\"$switchname_ip\"}/{\"Name\":\"NodeName\",\"value\":\"$iswitchn\"},+   {\"Name\":\"IPAddress\",\"value\":\"$switchname_ip\"}/g" $JSONREPFIL | sed 's/+ /\n /g' > $JSONREPFIL.new
              mv -f $JSONREPFIL.new $JSONREPFIL
	    fi
          fi 
        done
      fi
    else
      if [ -e ${OUTPUTDIR}/o_ibswitches_full.out ]; then 
        for switchname in `cat ${OUTPUTDIR}/o_ibswitches_full.out`
        do
          switchn=$(echo "$switchname"|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $1}'|sed 's/"$//g')
	  if [[ -z $switchn && -n $RAT_IBSWITCHES ]]; then switchn=$switchname; fi          
	  if [[ -z $switchn || $switchn = "" ]]; then continue; fi
          is_ibswitch_ip=$(echo $switchn|grep -c '[A-Za-z]')
          if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -ne 0 ]]; then
            switchname_ip=$(echo "$switchname"|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $2}'|sed 's/"$//g')

	    if [[ -z $switchname_ip && -n $RAT_IBSWITCHES ]]; then switchname_ip=`nslookup "$switchn" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`; fi

            is_ibswitch_ip=$(echo $switchname_ip|grep -c '[A-Za-z]')
            if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 1 ]]; then
              switchname_ip=`nslookup "$switchn" | grep -wi address: | grep -v "#"|$AWK '{print $NF}'`;
            fi
            is_ibswitch_ip=$(echo $switchname_ip|grep -c '[A-Za-z]')
            if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]; then
	      iswitchn=`echo "$switchname"|$AWK -F. '{print $1}'`
              sed "s/ColumnValue Name=\"NodeName\" value=\"$switchn\"\/>/ColumnValue Name=\"NodeName\" value=\"$switchn\"\/\>+       \<ColumnValue Name=\"IPAddress\" value=\"$switchname_ip\"\/>/g" $XMLREPFIL|sed 's/+ /\n /g' > $XMLREPFIL.new	
              mv -f $XMLREPFIL.new $XMLREPFIL
	      sed "s/{\"Name\":\"NodeName\",\"value\":\"$switchn\"}/{\"Name\":\"NodeName\",\"value\":\"$switchn\"},+   {\"Name\":\"IPAddress\",\"value\":\"$switchname_ip\"}/g" $JSONREPFIL | sed 's/+ /\n /g' > $JSONREPFIL.new
              mv -f $JSONREPFIL.new $JSONREPFIL
            fi
	  else
	    switchname_ip=$(echo "$switchname"|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $2}'|sed 's/"$//g')	    
	    if [[ -z $switchname_ip || $switchname_ip = "" ]]; then continue; fi
	    if [[ -z $switchname_ip && -n $RAT_IBSWITCHES ]]; then switchname_ip=$switchn; fi
	    iswitchname=`nslookup "$switchname_ip"|grep -w name|$AWK '{print $NF}'|sed 's/.$//'`;
	    iswitchname=`echo "$iswitchname"|$AWK -F. '{print $1}'`
	    is_ibswitch_name=$(echo "$iswitchname"|grep -c '[A-Za-z]')
	    if [[ -n $is_ibswitch_name && $is_ibswitch_name -ne 0 ]]; then
	      iswitchn=`echo "$iswitchname"|$AWK -F. '{print $1}'`
              sed "s/ColumnValue Name=\"NodeName\" value=\"$switchn\"\/>/ColumnValue Name=\"NodeName\" value=\"$switchn\"\/\>+       \<ColumnValue Name=\"IPAddress\" value=\"$switchname_ip\"\/>/g" $XMLREPFIL|sed 's/+ /\n /g' > $XMLREPFIL.new	
	      mv -f $XMLREPFIL.new $XMLREPFIL
	      sed "s/{\"Name\":\"NodeName\",\"value\":\"$switchn\"}/{\"Name\":\"NodeName\",\"value\":\"$switchn\"},+   {\"Name\":\"IPAddress\",\"value\":\"$switchname_ip\"}/g" $JSONREPFIL | sed 's/+ /\n /g' > $JSONREPFIL.new
              mv -f $JSONREPFIL.new $JSONREPFIL
	    fi
          fi
        done
      fi
    fi # if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  fi
fi

#call function to write xml file to remote nodes for CC12
if [[ $OFFLINE -eq 0 ]] && [[ $db_machine_compute -eq 1 || $is_exalogic_machine -eq 1 || $is_exalogic_foxtrot -eq 1 || $is_exalytics_machine -eq  1 || $is_bda_machine -eq 1  ]]
then 
  copy_em_xml_files_to_remote_nodes
fi
#$READ -p "stop here for copy_em_xml_files_to_remote_nodes"

perl_exe=$(which perl|tr -d '\r');
if [ -n "$perl_exe" ] ; then
  # Create ${program_name}_browse_<FDS>.html
  $perl_exe $SCRIPTPATH/.cgrep/raw_data_browser.pl $OUTPUTDIR  >/dev/null 2>>$ERRFIL
fi

#Moved this finished before reorg
if [ $OFFLINE -eq 0 ]
then
  echo -e "`date '+%a %b %d %H:%M:%S %Y'` - ${program_name} execution finished\n">>$RACCHECK_TIMING
  echo $fmt_timing_lines >>$RACCHECK_TIMING
fi

update_location_file

if [ -z "$RAT_KEEP_TEXT_REPORT" ]; then
  rm -f $OUTPUTDIR/*.rep >/dev/null 2>&1;
fi

for rawout in `find $OUTPUTDIR/ -name "*.rawout"`
do
  rm -f $rawout
done

reorg_output_dir

if [[ -e $OUTPUTDIR/reports/index.htm ]] 
then
	echo "<div id=\"vmpbody\">" >> $HTML_REPFILE
	echo "<hr>" >> $HTML_REPFILE
	echo "<a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
	echo "<a name=\"vmpscan\"></a>" >> $HTML_REPFILE
	echo "<h2>Clusterwide Linux Operating system health check(VMPScan)</h2>" >> $HTML_REPFILE
        echo "<b><p style=\"font-size:14px\"><span style=\"color:green;font-size:14px\">Note!</span> This is summary of the VMPScan report. To browse full report, please open orachk report present under the 'reports' folder of orachk collection zip file</p></b><br>" >> $HTML_REPFILE

	perl_exe=$(which perl|tr -d '\r');
	if [ -n "$perl_exe" ] ; then
  		$perl_exe $SCRIPTPATH/.cgrep/parse_index.pl $OUTPUTDIR/reports/index.htm $HTML_REPFILE  >/dev/null 2>>$ERRFIL
	fi
	echo "</div>" >> $HTML_REPFILE

fi

if [[ -e $OUTPUTDIR/${program_name}_consumers.html ]] && [[ -z "$MERGEFILES" ]]
then
  echo "<hr>" >> $HTML_REPFILE
  cat $OUTPUTDIR/${program_name}_consumers.html >> $HTML_REPFILE
fi 

echo "</body>
<br><a href=\"#\" onclick=\"javascript:processForm();\"><div id=\"results\">Switch to old format</div></a>
</html>" >> $HTML_REPFILE

if [[  -e $HTML_REPFILE && -e $OUTPUTDIR/reports ]] && [ -z "$MERGEFILES" ]
then
  cp -f $HTML_REPFILE ${HTML_REPFILE}_copy >/dev/null 2>&1
  mv -f $OUTPUTDIR/*.html $OUTPUTDIR/reports >/dev/null 2>&1
  cp -f ${HTML_REPFILE}_copy $HTML_REPFILE >/dev/null 2>&1
  cp -f $HTML_REPFILE $OUTPUTDIR/reports >/dev/null 2>&1
  rm -f ${HTML_REPFILE}_copy >/dev/null 2>&1
fi

create_program_cache

#To delete dat files in offline from output directory
if [[ $OFFLINE -eq 1 && `find $OUTPUTDIR -name '*.dat' -type f|wc -l` -gt 0 ]];then rm -f $OUTPUTDIR/*.dat >/dev/null 2>&1;fi

if [ $OFFLINE -eq 0 ]
then
  if [[ ! -n "$RAT_KEEP_PASSWORD_IN_DEBUG" && -f "$RAT_DEBUG_FILENAME_INTERNAL" ]] ; then
    if [[ -n "$RAT_KEEP_ORIG_DEBUG_FILE" && $RAT_KEEP_ORIG_DEBUG_FILE -eq "1" ]] ; then
      cp -f $RAT_DEBUG_FILENAME_INTERNAL $RAT_DEBUG_FILENAME_INTERNAL.orig
    fi
    remove_passwords_in_debug;
  fi

  if [ -e "$RAT_DEBUG_FILENAME_INTERNAL" ]; then cp -f $RAT_DEBUG_FILENAME_INTERNAL $OUTPUTDIR/log >/dev/null 2>&1; fi

  if [[ ! -n "$RAT_KEEP_REDIRECTION_IN_SCRIPT" ]] ; then remove_redirection_in_scripts; fi

  cd $OUTPUTDIR
  LOGFIL=$OUTPUTDIR/log/${program_name}.log
  #$READ -p "OUTPUTDIR=$OUTPUTDIR"
  cd ..
  which zip >/dev/null 2>&1
  if [ `echo $?` -eq 0 ]
  then
    OUTPUTDIR_ZIP=$(basename $OUTPUTDIR)
    CELLDIR_ZIP=$(basename $CELLDIR)
    INPUTDIR_ZIP=$(basename $INPUTDIR)
    if [[ -e $OUTPUTDIR/reports/index.htm ]]
    then
	zip -qr  --symlinks "$UPLOADFIL".zip $OUTPUTDIR_ZIP/* $OUTPUTDIR_ZIP/$CELLDIR_ZIP/* $OUTPUTDIR_ZIP/$INPUTDIR_ZIP/* 2>>$ERRFIL
    else
	zip -qr "$UPLOADFIL".zip $OUTPUTDIR_ZIP/* $OUTPUTDIR_ZIP/$CELLDIR_ZIP/* $OUTPUTDIR_ZIP/$INPUTDIR_ZIP/* 2>>$ERRFIL
    fi 
    upload_result_conn_check
    if [[ $raccheck_upload_env_set -eq 1 && $upload_result_conn_status -eq 1 ]];then 
      OLD_ORACLE_HOME=$ORACLE_HOME
      if [[ -n $RAT_UPLOAD_ORACLE_HOME ]];then
        ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
      else
        ORACLE_HOME="$CRS"
      fi
      export ORACLE_HOME="$ORACLE_HOME"
      #export TWO_TASK="$RAT_UPLOAD_CONNECT_STRING"
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      free_space_in_db=$(echo -e "set heading off feedback off\n SELECT round(sum(bytes)/1048576) FROM user_free_space  where tablespace_name = (SELECT nvl(tablespace_name,'XXX') from user_tables where table_name = 'RCA13_DOCS');"|$ORACLE_HOME/bin/sqlplus -s  $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING") >>$LOGFIL
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi      
      #unset ORACLE_HOME
      if [[ $free_space_in_db -gt $RAT_DBUPLOAD_SIZE ]];then
        check_flag_status
        if [[ -n $cm_upgrade_flag ]];then
          upgrade_cm
          cm_upgrade_status=$?
        else
          cm_upgrade_status=0
        fi
        if [[ $cm_upgrade_status -eq 0 ]];then
          if [[ -n $cm_upgrade_flag && $cm_upgrade_flag == "Y" ]];then
            echo -e "\n$program_name can not upload collection to Oracle Health Checks Collection Manager because collection manager is upgrading to newest version. Please wait and try again\n\nUse following command line option to upload failed collection:\n\n./$program_name -uploadfailed ${UPLOADFIL}.zip\n\n"  |tee -a $LOGFIL
          else
            upload_zip_file "${UPLOADFIL}.zip"
          fi
          if [ $zip_data_upload_status -eq  1 ]
          then
            echo -e "required environment variables are not set to upload zip file to database">>$LOGFIL
          elif [ $zip_data_upload_status -eq 2 ]
          then
            echo -e $RED"${program_name} was not able to make successfull connection to database to upload "${UPLOADFIL}.zip".\nPlease run ${LDRCTLFIL_NEW} script manually to upload "${UPLOADFIL}.zip" to database\n$NORM"|tee -a $LOGFIL
          elif [ $zip_data_upload_status -eq 3 ]
          then
            echo -e "$zip_upload_message"|tee -a $LOGFIL
          else
            echo -e "$zip_upload_message"|tee -a $LOGFIL
          fi
          echo ""
          echo ""
        else
          echo -e "\n$program_name can not upload collection to Oracle Health Checks Collection Manager. Please upgrade the collection manager and try again.\n\nUse following command line option to upgrade collection manager:\n\n./$program_name -cmupgrade\n\n" |tee -a $LOGFIL
        fi       
      else
        echo -e "\nAvailable free memory space in database is less than $RAT_DBUPLOAD_SIZE MB. File upload to database has been skipped\n" |tee -a $LOGFIL
      fi
    else
      print_conn_check_msg     
    fi
    ORACLE_HOME="$OLD_ORACLE_HOME"

    #Adding changed files to zip
    if [[ -e $OUTPUTDIR/reports/index.htm ]]
    then
	zip -qr --symlinks "$UPLOADFIL".zip $OUTPUTDIR_ZIP/*  2>>$ERRFIL
    else
    	zip -qr "$UPLOADFIL".zip $OUTPUTDIR_ZIP/*  2>>$ERRFIL
    fi
    echo "UPLOAD(if required) - "$UPLOADFIL".zip"
  else
    OUTPUTDIR_ZIP=$(basename $OUTPUTDIR)
    INPUTDIR_ZIP=$(basename $INPUTDIR)

    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] ; then
      if [[ -e $OUTPUTDIR_ZIP/$INPUTDIR_ZIP ]]; then
        tar -czf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* $OUTPUTDIR_ZIP/$INPUTDIR_ZIP/* 2>>$ERRFIL
      else
        tar -czf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* 2>>$ERRFIL
      fi
    else
      tar -czf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* 2>>$ERRFIL
    fi

    if [ ! -f "${UPLOADFIL}.tar.gz" ]; then 
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] ; then
	if [[ -e $OUTPUTDIR_ZIP/$INPUTDIR_ZIP ]]; then
          tar -cvf "$UPLOADFIL".tar $OUTPUTDIR_ZIP/* $OUTPUTDIR_ZIP/$INPUTDIR_ZIP/* >/dev/null; 
	else
          tar -cvf "$UPLOADFIL".tar $OUTPUTDIR_ZIP/* >/dev/null; 
        fi
      else
        tar -cvf "$UPLOADFIL".tar $OUTPUTDIR_ZIP/* >/dev/null; 
      fi
      gzip -q "$UPLOADFIL".tar >/dev/null 2>&1; 
    fi;
    upload_result_conn_check
    if [[ $raccheck_upload_env_set -eq 1 && $upload_result_conn_status -eq 1 ]];then
      OLD_ORACLE_HOME=$ORACLE_HOME
      if [[ -n $RAT_UPLOAD_ORACLE_HOME ]];then
        ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
      else
        ORACLE_HOME="$CRS"
      fi
      export ORACLE_HOME="$ORACLE_HOME"
      #export TWO_TASK="$RAT_UPLOAD_CONNECT_STRING"
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set +x; fi
      free_space_in_db=$(echo -e "set heading off feedback off\n SELECT round(sum(bytes)/1048576) FROM user_free_space  where tablespace_name = (SELECT nvl(tablespace_name,'XXX') from user_tables where table_name = 'RCA13_DOCS');"|$ORACLE_HOME/bin/sqlplus -s  $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING") >>$LOGFIL
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq "1" && -z "$RAT_PASSWORD_CLEANUP" ]]; then set -x; fi
      #unset ORACLE_HOME
      ORACLE_HOME="$OLD_ORACLE_HOME"

      if [[ $free_space_in_db -gt $RAT_DBUPLOAD_SIZE ]];then
        check_flag_status
        if [[ -n $cm_upgrade_flag ]];then
          upgrade_cm
          cm_upgrade_status=$?
        else
          cm_upgrade_status=0
        fi
        if [[ $cm_upgrade_status -eq 0 ]];then
          if [[ -n $cm_upgrade_flag && $cm_upgrade_flag == "Y" ]];then
            echo -e "\n$program_name can not upload collection to Oracle Health Checks Collection Manager because collection manager is upgrading to newest version. Please wait and try again\n\nUse following command line option to upload failed collection:\n\n./$program_name -uploadfailed ${UPLOADFIL}.zip\n\n"  |tee -a $LOGFIL
          else
            upload_zip_file "${UPLOADFIL}.tar.gz"
          fi
          if [ $zip_data_upload_status -eq  1 ]
          then
            echo -e "required environment variables are not set to upload zip file to database">>$LOGFIL
          elif [ $zip_data_upload_status -eq 2 ]
          then
            echo -e $RED"${program_name} was not able to make successfull connection to database to upload "${UPLOADFIL}.tar.gz".\nPlease run ${LDRCTLFIL_NEW} script manually to upload "${UPLOADFIL}.tar.gz" to database\n$NORM"|tee -a $LOGFIL
          elif [ $zip_data_upload_status -eq 3 ]
          then
            echo -e "$zip_upload_message"|tee -a $LOGFIL
          else
            echo -e "$zip_upload_message"|tee -a $LOGFIL
          fi
          echo ""
          echo ""
        else
          echo -e "\n$program_name can not upload collection to Oracle Health Checks Collection Manager. Please upgrade the collection manager and try again.\n\nUse following command line option to upgrade collection manager:\n\n./$program_name -cmupgrade\n\n" |tee -a $LOGFIL
        fi
      else
        echo -e "\nAvailable free memory space in database is less than $RAT_DBUPLOAD_SIZE MB. File upload to database has been skipped\n" |tee -a $LOGFIL
      fi
    else
      print_conn_check_msg      
    fi
 
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] ; then
      if [[ -e $OUTPUTDIR_ZIP/$INPUTDIR_ZIP ]]; then
	tar -czf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* $OUTPUTDIR_ZIP/$INPUTDIR_ZIP/* >/dev/null;
      else
        tar -czf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* 2>>$ERRFIL
      fi
    else    
      tar -czf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* 2>>$ERRFIL
    fi

    if [ ! -f "${UPLOADFIL}.tar.gz" ]; then 
      if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] ; then
	if [[ -e $OUTPUTDIR_ZIP/$INPUTDIR_ZIP ]]; then
	  tar -cvf "$UPLOADFIL".tar $OUTPUTDIR_ZIP/* $OUTPUTDIR_ZIP/$INPUTDIR_ZIP/* >/dev/null;
	else
          tar -cvf "$UPLOADFIL".tar $OUTPUTDIR_ZIP/* >/dev/null; 
	fi
      else
        tar -cvf "$UPLOADFIL".tar $OUTPUTDIR_ZIP/* >/dev/null; 
      fi
      gzip -q "$UPLOADFIL".tar >/dev/null 2>&1; 
    fi;

    echo ""
    echo ""
    echo "UPLOAD(if required) - "$UPLOADFIL".tar.gz"
  fi
else
  if [ -n "$MERGEFILES" ]
  then
    HTML_REPFILE=$NEW_HTML_REPFILE
    MERGEDIR=$WRKDIR/${replace_name}_merge
    UPLOADFIL=$WRKDIR/${replace_name}_merge

    if [ -e $WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge ]; then mv -f $WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge $DUMPDIR/outfiles/o_host_list.out; fi
    if [ -d "$MERGEDIR" ]; then 
      rm -rf $MERGEDIR 2>>$ERRFIL;
      rm -rf ${MERGEDIR}.zip 2>>$ERRFIL; 
    fi;

    mv -f $OUTPUTDIR $MERGEDIR
    mv -f $WRKDIR/.MERGED_COLLECTIONS/*.out $MERGEDIR/outfiles/ >/dev/null 2>&1 
    cd $MERGEDIR
    for renamefile in `find . -name "*${replace_name}*"`
    do
      merge_file=$(echo $renamefile|sed "s/${replace_name}/${replace_name}_merge/g");
      mv -f $renamefile $merge_file 

      sed "s|${replace_name}\.zip<|${replace_name}_merge\.zip<|g" $merge_file >$merge_file.new
      rm -f $merge_file
      mv -f $merge_file.new $merge_file
    done  

    browse_pattern=$(echo "$replace_name"|sed "s/${program_name}/${program_name}_browse/g");
    for renamefile in `find . -name "*${browse_pattern}*"`
    do
      browse_file=$(echo $renamefile|sed "s/${browse_pattern}/${browse_pattern}_merge/g");
      mv -f $renamefile $browse_file
    done  

    OUTPUTDIR=$(echo "$OUTPUTDIR"|sed "s|\.MERGED_COLLECTIONS||g"); 	      
    OUTPUTDIR=$(echo "$OUTPUTDIR"|sed "s|${replace_name}|${replace_name}_merge|g"); 	      

    ERRFIL=$(echo $ERRFIL|sed "s|\.MERGED_COLLECTIONS||g");
    ERRFIL=$(echo $ERRFIL|sed "s|${replace_name}|${replace_name}_merge|g");

    if [[ -d $WRKDIR/.MERGED_COLLECTIONS/ ]];
    then
      rm -rf $WRKDIR/.MERGED_COLLECTIONS >/dev/null 2>&1
    fi
  fi

  cd $OUTPUTDIR
  cd ..
  if [ -e "${program_name}_${outfilefds1}_collect_${outfilefds2}_${outfilefds3}.zip" ]; then rm -f ${program_name}_${outfilefds1}_collect_${outfilefds2}_${outfilefds3}.zip 2>>$ERRFIL; fi
  if [ -e "${program_name}_${outfilefds1}_collect_${outfilefds3}_${outfilefds3}.tar.gz" ]; then rm -f ${program_name}_${outfilefds1}_collect_${outfilefds3}_${outfilefds3}.tar.gz 2>>$ERRFIL; fi
  which zip >/dev/null 2>&1
  if [ `echo $?` -eq 0 ]
  then
    CELLDIR_ZIP=$(basename $CELLDIR)
    INPUTDIR_ZIP=$(basename $INPUTDIR)
    if [ -n "$MERGEFILES" ]
    then
      DIR_ZIP=$(basename $MERGEDIR)
      if [[ -e $OUTPUTDIR/reports/index.htm ]]
      then	
	zip -qr --symlinks "$UPLOADFIL".zip $DIR_ZIP/* $DIR_ZIP/$CELLDIR_ZIP/* $DIR_ZIP/$INPUTDIR_ZIP/* 2>>$ERRFIL
      else
      	zip -qr "$UPLOADFIL".zip $DIR_ZIP/* $DIR_ZIP/$CELLDIR_ZIP/* $DIR_ZIP/$INPUTDIR_ZIP/* 2>>$ERRFIL
      fi
    else
      if [[ -e $OUTPUTDIR/reports/index.htm ]]
      then
	      zip -qr --symlinks "$UPLOADFIL".zip ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/$CELLDIR_ZIP/* ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/$INPUTDIR_ZIP/* 2>>$ERRFIL
      else
	      zip -qr "$UPLOADFIL".zip ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/$CELLDIR_ZIP/* ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/$INPUTDIR_ZIP/* 2>>$ERRFIL
      fi
    fi
    echo ""
    echo ""
    echo "UPLOAD(if required) - "$UPLOADFIL".zip"
  else
    #$READ -p "UPLOADFIL=$UPLOADFIL ${outfilefds1} ${outfilefds2} ${outfilefds3}"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] ; then
      if [[ -e ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/$INPUTDIR_ZIP ]]; then
        tar -czf "$UPLOADFIL".tar.gz ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/$INPUTDIR_ZIP/* 2>>$ERRFIL
      else
        tar -czf "$UPLOADFIL".tar.gz ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* 2>>$ERRFIL
      fi
    else
      tar -czf "$UPLOADFIL".tar.gz ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* 2>>$ERRFIL
    fi
    
    echo ""
    echo ""
    echo "UPLOAD(if required) - "$UPLOADFIL".tar.gz"
  fi     
fi

if [[ ! $autorun -eq "1" ]] ; then
  if [[ -f "/etc/oracle/cell/network-config/cellip.ora" ]];then
    CELLIP="/etc/oracle/cell/network-config/cellip.ora"
    if [[ ! -d $RTEMPDIR_D ]];then
      mkdir $RTEMPDIR_D >/dev/null 2>&1;
      temp_d_dir_created=1;
    fi
    if [[ -n "$CELLIP" && -e "$CELLIP" ]] ; then cp -f $CELLIP $RTEMPDIR_D/.cells.txt; fi
  fi

  if [[ -n $RAT_CELLS ]];then
    if [ ! -d $RTEMPDIR ]; then mkdir $RTEMPDIR >/dev/null 2>&1;fi
    cli_cells=$(echo "$RAT_CELLS")
    temp_cells=$(echo $cli_cells | tr "," "\n")
    for single_cellip in $temp_cells
    do
      echo "cell=\"$single_cellip\"" >> $RTEMPDIR/cellip_for_mail.ora
    done
    CELLIP="$RTEMPDIR/cellip_for_mail.ora"
    cp -f $CELLIP $RTEMPDIR_D/.cells.txt >/dev/null 2>&1;
  fi

  matter="Please find Oracle $SYSTEM_NAME Assessment Report for $program_name run"
  html_report=${HTML_REPFILE}
  send_email "First : Oracle $SYSTEM_NAME Assessment Report for $program_name run" "$matter" "1" "all"
  rm -rf $RTEMPDIR >/dev/null 2>&1;
  if [[ $temp_d_dir_created -eq 1 ]];then rm -rf $RTEMPDIR_D >/dev/null 2>&1; fi
fi

echo -e "\n"
echo -e "\n"

exit_status;
}

